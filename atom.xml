<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Kubi Code'Blog]]></title>
  <subtitle><![CDATA[The palest ink is better than the best memory.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yyl8781697.github.io/"/>
  <updated>2015-07-20T12:53:05.000Z</updated>
  <id>http://yyl8781697.github.io/</id>
  
  <author>
    <name><![CDATA[Kubi Code]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[把数组排成最小的数]]></title>
    <link href="http://yyl8781697.github.io/2015/07/20/Algorithm/Minimum-Combination-in-Array/"/>
    <id>http://yyl8781697.github.io/2015/07/20/Algorithm/Minimum-Combination-in-Array/</id>
    <published>2015-07-20T12:31:43.000Z</published>
    <updated>2015-07-20T12:53:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>输入一个正整数数组，将它们连接起来排成一个数，输出能排出的所有数字中最小的一个。例如输入数组<span class="list">{32,  321}</span>，则输出这两个能排成的最小数字<span class="number">32132</span>。请给出解决问题的算法，并证明该算法。
</code></pre><h2 id="解析">解析</h2><p>假如有两个数字a,b，其关键思路不是比较a,b，而是比较ab和ba。。。<br>如果ab&lt;ba,则会有a&lt;b，所以这题的关键就是构建a,b的比较器</p>
<p>关于证明：请看<a href="http://blog.csdn.net/cxllyg/article/details/7659525" target="_blank" rel="external">这个</a></p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 思路是比较ab和ba。。。如果ab&lt;ba,则会有a&lt;b</span><br><span class="line"> *<span class="javadoctag"> @param</span> a</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">minimumCombination</span><span class="params">(Integer[] a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Arrays.sort(a, <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a,Integer b)</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (a+<span class="string">""</span>+b).compareTo(b+<span class="string">""</span>+a);<span class="comment">//构建ab的比较器</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sb.append(a[i]);<span class="comment">//然后直接连起来就可以了</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> sb.toString();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Integer[] a=&#123;<span class="number">32</span>,<span class="number">321</span>,<span class="number">23</span>&#125;; </span><br><span class="line">	System.out.println(minimumCombination(a));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出</p>
<pre><code>2332132
</code></pre><h2 id="参考">参考</h2><ul>
<li>July 微软面试100题系列 第68题</li>
<li><a href="http://blog.csdn.net/cxllyg/article/details/7659525" target="_blank" rel="external">【百度面试题】把数组排成最小的数</a></li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>输入一个正整数数组，将它们连接起来排成一个数，输出能排出的所有数字中最小的一个。例如输入数组<span class="list">{32,  321}</span>，则输出这两个能排成的最小数字<span class="]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[火车票 查询问题  针对12306设计一个快速的查询系统]]></title>
    <link href="http://yyl8781697.github.io/2015/07/19/Algorithm/TrainTickets/"/>
    <id>http://yyl8781697.github.io/2015/07/19/Algorithm/TrainTickets/</id>
    <published>2015-07-19T14:22:31.000Z</published>
    <updated>2015-07-19T16:10:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>火车票 查询问题  针对12306设计一个快速的查询系统
</code></pre><blockquote>
<p>这个网上看到的，好像是百度的一道面试题</p>
</blockquote>
<h2 id="解析">解析</h2><blockquote>
<p>思想就是将火车票区间的每个站按位映射，然后通过位操作法来查询，这种方式应该比较快，并且存储比较小</p>
</blockquote>
<p>比如宁波到上海的高铁G7518有7个站：宁波-&gt;余姚北-&gt;绍兴北-&gt;杭州东-&gt;桐乡-&gt;嘉善南-&gt;上海虹桥<br>那么这趟车的一张票可以用0X7F来存储：01111111，低位表示出发，高位表示终止<br>那么我如果需要查询的话：查宁波到杭州东就为:00000111（第4站杭州东站只作为达到之用，不会占用其他票，所以置0即可），然后这两个数做一个与操作就可以，如果与操作之后的值还是00000111的话，就表示有票<br>还有购买的话 只需要做抑或操作即可,01111111^00000111=01111000，这样就表示余票就只有杭州东到上海虹桥的票了<br>有了，有这种思路之后，可以简单的看几个代码片段</p>
<h2 id="查询票的构建">查询票的构建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 根据出发和达到站构建票</span><br><span class="line"> *<span class="javadoctag"> @param</span> start</span><br><span class="line"> *<span class="javadoctag"> @param</span> end</span><br><span class="line"> *<span class="javadoctag"> @return</span> -1表示没有这些站点</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">buildTicket</span><span class="params">(String start,String end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!STATION_MAP.containsKey(start) || !STATION_MAP.containsKey(end))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//表示没有这些站点  或者站点名字出错</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> si=STATION_MAP.get(start),ei=STATION_MAP.get(end);</span><br><span class="line">	<span class="keyword">int</span> qTicket=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(si&lt;ei)</span><br><span class="line">	&#123;</span><br><span class="line">		qTicket|=<span class="number">0x1</span>&lt;&lt;si;<span class="comment">//在相应的位置上置1  注意  达到站是不置1  </span></span><br><span class="line">		si++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> qTicket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查票的时候往往是一个起始站，还有一个到达站，这里我们就要构建乘车区间的位置为1</p>
<blockquote>
<p>注意：到达站只做到达之用，并不是经过它，为了顺利让到达站还可以作为其他票的起始点，所以这里达到站不置1<br>同时为了方法无法找到对应的区间，所以这里要先判断一下</p>
</blockquote>
<h2 id="查询">查询</h2><p>查询只需要进行一个与操作即可，并且不需要改变原数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 查询是否有票</span><br><span class="line"> *<span class="javadoctag"> @param</span> start</span><br><span class="line"> *<span class="javadoctag"> @param</span> end</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">query</span><span class="params">(String start,String end)</span></span><br><span class="line"></span>&#123;		</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.query(<span class="keyword">this</span>.buildTicket(start, end));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> State <span class="title">query</span><span class="params">(<span class="keyword">int</span> qTicket)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(qTicket==-<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> State.ERROR;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (rTicket&amp;qTicket)==qTicket?State.SUCCESS:State.FAILED;<span class="comment">//如果进行与操作之后值还是查询票的数据 就表示有票</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="购买">购买</h2><p>购买时需要改变原存储数据，这里只需要进行异或操作即可，将购买区间的位置0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 买票操作</span><br><span class="line"> *<span class="javadoctag"> @param</span> start</span><br><span class="line"> *<span class="javadoctag"> @param</span> end</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">buy</span><span class="params">(String start,String end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> qTicket=<span class="keyword">this</span>.buildTicket(start, end);</span><br><span class="line">	State state=<span class="keyword">this</span>.query(qTicket);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(state==State.SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>.rTicket^=qTicket;<span class="comment">//进行异或操作 将票买了</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="退票">退票</h2><p>退票操作起始也需要进行或运算，将原来置0的的位置置1即可，不过为了安全，在或运算之前先判断要退的票是否是该票区间的位都已经置0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 退票操作</span><br><span class="line"> *<span class="javadoctag"> @param</span> start</span><br><span class="line"> *<span class="javadoctag"> @param</span> end</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">refund</span><span class="params">(String start,String end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> qTicket=<span class="keyword">this</span>.buildTicket(start, end);</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 1100010</span><br><span class="line">	 * 0011100</span><br><span class="line">	 * 这里是为了判断退票的区间在余票中是否被正好买掉</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span>((<span class="keyword">this</span>.rTicket|qTicket)-<span class="keyword">this</span>.rTicket==qTicket)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>.rTicket|=qTicket;<span class="comment">//将票归还</span></span><br><span class="line">		<span class="keyword">return</span> State.SUCCESS;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> State.ERROR;<span class="comment">//发生意外错误了</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="全部贴上来">全部贴上来</h2><p>全部的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 火车票 查询问题  针对12306设计一个快速的查询系统</span><br><span class="line"> * 思想就是将火车票区间的每个站按位映射，然后通过位操作法来查询</span><br><span class="line"> * 注：本代码只是演示了查询的流程  关于同步方面并未考虑</span><br><span class="line"> *<span class="javadoctag"> @author</span> yanyl</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainTickets</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 一个宁波到上海的高铁为例</span><br><span class="line">	 * 每一个元素都是表示停靠站点</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String,Integer&gt; STATION_MAP;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 和STATION_MAP一样的信息  </span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String[] STATION_ARRAY=&#123;<span class="string">"宁波"</span>,<span class="string">"余姚北"</span>,<span class="string">"绍兴北"</span>,<span class="string">"杭州东"</span>,<span class="string">"桐乡"</span>,<span class="string">"嘉善南"</span>,<span class="string">"上海虹桥"</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TrainTickets</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//初始化一下站点信息</span></span><br><span class="line">		STATION_MAP=<span class="keyword">new</span> HashMap&lt;String,Integer&gt;()&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;STATION_ARRAY.length;i++)</span><br><span class="line">				&#123;</span><br><span class="line">					put(STATION_ARRAY[i],i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 01111111  低位表示起始  高位表示终止  一共7站</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> rTicket=<span class="number">0x7F</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">enum</span> State&#123;</span><br><span class="line">		<span class="javadoc">/**</span><br><span class="line">		 * 成功标志 有票 或者购买成功</span><br><span class="line">		 */</span></span><br><span class="line">		SUCCESS,</span><br><span class="line">		<span class="javadoc">/**</span><br><span class="line">		 * 失败标志 无票 或者购买失败</span><br><span class="line">		 */</span></span><br><span class="line">		FAILED,</span><br><span class="line">		<span class="javadoc">/**</span><br><span class="line">		 * 错误标志 可能使两个站点不存在</span><br><span class="line">		 */</span></span><br><span class="line">		ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 查询是否有票</span><br><span class="line">	 *<span class="javadoctag"> @param</span> start</span><br><span class="line">	 *<span class="javadoctag"> @param</span> end</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> State <span class="title">query</span><span class="params">(String start,String end)</span></span><br><span class="line">	</span>&#123;		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.query(<span class="keyword">this</span>.buildTicket(start, end));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> State <span class="title">query</span><span class="params">(<span class="keyword">int</span> qTicket)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(qTicket==-<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> State.ERROR;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> (rTicket&amp;qTicket)==qTicket?State.SUCCESS:State.FAILED;<span class="comment">//如果进行与操作之后值还是查询票的数据 就表示有票</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 买票操作</span><br><span class="line">	 *<span class="javadoctag"> @param</span> start</span><br><span class="line">	 *<span class="javadoctag"> @param</span> end</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> State <span class="title">buy</span><span class="params">(String start,String end)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> qTicket=<span class="keyword">this</span>.buildTicket(start, end);</span><br><span class="line">		State state=<span class="keyword">this</span>.query(qTicket);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(state==State.SUCCESS)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>.rTicket^=qTicket;<span class="comment">//进行异或操作 将票买了</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 退票操作</span><br><span class="line">	 *<span class="javadoctag"> @param</span> start</span><br><span class="line">	 *<span class="javadoctag"> @param</span> end</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> State <span class="title">refund</span><span class="params">(String start,String end)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> qTicket=<span class="keyword">this</span>.buildTicket(start, end);</span><br><span class="line">		</span><br><span class="line">		<span class="javadoc">/**</span><br><span class="line">		 * 1100010</span><br><span class="line">		 * 0011100</span><br><span class="line">		 * 这里是为了判断退票的区间在余票中是否被正好买掉</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="keyword">if</span>((<span class="keyword">this</span>.rTicket|qTicket)-<span class="keyword">this</span>.rTicket==qTicket)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>.rTicket|=qTicket;<span class="comment">//将票归还</span></span><br><span class="line">			<span class="keyword">return</span> State.SUCCESS;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> State.ERROR;<span class="comment">//发生意外错误了</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 根据出发和达到站构建票</span><br><span class="line">	 *<span class="javadoctag"> @param</span> start</span><br><span class="line">	 *<span class="javadoctag"> @param</span> end</span><br><span class="line">	 *<span class="javadoctag"> @return</span> -1表示没有这些站点</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">buildTicket</span><span class="params">(String start,String end)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!STATION_MAP.containsKey(start) || !STATION_MAP.containsKey(end))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//表示没有这些站点  或者站点名字出错</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> si=STATION_MAP.get(start),ei=STATION_MAP.get(end);</span><br><span class="line">		<span class="keyword">int</span> qTicket=<span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(si&lt;ei)</span><br><span class="line">		&#123;</span><br><span class="line">			qTicket|=<span class="number">0x1</span>&lt;&lt;si;<span class="comment">//在相应的位置上置1  注意  达到站是不置1  </span></span><br><span class="line">			si++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> qTicket;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 获取余票状态</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">remaining</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">boolean</span> cc=<span class="keyword">false</span>;<span class="comment">//false 表示前一站已经被买了 </span></span><br><span class="line">		sb.append(<span class="string">"余票状态："</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;STATION_ARRAY.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> mark=<span class="number">0x1</span>&lt;&lt;i;</span><br><span class="line">			<span class="keyword">if</span>((<span class="keyword">this</span>.rTicket&amp;mark)==mark)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(cc)</span><br><span class="line">				&#123;</span><br><span class="line">					sb.append(<span class="string">"-&gt;"</span>);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					sb.append(<span class="string">"  "</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				sb.append(STATION_ARRAY[i]);</span><br><span class="line">				cc=<span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cc=<span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TrainTickets tt=<span class="keyword">new</span> TrainTickets();</span><br><span class="line">		System.out.println(tt.remaining());</span><br><span class="line">		System.out.println(<span class="string">"查询 宁波-&gt;杭州南:"</span>+tt.query(<span class="string">"宁波"</span>,<span class="string">"杭州南"</span>));</span><br><span class="line">		System.out.println(<span class="string">"查询 宁波-&gt;杭州东:"</span>+tt.query(<span class="string">"宁波"</span>,<span class="string">"杭州东"</span>));</span><br><span class="line">		System.out.println(<span class="string">"购买 宁波-&gt;杭州东:"</span>+tt.buy(<span class="string">"宁波"</span>,<span class="string">"杭州东"</span>));</span><br><span class="line">		System.out.println(tt.remaining());</span><br><span class="line">		System.out.println(<span class="string">"购买 宁波-&gt;杭州东:"</span>+tt.buy(<span class="string">"宁波"</span>,<span class="string">"杭州东"</span>));</span><br><span class="line">		System.out.println(<span class="string">"购买 宁波-&gt;绍兴北:"</span>+tt.buy(<span class="string">"宁波"</span>,<span class="string">"绍兴北"</span>));</span><br><span class="line">		System.out.println(<span class="string">"购买 绍兴北-&gt;桐乡:"</span>+tt.buy(<span class="string">"绍兴北"</span>,<span class="string">"桐乡"</span>));</span><br><span class="line">		System.out.println(<span class="string">"购买 杭州东-&gt;桐乡:"</span>+tt.buy(<span class="string">"杭州东"</span>,<span class="string">"桐乡"</span>));</span><br><span class="line">		System.out.println(tt.remaining());</span><br><span class="line">		System.out.println(<span class="string">"退票 宁波-&gt;杭州东:"</span>+tt.refund(<span class="string">"宁波"</span>,<span class="string">"杭州东"</span>));</span><br><span class="line">		System.out.println(tt.remaining());</span><br><span class="line">		System.out.println(<span class="string">"购买 宁波-&gt;杭州东:"</span>+tt.buy(<span class="string">"宁波"</span>,<span class="string">"杭州东"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后的测试运算结果为：</p>
<pre><code>余票状态：  宁波-&gt;余姚北-&gt;绍兴北-&gt;杭州东-&gt;桐乡-&gt;嘉善南-&gt;上海虹桥
查询 宁波-&gt;杭州南<span class="symbol">:ERROR</span>
查询 宁波-&gt;杭州东<span class="symbol">:SUCCESS</span>
购买 宁波-&gt;杭州东<span class="symbol">:SUCCESS</span>
余票状态：  杭州东-&gt;桐乡-&gt;嘉善南-&gt;上海虹桥
购买 宁波-&gt;杭州东<span class="symbol">:FAILED</span>
购买 宁波-&gt;绍兴北<span class="symbol">:FAILED</span>
购买 绍兴北-&gt;桐乡<span class="symbol">:FAILED</span>
购买 杭州东-&gt;桐乡<span class="symbol">:SUCCESS</span>
余票状态：  桐乡-&gt;嘉善南-&gt;上海虹桥
退票 宁波-&gt;杭州东<span class="symbol">:SUCCESS</span>
余票状态：  宁波-&gt;余姚北-&gt;绍兴北  桐乡-&gt;嘉善南-&gt;上海虹桥
购买 宁波-&gt;杭州东<span class="symbol">:SUCCESS</span>
</code></pre><p>心细的小伙伴可以发现最后一次余票查询有bug，是的，应该有绍兴北到杭州东的票，不过这里只是显示问题而已，修改<code>remaining()</code>方法即可，因为看最后一条记录也的确都是可以购买到得</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>火车票 查询问题  针对12306设计一个快速的查询系统
</code></pre><blockquote>
<p>这个网上看到的，好像是百度的一道面试题</p>
</blockquote>
<h2 id="解析">解析]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Java Base" scheme="http://yyl8781697.github.io/tags/Java-Base/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最长递增子序列]]></title>
    <link href="http://yyl8781697.github.io/2015/07/19/Algorithm/Longest/"/>
    <id>http://yyl8781697.github.io/2015/07/19/Algorithm/Longest/</id>
    <published>2015-07-19T08:31:57.000Z</published>
    <updated>2015-07-19T12:22:08.000Z</updated>
    <content type="html"><![CDATA[<p>题目</p>
<pre><code>给定一个长度为<span class="keyword">N</span>的数组，找出一个最长的单调自增子序列（不一定连续，但是顺序不能乱）。例如：给定一个长度为<span class="number">6</span>的数组A<span class="list">{5， 6， 7， 1， 2， 8}</span>，则其最长的单调递增子序列为<span class="list">{5，6，7，8}</span>，长度为<span class="number">4.</span>
</code></pre><h2 id="解析">解析</h2><blockquote>
<p>此题面试中非常常见，其实比较简单，一般面试中不要慌，按条理来一般都能答出 ^_^</p>
</blockquote>
<p>N长度的数组，关于最长递增子序列有max(l(i))=max(l(i-1)),i&gt;1, a[i]&gt;a[i-1]，这个关系式很重要<br>再来看假如N=1，那么l=1<br>如果N=2,有{16,24}，那么可以发现l=2，因为max(l(0))=1,24&gt;16,所以max(l(1))=max(l(0))+1<br>好了，其实我们可以维护一个N的辅助数组，每个值表示在当前元素下考虑后面的元素可能组成的最长递增子序列,比如刚刚为N=2，有f[0]=2,f[1]=1<br>现在来看一个长一点的数组：</p>
<pre><code><span class="atom">a</span>={<span class="number">3</span>,<span class="number">18</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="number">41</span>,<span class="number">16</span>,<span class="number">24</span>}
我们从后往前进行遍历（第一个索引为<span class="number">0</span>）
<span class="atom">a</span>[<span class="number">9</span>]=<span class="number">24</span>，为最后一个元素，所以辅助数组<span class="atom">b</span>中<span class="atom">f</span>[<span class="number">9</span>]=<span class="number">1</span> 表示它以及它最后可能组成的最长递增子序列为<span class="number">1</span>
则有
<span class="atom">f</span>={<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="number">1</span>}
<span class="atom">a</span>[<span class="number">8</span>]=<span class="number">16</span>，所以<span class="atom">a</span>[<span class="number">8</span>]&lt;<span class="atom">a</span>[<span class="number">9</span>],故<span class="atom">f</span>[<span class="number">8</span>]=<span class="number">2</span>
<span class="atom">f</span>={<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="number">2</span>,<span class="number">1</span>}
而<span class="atom">a</span>[<span class="number">7</span>]=<span class="number">41</span>&gt;<span class="atom">a</span>[<span class="number">8</span>]，同时<span class="atom">a</span>[<span class="number">7</span>]&gt;<span class="number">10</span>，所以考虑<span class="atom">a</span>[<span class="number">7</span>]以后的元素它可能的最长递增子序列为<span class="number">1</span>
<span class="atom">f</span>={<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>}
现在来看<span class="atom">a</span>[<span class="number">6</span>]=<span class="number">23</span>&lt;<span class="atom">a</span>[<span class="number">41</span>]，暂时<span class="atom">f</span>[<span class="number">6</span>]=<span class="atom">f</span>[<span class="number">7</span>]+<span class="number">1</span>=<span class="number">2</span> 再来看<span class="atom">a</span>[<span class="number">6</span>]&lt;<span class="atom">a</span>[<span class="number">9</span>] 所以<span class="atom">f</span>[<span class="number">6</span>]=<span class="atom">f</span>[<span class="number">9</span>]+<span class="number">1</span> 还是<span class="number">2</span>
<span class="atom">f</span>={<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>}
再来看一个<span class="atom">a</span>[<span class="number">5</span>]=<span class="number">12</span>，<span class="atom">a</span>[<span class="number">5</span>]&lt;<span class="atom">a</span>[<span class="number">6</span>] 故<span class="atom">f</span>[<span class="number">5</span>]=<span class="atom">f</span>[<span class="number">6</span>]+<span class="number">1</span>=<span class="number">3</span> 再继续<span class="atom">a</span>[<span class="number">7</span>],<span class="atom">a</span>[<span class="number">8</span>],<span class="atom">a</span>[<span class="number">9</span>]对比之后<span class="atom">f</span>[<span class="number">5</span>]还是等于<span class="number">3</span>
<span class="atom">f</span>={<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>}
.
.
.
<span class="atom">f</span>={<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>}

然后根据数组<span class="atom">b</span>取降序位置的索引<span class="number">6</span>，<span class="number">5</span>，<span class="number">4</span>，<span class="number">3</span>，<span class="number">2</span>，<span class="number">1</span>在<span class="atom">a</span>上打印出来即可
</code></pre><p>这里主要是介绍动态规划法：<br>貌似还有最大公共子序列法以及一个插入法来求</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] a=&#123;<span class="number">3</span>,<span class="number">18</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="number">41</span>,<span class="number">16</span>,<span class="number">24</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span>[] f=<span class="keyword">new</span> <span class="keyword">int</span>[a.length];<span class="comment">//存放当前索引位置上以它为起点可能存在的最长子序列个数</span></span><br><span class="line">	<span class="keyword">int</span> maxIndex=-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> maxLen=-<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=a.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		f[i]=<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(i==a.length-<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;a.length;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&lt;a[j] &amp;&amp; f[i]&lt;=f[j])</span><br><span class="line">			&#123;</span><br><span class="line">				f[i]=f[j]+<span class="number">1</span>;<span class="comment">//计算当前以当前位置为索引起始点的最长自增字符串个数</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(f[i]&gt;maxLen)</span><br><span class="line">		&#123;</span><br><span class="line">			maxLen=f[i];<span class="comment">//得到最长的标志</span></span><br><span class="line">			maxIndex=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=maxIndex;i&lt;a.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(f[i]==maxLen)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line">			maxLen--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<pre><code>3
7
10
12
23
41
</code></pre><h2 id="参考">参考</h2><p><a href="http://qiemengdao.iteye.com/blog/1660229" target="_blank" rel="external">http://qiemengdao.iteye.com/blog/1660229</a></p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>题目</p>
<pre><code>给定一个长度为<span class="keyword">N</span>的数组，找出一个最长的单调自增子序列（不一定连续，但是顺序不能乱）。例如：给定一个长度为<span class="number">6</span>的数组A<span]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[打印一个集合所有的子集和]]></title>
    <link href="http://yyl8781697.github.io/2015/07/19/Algorithm/SubCollection/"/>
    <id>http://yyl8781697.github.io/2015/07/19/Algorithm/SubCollection/</id>
    <published>2015-07-19T07:39:20.000Z</published>
    <updated>2015-07-19T08:04:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>打印一个集合所有的子集和，比如<span class="list">{a,b,c}</span>的子集和有<span class="list">{a}</span>,<span class="list">{b}</span>,<span class="list">{c}</span>,<span class="list">{a,b}</span>,<span class="list">{a,c}</span>,<span class="list">{b,c}</span>,<span class="list">{a,b,c}</span>以及 空
</code></pre><h2 id="解析">解析</h2><p>一个元素个数为n的集合所包含的所有组合的子集个数有2^n个，这样其实就可以将所以集合的情况映射到0~2^n-1个，然后按位取元素即可</p>
<pre><code>比如<span class="list">{a,b,c}</span>这个三元素的集合按位映射
<span class="list">{0,0,0}</span>=&gt;空
<span class="list">{0,0,1}</span>=&gt;<span class="list">{c}</span>
<span class="list">{0,1,0}</span>=&gt;<span class="list">{b}</span>
<span class="list">{0,1,1}</span>=&gt;<span class="list">{b,c}</span>
.
.
.
<span class="list">{1,1,1}</span>=&gt;<span class="list">{a,b,c}</span>
</code></pre><h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 将集合映射到位，然后进行与操作,然后一个集合可能含有的子元素最多是2^n个</span><br><span class="line"> *<span class="javadoctag"> @param</span> cs</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">subCollection</span><span class="params">(<span class="keyword">char</span>[] cs)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len=cs.length,maxNum=<span class="number">1</span>&lt;&lt;len;</span><br><span class="line">	<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> mark=<span class="number">0x1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxNum;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len &amp;&amp; temp!=<span class="number">0</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>((temp&amp;mark)==<span class="number">1</span>)<span class="comment">//取最低位的数字是否为1   </span></span><br><span class="line">			&#123;</span><br><span class="line">				System.out.print(cs[j]);</span><br><span class="line">			&#125;</span><br><span class="line">			temp=temp&gt;&gt;<span class="number">1</span>;<span class="comment">//右移一位</span></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的复杂度为<code>O(n*2^n)</code>，最主要的是这种方式代码写起来很方便<br>其测试代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span>[] cs=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line">	subCollection(cs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出的结果为</p>
<pre><code><span class="tag">a</span>
<span class="tag">b</span>
ab
c
ac
bc
abc
</code></pre><h2 id="参考">参考</h2><p>July微软100道面试题  忘了第哪一道 -_-</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>打印一个集合所有的子集和，比如<span class="list">{a,b,c}</span>的子集和有<span class="list">{a}</span>,<span class="list">{b}</spa]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[奇数偶数分离 奇数在左侧,偶数在右侧,要求复杂度为O(N)]]></title>
    <link href="http://yyl8781697.github.io/2015/07/19/Algorithm/OddEvenSplit/"/>
    <id>http://yyl8781697.github.io/2015/07/19/Algorithm/OddEvenSplit/</id>
    <published>2015-07-19T07:20:01.000Z</published>
    <updated>2015-07-19T08:06:22.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>奇数偶数分离 奇数在左侧  偶数在右侧 要求复杂度为<span class="function"><span class="title">O</span><span class="params">(N)</span></span>
</code></pre><h2 id="解析">解析</h2><p>本题的难点主要是在O(N)复杂度的要求，但是想想有没有类似对数组左右分离的操作？<br>对，就是快速排序，在使用快速排序的分区中左边都是小于基准，右边都是大于基准<br>所以，同理，现在按照快排分区的思想，左边都是为奇数，右边都是为偶数，基数无论为奇偶皆可</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 使用快速排序的分区思想，只是&amp;lt;和&amp;gt;变为奇数和偶数而已</span><br><span class="line"> *<span class="javadoctag"> @param</span> a</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oddEvenSplit</span><span class="params">(<span class="keyword">int</span>[] a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.length&lt;<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> k=a[<span class="number">0</span>],i=<span class="number">0</span>,j=a.length-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>((a[j]&amp;<span class="number">1</span>)==<span class="number">0</span> &amp;&amp; i&lt;j)<span class="comment">//从右往左找  直到遇到奇数</span></span><br><span class="line">			j--;</span><br><span class="line">		a[i]=a[j];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>((a[i]&amp;<span class="number">1</span>)==<span class="number">1</span> &amp;&amp; i&lt;j)<span class="comment">//从左往右找  直到遇到偶数</span></span><br><span class="line">			i++;</span><br><span class="line">		a[j]=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	a[i]=k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看下测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">	oddEvenSplit(a);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">		System.out.print(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出的结果为：</p>
<pre><code>75314628
</code></pre><p>可以发现这里是以1为基准，1左边的都是奇数，1右边的都是偶数</p>
<h2 id="参考">参考</h2><p>July微软100道面试题  忘了第哪一道 -_-</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>奇数偶数分离 奇数在左侧  偶数在右侧 要求复杂度为<span class="function"><span class="title">O</span><span class="params">(N)</span></]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从52张牌中随意取5张，看是否能组成顺子]]></title>
    <link href="http://yyl8781697.github.io/2015/07/18/Algorithm/CardStraight/"/>
    <id>http://yyl8781697.github.io/2015/07/18/Algorithm/CardStraight/</id>
    <published>2015-07-18T15:23:27.000Z</published>
    <updated>2015-07-18T15:44:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>从52张牌中随意取5张，看是否能组成顺子
其中1~k 表示1~13  大小王可以代替任意数字
</code></pre><h2 id="解题">解题</h2><p>首先可以将牌映射到数组上，然后将数组排序<br>在使用左右两端的指针向中间靠<br>如果左指针与接下来的值相差1或者接下来的值时大小王 则过到下一个<br>否则判断右指针是否有大小王  有的话右指针左移一位</p>
<pre><code>现在有牌排序之后的样纸
<span class="number">1</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">5</span>，king
^           ^
第一次判断的时候可以发现<span class="number">1</span>=<span class="number">2</span>-<span class="number">1</span>  正好成顺序
<span class="number">1</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">5</span>，king
   ^        ^
但是在第二次迭代中会发现这次<span class="number">2</span>!=<span class="number">4</span>-<span class="number">1</span>
所以要去判断最后面是否存在<span class="tag">q</span>,如果存在，这右指针前面移动
<span class="number">1</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">5</span>，king
   ^    ^

然后这里不断迭代即可，直到左右指针碰到一起
</code></pre><h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 先排序</span><br><span class="line"> * 在使用左右两端的指针向中间靠</span><br><span class="line"> * 如果左指针与接下来的值相差1或者接下来的值时大小王 则过到下一个</span><br><span class="line"> * 否则判断右指针是否有大小王  有的话右指针左移一位</span><br><span class="line"> *<span class="javadoctag"> @param</span> a</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">cardStraight</span><span class="params">(<span class="keyword">int</span>[] a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Arrays.sort(a);<span class="comment">//进行排序 O(nlogn)</span></span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=a.length-<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">int</span> cur=a[i];<span class="comment">//表示当前比较的牌 不是前后两张牌是否是连续的或者是用大小王来代替的 这个cur的计数都会+1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(cur==a[i+<span class="number">1</span>]-<span class="number">1</span>||a[i+<span class="number">1</span>]==Integer.MAX_VALUE)</span><br><span class="line">		&#123;</span><br><span class="line">			i++;<span class="comment">//这里表示上下两张牌连续 后者最后一张可以用的牌位大小王</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j]==Integer.MAX_VALUE)<span class="comment">//不通过  判断最后一张牌是不是大小王</span></span><br><span class="line">			&#123;</span><br><span class="line">				j--;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				flag=<span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cur++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看一下测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里使用Integer.MAX_VALUE表示大小王</span></span><br><span class="line">	<span class="keyword">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	System.out.println(cardStraight(a));</span><br><span class="line">	<span class="keyword">int</span>[] b=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	System.out.println(cardStraight(b));</span><br><span class="line">	<span class="keyword">int</span>[] c=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,Integer.MAX_VALUE&#125;;<span class="comment">//有一个大小王</span></span><br><span class="line">	System.out.println(cardStraight(c));</span><br><span class="line">	<span class="keyword">int</span>[] d=&#123;<span class="number">1</span>,Integer.MAX_VALUE,Integer.MAX_VALUE,<span class="number">4</span>,Integer.MAX_VALUE&#125;;<span class="comment">//有好多大小王</span></span><br><span class="line">	System.out.println(cardStraight(d));</span><br><span class="line">	<span class="keyword">int</span>[] e=&#123;<span class="number">1</span>,Integer.MAX_VALUE,Integer.MAX_VALUE,<span class="number">6</span>,Integer.MAX_VALUE&#125;;<span class="comment">//有好多大小王  但是最大的牌也太大了</span></span><br><span class="line">	System.out.println(cardStraight(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终结果为：</p>
<pre><code><span class="literal">true</span>
<span class="literal">false</span>
<span class="literal">true</span>
<span class="literal">true</span>
<span class="literal">false</span>
</code></pre><hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>从52张牌中随意取5张，看是否能组成顺子
其中1~k 表示1~13  大小王可以代替任意数字
</code></pre><h2 id="解题">解题</h2><p>首先可以将牌映射到数组上，然后将数组排序<br>在使用左]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用递归的方法将栈颠倒]]></title>
    <link href="http://yyl8781697.github.io/2015/07/18/Algorithm/Put-Upside-Down-Stack/"/>
    <id>http://yyl8781697.github.io/2015/07/18/Algorithm/Put-Upside-Down-Stack/</id>
    <published>2015-07-17T16:33:15.000Z</published>
    <updated>2015-07-18T08:49:07.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>使用递归的方法将栈颠倒
</code></pre><h2 id="解题">解题</h2><p>假设当前的入栈顺序为1,2,3,4,5  那么我们的目标是将栈内的顺序改为5,4,3,2,2,1<br>先来看如果将数据搞成了1 和5,4,3,2  那么只需要将1放在栈的尾部即可，就可以变成了5,4,3,2,1<br>那么如何将2，3，4，5变为5,4,3,2呢，其实同理，也是分为2和5,4,2 一致递归</p>
<p>关于如何将元素放入栈的尾部？</p>
<pre><code>将e放到底部
先递归逐个将元素取出来  取至空的时候将e给<span class="keyword">push</span>进去
然后再依次将取出来的元素也给<span class="keyword">push</span>进去
</code></pre><h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 1,2,3,4,5看成1和2,3,4,5</span><br><span class="line"> * 假如已经将2,3,4,5倒转置5,4,3,2  那么只需要将1放到末尾即可</span><br><span class="line"> * 同时关于2,3,4,5的倒置也可以看做3,4,5和2的分离</span><br><span class="line"> * 逐步递归即可</span><br><span class="line"> *<span class="javadoctag"> @param</span> stack</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">putUpsideDownStack</span><span class="params">(Stack&lt;E&gt; stack)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(stack.size()&lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	</span><br><span class="line">	E t=stack.pop();</span><br><span class="line">	putUpsideDownStack(stack);</span><br><span class="line">	addToBottom(stack,t);<span class="comment">//将当前元素放到底部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 将e放到底部</span><br><span class="line"> * 先递归逐个将元素取出来  取至空的时候将e给push进去</span><br><span class="line"> * 然后再依次将取出来的元素也给push进去</span><br><span class="line"> *<span class="javadoctag"> @param</span> stack</span><br><span class="line"> *<span class="javadoctag"> @param</span> e</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addToBottom</span><span class="params">(Stack&lt;E&gt; stack,E e)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(stack.size()==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		stack.push(e);<span class="comment">//放到底部</span></span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	E t=stack.pop();</span><br><span class="line">	addToBottom(stack,e);</span><br><span class="line">	stack.push(t);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证结果可以看到<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">	stack.push(<span class="number">1</span>);</span><br><span class="line">	stack.push(<span class="number">2</span>);</span><br><span class="line">	stack.push(<span class="number">3</span>);</span><br><span class="line">	stack.push(<span class="number">4</span>);</span><br><span class="line">	stack.push(<span class="number">5</span>);</span><br><span class="line">	putUpsideDownStack(stack);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(stack.size()&gt;<span class="number">0</span>)</span><br><span class="line">		System.out.println(stack.pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>1
2
3
4
5
</code></pre><h2 id="参考">参考</h2><p><a href="http://blog.csdn.net/cxllyg/article/details/7655935" target="_blank" rel="external">http://blog.csdn.net/cxllyg/article/details/7655935</a></p>
<blockquote>
<p>其实我只是将参考里面的意思给复述了一下，我好自己理解-_-</p>
</blockquote>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>使用递归的方法将栈颠倒
</code></pre><h2 id="解题">解题</h2><p>假设当前的入栈顺序为1,2,3,4,5  那么我们的目标是将栈内的顺序改为5,4,3,2,2,1<br>先来看如果将数据搞成了]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在O(1)时间内删除一个单链表上指定的节点]]></title>
    <link href="http://yyl8781697.github.io/2015/07/17/Algorithm/DeleteNode-In-O1/"/>
    <id>http://yyl8781697.github.io/2015/07/17/Algorithm/DeleteNode-In-O1/</id>
    <published>2015-07-16T23:19:56.000Z</published>
    <updated>2015-07-18T08:47:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>在<span class="function"><span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span>时间内删除一个单链表上指定的节点
</code></pre><h2 id="解题">解题</h2><p>这题主要是需要O(1)的复杂度，我们之前一般删除节点的方法都是找到要删除节点p，然后p.parent.next=p.next就可以了，但是那个复杂度是O(n)</p>
<p>不过这里有一种我称为狸猫换太子的方法来解决这个问题</p>
<pre><code><span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>
 假如现在要删除p.<span class="typedef"><span class="keyword">data</span>=3</span>
 首先将p.<span class="typedef"><span class="keyword">data</span>=p.next.<span class="keyword">data</span></span>
 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>
 然后将p.next删除
 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>

 如果是尾节点  需要重新遍历
</code></pre><p>思路很精妙，就是将p.next作为傀儡，删除它</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line"> * 假如现在要删除p.data=3</span><br><span class="line"> * 首先将p.data=p.next.data</span><br><span class="line"> * 1-&gt;2-&gt;4-&gt;4-&gt;5</span><br><span class="line"> * 然后将p.next删除</span><br><span class="line"> * 1-&gt;2-&gt;4-&gt;5</span><br><span class="line"> * </span><br><span class="line"> * 如果是尾节点  需要重新遍历</span><br><span class="line"> * 还有 如果是p==head  则直接得置空  但是在java中这个操作不是很好做。所以。。。</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> *<span class="javadoctag"> @param</span> head</span><br><span class="line"> *<span class="javadoctag"> @param</span> dNode</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteNodeInO1</span><span class="params">(Link head,Link p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(p.next==<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//表示尾部节点</span></span><br><span class="line">		Link q=head;</span><br><span class="line">		<span class="keyword">while</span>(q.next!=p)</span><br><span class="line">			q=q.next;<span class="comment">//找到尾节点的前一个节点</span></span><br><span class="line">		q.next=<span class="keyword">null</span>;<span class="comment">//进行删除</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		p.data=p.next.data;</span><br><span class="line">		p.next=p.next.next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Link head)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Link p=head;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.print(p.data);</span><br><span class="line">		p=p.next;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Link</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">public</span> Link next;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> data)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data=data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只是要删除节点是头部或者尾部的时候需要额外考虑，按遍历的方法删除即可</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>在<span class="function"><span class="title">O</span><span class="params">(<span class="number">1</span>)</span]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[链表的逆序输出]]></title>
    <link href="http://yyl8781697.github.io/2015/07/16/Algorithm/Print-Tail-Head/"/>
    <id>http://yyl8781697.github.io/2015/07/16/Algorithm/Print-Tail-Head/</id>
    <published>2015-07-16T15:52:12.000Z</published>
    <updated>2015-07-16T23:17:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题">问题</h2><pre><code>如何将一个链表进行逆序输出，比如<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>的链表输出为<span class="number">4321</span>
</code></pre><h2 id="解题">解题</h2><ol>
<li>最方便可能就是先讲原生链表翻转，再按翻转的输出，这样会破坏原有链表的结构</li>
<li>第二种就是先遍历存放到一个数组或者栈中，然后从后往前输出即可，就需要额外的O(n)空间。</li>
</ol>
<p>这两种方法都是需要额外的复杂度或者空间，网络行流传更好的方法就是使用递归-_-! 神方法啊，递归一次即可。。</p>
<h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 使用递归 不消耗其他的空间</span><br><span class="line"> *<span class="javadoctag"> @param</span> link</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTail2Head</span><span class="params">(Link link)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(link!=<span class="keyword">null</span> &amp;&amp; link.next!=<span class="keyword">null</span>)</span><br><span class="line">		printTail2Head(link.next);</span><br><span class="line">	System.out.println(link.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Link</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">public</span> Link next;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> data)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data=data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种方法固然好，但是注意，如果链表的长度很长，也许会给<code>stackOverflowException</code>的异常。</p>
</blockquote>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="问题">问题</h2><pre><code>如何将一个链表进行逆序输出，比如<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</sp]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[链表的翻转]]></title>
    <link href="http://yyl8781697.github.io/2015/07/16/Algorithm/LinkedList-Revert/"/>
    <id>http://yyl8781697.github.io/2015/07/16/Algorithm/LinkedList-Revert/</id>
    <published>2015-07-16T15:28:28.000Z</published>
    <updated>2015-07-16T23:16:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>将链表<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>翻转成<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>。
</code></pre><h2 id="解题">解题</h2><p>最简单就是遍历链表，然后保存到一个数组中，然后再向后构建数组，当然，这种方式不好，会有额外开销。-_-<br>这里来介绍一下另一种方法：<br>假设现在的链表是</p>
<pre><code><span class="built_in">null</span><span class="subst">-&gt;</span><span class="number">1</span><span class="subst">-&gt;</span><span class="number">2</span><span class="subst">-&gt;</span><span class="number">3</span><span class="subst">-&gt;</span><span class="number">4</span><span class="subst">-&gt;</span><span class="built_in">null</span>
</code></pre><p>如果我们想办法将2移到1的前面，然后3又移到2的前面，最后将4移动3的前面，这不就完了嘛？<br>好，现在开始移动：</p>
<pre><code>    <span class="number">2</span>
   <span class="subst">/</span> <span class="subst">\</span> 
<span class="built_in">null</span>  <span class="number">1</span><span class="subst">-&gt;</span><span class="number">3</span><span class="subst">-&gt;</span><span class="number">4</span><span class="subst">-&gt;</span><span class="built_in">null</span>
将<span class="number">1</span>指向<span class="number">2</span>的next，然后将<span class="number">2</span>的next指向head的next，然后head的next指向<span class="number">2</span>

    <span class="number">3</span><span class="subst">-</span><span class="number">2</span>
   <span class="subst">/</span>  <span class="subst">|</span>
<span class="built_in">null</span>  <span class="number">1</span><span class="subst">-&gt;</span><span class="number">4</span><span class="subst">-&gt;</span><span class="built_in">null</span>
然后再移动<span class="number">3</span>

    <span class="number">4</span><span class="subst">-</span><span class="number">3</span><span class="subst">-</span><span class="number">2</span>
   <span class="subst">/</span>    <span class="subst">|</span>
<span class="built_in">null</span>    <span class="number">1</span><span class="subst">-&gt;</span><span class="built_in">null</span>
再移动<span class="number">4</span>
</code></pre><blockquote>
<p>这种方式就不需要额外的空间，也只需要遍历一遍即可。</p>
</blockquote>
<h2 id="代码">代码</h2><p>具体的代码如下，链表节点的数据结构为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">public</span> Node next;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val,Node next)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.val=val;</span><br><span class="line">		<span class="keyword">this</span>.next=next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>则其翻转的函数为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">revert</span><span class="params">(Node head)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Node temp=head.next;</span><br><span class="line">	Node p=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span>(temp.next!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p=temp.next;<span class="comment">//保存1号的下一个节点</span></span><br><span class="line">		temp.next=p.next;<span class="comment">//将1号的下一个节点删除</span></span><br><span class="line">		p.next=head.next;<span class="comment">//将1号的下一个节点指向链表第一点节点（非头部）</span></span><br><span class="line">		head.next=p;<span class="comment">//更新头部的指向</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试的代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	Node node4=<span class="keyword">new</span> Node(<span class="number">4</span>,<span class="keyword">null</span>);</span><br><span class="line">	Node node3=<span class="keyword">new</span> Node(<span class="number">3</span>,node4);</span><br><span class="line">	Node node2=<span class="keyword">new</span> Node(<span class="number">2</span>,node3);</span><br><span class="line">	Node node1=<span class="keyword">new</span> Node(<span class="number">1</span>,node2);</span><br><span class="line">	Node head=<span class="keyword">new</span> Node(-<span class="number">1</span>,node1);</span><br><span class="line">	print(head);</span><br><span class="line">	revert(head);</span><br><span class="line">	print(head);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终的输出为</p>
<pre><code>1,2,3,4,
4,3,2,1,
</code></pre><h2 id="参考">参考</h2><ol>
<li><a href="http://blog.csdn.net/chuyuqing/article/details/44457665" target="_blank" rel="external">http://blog.csdn.net/chuyuqing/article/details/44457665</a></li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>将链表<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[graphx上的一些简单应用]]></title>
    <link href="http://yyl8781697.github.io/2015/07/07/Spark/Graphs-Applications/"/>
    <id>http://yyl8781697.github.io/2015/07/07/Spark/Graphs-Applications/</id>
    <published>2015-07-07T14:59:23.000Z</published>
    <updated>2015-07-19T08:13:42.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文是温习<a href="http://www.csdn.net/article/2014-08-07/2821097" target="_blank" rel="external">快刀初试：Spark GraphX在淘宝的实践</a>这篇文章中明风大神提到得几个graphx的应用,并且自己使用graphx将其实现一下^_^</p>
</blockquote>
<h2 id="看实验用的图：">看实验用的图：</h2><p><img src="/img/Graphx-Application/sampleG.jpg" alt=""></p>
<h2 id="度分布">度分布</h2><p>最近忙复习，没时间写-<em>-  还未完待续呢^</em>^</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文是温习<a href="http://www.csdn.net/article/2014-08-07/2821097" target="_blank" rel="external">快刀初试：Spark GraphX在淘宝的实践</a>这篇文章]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Spark" scheme="http://yyl8781697.github.io/tags/Spark/"/>
    
      <category term="Spark" scheme="http://yyl8781697.github.io/categories/Spark/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[假设你有一个用 1001 个整数组成的数组,这些整数是任意排列的]]></title>
    <link href="http://yyl8781697.github.io/2015/07/05/Algorithm/1-2-n/"/>
    <id>http://yyl8781697.github.io/2015/07/05/Algorithm/1-2-n/</id>
    <published>2015-07-05T15:41:26.000Z</published>
    <updated>2015-07-05T15:52:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>假设你有一个用 <span class="number">1001</span> 个整数组成的数组,这些整数是任意排列的,但是你知道所有的整 数都在 <span class="number">1</span> 到 <span class="number">1000</span><span class="comment">(包括 1000)</span>之间。此外,除一个数字出现两次外,其他所有数字只出现一 次。假设你只能对这个数组做一次处理,用一种算法找出重复的那个数字。如果你在运算中 使用了辅助的存储方式,那么你能找到不用这种方式的算法吗?
</code></pre><h2 id="方法1">方法1</h2><p>这里都说1~1000都至少包含一遍了，所以求和在减去1~1000的和即可<br>假设遍历数组之后的求和为sum，则那个数字就是sum-(1000*10001/2)</p>
<blockquote>
<p>但是如果这里不是1000，而是这个数字非常的大，求和就可能出现溢出</p>
</blockquote>
<h2 id="方法2">方法2</h2><p>还记得有一道经典的<a href="https://leetcode.com/problems/single-number/" target="_blank" rel="external">leetcode题目</a>就是一个数组中每个数出现2次，只有一个数字出现了3次，找出这个数字。<br>该题目的思路是A^A=0,A^0=A</p>
<p>按这个思路，因为我们知道1~1000已经出现一遍了，那么在遍历的时候自变量i也会从1~1000出现一遍，所以可以利用i来构造每个数字出现两次的情况，所以解题思路就是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchTwiceNum</span><span class="params">(<span class="keyword">int</span> a[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k=a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		k^=a[i]^i;<span class="comment">//通过i来构造</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样操作就不会出现溢出的情况了</p>
<h2 id="参考">参考</h2><ul>
<li>July微软面试题第8题</li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>假设你有一个用 <span class="number">1001</span> 个整数组成的数组,这些整数是任意排列的,但是你知道所有的整 数都在 <span class="number">1</span> 到 <sp]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[单向列表是否有环，两个链表是否相交，以及交点]]></title>
    <link href="http://yyl8781697.github.io/2015/07/03/Algorithm/Single-Linked-Cycle-Y/"/>
    <id>http://yyl8781697.github.io/2015/07/03/Algorithm/Single-Linked-Cycle-Y/</id>
    <published>2015-07-02T16:49:20.000Z</published>
    <updated>2015-07-12T01:18:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="单向链表的结构">单向链表的结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">public</span> Link next;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> data)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data=data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//为了打印方便而加上去的。。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> String.format(<span class="string">"data:%s"</span>,<span class="keyword">this</span>.data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单向链表是否有环">单向链表是否有环</h2><p>这题的思路很简单，先创建两个指针都指向链表的头部，一个fast指针每次走两步，另一个slow指针每次都走一步，如果fast指针能走到null的地方就说明该单链表没有环，否则fast和slow节点一定会走到同一个节点，表示有环<br>具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 判断是否有环</span><br><span class="line"> *<span class="javadoctag"> @param</span> head</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCycle</span><span class="params">(Link head)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(head!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Link fast=head,slow=head;</span><br><span class="line">		<span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)<span class="comment">//如果走到尾的肯定是fast先 所以这里只需要判断fast即可</span></span><br><span class="line">		&#123;</span><br><span class="line">			slow=slow.next;</span><br><span class="line">			fast=fast.next.next;</span><br><span class="line">			<span class="keyword">if</span>(fast==slow)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//两个指针指向了同一个节点 表示有环</span></span><br><span class="line">				flag=<span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="判断两个单向链表是否相交">判断两个单向链表是否相交</h2><p>这里可以想一下，单向链表的相交是什么情况？<br>那肯定是一个Y字形的，因为两个链表都是单向的嘛^_^，所以有两种解法</p>
<ol>
<li>利用上面的环，先遍历其中一个链表，另其首尾相连，（其实如果相交就会构成一个含有环的单链表），此时再从另一个链表的头部出发找是否有环就可以了</li>
<li>将两个链表都遍历到尾结果，如果这两个尾节点是同一个节点，说明就是相交</li>
</ol>
<blockquote>
<p>其实还可以使用hash的方法，也就是遍历两个链表进行hash，同一个节点的hash值肯定是一样的，然后就是两个集合的包含元素查找即可</p>
</blockquote>
<h2 id="判断两个相交的链表的交点1">判断两个相交的链表的交点1</h2><p>其实这里根据上一问可知，如果有交点，那个交点就是环的入口点，所以先根据环的方法找入口点，然后将fast指针指向链表的头部，但是这个fast节点之后都是走一步，和slow同时走，它们相等的地方就是环的交点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 两个链表是否相交  就是Y形状</span><br><span class="line"> *<span class="javadoctag"> @param</span> head</span><br><span class="line"> *<span class="javadoctag"> @return</span> //如果相交 返回交点</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Link <span class="title">isY</span><span class="params">(Link head1,Link head2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Link y=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span>(head1!=<span class="keyword">null</span> &amp;&amp; head2!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Link h=head1;</span><br><span class="line">		<span class="keyword">while</span>(h.next!=<span class="keyword">null</span>)</span><br><span class="line">			h=h.next;</span><br><span class="line">		h.next=head1;<span class="comment">//将链表1的收尾相连</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(head2!=<span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Link fast=head2,slow=head2;</span><br><span class="line">			<span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				slow=slow.next;</span><br><span class="line">				fast=fast.next.next;</span><br><span class="line">				<span class="keyword">if</span>(fast==slow)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//两个指针指向了同一个节点 表示有环</span></span><br><span class="line">					flag=<span class="keyword">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(flag)</span><br><span class="line">			&#123;</span><br><span class="line">				fast=head2;<span class="comment">//回到起点</span></span><br><span class="line">				<span class="keyword">while</span>(slow!=fast)</span><br><span class="line">				&#123;</span><br><span class="line">					slow=slow.next;</span><br><span class="line">					fast=fast.next;</span><br><span class="line">				&#125;</span><br><span class="line">				y=fast;<span class="comment">//得到交点</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		h.next=<span class="keyword">null</span>;<span class="comment">//将第一个链表该为单链表</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ps.如果需要看交点具体的推导看<a href="http://www.cnblogs.com/BeyondAnyTime/archive/2012/07/06/2580026.html" target="_blank" rel="external">http://www.cnblogs.com/BeyondAnyTime/archive/2012/07/06/2580026.html</a></p>
</blockquote>
<h2 id="判断两个相交的链表的交点2">判断两个相交的链表的交点2</h2><p>求出两个单链表的尾节点，在这个过程中可以很容易得到两个链表的长度，len1,len2，然后先让长的链表走abs(len1-len2)，然后让两个链表齐头并进就可以找到交点，复杂度是O(n+m)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 两个链表是否相交  就是Y形状</span><br><span class="line"> * 首先首先将两个环各自走到尾部，记录tail1和len1，以及tail2和len2</span><br><span class="line"> * 如果tail1=tail2  则相交</span><br><span class="line"> * 然后先让长的链表走abs(len1-len2)，然后让两个链表齐头并进就可以找到交点，复杂度是O(n+m)</span><br><span class="line"> *<span class="javadoctag"> @param</span> head1</span><br><span class="line"> *<span class="javadoctag"> @param</span> head2</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Link <span class="title">isY2</span><span class="params">(Link head1,Link head2)</span></span>&#123;</span><br><span class="line">	Link y=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span>(head1!=<span class="keyword">null</span> &amp;&amp; head2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		Link tail1=head1,tail2=head2;</span><br><span class="line">		<span class="keyword">int</span> len1=<span class="number">1</span>,len2=<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//记录两个链表的尾部节点 以及他们的长度</span></span><br><span class="line">		<span class="keyword">while</span>(tail1.next!=<span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			len1++;</span><br><span class="line">			tail1=tail1.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(tail2.next!=<span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			len2++;</span><br><span class="line">			tail2=tail2.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//两个尾部相等就表示相交</span></span><br><span class="line">		<span class="keyword">if</span>(tail1==tail2)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//区分长链表和端链表</span></span><br><span class="line">			Link longLink=head1,shortLink=head2;</span><br><span class="line">			<span class="keyword">if</span>(len1&lt;len2)</span><br><span class="line">			&#123;</span><br><span class="line">				longLink=head2;</span><br><span class="line">				shortLink=head1;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//将长链表先走abs(len1-len2)步</span></span><br><span class="line">			<span class="keyword">int</span> diff=Math.abs(len1-len2);</span><br><span class="line">			<span class="keyword">while</span>(diff&gt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				longLink=longLink.next;</span><br><span class="line">				diff--;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span>(longLink!=shortLink)</span><br><span class="line">			&#123;</span><br><span class="line">				longLink=longLink.next;</span><br><span class="line">				shortLink=shortLink.next;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			y=longLink;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="演示结果代码">演示结果代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Link head1=<span class="keyword">new</span> Link(<span class="number">1</span>);</span><br><span class="line">	Link link1=<span class="keyword">new</span> Link(<span class="number">2</span>);</span><br><span class="line">	head1.next=link1;</span><br><span class="line">	Link link2=<span class="keyword">new</span> Link(<span class="number">3</span>);</span><br><span class="line">	link1.next=link2;</span><br><span class="line">	Link link3=<span class="keyword">new</span> Link(<span class="number">4</span>);</span><br><span class="line">	link2.next=link3;</span><br><span class="line">	Link link4=<span class="keyword">new</span> Link(<span class="number">5</span>);</span><br><span class="line">	link3.next=link4;</span><br><span class="line">	Link link5=<span class="keyword">new</span> Link(<span class="number">6</span>);</span><br><span class="line">	link4.next=link5;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	System.out.println(isCycle(head1));</span><br><span class="line">	link5.next=link2;<span class="comment">//使链表相交</span></span><br><span class="line">	System.out.println(isCycle(head1));</span><br><span class="line">	link5.next=<span class="keyword">null</span>;<span class="comment">//重置为单链表</span></span><br><span class="line">	</span><br><span class="line">	Link head2=<span class="keyword">new</span> Link(<span class="number">7</span>);</span><br><span class="line">	Link link6=<span class="keyword">new</span> Link(<span class="number">8</span>);</span><br><span class="line">	head2.next=link6;</span><br><span class="line">	Link link7=<span class="keyword">new</span> Link(<span class="number">9</span>);</span><br><span class="line">	link6.next=link7;<span class="comment">//新建一个单列表</span></span><br><span class="line">	</span><br><span class="line">	System.out.println(isY(head1,head2));</span><br><span class="line">	link7.next=link2;<span class="comment">//将第二的单链表的某个元素指向第一个链表</span></span><br><span class="line">	System.out.println(isY(head1,head2));</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体结果</p>
<pre><code><span class="literal">false</span>
<span class="literal">true</span>
<span class="literal">null</span>
<span class="string">data:</span><span class="number">3</span>
</code></pre><hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="单向链表的结构">单向链表的结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="l]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[定义栈的数据结构，要求添加一个min函数，能够得到栈的最小元素]]></title>
    <link href="http://yyl8781697.github.io/2015/07/02/Algorithm/MinStack/"/>
    <id>http://yyl8781697.github.io/2015/07/02/Algorithm/MinStack/</id>
    <published>2015-07-02T15:11:04.000Z</published>
    <updated>2015-07-02T15:23:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>定义栈的数据结构，要求添加一个min函数，能够得到栈的最小元素。要求函数min、push以及pop的时间复杂度都是<span class="function"><span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span>。
</code></pre><h2 id="解题">解题</h2><p>这道题目的主要难点就是需要的复杂度为O(1)，也就是说在求最小值的时候无法遍历该栈。<br>正确地解法就是使用一个辅助栈（数组），为维持当前栈容量下地最小值情况</p>
<p>比如</p>
<pre><code>栈数据
3,5,2,4,1
辅助数据
0,0,2,2,4
</code></pre><p>将5压入栈的时候，发现上一个栈顶元素下的最小值是3，故这里无法更新最小值，仍旧将当前的最小值置为3（索引位置为0），但是当2压入栈的时候<br>，可以发展2&lt;3，所以在该类情况下会将当前栈的最小值更新为2（即索引为2）<br>这种设计在出栈的时候只需要将栈数据的栈顶出掉即可，同样在求最小值的时候只要返回当前辅助数据中索引值在栈数据中的值即可<br>这样就非常方便地实现了O（1）的要求，同时因为辅助栈是存储索引位置，索引并不会占用很大的内容空间</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//存储栈的元素</span></span><br><span class="line">	<span class="keyword">private</span> Object[] elementData;</span><br><span class="line">	<span class="comment">//存储当前栈尺寸下最小元素的位置</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] minPos;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//栈的实际大小</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//栈的总容量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> capacity=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//栈的默认容量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELAULT_CAPACITY=<span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(DELAULT_CAPACITY);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">(<span class="keyword">int</span> capacity)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.elementData=<span class="keyword">new</span> Object[capacity];</span><br><span class="line">		<span class="keyword">this</span>.minPos=<span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 将数据压入栈</span><br><span class="line">	 *<span class="javadoctag"> @param</span> e</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		ensureCapacity(size+<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		elementData[size]=e;</span><br><span class="line">		<span class="comment">//这里来维护最小元素位置的数组</span></span><br><span class="line">		<span class="keyword">if</span>(size==<span class="number">0</span> || e.compareTo((E)elementData[minPos[size-<span class="number">1</span>]])&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//更新栈的最小元素</span></span><br><span class="line">			minPos[size]=size;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			minPos[size]=size-<span class="number">1</span>;<span class="comment">//保持原来的为最小</span></span><br><span class="line">		&#125;</span><br><span class="line">		size++;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 出栈  直接出</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 *<span class="javadoctag"> @throws</span> EmptyStackException</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> EmptyStackException</span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(size&lt;=<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">		</span><br><span class="line">		size--;</span><br><span class="line">		<span class="keyword">return</span> (E)elementData[size];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 取最小值  直接在辅助的数组上取值即可</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 *<span class="javadoctag"> @throws</span> EmptyStackException</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">min</span><span class="params">()</span> <span class="keyword">throws</span> EmptyStackException</span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(size&lt;=<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> (E)elementData[minPos[size-<span class="number">1</span>]];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 确保容量足够</span><br><span class="line">	 *<span class="javadoctag"> @param</span> minCapacity</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(minCapacity&gt;capacity)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//需要扩容</span></span><br><span class="line">			<span class="keyword">int</span> newCapacity = minCapacity + (minCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">			elementData=Arrays.copyOf(elementData, newCapacity);<span class="comment">//拷贝数组</span></span><br><span class="line">			minPos=Arrays.copyOf(minPos, newCapacity);</span><br><span class="line">			capacity=newCapacity;<span class="comment">//更新容量</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStack</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"\r\n栈数据"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">			System.out.print(<span class="keyword">this</span>.elementData[i]+<span class="string">","</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"\r\n辅助数据"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">			System.out.print(<span class="keyword">this</span>.minPos[i]+<span class="string">","</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现这个栈的代码如上，使用main函数的测试如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	MinStack&lt;Integer&gt; minStack=<span class="keyword">new</span> MinStack&lt;Integer&gt;();</span><br><span class="line">	minStack.push(<span class="number">3</span>);</span><br><span class="line">	minStack.push(<span class="number">5</span>);</span><br><span class="line">	minStack.push(<span class="number">2</span>);</span><br><span class="line">	minStack.push(<span class="number">4</span>);</span><br><span class="line">	minStack.push(<span class="number">1</span>);</span><br><span class="line">	minStack.printStack();</span><br><span class="line">	System.out.println(<span class="string">"最小值:"</span>+minStack.min());</span><br><span class="line">	minStack.pop();</span><br><span class="line">	minStack.printStack();</span><br><span class="line">	System.out.println(<span class="string">"最小值:"</span>+minStack.min());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终就可以打印出:</p>
<pre><code>栈数据
3,5,2,4,1,
辅助数据
0,0,2,2,4,
最小值<span class="pseudo">:1</span>

栈数据
3,5,2,4,
辅助数据
0,0,2,2,
最小值<span class="pseudo">:2</span>
</code></pre><h2 id="参考">参考</h2><ul>
<li><a href="http://zhedahht.blog.163.com/blog/static/25411174200712895228171/" target="_blank" rel="external">http://zhedahht.blog.163.com/blog/static/25411174200712895228171/</a></li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>定义栈的数据结构，要求添加一个min函数，能够得到栈的最小元素。要求函数min、push以及pop的时间复杂度都是<span class="function"><span class="title">O</span><s]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉排序树转为双向链表]]></title>
    <link href="http://yyl8781697.github.io/2015/07/01/Algorithm/Binary-Search-Tree-2-Double-LinkedList/"/>
    <id>http://yyl8781697.github.io/2015/07/01/Algorithm/Binary-Search-Tree-2-Double-LinkedList/</id>
    <published>2015-06-30T23:36:00.000Z</published>
    <updated>2015-07-02T15:25:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>输入一棵排序二叉树，将此树转换成一个排序的双向链表，要求不能创建任何新的借点，只能调整指针的指向.
</code></pre><h2 id="分析">分析</h2><blockquote>
<p>二叉排序树的中序遍历可以得到它的排序元素，但是，但是“它不能创建任何新的节点，只能调整指针的指向”，所以，直接中序法就不可行了。</p>
</blockquote>
<p>大致思路是如下的：</p>
<ul>
<li>如果当前根节点的左子树不为空，则<ol>
<li>递归左子树</li>
<li>查找左子树最大的元素</li>
<li>将该元素的<code>right</code>指针指向根节点，将根节点的<code>left</code>指针指向该元素</li>
</ol>
</li>
<li>如果当前根节点的右子树不为空，则<ol>
<li>递归右子树</li>
<li>查找右子树最小的元素</li>
<li>将该元素的<code>left</code>指针指向根节点，将根节点的<code>right</code>指针指向该元素</li>
</ol>
</li>
</ul>
<blockquote>
<p>注：<code>tree</code>的<code>left</code>和<code>right</code>结构正好对应<code>list</code>的<code>pre</code>和<code>next</code>结构</p>
</blockquote>
<pre><code>      <span class="number">8</span>    
    /   <span class="string">\</span>
   <span class="number">3</span>     <span class="number">10</span>
 /   <span class="string">\</span>     <span class="string">\</span>
<span class="number">1</span>     <span class="number">6</span>     <span class="number">14</span>
    /  <span class="string">\</span>   /
   <span class="number">4</span>    <span class="number">7</span> <span class="number">13</span> 

它依次调整的点为：<span class="number">1</span>(l),<span class="number">4</span>(l),<span class="number">7</span>(r),<span class="number">4</span>(r),<span class="number">7</span>(l),<span class="number">13</span>(l),<span class="number">13</span>(r),<span class="number">10</span>(r)
      <span class="number">8</span>    
    /   <span class="string">\</span>
 <span class="number">1</span>-<span class="number">3</span>     <span class="number">10</span>
    <span class="string">\</span>     <span class="string">\</span>
    <span class="number">6</span>     <span class="number">14</span>
    /  <span class="string">\</span>   /
   <span class="number">4</span>    <span class="number">7</span> <span class="number">13</span> 
   <span class="number">1</span>为<span class="number">3</span>左子树的最大点，所以的右指针指向<span class="number">3</span>，<span class="number">3</span>的左指针指向<span class="number">1</span>


       <span class="number">8</span>    
    /   <span class="string">\</span>
 <span class="number">1</span>-<span class="number">3</span>     <span class="number">10</span>
    <span class="string">\</span>     <span class="string">\</span>
   <span class="number">4</span>-<span class="number">6</span>     <span class="number">14</span>
      <span class="string">\</span>   /
       <span class="number">7</span> <span class="number">13</span> 

 <span class="number">4</span>为<span class="number">6</span>的左子树的最大值，所以<span class="number">4</span>的右指针指向<span class="number">6</span>，<span class="number">6</span>左指针<span class="number">4</span>

      <span class="number">8</span>    
    /   <span class="string">\</span>
 <span class="number">1</span>-<span class="number">3</span>     <span class="number">10</span>
    <span class="string">\</span>     <span class="string">\</span>
   <span class="number">4</span>-<span class="number">6</span>-<span class="number">7</span>   <span class="number">14</span>
          /
         <span class="number">13</span>

 <span class="number">7</span>为<span class="number">6</span>的右子树的最小值，所以<span class="number">7</span>的左指针指向<span class="number">6</span>，<span class="number">6</span>右指针<span class="number">4</span>

     <span class="number">8</span>    
    /   <span class="string">\</span>
 <span class="number">1</span>-<span class="number">3</span>     <span class="number">10</span>
    <span class="string">\</span>     <span class="string">\</span>
     <span class="number">4</span>-<span class="number">6</span>-<span class="number">7</span> <span class="number">14</span>
          /
         <span class="number">13</span>

 <span class="number">4</span>为<span class="number">3</span>的右子树的最小值，所以<span class="number">4</span>的左指针指向<span class="number">3</span>，<span class="number">3</span>右指针<span class="number">4</span>

 <span class="number">1</span>-<span class="number">3</span>-<span class="number">4</span>-<span class="number">6</span>-<span class="number">7</span>-<span class="number">8</span>    
           <span class="string">\</span>
            <span class="number">10</span>
             <span class="string">\</span>
             <span class="number">14</span>
             /
            <span class="number">13</span>

<span class="number">7</span>为<span class="number">8</span>左子树的最小值，所以<span class="number">7</span>的右指针指向<span class="number">8</span>，<span class="number">8</span>的左指针指向<span class="number">7</span>
这样就完成了根节点左边的转换，右边的转换思路一致
</code></pre><h2 id="代码实现">代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 查找左子树中最大的节点</span><br><span class="line"> *<span class="javadoctag"> @param</span> T</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title">findMaxNodeInLeft</span><span class="params">(TreeNode T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	TreeNode t=T.left;</span><br><span class="line">	<span class="keyword">if</span>(t!=<span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">while</span>(t.right!=<span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			t=t.right;<span class="comment">//因为肯定右子树更加大</span></span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 查找右子树种的最小节点</span><br><span class="line"> *<span class="javadoctag"> @param</span> T</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title">findMinNodeInRight</span><span class="params">(TreeNode T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	TreeNode t=T.right;</span><br><span class="line">	<span class="keyword">if</span>(t!=<span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">while</span>(t.left!=<span class="keyword">null</span>)</span><br><span class="line">			t=t.left;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 二叉排序树转双向链表</span><br><span class="line"> *<span class="javadoctag"> @param</span> T</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">convertNode</span><span class="params">(TreeNode T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T.left!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		convertNode(T.left);</span><br><span class="line">		TreeNode t=findMaxNodeInLeft(T);<span class="comment">//左子树中最大的点  它一定是在叶子上面</span></span><br><span class="line">		t.right=T;<span class="comment">//将左子树最小的点连在根节点的左侧</span></span><br><span class="line">		T.left=t;</span><br><span class="line">		t.parent=<span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T.right!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		convertNode(T.right);</span><br><span class="line">		TreeNode t=findMinNodeInRight(T);</span><br><span class="line">		t.left=T;<span class="comment">//将右子树最小的点连点根节点的右侧</span></span><br><span class="line">		T.right=t;</span><br><span class="line">		t.parent=<span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具体实验代码">具体实验代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	TreeNode root=<span class="keyword">new</span> TreeNode();</span><br><span class="line">	root.parent=<span class="keyword">new</span> TreeNode(Integer.MAX_VALUE);<span class="comment">//凭空设置一个超级根节点  </span></span><br><span class="line">	root.parent.right=root;<span class="comment">//超级根节点接管根节点</span></span><br><span class="line">	insert(root,<span class="number">8</span>);</span><br><span class="line">	insert(root,<span class="number">3</span>);</span><br><span class="line">	insert(root,<span class="number">10</span>);</span><br><span class="line">	insert(root,<span class="number">1</span>);</span><br><span class="line">	insert(root,<span class="number">6</span>);</span><br><span class="line">	insert(root,<span class="number">14</span>);</span><br><span class="line">	insert(root,<span class="number">4</span>);</span><br><span class="line">	insert(root,<span class="number">7</span>);</span><br><span class="line">	insert(root,<span class="number">13</span>);<span class="comment">//上面的insert是构建排序二叉树</span></span><br><span class="line">	System.out.println(root);</span><br><span class="line">	convertNode(root);</span><br><span class="line">	System.out.println(root);</span><br><span class="line">	</span><br><span class="line">	TreeNode head=root;</span><br><span class="line">	<span class="keyword">while</span>(head.left!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		head=head.left;<span class="comment">//查找头结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将双向链表打印出来</span></span><br><span class="line">	<span class="keyword">while</span>(head.right!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(head.data);</span><br><span class="line">		head=head.right;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于二叉排序树具体介绍看我之前的<a href="http://kubicode.me/2015/06/29/Data%20Struct/Binary-Search-Tree/" target="_blank" rel="external">二叉排序树</a></p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>输入一棵排序二叉树，将此树转换成一个排序的双向链表，要求不能创建任何新的借点，只能调整指针的指向.
</code></pre><h2 id="分析">分析</h2><blockquote>
<p>二叉排序树的中序遍历可以]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉查找树]]></title>
    <link href="http://yyl8781697.github.io/2015/06/29/Data%20Struct/Binary-Search-Tree/"/>
    <id>http://yyl8781697.github.io/2015/06/29/Data Struct/Binary-Search-Tree/</id>
    <published>2015-06-29T12:30:58.000Z</published>
    <updated>2015-06-30T23:41:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>二叉查找树（Binary Search Tree），又称二叉搜索树、二叉排序树。它符合这样的特征：</p>
<ul>
<li>它是一颗二叉树（空树也可以）</li>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</li>
<li>它的左、右子树也也都是为二叉排序树。</li>
</ul>
<pre><code>      <span class="number">8</span>    
    /   <span class="string">\</span>
   <span class="number">3</span>     <span class="number">10</span>
 /   <span class="string">\</span>     <span class="string">\</span>
<span class="number">1</span>     <span class="number">6</span>     <span class="number">14</span>
    /   <span class="string">\</span>  /
   <span class="number">4</span>    <span class="number">7</span> <span class="number">13</span> 
</code></pre><blockquote>
<p>二叉查找树的搜索、插入、删除的时间复杂度等于O(h)，期望O(logn)，最坏O(n)</p>
</blockquote>
<h2 id="树的结构">树的结构</h2><p>它的结构和普通的二叉树一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 树的结构</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> data=Integer.MIN_VALUE;<span class="comment">//节点数据 </span></span><br><span class="line">	<span class="keyword">public</span> TreeNode left,right;<span class="comment">//左右节点</span></span><br><span class="line">	<span class="keyword">public</span> TreeNode parent;<span class="comment">//父节点  java里面加这个属性方便操作一点^_^</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data=data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据上面的定义，有<code>tn.left.data&lt;tn.data&lt;tn.right.data</code></p>
<h2 id="查找">查找</h2><p>二叉排序树种的查找过程为</p>
<ol>
<li>若排序树tree是空树，则查找失败，直接返回，否则：</li>
<li>若x等于树的根节点的值，则查找成功，返回该节点；否则：</li>
<li>若x小于树的根节点的值，则搜索左子树；否则：</li>
<li>查找右子树。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 查找操作</span><br><span class="line"> *<span class="javadoctag"> @param</span> T  当前树的节点</span><br><span class="line"> *<span class="javadoctag"> @param</span> x  查询点</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">search</span><span class="params">(TreeNode T,<span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="keyword">null</span>)<span class="comment">//当前节点为null时表示没有找到</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span>(T.data==x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> T;<span class="comment">//表示查找成功</span></span><br><span class="line">	&#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(T.data&gt;x)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="comment">//当前节点大于查询值的时候 进行左子节点的查找</span></span><br><span class="line">		<span class="keyword">return</span> search(T.left,x);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;<span class="comment">//否则进行右子节点的查找</span></span><br><span class="line">		<span class="keyword">return</span> search(T.right,x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>假如我现在查找的值为4的节点，则查找的路径为8-&gt;3-&gt;6-&gt;4 最终可以找到值</p>
<h2 id="插入">插入</h2><p>二叉排序树的插入过程为：</p>
<ol>
<li>若排序树为空树，这当前插入节点就是树的根节点，否则</li>
<li>判断x是否等于树当前节点的值，如果是，则不插入，否则</li>
<li>若x小于当前节点的值，如果此时当前节点的左子树为空，则直接插入到当前节点的左子树，否则将当前节点置为左子树进行第2步操作</li>
<li>若x大于当前节点的值，如果此时当前节点的右子树为空，则直接插入到当前节点的右子树，否则将当前节点置为右子树进行第2步操作</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 树的插入操作</span><br><span class="line"> *<span class="javadoctag"> @param</span> T  树的根节点</span><br><span class="line"> *<span class="javadoctag"> @param</span> x  需要插入的节点</span><br><span class="line"> *<span class="javadoctag"> @return</span>  如果插入成功返回true,否则返回false</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(TreeNode T,<span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T.data==Integer.MIN_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		T.data=x;<span class="comment">//空节点的时候 插入点就是根节点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	TreeNode t=T;</span><br><span class="line">	<span class="keyword">while</span>(t!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(t.data==x)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(t.data&gt;x)</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(t.left==<span class="keyword">null</span>)</span><br><span class="line">			&#123;	<span class="comment">//当前对比节点的左子节点为空了 直接插入就好了</span></span><br><span class="line">				t.left=<span class="keyword">new</span> TreeNode(x);</span><br><span class="line">				t.left.parent=t;<span class="comment">//更新父节点</span></span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				t=t.left;<span class="comment">//否则继续进行左子节点的查找</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(t.right == <span class="keyword">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				t.right=<span class="keyword">new</span> TreeNode(x);</span><br><span class="line">				t.right.parent=t;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				t=t.right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实简单的版本就是先进行插入点得查找，如果找到点节点，则不插入，如果未找到，则直接插入到最后一个判断节点的后边即可。</p>
</blockquote>
<p>假如我当前插入的值是5，则进行查找操作了，在找到4之后发现未找到该值的节点，并且5&gt;4，所以5会插入到4的右孩子上</p>
<pre><code>      <span class="number">8</span>    
    /   <span class="string">\</span>
   <span class="number">3</span>     <span class="number">10</span>
 /   <span class="string">\</span>     <span class="string">\</span>
<span class="number">1</span>     <span class="number">6</span>     <span class="number">14</span>
    /   <span class="string">\</span>  /
   <span class="number">4</span>    <span class="number">7</span> <span class="number">13</span> 
    <span class="string">\</span>
     <span class="number">5</span>
</code></pre><h2 id="删除">删除</h2><p>二叉排序树的删除分为三种情况：</p>
<ul>
<li>当前删除的节点为叶子节点，也就是没有孩子节点，此时可以直接删除，将当前删除节点的父节点对应的孩子指向空即可<blockquote>
<p>比如要删除5，只需要将4的右子树指向空即可</p>
</blockquote>
</li>
<li>当前删除的节点仅含左子树或者右子树，这种情况下也是直接删除该节点即可，只不过是将当前删除的父节点对应的孩子指向删除节点对应的孩子即可<blockquote>
<p>比如要删除4，只需要将6的左子树指向5即可</p>
</blockquote>
</li>
<li>当前删除的节点的左右子树都存在，此时先查找删除节点的左子树的最大值，然后删除迭代删除该节点，最后将删除节点的值更新为最大值即可（注意这是一个递归过程..）<blockquote>
<p>比如要删除6，则先找它左子树的最大值为5，这个时候要删除5这个节点，然后将6的值域更新为5即可</p>
</blockquote>
</li>
</ul>
<p>具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 删除节点</span><br><span class="line"> *<span class="javadoctag"> @param</span> T  树的跟</span><br><span class="line"> *<span class="javadoctag"> @param</span> x  需要删除的值</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(TreeNode T,<span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	TreeNode t=search(T,x);</span><br><span class="line">	<span class="keyword">if</span>(t!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> isExistLeft=t.left!=<span class="keyword">null</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> isExistRight=t.right!=<span class="keyword">null</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">switch</span>(isExistLeft|isExistRight&lt;&lt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//the leaf node</span></span><br><span class="line">			deleteMySelf(t);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//only left</span></span><br><span class="line">			deleteOnlyLeft(t);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//obly right</span></span><br><span class="line">			deleteOnlyRight(t);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//both child</span></span><br><span class="line">			TreeNode maxT=findMaxNodeInLeft(t);<span class="comment">//先查找当前节点中左子树中最大的节点</span></span><br><span class="line">			delete(T,maxT.data);<span class="comment">//删除那个节点</span></span><br><span class="line">			t.data=maxT.data;<span class="comment">//然后更新当前节点中的值  即可</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"no no no,somehing must be wrong!"</span>);</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//没有找到该节点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 删除我自己</span><br><span class="line"> *<span class="javadoctag"> @param</span> t</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteMySelf</span><span class="params">(TreeNode t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t.parent!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(t.parent.left==t)</span><br><span class="line">		&#123;</span><br><span class="line">			t.parent.left=<span class="keyword">null</span>;<span class="comment">//直接删除我自己</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			t.parent.right=<span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		t.parent.right=<span class="keyword">new</span> TreeNode();<span class="comment">//相当于初始化根节点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 当前节点仅含左子树的情况下进行删除</span><br><span class="line"> *<span class="javadoctag"> @param</span> t</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteOnlyLeft</span><span class="params">(TreeNode t)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t.parent!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(t.parent.left==t)</span><br><span class="line">		&#123;</span><br><span class="line">			t.parent.left=t.left;<span class="comment">//直接删除当前节点t</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			t.parent.right=t.left;</span><br><span class="line">		&#125;</span><br><span class="line">		t.left.parent=t.parent;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//根节点被删除</span></span><br><span class="line">		t.data=t.left.data;</span><br><span class="line">		t.left=t.left.left;</span><br><span class="line">		t.right=t.left.right;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 当前节点仅含左右树的情况下进行删除</span><br><span class="line"> *<span class="javadoctag"> @param</span> t</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteOnlyRight</span><span class="params">(TreeNode t)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t.parent!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(t.parent.left==t)</span><br><span class="line">		&#123;</span><br><span class="line">			t.parent.left=t.right;<span class="comment">//直接删除当前节点t</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			t.parent.right=t.right;</span><br><span class="line">		&#125;</span><br><span class="line">		t.right.parent=t.parent;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//根节点被删除</span></span><br><span class="line">		t.data=t.right.data;</span><br><span class="line">		t.left=t.left.left;</span><br><span class="line">		t.right=t.left.right;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 查找左子树中最大的节点</span><br><span class="line"> *<span class="javadoctag"> @param</span> T</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title">findMaxNodeInLeft</span><span class="params">(TreeNode T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	TreeNode t=T.left;</span><br><span class="line">	<span class="keyword">if</span>(t!=<span class="keyword">null</span>)</span><br><span class="line">	<span class="keyword">while</span>(t.right!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		t=t.right;<span class="comment">//因为肯定右子树更加大</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="实际操练">实际操练</h2><p>最后关于上文中各个操作的操练代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	TreeNode root=<span class="keyword">new</span> TreeNode();</span><br><span class="line">	root.parent=<span class="keyword">new</span> TreeNode(Integer.MAX_VALUE);<span class="comment">//凭空设置一个超级根节点  </span></span><br><span class="line">	root.parent.right=root;<span class="comment">//超级根节点接管根节点</span></span><br><span class="line">	insert(root,<span class="number">8</span>);</span><br><span class="line">	insert(root,<span class="number">3</span>);</span><br><span class="line">	insert(root,<span class="number">10</span>);</span><br><span class="line">	insert(root,<span class="number">1</span>);</span><br><span class="line">	insert(root,<span class="number">6</span>);</span><br><span class="line">	insert(root,<span class="number">14</span>);</span><br><span class="line">	insert(root,<span class="number">4</span>);</span><br><span class="line">	insert(root,<span class="number">7</span>);</span><br><span class="line">	insert(root,<span class="number">13</span>);<span class="comment">//上面的insert是构建排序二叉树</span></span><br><span class="line">	insert(root,<span class="number">5</span>);<span class="comment">//再次进行插入操作</span></span><br><span class="line">	System.out.println(root);</span><br><span class="line">	delete(root,<span class="number">3</span>);<span class="comment">//删除操作</span></span><br><span class="line">	System.out.println(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://www.cnblogs.com/zhuyf87/archive/2012/11/09/2763113.html" target="_blank" rel="external">http://www.cnblogs.com/zhuyf87/archive/2012/11/09/2763113.html</a></li>
<li><a href="http://www.cnblogs.com/vamei/archive/2013/03/17/2962290.html" target="_blank" rel="external">http://www.cnblogs.com/vamei/archive/2013/03/17/2962290.html</a></li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="介绍">介绍</h2><p>二叉查找树（Binary Search Tree），又称二叉搜索树、二叉排序树。它符合这样的特征：</p>
<ul>
<li>它是一颗二叉树（空树也可以）</li>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值<]]>
    </summary>
    
      <category term="Data Struct" scheme="http://yyl8781697.github.io/tags/Data-Struct/"/>
    
      <category term="Data Struct" scheme="http://yyl8781697.github.io/categories/Data-Struct/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自己煮：红烧肉炖土豆]]></title>
    <link href="http://yyl8781697.github.io/2015/06/28/Food/hongshaorou-dun-tudou/"/>
    <id>http://yyl8781697.github.io/2015/06/28/Food/hongshaorou-dun-tudou/</id>
    <published>2015-06-28T14:18:35.000Z</published>
    <updated>2015-06-28T14:39:29.000Z</updated>
    <content type="html"><![CDATA[<p>下午买菜的时候闻到了阵阵红烧肉土豆的香味，忍不住去菜场也买了这道菜 ^_^  的材料（7块钱的肉，3块钱的土豆，10快拿取不用找，谢谢！）</p>
<p>红烧肉炖土豆：</p>
<ol>
<li>将五花肉切片，也不能太细，并且最好要带有一点点肥肉才好吃</li>
<li>销小土豆（小土豆要比大得好吃），蛮难销的，差点手都销开了 -_-</li>
<li>起油锅，放一点点油</li>
<li>将糖放入沸腾的油锅中，炒至红色（几秒就好了）</li>
<li>放入五花肉，爆炒1分钟，（这个时候肉的颜色很深很有胃口）</li>
<li>此时倒水，没过肉，这时候加一些老抽和料酒，还有茴香，八角之类的</li>
<li>煮40分钟左右</li>
<li>放入准备就绪的小土豆（这个时候可能要加点水）</li>
<li>再煮20分钟，看到收汁即可</li>
</ol>
<p>直接上成品<br><img src="/img/Food/hongshaorou.jpg" alt=""></p>
<p>这个看上去还可以把，其实味道也还可以 ^_^</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>下午买菜的时候闻到了阵阵红烧肉土豆的香味，忍不住去菜场也买了这道菜 ^_^  的材料（7块钱的肉，3块钱的土豆，10快拿取不用找，谢谢！）</p>
<p>红烧肉炖土豆：</p>
<ol>
<li>将五花肉切片，也不能太细，并且最好要带有一点点肥肉才好吃</li>
<li>销]]>
    </summary>
    
      <category term="Food" scheme="http://yyl8781697.github.io/tags/Food/"/>
    
      <category term="Food" scheme="http://yyl8781697.github.io/categories/Food/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Effective Java》第十一章：序列化]]></title>
    <link href="http://yyl8781697.github.io/2015/06/28/Effective%20Java/Serialization/"/>
    <id>http://yyl8781697.github.io/2015/06/28/Effective Java/Serialization/</id>
    <published>2015-06-27T16:08:34.000Z</published>
    <updated>2015-06-28T13:51:40.000Z</updated>
    <content type="html"><![CDATA[<p>“将一个对象编码成一个字节流”，这个过程称为对象序列化，相反的过程称为反序列化。</p>
<h2 id="第74条：谨慎地实现Serializable接口">第74条：谨慎地实现Serializable接口</h2><p>只要添加<code>implements Serializable</code>，就可以使一个类可被序列化，写法上虽然看上去很简单，但是如果你认为真的这么简单的话就会付出很大的代价：</p>
<ul>
<li>一旦一个可序列化类被发布，就大大降低了“改变这个类的实现”的灵活性。<ol>
<li>一旦一个类实现<code>Serializable</code>接口，它的字节流编码就变成了导出API的一部分，一旦这个类被广泛使用，往往必须永远支持这种序列化形式。</li>
<li>如果接受了默认的序列化形式，并且以后又要改变这个类的内部实现，结果可能会导致序列化形式不兼容</li>
<li>序列化会使类的演变受到限制，这种限制与序列化版本UID有关，每个可序列化的类都有一个唯一标识符<code>serialVersionUID</code>，如果没有指定，则系统会根据类的具体实现来进行自动生成，所以你修改了类，并且没有显示的指定UID，那么兼容性就会被破坏。</li>
</ol>
</li>
<li>它增加了Bug和安全漏洞的可能性<br>  序列化机制是一种语言之外的对象创建机制，所以反序列化是一个“隐藏的构造器”，具体与其他构造器相同的特点，所以反序列化过程也必须保证有构造器建立起来的约束关系，并且不允许攻击者在访问构造器过程中的内部对象，所以默认的反序列化机制很容易是对象约束遭到破坏，以及遭受非法的访问。</li>
<li>随着类发行新的版本，相关测试的负担也增加了<br>  新的版本发布之后，要检查是否可以“在新版本中序列化一个实例，然后在旧版本中依然可以反序列化”，这个测试除了二进制兼容性以外，还要测试语义兼容性。所有测试的难度都是相当大啊！</li>
</ul>
<p>下面是关于序列化类的操作：</p>
<ul>
<li>如果一个了类将要加入某个框架中，并且该框架依赖于序列化来实现对象传输或者持久化，那么实现<code>Serializable</code>这个接口就是非常有必要的。</li>
<li>还有为了继承而设计的类尽量少的去实现<code>Serializable</code>接口，用户的接口也应该尽可能烧得继承<code>Serializable</code>接口，不然会对实现这些接口或者类的程序猿增加很多负担</li>
<li><p>实现一个带有可序列化实例的类时，应该要注意类的约束条件，并且要实现</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObjectNoData</span><span class="params">()</span> <span class="keyword">throws</span> InvalidObjectException</span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"stream data is required"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于为继承而设计的不可序列化的类，你应该考虑提供一个无参构造器</p>
</li>
<li>内部类不应该实现<code>Serializable</code></li>
</ul>
<p>简而言之，千万不要认为实现<code>Serializable</code>很容易，里面的坑多着呢。</p>
<h2 id="第75条：考虑使用自定义的序列化形式">第75条：考虑使用自定义的序列化形式</h2><p>一个对象的默认序列化使将该对象进行物理表示，也就是说，默认序列化描述了该对象内部所包含的数据，以及每一个可以从这个对象到达其他对象的内部数据。</p>
<blockquote>
<p>而对于一个对象来说，理想的序列化应该只包含该对象索比表示的逻辑数据，而逻辑数据和物理数据是应该相互独立的。</p>
</blockquote>
<p>当对象的物理表示等同于它的路基表示是，使用默认的序列化是合理的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String lastName;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String firstName;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String middelName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类似这样的实体类，物理内容的这三个字段也可以很精确的反应它的逻辑内容。</p>
<p>来看看下面的序列化类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringList</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> Entry head = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">		String data;</span><br><span class="line">		Entry next;</span><br><span class="line">		Entry previous;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从逻辑意义上讲，这个类表示一个字符串的序列，但是从物理意义上讲，把该序列化表示为一个双向链表。所以此时如果使用默认的序列化，那将会镜像除链表中所有的项以及这些项之间的所有双向链表。。-_-，大工程啊</p>
<p>当一个类的物理表示与它的逻辑内容有区别时，使用默认序列化将会有以下4个缺点：</p>
<ol>
<li>它使这个类的导出API永远的束缚在该类的内容（<code>StringList.Entry</code>也会成为公有API的一部分）</li>
<li>会消耗很多的空间（因为会维护一个双向链表）</li>
<li>会消耗很多时间（遍历啊）</li>
<li>会引起栈溢出（递归啊）</li>
</ol>
<p>其实类似这种类编写它的自定义序列化需求并不是很麻烦：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringList</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="comment">//添加“易变”标志防止默认序列化</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> Entry head = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span></span>&#123;</span><br><span class="line">		String data;</span><br><span class="line">		Entry next;</span><br><span class="line">		Entry previous;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		<span class="comment">//TO DO</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">	</span>&#123;</span><br><span class="line">		s.defaultWriteObject();</span><br><span class="line">		s.writeInt(size);</span><br><span class="line">		<span class="comment">//在这里序列化</span></span><br><span class="line">		<span class="keyword">for</span>(Entry e=head;e != <span class="keyword">null</span> ; e=e.next)</span><br><span class="line">			s.writeObject(e.data);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span><br><span class="line">		<span class="keyword">throws</span> ClassNotFoundException,IOException</span><br><span class="line">	</span>&#123;</span><br><span class="line">		s.defaultReadObject();</span><br><span class="line">		<span class="comment">//在这里进行反序列化</span></span><br><span class="line">		<span class="keyword">int</span> numElements= s.readInt();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numElements;i++)</span><br><span class="line">			add((String)s.readObject());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用默认的<code>readObject()</code>和<code>writeObject()</code>可以影响全类的序列化形式，极大的增强灵活性。</p>
<p>还有类似<code>key-value</code>的散列表也不适合使用默认的序列化，因为在不同的JVM中最终形成的散列位置可能会不一样。</p>
<blockquote>
<p>切记不管使用什么序列化方式，建议都显示的加上序列的唯一版本UID</p>
</blockquote>
<p>总而言之，当默认的序列化能合理的描述逻辑内容时，使用默认序列化就好了，否则建议使用自定义的序列化^_^</p>
<h2 id="第76条：保护性的编写readObject方法">第76条：保护性的编写readObject方法</h2><p>针对第39条的<a href="http://kubicode.me/2015/06/09/Effective%20Java/Method/#第39条：必要时进行保护性拷贝" target="_blank" rel="external">日期类</a>，根据上一条的指导，貌似使用默认的序列化也是蛮合理的，增加<code>implements Serializable</code>即可。但是如果真的这么做，那么这个类将不再保证它的关键约束了。</p>
<p>因为<code>readObject()</code>方法相当于是一个接受字节流的构造函数，那如果有人伪造了这个字节流的话，反序列化出来的对象时相当危险的。还有一个信号就是反序列化出来对象还可以随意被改动，因为默认的序列化并没有使用保护性拷贝，所以如果增对该日期类实现自己的序列化的化，可以这么干：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span><br><span class="line">		<span class="keyword">throws</span> IOException,ClassNotFoundException</span><br><span class="line"></span>&#123;</span><br><span class="line">	s.defaultReadObject();</span><br><span class="line">	</span><br><span class="line">	start=<span class="keyword">new</span> Date(start.getTime());<span class="comment">//进行保护兴拷贝</span></span><br><span class="line">	end=<span class="keyword">new</span> Date(end.getTime());</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(start.compareTo(end)&gt;<span class="number">0</span>)<span class="comment">//进行安全性检查</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(start +<span class="string">"after"</span>+ end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是编写<code>readObject</code>方法的指导方针：</p>
<ul>
<li>对于对象引用域必须保持私有的类，要保护性得拷贝这个域中的每个对象。</li>
<li>对于任何约束条件，如果检查失败，则应该抛出一个<code>InvalidObjectException</code>异常。</li>
<li>如果整个对象图在被反序列化之后必须进行验证，就应该使用<code>ObjectInputValidation</code>接口</li>
<li>无论是直接方式还是间接方法，都不要调用类中任何可被覆盖的方法</li>
</ul>
<p>总而言之，当你编写<code>readObject</code>方法的时候，都要想：你正在编写一个公有的构造器，无论给他传递什么字节流，都必须产生一个有效的实例。</p>
<h2 id="第77条：对于实例控制，枚举类型优于readResolve">第77条：对于实例控制，枚举类型优于readResolve</h2><p>一般的单例类，如果添加了<code>implements Serializable</code>之后，它就不再是一个单例，因为反序列化可以看做是另一个构造器，此时你就需要使用<code>readResolve()</code>方法，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接返回这个单例就好了，但是注意的是这个单例需要用<code>transient</code>来标记</p>
<p>当然说了这么做，然而其实这并没什么卵用，这种方法还不如使用枚举单例 -_-，可以参考<a href="http://kubicode.me/2015/04/22/Effective%20Java/Create-Destory-Object/#第3条：用私有的构造器或者枚举类型强化Singleton属性" target="_blank" rel="external">第3条</a>，它写得简单，用的省心。</p>
<h2 id="第78条：考虑用序列化代理代替序列化实例">第78条：考虑用序列化代理代替序列化实例</h2><p>序列化代理模式可以解决普通类实现序列化时带来的各种副作用。</p>
<p>序列化代理模式非常简单：</p>
<ol>
<li>为可序列化类设计一个私有的静态嵌套类</li>
<li>为该嵌套类添加一个构造器，实现外围类的参数的复制<br>3， 这个嵌套类中需要添加一个<code>readResolve()</code>方法进行外围类的返回</li>
<li>在外围类中添加<code>writeReplace()</code>方法进行外围类的复制</li>
<li>在外围类中还要添加一个<code>readObject</code>防止被攻击</li>
</ol>
<p>根据上述指导，看下<code>EnumSet</code>源码中的序列化代理类的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * This class is used to serialize all EnumSet instances, regardless of</span><br><span class="line"> * implementation type.  It captures their "logical contents" and they</span><br><span class="line"> * are reconstructed using public static factories.  This is necessary</span><br><span class="line"> * to ensure that the existence of a particular implementation type is</span><br><span class="line"> * an implementation detail.</span><br><span class="line"> *</span><br><span class="line"> *<span class="javadoctag"> @serial</span> include</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationProxy</span> &lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="javadoc">/**</span><br><span class="line">     * The element type of this enum set.</span><br><span class="line">     *</span><br><span class="line">     *<span class="javadoctag"> @serial</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;E&gt; elementType;</span><br><span class="line"></span><br><span class="line">    <span class="javadoc">/**</span><br><span class="line">     * The elements contained in this enum set.</span><br><span class="line">     *</span><br><span class="line">     *<span class="javadoctag"> @serial</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Enum[] elements;</span><br><span class="line"></span><br><span class="line">    SerializationProxy(EnumSet&lt;E&gt; set) &#123;</span><br><span class="line">        elementType = set.elementType;<span class="comment">//把数据拷贝进来</span></span><br><span class="line">        elements = set.toArray(ZERO_LENGTH_ENUM_ARRAY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EnumSet&lt;E&gt; result = EnumSet.noneOf(elementType);</span><br><span class="line">        <span class="keyword">for</span> (Enum e : elements)</span><br><span class="line">            result.add((E)e);</span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//实例化Enumset</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362491234563181265L</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">writeReplace</span><span class="params">()</span> </span>&#123;<span class="comment">//代理模式的入口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SerializationProxy&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// readObject method for the serialization proxy pattern</span></span><br><span class="line"><span class="comment">// See Effective Java, Second Ed., Item 78.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream stream)</span></span><br><span class="line">    <span class="keyword">throws</span> java.io.InvalidObjectException </span>&#123;<span class="comment">//防止被攻击 竟然注释和Effective Java有关</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> java.io.InvalidObjectException(<span class="string">"Proxy required"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总而言之，推荐使用序列化代理模式！！！^_^</p>
<h2 id="总结">总结</h2><p>真不容易，这本书终于看完了，这段时间因为工作日要上班，并且还要被老板催着科研论文，真心蛋疼~所以看书的进度还是比较慢啊。<br>不够回顾本书，里面还是提出了蛮多非常经典的建议的，感谢本书，感谢作者。^_^</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>“将一个对象编码成一个字节流”，这个过程称为对象序列化，相反的过程称为反序列化。</p>
<h2 id="第74条：谨慎地实现Serializable接口">第74条：谨慎地实现Serializable接口</h2><p>只要添加<code>implements Seria]]>
    </summary>
    
      <category term="Java" scheme="http://yyl8781697.github.io/tags/Java/"/>
    
      <category term="Effective Java" scheme="http://yyl8781697.github.io/categories/Effective-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TeraSort在Hadoop中的非常非常非常简单的实现]]></title>
    <link href="http://yyl8781697.github.io/2015/06/27/Hadoop/TeraSort-in-Hadoop/"/>
    <id>http://yyl8781697.github.io/2015/06/27/Hadoop/TeraSort-in-Hadoop/</id>
    <published>2015-06-27T10:26:12.000Z</published>
    <updated>2015-06-27T16:05:41.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>关于TeraSort的思想其实是非常简单的，但是查了网上好多资料，感觉把它的实现复杂化了（指的在<code>Hadoop</code>中），它们要自定义<code>InputFormat</code>，<code>RecordReader</code>等，其实我想说，实现一个TeraSort根本不需要这么麻烦，所以本文就将实现一个非常简单、非常简单、非常简单的实现记录下来，额，重要的事情说三遍。^_^</p>
</blockquote>
<h2 id="TeraSort简介">TeraSort简介</h2><pre><code><span class="number">1</span>TB排序通常用于衡量分布式数据处理框架的数据处理能力。TeraSort是Hadoop中的的一个排序作业，在<span class="number">2008</span>年，Hadoop在<span class="number">1</span>TB排序基准评估中赢得第一名，耗时<span class="number">209</span>秒。<span class="comment">(其实现在在TeraSort上Spark已将Hadoop甩在后面-_-)</span>
</code></pre><p>在看排序之前，先来看一下Map-Reduce的一张非常经典的流程图：<br><img src="/img/TeraSort-in-Hadoop/shuffle.gif" alt="Map-Reduce流程图"></p>
<p>从图种可以了解到Map-Reduce执行的整个过程中会进行两次排序，一次是在Map端的shuffle，另一次是在Reduce端的shuffle，TeraSort正好是利用这种特性来进行排序</p>
<blockquote>
<p>注意，这里的排序仅仅是针对<code>key</code>的。</p>
</blockquote>
<p>假如现在我只有一个reduce，那么根据上面描述的我们知道在这里reduce里面得到的值都是有序的，这是使用<code>Hadoop</code>最简单的排序方法，执行流程如下图：<br><img src="/img/TeraSort-in-Hadoop/sortInOneReduce.jpg" width="500px"></p>
<p>这样的实现方式虽然便捷，但是丢失了排序在reduce端的并行度，那么有没有其他更好的方法呢？<br>先来想象一下快速排序的思想，一个基准值的左侧都是小于该值，右侧都是大于基准值，也就是说左侧都是小于右侧的，那如果左侧都是有序的，并且右侧也是有序的，那就可以说整个序列是有序的，把这个思想放到Hadoop中去（一个reduce输出一个partition），我们已经知道二次排序之后得到的每个partition中的数据都是被排序过的，那假如对于两个任意的元素有partiton<sub>i</sub>&lt;partiton<sub>i+1</sub>，那我们就可以说partiton<sub>(i,i+1)</sub>是有序的，把这个推广到全局的partition，就是TeraSort了</p>
<p><img src="/img/TeraSort-in-Hadoop/sortInMulReduce.jpg" alt=""></p>
<h2 id="TeraSort实现">TeraSort实现</h2><p>所以，把TeraSort方法用<code>Hadoop</code>来实现，必须要额外做的就是采样和数据划分。</p>
<ul>
<li>采样：从输入数据中采取一定的样本比例，将这些样本进行排序，然后按reduce得数量进行夸区间取值，作为分区的划分标志</li>
<li>数据划分：在采样之后有的划分标志之后，根据划分标志对数据进行分区，确保partiton<sub>i</sub>&lt;partiton<sub>i+1</sub></li>
</ul>
<p>例如：当前的输入数据为3，1，6，7，9，5，4，13，2，假设使用3个reduce<br>现采样的数据为3，1，6，7，9，5,则最终计算的划分标志就是3,7<br>也就是说小于等于3的落入第一个分区中，否则小于等于7的落入第二个分区中，其他的落入第三个放入中，则形成<br>{3,1,2},{6,7,5,4},{9,13}，各个分区进行排序之后为{1,2,3},{4,5,6,7},{9,13}，<br>就完成了最终的排序</p>
<p>好，现在来看这个很简单的程序代码：<br>首先，我们需要实现自己的采样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 排序之前的采样器</span><br><span class="line"> * 先采样 再排序  再根据reducer数目取值</span><br><span class="line"> *<span class="javadoctag"> @author</span> root</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TearSortSampler</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 分片采样数据的路径</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Path SPLIT_SAMPLE_PATH=<span class="keyword">new</span> Path(<span class="string">"/tmp/splitSample"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 进行采样  并且会将采样数据放入路径为SPLIT_SAMPLE_PATH的hdfs中</span><br><span class="line">	 *<span class="javadoctag"> @param</span> job</span><br><span class="line">	 *<span class="javadoctag"> @param</span> sampleNum</span><br><span class="line">	 *<span class="javadoctag"> @throws</span> Exception</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sampler</span><span class="params">(Job job,<span class="keyword">int</span> sampleNum)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">	</span>&#123;</span><br><span class="line">		</span><br><span class="line">		InputFormat tif=<span class="keyword">new</span> TextInputFormat();</span><br><span class="line">		</span><br><span class="line">		List&lt;InputSplit&gt; inputSplits=tif.getSplits(job);</span><br><span class="line">		List&lt;Integer&gt; sampleList=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		FileSystem fs=FileSystem.get(job.getConfiguration());</span><br><span class="line">		<span class="keyword">int</span> recordsPerSample=sampleNum/inputSplits.size();<span class="comment">//每个分片的采样数据</span></span><br><span class="line">		<span class="comment">//按分片读取样本</span></span><br><span class="line">		<span class="keyword">for</span>(InputSplit split:inputSplits)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> sn=<span class="number">0</span>;</span><br><span class="line">			TaskAttemptContext context = <span class="keyword">new</span> TaskAttemptContextImpl(</span><br><span class="line">		              job.getConfiguration(), <span class="keyword">new</span> TaskAttemptID());</span><br><span class="line">			RecordReader&lt;Object,Text&gt; reader=tif.createRecordReader(split, context);</span><br><span class="line">			Text text=<span class="keyword">new</span> Text();</span><br><span class="line">			reader.initialize(split, context);</span><br><span class="line">			<span class="keyword">while</span>(reader.nextKeyValue())</span><br><span class="line">			&#123;</span><br><span class="line">				text=reader.getCurrentValue();</span><br><span class="line">				sampleList.add(Integer.parseInt(text.toString()));</span><br><span class="line">				<span class="keyword">if</span>(sn++&gt;recordsPerSample)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			reader.close();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Collections.sort(sampleList);<span class="comment">//进行排序</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将采样数据写入hdfs</span></span><br><span class="line">		DataOutputStream writer = fs.create(SPLIT_SAMPLE_PATH,<span class="keyword">true</span>);</span><br><span class="line">		<span class="keyword">int</span> span=sampleList.size()/job.getNumReduceTasks(),n=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> x=job.getNumReduceTasks();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=span;i&lt;sampleList.size();i+=span)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(++n&gt;=job.getNumReduceTasks())</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">new</span> Text(sampleList.get(i)+<span class="string">"\r\n"</span>).write(writer);</span><br><span class="line">		&#125;</span><br><span class="line">		writer.close();</span><br><span class="line">		<span class="comment">//添加缓存 不知道这里有用不 好像我没用到</span></span><br><span class="line">		job.addCacheFile(<span class="keyword">new</span> URI(SPLIT_SAMPLE_PATH.toString()));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 获取分片标志点</span><br><span class="line">	 *<span class="javadoctag"> @param</span> conf</span><br><span class="line">	 *<span class="javadoctag"> @param</span> splitNum</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 *<span class="javadoctag"> @throws</span> NumberFormatException</span><br><span class="line">	 *<span class="javadoctag"> @throws</span> IOException</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getSplitPonit(Configuration conf,<span class="keyword">int</span> splitNum)</span><br><span class="line">	&#123;</span><br><span class="line">		FileSystem fs=<span class="keyword">null</span>;</span><br><span class="line">		DataInputStream reader = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">int</span>[] points=<span class="keyword">new</span> <span class="keyword">int</span>[splitNum-<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			fs=FileSystem.get(conf);</span><br><span class="line">			reader = fs.open(SPLIT_SAMPLE_PATH);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				points[i]=Integer.parseInt(reader.readLine().trim());</span><br><span class="line">			&#125;</span><br><span class="line">				</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">		&#123;&#125;</span><br><span class="line">		<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(reader!=<span class="keyword">null</span>)</span><br><span class="line">					reader.close();<span class="comment">//关闭异常可以不用理会</span></span><br><span class="line">			&#125;<span class="keyword">catch</span>(Exception e2)&#123;&#125;			</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> points;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 删除采样路径</span><br><span class="line">	 *<span class="javadoctag"> @param</span> job</span><br><span class="line">	 *<span class="javadoctag"> @throws</span> IOException</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteSamplePath</span><span class="params">(Job job)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">	</span>&#123;</span><br><span class="line">		FileSystem fs=FileSystem.get(job.getConfiguration());</span><br><span class="line">		<span class="keyword">if</span>(fs.exists(SPLIT_SAMPLE_PATH))</span><br><span class="line">			fs.delete(SPLIT_SAMPLE_PATH,<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该采样其中主要包含采样以及划分标志的获取：</p>
<ul>
<li>采样：从输入文件中读取各个分片，但是根据采样数量的区别，所以这里只会读取各个分片的top k个值，然后进行汇总排序，则进行跨区间取值，最后才放入自己的Hdfs中。</li>
<li>获取划分标志：从上一步存储的数据直接读取即可</li>
</ul>
<p>再来卡一下简单的数据划分<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeraSortPartition</span> </span><br><span class="line">				<span class="keyword">extends</span> <span class="title">Partitioner</span>&lt;<span class="title">IntWritable</span>,<span class="title">NullWritable</span>&gt;</span><br><span class="line">				<span class="keyword">implements</span>  <span class="title">Configurable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Configuration conf=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] splitPoints=<span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 根据采样  的样本来划分</span><br><span class="line">	 *<span class="javadoctag"> @param</span> key</span><br><span class="line">	 *<span class="javadoctag"> @param</span> value</span><br><span class="line">	 *<span class="javadoctag"> @param</span> splitNum</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(IntWritable key, NullWritable value, <span class="keyword">int</span> splitNum)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(splitPoints==<span class="keyword">null</span>)</span><br><span class="line">			splitPoints=TearSortSampler.getSplitPonit(conf,splitNum);</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">int</span> index=-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;splitPoints.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(key.get()&lt;=splitPoints[i])</span><br><span class="line">			&#123;</span><br><span class="line">				index=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(index==-<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//key 很大  划分到最后一个分区</span></span><br><span class="line">			index=splitPoints.length;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> index;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initSplitPoints</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">	</span>&#123;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Configuration <span class="title">getConf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.conf;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConf</span><span class="params">(Configuration conf)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.conf=conf;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此划分就是用到了采样器中的采样标志，然后该标志分别划分到相应的分区中</p>
<blockquote>
<p>采样时发生在<code>JobClient端</code>,获取划分标志是在<code>Map</code>端</p>
</blockquote>
<p>最后就是实现MR步骤的代码了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TearSortMapper</span> <span class="keyword">extends</span></span><br><span class="line">			<span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">NullWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> IntWritable num = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Context context)</span></span><br><span class="line">				<span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">			num.set(Integer.valueOf(value.toString()));</span><br><span class="line">			context.write(num, NullWritable.get());</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TearSortReducer</span> <span class="keyword">extends</span></span><br><span class="line">			<span class="title">Reducer</span>&lt;<span class="title">IntWritable</span>, <span class="title">NullWritable</span>, <span class="title">IntWritable</span>, <span class="title">NullWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(IntWritable key, Iterable&lt;NullWritable&gt; values,</span><br><span class="line">				Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">			context.write(key, NullWritable.get());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(args.length&lt;<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">"i am so sorry,the input arguments can't less 2"</span>);</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Path input=<span class="keyword">new</span> Path(args[<span class="number">0</span>]);</span><br><span class="line">		Path output=<span class="keyword">new</span> Path(args[<span class="number">1</span>]);</span><br><span class="line">		</span><br><span class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">		FileSystem fs=FileSystem.get(conf);</span><br><span class="line">		<span class="keyword">if</span>(fs.exists(output))</span><br><span class="line">			fs.delete(output,<span class="keyword">true</span>);</span><br><span class="line">		</span><br><span class="line">		Job job = Job.getInstance(conf, <span class="string">"terasort"</span>);</span><br><span class="line">		job.setJarByClass(TearSort.class);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		job.setMapperClass(TearSortMapper.class);</span><br><span class="line">		job.setReducerClass(TearSortReducer.class);</span><br><span class="line">		job.setOutputKeyClass(IntWritable.class);</span><br><span class="line">		job.setOutputValueClass(NullWritable.class);</span><br><span class="line">		FileInputFormat.addInputPath(job, input);</span><br><span class="line">		FileOutputFormat.setOutputPath(job, output);</span><br><span class="line">		job.setNumReduceTasks(<span class="number">2</span>);<span class="comment">//指定对应的redue数量</span></span><br><span class="line">		job.setPartitionerClass(TeraSortPartition.class);<span class="comment">//指定自己的分区划分函数</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//进行采样</span></span><br><span class="line">		TearSortSampler.sampler(job, <span class="number">100</span>);</span><br><span class="line">		</span><br><span class="line">		System.exit(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其实看了上面的程序还真的可以发现，TeraSort最核心的就是采样和划分，在具体的map和reduce只是一个输出而已</p>
<p>这里的测试输入是一行一个数字，现使用随机1w个数字来进行检测，设置了2个reduce，直接进行排序后的结果为：<br><img src="/img/TeraSort-in-Hadoop/result1.png" alt=""><br><img src="/img/TeraSort-in-Hadoop/result2.png" alt=""></p>
<p>从上面的结果中可以发现每个partition中都是排序的，而且两个partiton之间也是有序的，则完成了TeraSort</p>
<blockquote>
<p>细心的同学可以看到10000个排序最后怎么只有6000来个数据输出了？额。。这是因为<code>shuffle</code>过程中将其重复的key给合并了，所以最终输出量会减少，如果需要弯完整的得到10000个数据，得利用value，将key同步放入value中，然后在reduce阶段迭代输出value就好了，因为这个不是本文的重点，所以也没在意。。。 ^_^</p>
</blockquote>
<h2 id="总结">总结</h2><ol>
<li>其实要完成TeraSort只需要添加采样和数据划分即可</li>
<li>这次采了不少坑，因为网上现有的好像TeraSort代码都是基于<code>Hadoop1.0</code>的，也就是说用了<code>mapred</code>包里面的类，而<code>Hadoop2.0</code>中都是在<code>mapreduce</code>这个包下面，导致了很多API接口都不一样，最后看了Hadoop中的TeraSort样例才跌跌撞撞写完—_—</li>
<li>然后这个程序并没有什么卵用，除了能让你更加方便的熟悉TeraSort的流程，如果这的要用TeraSort的话还是建议使用Hadoop样例中的版本，毕竟它考虑的更加全面^_^</li>
</ol>
<hr>
<blockquote>
<p>配图来自网络，本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>关于TeraSort的思想其实是非常简单的，但是查了网上好多资料，感觉把它的实现复杂化了（指的在<code>Hadoop</code>中），它们要自定义<code>InputFormat</code>，<code>RecordReader</cod]]>
    </summary>
    
      <category term="Hadoop" scheme="http://yyl8781697.github.io/tags/Hadoop/"/>
    
      <category term="Hadoop" scheme="http://yyl8781697.github.io/categories/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自己煮：猪蹄黄豆汤]]></title>
    <link href="http://yyl8781697.github.io/2015/06/26/Food/zhuti-huangdou-tang/"/>
    <id>http://yyl8781697.github.io/2015/06/26/Food/zhuti-huangdou-tang/</id>
    <published>2015-06-26T14:18:25.000Z</published>
    <updated>2015-06-28T14:29:01.000Z</updated>
    <content type="html"><![CDATA[<p>猪蹄黄豆汤的流程：</p>
<ol>
<li>切猪蹄（真难切。。。）</li>
<li>将切好的猪蹄和黄豆在水中浸泡好几个小时</li>
<li>起油锅，放一点点油</li>
<li>将猪蹄炒30秒左右</li>
<li>加水没过猪蹄，</li>
<li>等水开了，放入黄豆</li>
<li>放入料酒，八角，茴香</li>
<li>一直煮2小时，期间加了一些水 -_-</li>
</ol>
<p>每个流程的照片忘了拍，但是至少成品拍了下来<br><img src="/img/Food/zhuti.jpg" alt=""></p>
<p>别看它样纸还可以，由于是咸猪蹄，又咸又硬啊。。。下次说什么也不想买咸猪蹄了</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>猪蹄黄豆汤的流程：</p>
<ol>
<li>切猪蹄（真难切。。。）</li>
<li>将切好的猪蹄和黄豆在水中浸泡好几个小时</li>
<li>起油锅，放一点点油</li>
<li>将猪蹄炒30秒左右</li>
<li>加水没过猪蹄，</li>
<li>等水开了，放入黄豆]]>
    </summary>
    
      <category term="Food" scheme="http://yyl8781697.github.io/tags/Food/"/>
    
      <category term="Food" scheme="http://yyl8781697.github.io/categories/Food/"/>
    
  </entry>
  
</feed>