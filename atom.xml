<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Kubi Code'Blog]]></title>
  <subtitle><![CDATA[The palest ink is better than the best memory.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yyl8781697.github.io/"/>
  <updated>2015-06-02T13:46:09.000Z</updated>
  <id>http://yyl8781697.github.io/</id>
  
  <author>
    <name><![CDATA[Kubi Code]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Spark源码中所使用的经典数据结构或者设计模式]]></title>
    <link href="http://yyl8781697.github.io/2015/06/02/Spark/The-Struct-or-Pattern-In-Spark-Source/"/>
    <id>http://yyl8781697.github.io/2015/06/02/Spark/The-Struct-or-Pattern-In-Spark-Source/</id>
    <published>2015-06-02T13:32:28.000Z</published>
    <updated>2015-06-02T13:46:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="位域法">位域法</h2><blockquote>
<p>如果一个枚举类型的元素主要用于在集合中，一般就使用<code>int</code>枚举类型，将2的不同倍数赋予每个常量。<br>这种表示方法让你用OR位运算将几个常量合并到一个集合中，称作位域。</p>
</blockquote>
<p>在<code>Spark</code>源码中进入<code>SparkSubmit</code>类中就可以看到<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cluster managers</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">YARN</span> =</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">STANDALONE</span> =</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">MESOS</span> =</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">LOCAL</span> =</span> <span class="number">8</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">ALL_CLUSTER_MGRS</span> =</span> <span class="type">YARN</span> | <span class="type">STANDALONE</span> | <span class="type">MESOS</span> | <span class="type">LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Deploy modes</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">CLIENT</span> =</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">CLUSTER</span> =</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">ALL_DEPLOY_MODES</span> =</span> <span class="type">CLIENT</span> | <span class="type">CLUSTER</span></span><br></pre></td></tr></table></figure></p>
<p>将集群类型和部署模式使用位域法来存储。</p>
<blockquote>
<p>在《Effective Java》第32条中提到，但是都不推荐。。<code>Spark</code>都使用了，难道这种结构不好嘛？？^_^</p>
</blockquote>
<h1 id="持续更新中。。。。">持续更新中。。。。</h1>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="位域法">位域法</h2><blockquote>
<p>如果一个枚举类型的元素主要用于在集合中，一般就使用<code>int</code>枚举类型，将2的不同倍数赋予每个常量。<br>这种表示方法让你用OR位运算将几个常量合并到一个集合中，称作位域。</p>
<]]>
    </summary>
    
      <category term="Spark" scheme="http://yyl8781697.github.io/tags/Spark/"/>
    
      <category term="Spark" scheme="http://yyl8781697.github.io/categories/Spark/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我在Mac中使用的各种实用工具]]></title>
    <link href="http://yyl8781697.github.io/2015/05/31/Mac/My-Tools-Used-In-Mac/"/>
    <id>http://yyl8781697.github.io/2015/05/31/Mac/My-Tools-Used-In-Mac/</id>
    <published>2015-05-31T06:30:53.000Z</published>
    <updated>2015-05-31T07:04:48.000Z</updated>
    <content type="html"><![CDATA[<p>用Mac一个多月来，已经慢慢习惯，Mac下的软件都比较精致，虽然其数量远不及Windows，但是日常使用的都已经有了。</p>
<h2 id="office2011_for_mac破解版">office2011 for mac破解版</h2><p>下载地址<a href="http://www.macx.cn/thread-2082485-1-1.html" target="_blank" rel="external">http://www.macx.cn/thread-2082485-1-1.html</a><br>穷人Mac使用者首选，可以和Windows上的office无缝对接，如果你安装完之后发现word很模糊的话 请将office升级到最新版。<br>里面还有一个很强的功能就是Micosoft Connection，用这个软件可以直接在mac端远程到windows端，方便的很。</p>
<h2 id="chmox">chmox</h2><p>下载地址<a href="http://chmox.sourceforge.net/" target="_blank" rel="external">http://chmox.sourceforge.net/</a><br>chmox可以在mac下查看chm帮助文档,毕竟chm格式的文档很多啊^_^，chmox真实良心产品</p>
<h2 id="Snip-截屏软件">Snip-截屏软件</h2><p>下载地址<a href="http://www.snip.qq.com/" target="_blank" rel="external">http://www.snip.qq.com/</a><br>它软件属于企鹅出品，质量也还不错，不过安装的时候建议不要绑定QQ邮箱-_-</p>
<h2 id="iTerm_2">iTerm 2</h2><p>下载地址<a href="http://iterm2.com/" target="_blank" rel="external">http://iterm2.com/</a><br>iTerm 2 的分屏功能让人用着很爽，它们都说和<a href="http://ohmyz.sh/" target="_blank" rel="external">ohmyz</a>配合简直优雅到爆，但是我还是比较习惯原生的.bash -_-</p>
<h2 id="Sublime_Text2">Sublime Text2</h2><p>下载地址<a href="http://www.sublimetext.com/2" target="_blank" rel="external">http://www.sublimetext.com/2</a><br>和Windows端一样好用，哈哈，因为习惯了这个编辑器。</p>
<blockquote>
<p>遗憾的是Notepad++没有Mac版-_-</p>
</blockquote>
<h2 id="FileZilla-Ftp_工具">FileZilla-Ftp 工具</h2><p>下载地址<a href="https://filezilla-project.org/" target="_blank" rel="external">https://filezilla-project.org/</a><br>用这个连接ftp很方便，不过由于系统语言是英文的，FileZilla老是对中文乱码，还不知道哪里设置。。。</p>
<h2 id="VirtualBox虚拟机">VirtualBox虚拟机</h2><p>下载地址<a href="https://www.virtualbox.org/" target="_blank" rel="external">https://www.virtualbox.org/</a><br>小巧，便捷，免费,用着还挺顺手。</p>
<h2 id="TeamViewer">TeamViewer</h2><p>下载地址<a href="https://www.teamviewer.com/en/index.aspx" target="_blank" rel="external">https://www.teamviewer.com/en/index.aspx</a><br>远程协作工具，该工具在Mac下一样好用</p>
<h2 id="MPlayer-视频播放器">MPlayer-视频播放器</h2><p>下载地址<a href="http://itunes.apple.com/us/app/mplayerx/id421131143?mt=12" target="_blank" rel="external">http://itunes.apple.com/us/app/mplayerx/id421131143?mt=12</a><br>非常好使的一个视频播放软件，支持较多的格式，比自带的QuickTime好用多了-_-</p>
<h2 id="Chrome">Chrome</h2><p>下载地址<a href="http://www.google.cn/chrome/" target="_blank" rel="external">http://www.google.cn/chrome/</a><br>还是习惯使用Chrome来上网啊。。。</p>
<h2 id="Eclipse">Eclipse</h2><p>下载地址<a href="http://www.eclipse.org/downloads/" target="_blank" rel="external">http://www.eclipse.org/downloads/</a><br>跨平台的IDE用起来就是舒服</p>
<h2 id="IDEA">IDEA</h2><p>下载地址<a href="http://www.jetbrains.com/idea/download/" target="_blank" rel="external">http://www.jetbrains.com/idea/download/</a><br>号称开发神奇，下载来玩玩。。^_^</p>
<blockquote>
<p>我喜欢将IDEA的KeyMap设置为Eclipse风格-_-</p>
</blockquote>
<h2 id="MacDown">MacDown</h2><p>下载地址<a href="http://macdown.uranusjr.com/" target="_blank" rel="external">http://macdown.uranusjr.com/</a><br>Mac下写Markdown文章的必备工具，免费漂亮。。</p>
<h2 id="必备常用软件">必备常用软件</h2><p>QQ、迅雷、搜狗输入法等不贴地址了，去各自的官网上都能下载到。蛮好用的。</p>
<p>持续更新中。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>用Mac一个多月来，已经慢慢习惯，Mac下的软件都比较精致，虽然其数量远不及Windows，但是日常使用的都已经有了。</p>
<h2 id="office2011_for_mac破解版">office2011 for mac破解版</h2><p>下载地址<a href="]]>
    </summary>
    
      <category term="Mac" scheme="http://yyl8781697.github.io/tags/Mac/"/>
    
      <category term="Mac" scheme="http://yyl8781697.github.io/categories/Mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用IDEA搭建Spark源码环境及编译Spark源码]]></title>
    <link href="http://yyl8781697.github.io/2015/05/31/Spark/Build-Spark-Source-And-Compile/"/>
    <id>http://yyl8781697.github.io/2015/05/31/Spark/Build-Spark-Source-And-Compile/</id>
    <published>2015-05-31T05:57:05.000Z</published>
    <updated>2015-05-31T15:30:02.000Z</updated>
    <content type="html"><![CDATA[<p>之前在看网上使用Eclipse搭建<code>Spark</code>的源码环境各种复杂，所以我只会spark source code下载下来，然后Import到Eclipse中，各种报错，各种包没有，还好我只是看看源码而已，不运行它报错也无所谓啦，人懒没办法..<br><br>但是现在想深入得学习一下<code>Spark</code>的源码环,就不得不搭建完整地环境，所以使用号称开发神器的IDEA来搭建<code>Spark</code>的源码环境，果然很方便^_^</p>
<h2 id="准备工作">准备工作</h2><ul>
<li><code>JDK1.7+</code></li>
<li><code>Scala2.10.4</code>(最好用这个版本，不然用最新版可能导致Spark出各种错误，点<a href="http://www.scala-lang.org/download/2.10.4.html" target="_blank" rel="external">这里</a>下载)</li>
<li><code>IntelliJ IDEA 14 Community Edition</code>(记得下载时选择<a href="http://www.jetbrains.com/idea/download/" target="_blank" rel="external">社区版</a>,它是免费的)</li>
<li><code>Mac OS X 10.10.2</code> (用其他环境也可以，但是别用windows啊)</li>
</ul>
<h2 id="从Github上clone源码">从Github上clone源码</h2><p>打开Idea,在欢迎界面别动！！！<br><br>点击<strong>Check out from version Control-&gt;Git</strong><br><br>在弹出的界面上输入github上spark的托管地址<a href="http://www.jetbrains.com/idea/download/" target="_blank" rel="external">http://www.jetbrains.com/idea/download/</a><br><img src="/img/Build-Spark-Source-And-Compile/clone.png" height="200px" width="400px"></p>
<p>好了，你可以慢慢等了，我这里clone了半小时-_-网速不好啊。</p>
<h2 id="pom-xml的依赖包下载"><code>pom.xml</code>的依赖包下载</h2><p>好不容易将<code>Spark</code>源码clone到本地了，这个时候idea会提醒你发现<code>pom.xml</code>，询问你是否下载其中的依赖，这个时候你要点“是”（Idea的强大之处就是会把这里的依赖全部给你下载了）。<br>好了，你又可以慢慢等待了，这个时候进度条在Idea右下角，想看进度的自己去点出来，我这里下载依赖貌似下载了一个多小时-_-</p>
<p>依赖包下载完成之后你就可以看<code>Spark</code>源码了<br><img src="/img/Build-Spark-Source-And-Compile/codeui.png" alt=""></p>
<h2 id="编译Spark源码">编译Spark源码</h2><p>编译之前先打开<code>pom.xml</code>看java的版本确保和你本机的版本一样。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">java.version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="title">java.version</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后打开终端iterm，进入sarpk的源码根目录，然后执行<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yans-MacBook-Pro:spark yanyl$build/mvn -DskipTests clean package</span><br></pre></td></tr></table></figure></p>
<p>进行最终的编译，这里编译也是要花很多时间啊-_-，慢慢等吧，天朝的网络就是没办法。</p>
<blockquote>
<p>如果想有其他的编译需求，比如Spark on Yarn：<br> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/mvn -Pyarn -Phadoop-2.4 -Dhadoop.version=2.4.0 -DskipTests clean package</span><br></pre></td></tr></table></figure></p>
<p>具体看官网<code><a href="http://spark.apache.org/docs/latest/building-spark.html#building-with-sbt" target="_blank" rel="external">http://spark.apache.org/docs/latest/building-spark.html#building-with-sbt</a></code>,也还可以使用<code>Sbt</code>来进行编译，不过推荐使用<code>Maven</code>，因为他会下载<code>Zinc</code>来加速编译，还可以显示依赖的下载进度^_^。</p>
</blockquote>
<p>编译完了之后控制台会输出：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Reactor Summary:</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] Spark Project Parent POM ........................... SUCCESS [  5.915 s]</span><br><span class="line">[INFO] Spark Launcher Project ............................. SUCCESS [ 11.219 s]</span><br><span class="line">[INFO] Spark Project Networking ........................... SUCCESS [  9.197 s]</span><br><span class="line">[INFO] Spark Project Shuffle Streaming Service ............ SUCCESS [  4.701 s]</span><br><span class="line">[INFO] Spark Project Unsafe ............................... SUCCESS [  4.131 s]</span><br><span class="line">[INFO] Spark Project Core ................................. SUCCESS [03:29 min]</span><br><span class="line">[INFO] Spark Project Bagel ................................ SUCCESS [  7.715 s]</span><br><span class="line">[INFO] Spark Project GraphX ............................... SUCCESS [ 21.757 s]</span><br><span class="line">[INFO] Spark Project Streaming ............................ SUCCESS [ 40.511 s]</span><br><span class="line">[INFO] Spark Project Catalyst ............................. SUCCESS [ 45.336 s]</span><br><span class="line">[INFO] Spark Project SQL .................................. SUCCESS [ 52.931 s]</span><br><span class="line">[INFO] Spark Project ML Library ........................... SUCCESS [01:10 min]</span><br><span class="line">[INFO] Spark Project Tools ................................ SUCCESS [  3.714 s]</span><br><span class="line">[INFO] Spark Project Hive ................................. SUCCESS [01:02 min]</span><br><span class="line">[INFO] Spark Project REPL ................................. SUCCESS [ 10.813 s]</span><br><span class="line">[INFO] Spark Project YARN ................................. SUCCESS [01:41 min]</span><br><span class="line">[INFO] Spark Project Assembly ............................. SUCCESS [01:25 min]</span><br><span class="line">[INFO] Spark Project External Twitter ..................... SUCCESS [  7.853 s]</span><br><span class="line">[INFO] Spark Project External Flume Sink .................. SUCCESS [  6.082 s]</span><br><span class="line">[INFO] Spark Project External Flume ....................... SUCCESS [  8.545 s]</span><br><span class="line">[INFO] Spark Project External MQTT ........................ SUCCESS [  6.492 s]</span><br><span class="line">[INFO] Spark Project External ZeroMQ ...................... SUCCESS [  6.426 s]</span><br><span class="line">[INFO] Spark Project External Kafka ....................... SUCCESS [  9.914 s]</span><br><span class="line">[INFO] Spark Project Examples ............................. SUCCESS [01:34 min]</span><br><span class="line">[INFO] Spark Project External Kafka Assembly .............. SUCCESS [ 31.930 s]</span><br><span class="line">[INFO] Spark Project YARN Shuffle Service ................. SUCCESS [  7.461 s]</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 15:27 min</span><br><span class="line">[INFO] Finished at: 2015-05-31T22:56:11+08:00</span><br><span class="line">[INFO] Final Memory: 83M/653M</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></p>
<p>现在你就可以在<code>$SPARK_HOME/assembly/target/scala-2.10/</code>下发现这个<code>spark-assembly-1.4.0-SNAPSHOT-hadoop2.6.0.jar</code>文件了，他可以在IDE中引用来开发<code>Spark</code>程序。</p>
<h2 id="验证">验证</h2><p>为了验证编译结果，你可以到<code>$SPARK_HOME/bin/</code>目录下取执行<code>spark-shell</code>这个脚本:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&#62; val rdd=sc.parallelize(List(1,2,3,5))&#10;rdd: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at &#60;console&#62;:21&#10;&#10;scala&#62; rdd.count&#10;//...&#27492;&#22788;&#30465;&#30053;log&#10;res0: Long = 4&#10;scala&#62;</span><br></pre></td></tr></table></figure></p>
<p>这里就可以运行<code>local</code>模式的<code>Spark</code>了，赶紧去体验吧~^_^</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前在看网上使用Eclipse搭建<code>Spark</code>的源码环境各种复杂，所以我只会spark source code下载下来，然后Import到Eclipse中，各种报错，各种包没有，还好我只是看看源码而已，不运行它报错也无所谓啦，人懒没办法..<br><]]>
    </summary>
    
      <category term="Spark" scheme="http://yyl8781697.github.io/tags/Spark/"/>
    
      <category term="Spark" scheme="http://yyl8781697.github.io/categories/Spark/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Effective Java》第六章：枚举和注解]]></title>
    <link href="http://yyl8781697.github.io/2015/05/30/Effective%20Java/Enum-And-Annotation/"/>
    <id>http://yyl8781697.github.io/2015/05/30/Effective Java/Enum-And-Annotation/</id>
    <published>2015-05-30T15:57:33.000Z</published>
    <updated>2015-06-03T15:36:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="第30条：用枚举代替int常量">第30条：用枚举代替int常量</h2><p>在编程语言中还没有引入枚举类型之前，表示枚举类型的常用模式就是声明一组具名的<code>int</code>常量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APPLE_FUJI			=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APPLE_PIPPIN		=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APPLE_GRANNY_SMITH	=<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p>但是它又诸多的缺点：</p>
<ul>
<li>在类型安全性和使用方便性方面没有任何帮助。</li>
<li>如果关联的<code>int</code>放生了变化，客户端必须得重新编译。</li>
<li>打印调试的时候只能打印数字</li>
</ul>
<p>上述<code>int</code>常量如何使用枚举类实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> APPLE&#123;FUJI,PIPPIN,GRANNY_SMITH&#125;;</span><br></pre></td></tr></table></figure></p>
<p>除了编码简单之外，枚举的特点还有：</p>
<ul>
<li>枚举是类型安全的（所有可以作为单例的泛型化来使用）。</li>
<li>可以增加或者重新排列枚举类型中的常量，而无需重新编译它的客户端代码。</li>
<li>可以通过<code>toString</code>方法来打印可视的字符串。</li>
</ul>
<p>枚举类型还可以添加任意的方法和域，并实现任意的接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calc</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 具体继承了接口 并重新实现了</span><br><span class="line"> *<span class="javadoctag"> @author</span> yanyl</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation implements Calc&#123;</span><br><span class="line">	PLUS(<span class="string">"+"</span>)&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	MINUS(<span class="string">"-"</span>)&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x-y;&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	TIMES(<span class="string">"*"</span>)&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x*y;&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	DIVIDE(<span class="string">"/"</span>)&#123;</span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x/y;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line">	Operation(String symbol)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>.symbol=symbol;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.symbol;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述枚举可以这么使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Calc calc=Operation.PLUS;</span><br><span class="line">System.out.println(calc.apply(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure></p>
<p>是不是超级方便~</p>
<blockquote>
<p>总之而言，与<code>int</code>常量对比，枚举类型的优势是不言而喻的，（当然，当初枚举的出现就是为了解决<code>int</code>常量问题的^_^，所以大家还是多使用枚举吧）</p>
</blockquote>
<h2 id="第31条：用实例域代替序数">第31条：用实例域代替序数</h2><p>什么是枚举的序数，你知道吗？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Ensemble&#123;</span><br><span class="line">	SOLO,DUET,TRIO,QUARTET,QUITTET,</span><br><span class="line">	SEXTET,SEPTET,OCTET,NONET,DECTET;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMusicians</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ordinal()+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个枚举都有一个<code>ordinal()</code>方法，用于返回当前枚举值的序数，这个见都没见过的方法用起来看似很方便，但是如果你要修改常量的顺序，那么维护起来就是一场噩梦。<br>第30条说过了，枚举里面可以有字段，所以这条就是推荐使用实例域代替序数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Ensemble&#123;</span><br><span class="line">	SOLO(<span class="number">1</span>),DUET(<span class="number">2</span>),TRIO(<span class="number">3</span>),QUARTET(<span class="number">4</span>),QUITTET(<span class="number">5</span>),</span><br><span class="line">	SEXTET(<span class="number">6</span>),SEPTET(<span class="number">7</span>),OCTET(<span class="number">8</span>),NONET(<span class="number">9</span>),DECTET(<span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 使用自定义的一个实例域</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> numberOfMusicians;</span><br><span class="line">	Ensemble(<span class="keyword">int</span> numberOfMusicians)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>.numberOfMusicians=numberOfMusicians;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMusicians</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> numberOfMusicians+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法实现的修过虽好，然是感觉写起来好麻烦。。。维护起来会很简单吗？？？</p>
<h2 id="第32条：用EnumSet代替位域">第32条：用EnumSet代替位域</h2><blockquote>
<p>这个小节讲的其实就是和位图法相关。</p>
</blockquote>
<p>如果一个枚举类型的元素主要用于在集合中，一般就使用<code>int</code>枚举类型，将2的不同倍数赋予每个常量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_BOLD			=<span class="number">1</span>&lt;&lt;<span class="number">0</span>;<span class="comment">//1</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_ITALIC		=<span class="number">1</span>&lt;&lt;<span class="number">1</span>;<span class="comment">//2</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_UNDERLINE		=<span class="number">1</span>&lt;&lt;<span class="number">2</span>;<span class="comment">//4</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_STRIKETHROUGH	=<span class="number">1</span>&lt;&lt;<span class="number">3</span>;<span class="comment">//8</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> styles=-<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyStyles</span><span class="params">(<span class="keyword">int</span> styles)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.styles=styles;<span class="comment">//这里其实就是用位图法来保存，取值要用位移来取  int这里只能存32个值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种表示方法让你用OR位运算将几个常量合并到一个集合中，称作位域。<br>然后你可能会使用这或操作种方法来保持状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Text().applyStyles(Text.STYLE_BOLD|Text.STYLE_ITALIC);</span><br></pre></td></tr></table></figure></p>
<p>这种做法一个是打印是来比较难看懂，还有编译表示所有元素时也没好好的办法。</p>
<p>还好有<code>EnumSet</code>的出现，它实现了<code>Set</code>接口，如果底层枚举类型少于64个，那么这个<code>EnumSet</code>就是用一个<code>long</code>类型来表示，所以性能上也是很高的，上面这个例子用<code>EnumSet</code>来实现就是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">enum</span> Style&#123;BOLD,ITALIC,UNDERLINE,STRIKETHROUGH&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> EnumSet&lt;Style&gt; styles=<span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyStyles</span><span class="params">(EnumSet&lt;Style&gt; styles)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.styles=styles;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用方法就用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Text().applyStyles(EnumSet.of(Text.Style.BOLD, Text.Style.ITALIC));</span><br></pre></td></tr></table></figure></p>
<p>这是调用之后你打印<code>styles</code>这个变量可以看到</p>
<pre><code>[BOLD, ITALIC]
</code></pre><p>这种打印显示的总比单纯的数字要美好的多。</p>
<blockquote>
<p>总而言之，正式因为枚举类型要用集合，所以没有理由用位域来表示它。<br>其实我觉得用<code>EnumSet</code>应该没有位域快啊，估计高手还是会去用位域的把</p>
</blockquote>
<h2 id="第33条：用EnumMap代替序数索引">第33条：用EnumMap代替序数索引</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Herb</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">enum</span> Type &#123;ANNUL,PERENNIAL,BIENNIAL&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你需要将上面类的实例根据<code>Type</code>枚举类型来存储起来是，它推荐这么做：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Herb.Type,Set&lt;Herb&gt;&gt; enumMap=<span class="keyword">new</span> EnumMap&lt;Herb.Type,Set&lt;Herb&gt;&gt;(Herb.Type.class);</span><br></pre></td></tr></table></figure></p>
<p>但是我觉得何必这么麻烦,用下面的写得表示也很方便嘛，也还不需要记那么多东西<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer,Set&lt;Herb&gt;&gt; map=<span class="keyword">new</span> HashMap&lt;Integer,Set&lt;Herb&gt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>每次使用<code>Type.ordinal()</code>的索引即可。</p>
<h2 id="第34条：用接口模拟可伸缩的枚举">第34条：用接口模拟可伸缩的枚举</h2><p>前面几条讲了使用<code>Enum</code>的便利性，安全性，但是它的可伸缩性比较弱，因为枚举无法再继承类或者枚举，比较幸运地时枚举支持接口的实现。<br>例如第30条中的四则运算我需要扩展其他的运算：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExtendOperation implements Calc&#123;</span><br><span class="line">	EXP(<span class="string">"^"</span>)&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> Math.pow(x,y);&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	REMAINDER(<span class="string">"%"</span>)&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x%y;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line">	ExtendOperation(String symbol)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>.symbol=symbol;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.symbol;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后你就可以这么使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	System.out.println(test(Operation.PLUS,<span class="number">2</span>,<span class="number">3</span>));<span class="comment">//调用加法</span></span><br><span class="line">	System.out.println(test(ExtendOperation.EXP,<span class="number">2</span>,<span class="number">3</span>));<span class="comment">//调用求幂</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt; &amp; Calc&gt; <span class="function"><span class="keyword">double</span> <span class="title">test</span><span class="params">(T opt,<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> opt.apply(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终会输出</p>
<pre><code>5.0
8.0
</code></pre><p>总而言之，虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型，对它进行模拟。</p>
<h2 id="第35条：注解优于命名模式">第35条：注解优于命名模式</h2><p>以<code>JUnit</code>为例，命名模式的3大缺陷：</p>
<ol>
<li>文字拼写错误会导致失败，并且没有任何提示</li>
<li>无法确保他们只用于相应的程序元素上</li>
<li>它们都没有提供将参数值与程序元素关联起来的好方法</li>
</ol>
<p>你这通过这种方式简单的来创建一个自己的注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="annotation">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> MyTest &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>MyTest</code>注解类型的声明就是它自身的<code>Retention</code>和<code>Targer</code>注解进行了注解，这些注解类型称为元注解，其中：</p>
<ul>
<li><code>@Retention(RetentionPolicy.RUNTIME)</code>表示<code>MyTest</code>注解应该在运行时保留</li>
<li><code>@Target(ElementType.METHOD)</code>表示该注解仅用于方法上</li>
</ul>
<p>我们有了这个注解之后可以这么使用它<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@MyTest</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@MyTest</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@MyTest</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"i am error test4"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那我们如何调用这个注解呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunTests</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tests=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> passed=<span class="number">0</span>;</span><br><span class="line">		Class testClass=Class.forName(<span class="string">"yyl.java.study.test.HelloWorld"</span>);</span><br><span class="line">		Object testClassInstance=testClass.newInstance();</span><br><span class="line">		<span class="keyword">for</span>(Method m:testClass.getDeclaredMethods())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(m.isAnnotationPresent(MyTest.class))</span><br><span class="line">			&#123;</span><br><span class="line">				tests++;</span><br><span class="line">				<span class="keyword">try</span></span><br><span class="line">				&#123;</span><br><span class="line">					m.invoke(testClassInstance,<span class="keyword">null</span>);<span class="comment">//对实例的方法进行调用</span></span><br><span class="line">					passed++;</span><br><span class="line">					System.out.println(<span class="string">"PASSED:"</span>+m.getName());</span><br><span class="line">				&#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">				&#123;</span><br><span class="line">					System.out.println(<span class="string">"FAILD:"</span>+m.getName());</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(String.format(<span class="string">"PASSED:%s,FAILED:%s"</span>,passed,tests-passed));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>启动这个<code>RunTests</code>会得到</p>
<pre><code><span class="string">PASSED:</span>test3
<span class="string">FAILD:</span>test4
<span class="string">PASSED:</span>test1
<span class="string">PASSED:</span><span class="number">2</span>,<span class="string">FAILED:</span><span class="number">1</span>
</code></pre><p>一个简易版的测试框架就完成了，该书中的其他内容是讲你如何完善这个自制的测试框架，比如添加异常的注解，最终判断失败的机制等，我个人觉得只要把上述的简易框架看懂其他都不是问题。^_^</p>
<blockquote>
<p>既然有了注解，那么完全没有理由再使用命名模式了。</p>
</blockquote>
<h2 id="第36条：坚持使用Override注解">第36条：坚持使用Override注解</h2><p>估计<code>Override</code>注解是在<code>Java</code>中最常见也是常用的一种注解了吧，它标志方法被重写，但是在<code>java</code>中你重写方法时不加<code>Override</code>也是可以正常运行的，所以我相信很多人会懒掉这个注解，关于这个注解书中有下面几个推荐理由：</p>
<ul>
<li>你再重写得定义上出错时如果有<code>Override</code>，编译器就会帮你检查错误</li>
<li>IDE具有自动检查功能，当你没有用<code>Override</code>但是却覆盖了超类的方法时，IDE就是产生一条警告，提醒确认。</li>
<li>还可以让程序员清晰地看到这条方式是否是重写方法，在看代码的找起来比较方便啊（我自己觉得的）</li>
</ul>
<p>总而言之，如果在你想要的每个方法声明中使用<code>Override</code>注解来覆盖超类声明，编译器就可以替你防止大量的错误（在继承抽象类时可以不加。。但是我觉得还是加的好）</p>
<h2 id="第37条：用标记接口定义类型">第37条：用标记接口定义类型</h2><p>标记接口是没有包含方法声明的接口，而只是指明一个类实现了具有某种属性的接口，比如<code>Serializable</code></p>
<p>关于标记接口与标记注解的争论：</p>
<p>标记接口的优势：</p>
<ul>
<li>标记接口定义的类型是由被标记类的实例实现的；标记注解则没有定义这样的类型</li>
<li>标记接口可以更加精确地进行锁定</li>
</ul>
<p>标记注解的优势：</p>
<ul>
<li>它可以通过默认的方式添加一个或者多个注解类型的元素</li>
<li>标记注解作为变成元素之一的框架中同样具有一致性。</li>
</ul>
<p>总而言之，标记接口和标记注解都各有用处，如果想要定义一个任何新的方法都不会与之关联的类型，标记接口是最好的选择。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="第30条：用枚举代替int常量">第30条：用枚举代替int常量</h2><p>在编程语言中还没有引入枚举类型之前，表示枚举类型的常用模式就是声明一组具名的<code>int</code>常量<br><figure class="highlight java"><]]>
    </summary>
    
      <category term="Java" scheme="http://yyl8781697.github.io/tags/Java/"/>
    
      <category term="Effective Java" scheme="http://yyl8781697.github.io/categories/Effective-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[学习和使用Scala的Json解析类库-JSON4S]]></title>
    <link href="http://yyl8781697.github.io/2015/05/24/Scala/Study-And-User-JSON4S/"/>
    <id>http://yyl8781697.github.io/2015/05/24/Scala/Study-And-User-JSON4S/</id>
    <published>2015-05-24T02:12:14.000Z</published>
    <updated>2015-05-24T13:06:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>在<code>Scala</code>环境下已经至少有6种Json解析的类库很用了很相似的抽象语法树(<em>AST</em>),而<code>JSON4S</code>这个项目的目标就是提供一个单一的<em>AST</em>树供其他<code>Scala</code>类库来使用。</p>
<p><img src="https://camo.githubusercontent.com/67e5a0a48c91139ac30d2ecbfd6d6b020e8688a2/68747470733a2f2f7261772e6769746875622e636f6d2f6a736f6e34732f6a736f6e34732f332e332f636f72652f6a736f6e2e706e67" alt="JSON4S工作原理"></p>
<p><code>JSON4S</code>的features：</p>
<ul>
<li>快速的<code>JSON</code>解析</li>
<li><code>LINQ</code> 风格的查询</li>
<li>可以紧密结合样例类</li>
<li>差别比较和合并</li>
<li>使用<code>DSL</code>来生成有效格式的<code>JSON</code></li>
<li>支持<code>XPATH</code></li>
<li>优雅的打印</li>
<li>支持<code>XML</code>的转换</li>
<li>序列化</li>
</ul>
<h2 id="下载JSON4S">下载JSON4S</h2><blockquote>
<p>作者使用的是<code>json4s-native_*.jar</code>（与<code>lift-json</code>相同的实现）。下载的时候注意将版本号进行替换。</p>
</blockquote>
<ul>
<li><p><code>SBT</code>用户</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val json4sNative = <span class="string">"org.json4s"</span> %% <span class="string">"json4s-native"</span> % <span class="string">"3.2.11"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>MAVEN</code>用户</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.json4s<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>json4s-native_$&#123;scala.version&#125;<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>3.2.11<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其他：</p>
<ul>
<li><a href="http://repo1.maven.org/maven2/org/json4s/json4s-core_2.11/3.2.11/json4s-core_2.11-3.2.11.jar" target="_blank" rel="external">http://repo1.maven.org/maven2/org/json4s/json4s-core_2.11/3.2.11/json4s-core_2.11-3.2.11.jar</a></li>
<li><a href="http://repo1.maven.org/maven2/org/json4s/json4s-native_2.11/3.2.11/json4s-native_2.11-3.2.11.jar" target="_blank" rel="external">http://repo1.maven.org/maven2/org/json4s/json4s-native_2.11/3.2.11/json4s-native_2.11-3.2.11.jar</a></li>
<li><a href="http://mirrors.ibiblio.org/pub/mirrors/maven2/com/thoughtworks/paranamer/paranamer/2.5.6/paranamer-2.5.6.jar" target="_blank" rel="external">http://mirrors.ibiblio.org/pub/mirrors/maven2/com/thoughtworks/paranamer/paranamer/2.5.6/paranamer-2.5.6.jar</a></li>
</ul>
</li>
<li>IEAD(我使用的)<br>  File-&gt;Project Structure-&gt;Modules-&gt;Dependencies-&gt;+-&gt;From Maven，然后输入json4s即可搜索，选择最新的json4s-natvie进行下载。</li>
</ul>
<h2 id="需导入的核心包介绍">需导入的核心包介绍</h2><ul>
<li><code>import org.json4s._</code><br>  不用多说，解析都是通过它来完成的。</li>
<li><p><code>import org.json4s.native.JsonMethods._</code><br>  <code>Scala</code>对象与外部<code>JSON</code>资源(字符串，流，文件等)相互转换的开放接口，代码不多，这里可以贴一下：</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">JsonMethods</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">org</span>.<span class="title">json4s</span>.<span class="title">JsonMethods</span>[</span><span class="type">Document</span>] &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//外部JSON资源转Scala对象</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(</span>in: <span class="type">JsonInput</span>, useBigDecimalForDouble: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">JValue</span> = in <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">StringInput</span>(s) =&gt; <span class="type">JsonParser</span>.parse(s, useBigDecimalForDouble)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ReaderInput</span>(rdr) =&gt; <span class="type">JsonParser</span>.parse(rdr, useBigDecimalForDouble)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">StreamInput</span>(stream) =&gt; <span class="type">JsonParser</span>.parse(<span class="type">Source</span>.fromInputStream(stream).bufferedReader(), useBigDecimalForDouble)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">FileInput</span>(file) =&gt; <span class="type">JsonParser</span>.parse(<span class="type">Source</span>.fromFile(file).bufferedReader(), useBigDecimalForDouble)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//外部JSON资源转Scala对象(返回值可选)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parseOpt</span>(</span>in: <span class="type">JsonInput</span>, useBigDecimalForDouble: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">Option</span>[<span class="type">JValue</span>] = in <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">StringInput</span>(s) =&gt; <span class="type">JsonParser</span>.parseOpt(s, useBigDecimalForDouble)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ReaderInput</span>(rdr) =&gt; <span class="type">JsonParser</span>.parseOpt(rdr, useBigDecimalForDouble)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">StreamInput</span>(stream) =&gt; <span class="type">JsonParser</span>.parseOpt(<span class="type">Source</span>.fromInputStream(stream).bufferedReader(), useBigDecimalForDouble)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">FileInput</span>(file) =&gt; <span class="type">JsonParser</span>.parseOpt(<span class="type">Source</span>.fromFile(file).bufferedReader(), useBigDecimalForDouble)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Renders JSON.</span><br><span class="line">   * Scala对象转外部JSON&lt;资源</span><br><span class="line">   * @see Printer#compact</span><br><span class="line">   * @see Printer#pretty</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">render</span>(</span>value: <span class="type">JValue</span>): <span class="type">Document</span> = value <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">null</span>          =&gt; text(<span class="string">"null"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JBool</span>(<span class="literal">true</span>)   =&gt; text(<span class="string">"true"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JBool</span>(<span class="literal">false</span>)  =&gt; text(<span class="string">"false"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JDouble</span>(n)    =&gt; text(n.toString)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JDecimal</span>(n)   =&gt; text(n.toString)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JInt</span>(n)       =&gt; text(n.toString)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JNull</span>         =&gt; text(<span class="string">"null"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JNothing</span>      =&gt; sys.error(<span class="string">"can't render 'nothing'"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JString</span>(<span class="literal">null</span>) =&gt; text(<span class="string">"null"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JString</span>(s)    =&gt; text(<span class="string">"\""</span>+<span class="type">JsonAST</span>.quote(s)+<span class="string">"\""</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JArray</span>(arr)   =&gt; text(<span class="string">"["</span>) :: series(trimArr(arr).map(render)) :: text(<span class="string">"]"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JObject</span>(obj)  =&gt;</span><br><span class="line">      <span class="function"><span class="keyword">val</span> <span class="title">nested</span> =</span> <span class="keyword">break</span> :: fields(trimObj(obj).map(&#123;<span class="keyword">case</span> (n,v) =&gt; text(<span class="string">"\""</span>+<span class="type">JsonAST</span>.quote(n)+<span class="string">"\":"</span>) :: render(v)&#125;))</span><br><span class="line">      text(<span class="string">"&#123;"</span>) :: nest(<span class="number">2</span>, nested) :: <span class="keyword">break</span> :: text(<span class="string">"&#125;"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">trimArr</span>(</span>xs: <span class="type">List</span>[<span class="type">JValue</span>]) = xs.filter(_ != <span class="type">JNothing</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">trimObj</span>(</span>xs: <span class="type">List</span>[<span class="type">JField</span>]) = xs.filter(_._2 != <span class="type">JNothing</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">series</span>(</span>docs: <span class="type">List</span>[<span class="type">Document</span>]) = punctuate(text(<span class="string">","</span>), docs)</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">fields</span>(</span>docs: <span class="type">List</span>[<span class="type">Document</span>]) = punctuate(text(<span class="string">","</span>) :: <span class="keyword">break</span>, docs)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">punctuate</span>(</span>p: <span class="type">Document</span>, docs: <span class="type">List</span>[<span class="type">Document</span>]): <span class="type">Document</span> =</span><br><span class="line">    <span class="keyword">if</span> (docs.length == <span class="number">0</span>) empty</span><br><span class="line">    <span class="keyword">else</span> docs.reduceLeft((d1, d2) =&gt; d1 :: p :: d2)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//紧凑和漂亮的打印</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">compact</span>(</span>d: <span class="type">Document</span>): <span class="type">String</span> = <span class="type">Printer</span>.compact(d)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pretty</span>(</span>d: <span class="type">Document</span>): <span class="type">String</span> = <span class="type">Printer</span>.pretty(d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">JsonMethods</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">native</span>.<span class="title">JsonMethods</span></span></span><br></pre></td></tr></table></figure>
<p>  可以发现<code>json4s</code>提供了<code>parse</code>和<code>render</code>两大方法来进行<code>JSON</code>的转换。</p>
</li>
<li><code>import org.json4s.JsonDSL._</code><br>  <code>render</code>方法需要传入的是<code>JValue</code>类型的值，它并不是<code>Scala</code>的原生对象，所以需要通过转换而为之。<code>JsonDSL</code>这个特质就是提供了这些隐式转换：  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">JsonDSL</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span> <span class="keyword"><span class="keyword">with</span></span> <span class="title">org</span>.<span class="title">json4s</span>.<span class="title">Implicits</span> &#123;</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">seq2jvalue</span>[</span><span class="type">A</span>](s : scala.<span class="type">Traversable</span>[<span class="type">A</span>])(<span class="keyword">implicit</span> evidence$<span class="number">1</span> : scala.<span class="type">Function1</span>[<span class="type">A</span>, org.json4s.<span class="type">JsonAST</span>.<span class="type">JValue</span>]) : org.json4s.<span class="type">JsonAST</span>.<span class="type">JArray</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">map2jvalue</span>[</span><span class="type">A</span>](m : scala.<span class="type">Predef</span>.<span class="type">Map</span>[scala.<span class="type">Predef</span>.<span class="type">String</span>, <span class="type">A</span>])(<span class="keyword">implicit</span> evidence$<span class="number">2</span> : scala.<span class="type">Function1</span>[<span class="type">A</span>, org.json4s.<span class="type">JsonAST</span>.<span class="type">JValue</span>]) : org.json4s.<span class="type">JsonAST</span>.<span class="type">JObject</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">option2jvalue</span>[</span><span class="type">A</span>](opt : scala.<span class="type">Option</span>[<span class="type">A</span>])(<span class="keyword">implicit</span> evidence$<span class="number">3</span> : scala.<span class="type">Function1</span>[<span class="type">A</span>, org.json4s.<span class="type">JsonAST</span>.<span class="type">JValue</span>]) : org.json4s.<span class="type">JsonAST</span>.<span class="type">JValue</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">symbol2jvalue</span>(</span>x : scala.<span class="type">Symbol</span>) : org.json4s.<span class="type">JsonAST</span>.<span class="type">JString</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">pair2jvalue</span>[</span><span class="type">A</span>](t : scala.<span class="type">Tuple2</span>[scala.<span class="type">Predef</span>.<span class="type">String</span>, <span class="type">A</span>])(<span class="keyword">implicit</span> evidence$<span class="number">4</span> : scala.<span class="type">Function1</span>[<span class="type">A</span>, org.json4s.<span class="type">JsonAST</span>.<span class="type">JValue</span>]) : org.json4s.<span class="type">JsonAST</span>.<span class="type">JObject</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">list2jvalue</span>(</span>l : scala.<span class="type">List</span>[org.json4s.<span class="type">JsonAST</span>.<span class="type">JField</span>]) : org.json4s.<span class="type">JsonAST</span>.<span class="type">JObject</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">jobject2assoc</span>(</span>o : org.json4s.<span class="type">JsonAST</span>.<span class="type">JObject</span>) : <span class="type">JsonDSL</span>.<span class="keyword">this</span>.<span class="type">JsonListAssoc</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">JsonListAssoc</span>(</span>left : scala.<span class="type">List</span>[org.json4s.<span class="type">JsonAST</span>.<span class="type">JField</span>]) <span class="keyword">extends</span> java.lang.<span class="type">Object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">~</span>(</span>right : scala.<span class="type">Tuple2</span>[scala.<span class="type">Predef</span>.<span class="type">String</span>, org.json4s.<span class="type">JsonAST</span>.<span class="type">JValue</span>]) : org.json4s.<span class="type">JsonAST</span>.<span class="type">JObject</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">~</span>(</span>right : org.json4s.<span class="type">JsonAST</span>.<span class="type">JObject</span>) : org.json4s.<span class="type">JsonAST</span>.<span class="type">JObject</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">pair2Assoc</span>[</span><span class="type">A</span>](t : scala.<span class="type">Tuple2</span>[scala.<span class="type">Predef</span>.<span class="type">String</span>, <span class="type">A</span>])(<span class="keyword">implicit</span> evidence$<span class="number">5</span> : scala.<span class="type">Function1</span>[<span class="type">A</span>, org.json4s.<span class="type">JsonAST</span>.<span class="type">JValue</span>]) : <span class="type">JsonDSL</span>.<span class="keyword">this</span>.<span class="type">JsonAssoc</span>[<span class="type">A</span>] = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">JsonAssoc</span>[</span><span class="type">A</span>](left : scala.<span class="type">Tuple2</span>[scala.<span class="type">Predef</span>.<span class="type">String</span>, <span class="type">A</span>])(<span class="keyword">implicit</span> evidence$<span class="number">6</span> : scala.<span class="type">Function1</span>[<span class="type">A</span>, org.json4s.<span class="type">JsonAST</span>.<span class="type">JValue</span>]) <span class="keyword">extends</span> java.lang.<span class="type">Object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">~</span>[</span><span class="type">B</span>](right : scala.<span class="type">Tuple2</span>[scala.<span class="type">Predef</span>.<span class="type">String</span>, <span class="type">B</span>])(<span class="keyword">implicit</span> evidence$<span class="number">7</span> : scala.<span class="type">Function1</span>[<span class="type">B</span>, org.json4s.<span class="type">JsonAST</span>.<span class="type">JValue</span>]) : org.json4s.<span class="type">JsonAST</span>.<span class="type">JObject</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">~</span>(</span>right : org.json4s.<span class="type">JsonAST</span>.<span class="type">JObject</span>) : org.json4s.<span class="type">JsonAST</span>.<span class="type">JObject</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="JSON字符串转对象">JSON字符串转对象</h2><p>可以使用<code>parse</code>方法将<code>JSON</code>字符串进行转换<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">t=parse</span>(</span><span class="string">""" &#123; "name" : "tom","age":23,"number":[1,2,3,4] &#125; """</span>)</span><br><span class="line">println(t)</span><br></pre></td></tr></table></figure></p>
<p>最终打印的结果为：</p>
<pre><code>JObject<span class="list">(<span class="keyword">List</span><span class="list">(<span class="list">(<span class="keyword">name</span>,JString<span class="list">(<span class="keyword">tom</span>)</span>)</span>, <span class="list">(<span class="keyword">age</span>,JInt<span class="list">(<span class="number">23</span>)</span>)</span>, <span class="list">(<span class="keyword">number</span>,JArray<span class="list">(<span class="keyword">List</span><span class="list">(<span class="keyword">JInt</span><span class="list">(<span class="number">1</span>)</span>, JInt<span class="list">(<span class="number">2</span>)</span>, JInt<span class="list">(<span class="number">3</span>)</span>, JInt<span class="list">(<span class="number">4</span>)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><p>根据打印结果可以发现转换之后的并不是<code>Scala</code>的原生对象，那么如何取得它的原生对象呢？它其实是一个<code>Map[String,_]</code>类型的转换<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>((k,v)&lt;-t.values.asInstanceOf[<span class="type">Map</span>[<span class="type">String</span>,_]])</span><br><span class="line">&#123;</span><br><span class="line">println(k,<span class="string">"-&gt;"</span>,v,v.getClass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将<code>Map</code>遍历输出之后</p>
<pre><code>(name,-&gt;,tom,class java<span class="class">.lang</span><span class="class">.String</span>)
(age,-&gt;,<span class="number">23</span>,class scala<span class="class">.math</span><span class="class">.BigInt</span>)
(number,-&gt;,<span class="function"><span class="title">List</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span></span>,class scala<span class="class">.collection</span><span class="class">.immutable</span>.<span class="variable">$colon</span><span class="variable">$colon</span>)
</code></pre><p>可以发现<code>parse</code>之后仍旧保留着语言来字符串中可识别的类型，那么还有其他方式取值吗？其实它还支持使用反斜杠(\)的方式进行在顶级目录下取值：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"name"</span>,(t \ <span class="string">"name"</span>).values)</span><br><span class="line">println(<span class="string">"age"</span>,(t \ <span class="string">"age"</span>).values)</span><br><span class="line">println(<span class="string">"number"</span>,(t \ <span class="string">"number"</span>).values)</span><br></pre></td></tr></table></figure></p>
<p>取到得结果为</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">name</span></span>,tom)</span>
<span class="list">(<span class="keyword">age</span>,<span class="number">23</span>)</span>
<span class="list">(<span class="keyword">number</span>,List<span class="list">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span>)</span>
</code></pre><p>这个功能是不是略显惊讶，特别方法，恩，的确很方便。<br><br>同时该对象还可以直接转换为样例类：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>(</span>name:<span class="type">String</span>,age:<span class="type">Int</span>)<span class="comment">//注意这个样例类不要放方法里面，放在外部可访问的地方即可</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">val</span> <span class="title">formats</span> =</span> <span class="type">DefaultFormats</span><span class="comment">//这个日期转换的隐式导入不要忘了，如果有特殊格式还需要自己写</span></span><br><span class="line">println(t.extract[<span class="type">Student</span>])<span class="comment">//这里即可取的对应的样例类数据</span></span><br></pre></td></tr></table></figure></p>
<p>输出为：</p>
<pre><code><span class="function"><span class="title">Student</span><span class="params">(tom,<span class="number">23</span>)</span></span>
</code></pre><p>这个转换功能特别方法，果然,<code>Scala</code>下得<code>JSON</code>转换类库还是有很多自己的特色的^_^。</p>
<h2 id="对象转JSON字符串">对象转JSON字符串</h2><blockquote>
<p>注意在打印的时候一定要添加<code>compact()</code>方法，这样才能将字符串紧凑的表示，不然都是<code>Doc</code>对象。</p>
</blockquote>
<ul>
<li><p>集合类的序列化</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(compact(render(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))))</span><br><span class="line"><span class="comment">//结果：[1,2,3,4]</span></span><br><span class="line">println(compact(render(<span class="type">Map</span>(<span class="string">"name"</span>-&gt;<span class="string">"tom"</span>,<span class="string">"age"</span>-&gt;<span class="string">"23"</span>))))</span><br><span class="line"><span class="comment">//结果：&#123;"name":"tom","age":"23"&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>只支持<code>Seq</code>和<code>List</code></p>
</blockquote>
</li>
<li><p>元组的序列化</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">tuple=</span>(</span><span class="string">"name"</span>,<span class="string">"tom"</span>)</span><br><span class="line">   println(compact(render(tuple)))</span><br><span class="line">   <span class="comment">//结果：&#123;"name":"tom"&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里只支持<code>Tuple2[String,A]</code>这种格式的元组，将会序列化成键值对</p>
</blockquote>
</li>
<li><p>可以使用<code>~</code>将两个字段进行连接操作</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">tuple=</span>(</span><span class="string">"name"</span>,<span class="string">"tom"</span>)~(<span class="string">"age"</span>,<span class="number">23</span>)</span><br><span class="line">println(tuple)</span><br><span class="line">println(compact(render(tuple)))</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//JObject(List((name,JString(tom)), (age,JInt(23))))</span></span><br><span class="line"><span class="comment">//&#123;"name":"tom","age":23&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>任何键的值可以为可选的，为<code>None</code>时将不会被序列化</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">tuple=</span>(</span><span class="string">"name"</span>,<span class="string">"tom"</span>)~(<span class="string">"age"</span>,<span class="type">None</span>:<span class="type">Option</span>[<span class="type">Int</span>])</span><br><span class="line">println(tuple)                                   </span><br><span class="line">println(compact(render(tuple)))</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//JObject(List((name,JString(tom)), (age,JNothing)))</span></span><br><span class="line"><span class="comment">//&#123;"name":"tom"&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一个复杂一点的列子</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Winner</span>(</span>id: <span class="type">Long</span>, numbers: <span class="type">List</span>[<span class="type">Int</span>])</span><br><span class="line">   <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Lotto</span>(</span>id: <span class="type">Long</span>, winningNumbers: <span class="type">List</span>[<span class="type">Int</span>], winners: <span class="type">List</span>[<span class="type">Winner</span>], drawDate: <span class="type">Option</span>[java.util.<span class="type">Date</span>])</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">val</span> <span class="title">winners</span> =</span> <span class="type">List</span>(<span class="type">Winner</span>(<span class="number">23</span>, <span class="type">List</span>(<span class="number">2</span>, <span class="number">45</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">3</span>, <span class="number">5</span>)), <span class="type">Winner</span>(<span class="number">54</span>, <span class="type">List</span>(<span class="number">52</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">18</span>, <span class="number">22</span>)))</span><br><span class="line">   <span class="function"><span class="keyword">val</span> <span class="title">lotto</span> =</span> <span class="type">Lotto</span>(<span class="number">5</span>, <span class="type">List</span>(<span class="number">2</span>, <span class="number">45</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>), winners, <span class="type">Option</span>(<span class="keyword">new</span> java.util.<span class="type">Date</span>()))</span><br><span class="line">   <span class="function"><span class="keyword">val</span> <span class="title">json</span> =</span></span><br><span class="line">     (<span class="string">"lotto"</span> -&gt;</span><br><span class="line">       (<span class="string">"lotto-id"</span> -&gt; lotto.id) ~</span><br><span class="line">         (<span class="string">"winning-numbers"</span> -&gt; lotto.winningNumbers) ~</span><br><span class="line">         (<span class="string">"draw-date"</span> -&gt; lotto.drawDate.map(_.toString)) ~</span><br><span class="line">         (<span class="string">"winners"</span> -&gt;</span><br><span class="line">           lotto.winners.map &#123; w =&gt;</span><br><span class="line">             ((<span class="string">"winner-id"</span> -&gt; w.id) ~</span><br><span class="line">               (<span class="string">"numbers"</span> -&gt; w.numbers))</span><br><span class="line">           &#125;))</span><br><span class="line"></span><br><span class="line">   println(compact(render(json)))</span><br></pre></td></tr></table></figure>
<p>  打印的结果为:</p>
<pre><code>{"<span class="attribute">lotto</span>":<span class="value">{"<span class="attribute">lotto-id</span>":<span class="value"><span class="number">5</span></span>,"<span class="attribute">winning-numbers</span>":<span class="value">[<span class="number">2</span>,<span class="number">45</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>]</span>,"<span class="attribute">draw-date</span>":<span class="value"><span class="string">"Sun May 24 15:41:29 CST 2015"</span></span>,"<span class="attribute">winners</span>":<span class="value">[{"<span class="attribute">winner-id</span>":<span class="value"><span class="number">23</span></span>,"<span class="attribute">numbers</span>":<span class="value">[<span class="number">2</span>,<span class="number">45</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">3</span>,<span class="number">5</span>]</span>},{"<span class="attribute">winner-id</span>":<span class="value"><span class="number">54</span></span>,"<span class="attribute">numbers</span>":<span class="value">[<span class="number">52</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">18</span>,<span class="number">22</span>]</span>}]</span>}</span>}
</code></pre><p>  如果你使用<code>pretty()</code>方法来组织<code>JSON</code>:</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(pretty(render(json)))</span><br></pre></td></tr></table></figure>
<p>  就可以得到：</p>
<pre><code>{
  "<span class="attribute">lotto</span>":<span class="value">{
    "<span class="attribute">lotto-id</span>":<span class="value"><span class="number">5</span></span>,
    "<span class="attribute">winning-numbers</span>":<span class="value">[<span class="number">2</span>,<span class="number">45</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>]</span>,
    "<span class="attribute">draw-date</span>":<span class="value"><span class="string">"Sun May 24 15:43:01 CST 2015"</span></span>,
    "<span class="attribute">winners</span>":<span class="value">[{
      "<span class="attribute">winner-id</span>":<span class="value"><span class="number">23</span></span>,
      "<span class="attribute">numbers</span>":<span class="value">[<span class="number">2</span>,<span class="number">45</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">3</span>,<span class="number">5</span>]
    </span>},{
      "<span class="attribute">winner-id</span>":<span class="value"><span class="number">54</span></span>,
      "<span class="attribute">numbers</span>":<span class="value">[<span class="number">52</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">18</span>,<span class="number">22</span>]
    </span>}]
  </span>}
</span>}
</code></pre><p>  这样可读性明显提高多了。</p>
</li>
</ul>
<h2 id="合并和差异化对比">合并和差异化对比</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">t1=parse</span>(</span></span><br><span class="line">  <span class="string">"""</span><br><span class="line">    &#123;"name":"tom",</span><br><span class="line">       "age":23,</span><br><span class="line">       "class":["xiaoerban"]</span><br><span class="line">    &#125;</span><br><span class="line">  """</span>)</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">t2=parse</span>(</span></span><br><span class="line">  <span class="string">"""</span><br><span class="line">    &#123;"name":"tom",</span><br><span class="line">       "age":23,</span><br><span class="line">       "class":["xiaosanban"]</span><br><span class="line">    &#125;</span><br><span class="line">  """</span>)</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">t3=t1</span> <span class="title">merge</span> <span class="title">t2</span></span><br><span class="line"></span>println(pretty(render(t3)))</span><br></pre></td></tr></table></figure>
<p>合并之后的结果为</p>
<pre><code>{
  "<span class="attribute">name</span>":<span class="value"><span class="string">"tom"</span></span>,
  "<span class="attribute">age</span>":<span class="value"><span class="number">23</span></span>,
  "<span class="attribute">class</span>":<span class="value">[<span class="string">"xiaoerban"</span>,<span class="string">"xiaosanban"</span>]
</span>}
</code></pre><p>接下来咱们对比一下合并之后的差异化：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">Diff</span>(</span>changed,added,deleted)=t3 diff t1</span><br><span class="line">println(<span class="string">"changed"</span>,changed)</span><br><span class="line">println(<span class="string">"added"</span>,added)</span><br><span class="line">println(<span class="string">"deleted"</span>,deleted)</span><br></pre></td></tr></table></figure></p>
<p>输出的差异化为：</p>
<pre><code><span class="list">(<span class="keyword">changed</span>,JNothing)</span>
<span class="list">(<span class="keyword">added</span>,JNothing)</span>
<span class="list">(<span class="keyword">deleted</span>,JObject<span class="list">(<span class="keyword">List</span><span class="list">(<span class="list">(<span class="keyword"><span class="built_in">class</span></span>,JArray<span class="list">(<span class="keyword">List</span><span class="list">(<span class="keyword">JString</span><span class="list">(<span class="keyword">xiaosanban</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><h2 id="XML的支持">XML的支持</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.json4s.<span class="type">Xml</span>.&#123;toJson, toXml&#125;</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">xml</span> =</span></span><br><span class="line">  &lt;users&gt;</span><br><span class="line">    &lt;user&gt;</span><br><span class="line">      &lt;id&gt;<span class="number">1</span>&lt;/id&gt;</span><br><span class="line">      &lt;name&gt;<span class="type">Harry</span>&lt;/name&gt;</span><br><span class="line">    &lt;/user&gt;</span><br><span class="line">    &lt;user&gt;</span><br><span class="line">      &lt;id&gt;<span class="number">2</span>&lt;/id&gt;</span><br><span class="line">      &lt;name&gt;<span class="type">David</span>&lt;/name&gt;</span><br><span class="line">    &lt;/user&gt;</span><br><span class="line">  &lt;/users&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">json</span> =</span> toJson(xml)</span><br><span class="line">println(pretty(render(json)))</span><br></pre></td></tr></table></figure>
<p>输出的结果为：</p>
<pre><code>{
  "<span class="attribute">users</span>":<span class="value">{
    "<span class="attribute">user</span>":<span class="value">[{
      "<span class="attribute">id</span>":<span class="value"><span class="string">"1"</span></span>,
      "<span class="attribute">name</span>":<span class="value"><span class="string">"Harry"</span>
    </span>},{
      "<span class="attribute">id</span>":<span class="value"><span class="string">"2"</span></span>,
      "<span class="attribute">name</span>":<span class="value"><span class="string">"David"</span>
    </span>}]
  </span>}
</span>}
</code></pre><h2 id="总结">总结</h2><p><code>JSON4S</code>很好很强大，其他功能请参考1。</p>
<p>虽然<code>Scala</code>可以无缝的直接访问<code>java</code>版本的<code>JSON</code>解析类库，但是由于<code>Scala</code>有它自己的语法简洁性，所以在<code>Scala</code>环境下强烈推荐使用<code>JSON4S</code>.^_^</p>
<h2 id="参考">参考</h2><ol>
<li><a href="https://github.com/json4s/json4s" target="_blank" rel="external">https://github.com/json4s/json4s</a></li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="介绍">介绍</h2><p>在<code>Scala</code>环境下已经至少有6种Json解析的类库很用了很相似的抽象语法树(<em>AST</em>),而<code>JSON4S</code>这个项目的目标就是提供一个单一的<em>AST</em>树供其他<]]>
    </summary>
    
      <category term="Json4s" scheme="http://yyl8781697.github.io/tags/Json4s/"/>
    
      <category term="Scala" scheme="http://yyl8781697.github.io/tags/Scala/"/>
    
      <category term="Scala" scheme="http://yyl8781697.github.io/categories/Scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Effective Java》第五章：泛型]]></title>
    <link href="http://yyl8781697.github.io/2015/05/23/Effective%20Java/Generic/"/>
    <id>http://yyl8781697.github.io/2015/05/23/Effective Java/Generic/</id>
    <published>2015-05-23T15:05:33.000Z</published>
    <updated>2015-05-31T15:32:49.000Z</updated>
    <content type="html"><![CDATA[<p>泛型，可以告诉编译器每个集合中接受哪些对象类型，编译器会自动地为你的插入进行转化，并在编译时告知是否插入了类型错误的对象。(貌似<code>Java</code>里面的泛型都是<strong>伪泛型</strong>吧-_-|)</p>
<h2 id="第23条：请不要再新代码中使用原生态类型">第23条：请不要再新代码中使用原生态类型</h2><blockquote>
<p>什么是原生态类型？</p>
</blockquote>
<p>类似<code>List&lt;E&gt;</code>,<code>Collection&lt;E&gt;</code>泛型的定义都有一个原生态类型，那就是<code>List</code>,<code>Collection</code>，用他们定义类型也不会出错.</p>
<blockquote>
<p>为什么不要使用原生态类型</p>
</blockquote>
<p>使用原生态类型的集合类可以插入各种不同的类型，他们在编译时不会进行类型检查，但是运行时遇到错误就会抛出，这样是很不安全的。</p>
<blockquote>
<p>我在不确定或者不在乎集合类型的情况下，是不是用原生态类型最好？</p>
</blockquote>
<p>还是不要用，可以使用无限制的通配符来替代，比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numElementsInCommon</span><span class="params">(Set&lt;?&gt; s1,Set&lt;?&gt; s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(Object o:s1)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(s2.contains(o))</span><br><span class="line">			count++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它是类型安全的，但是无法猜测放入了哪些对象，此时可以使用<strong>泛型</strong>或者<strong>有限制的通配符类型</strong>（下文会描述）。</p>
<h2 id="第24条：消除非首检警告">第24条：消除非首检警告</h2><blockquote>
<p>非受检警告很重要，每个警告都表示可能在运行时抛出<code>ClassCastException</code>异常，我们应该在编码时尽量消除编辑器给出的每一条受检警告。如果无法消除非首检警告，同时可证明引起警告的代码是类型安全的，就可以在尽量小得范围中，用<code>@SuppressWarnings(“uncheck”)</code>注解来禁止该警告，并且要把禁止该警告的原因记录下来。</p>
</blockquote>
<h2 id="第25条：列表优先于数组">第25条：列表优先于数组</h2><p>数组与泛型相比，有两个重要的不同点:</p>
<ol>
<li><p>数组是协变的，泛型则是不可变的<br> 如果<code>Sub</code>为<code>Super</code>的子类，那么数组类型<code>Sub[]</code>就是<code>Super[]</code>的子类，但是<code>List&lt;Sub&gt;</code>与<code>List&lt;Super&gt;</code>并没有什么卵关系。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object[] objectArray=<span class="keyword">new</span> Long[<span class="number">10</span>];</span><br><span class="line">objectArray[<span class="number">0</span>]=<span class="string">"Hello"</span>;<span class="comment">//运行时会再这里抛ArrayStoreException异常</span></span><br><span class="line"></span><br><span class="line">List&lt;Object&gt; list=<span class="keyword">new</span> List&lt;Long&gt;();<span class="comment">//在编译时就在这里出错了</span></span><br><span class="line">list.add(<span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure>
<p> 从上面看出来，它们都不能将<code>String</code>放入<code>Long</code>容器中，但是明显泛型的报错更加合理。</p>
</li>
</ol>
<p>2.数组是具体化的，因此在运行时才会知道并检查它们元素类型的约束，而泛型是通过擦除来实现的，因此泛型时只在编译时强化它们的类信息，并在运行时丢弃。</p>
<blockquote>
<p>泛型是数组不能很好的混合使用，使用泛型数组定义式非法的。</p>
</blockquote>
<h2 id="第26条：优先考虑泛型">第26条：优先考虑泛型</h2><p>使用泛型简单，但是自己编写泛型还是有一点麻烦的，下面是第6条中的两种泛型版本。<br>1.使用泛型<code>E[]</code>来存储数据，但是用<code>Object[]</code>的数组转换来处理泛型数组的创建错误<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 简单的栈结构的实现 泛型版本-泛型数组转换</span><br><span class="line"> *<span class="javadoctag"> @author</span> yyl  form Effective Java</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> E[] elements;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPCAITY=<span class="number">16</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 这个elements元素只会使用E类型来添加</span><br><span class="line">	 * 所以他是足够安全的</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		elements=(E[])<span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPCAITY];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		ensureCapacity();<span class="comment">//确保容量足够</span></span><br><span class="line">		elements[size++]=e;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">		<span class="keyword">return</span> elements[--size];<span class="comment">//</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(elements.length==size)</span><br><span class="line">			elements=Arrays.copyOf(elements, <span class="number">2</span>*size+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>使用<code>Object[]</code>来存储，但是返回类型使用<code>Object</code>向泛型类型<code>E</code>去转换<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 简单的栈结构的实现 泛型版本-泛型转换</span><br><span class="line"> *<span class="javadoctag"> @author</span> yyl  form Effective Java</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object[] elements;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPCAITY=<span class="number">16</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		elements=<span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPCAITY];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		ensureCapacity();<span class="comment">//确保容量足够</span></span><br><span class="line">		elements[size++]=e;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 这里都是需要返回E</span><br><span class="line">	 * 所以这里的转换是安全的</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">		<span class="keyword">return</span> (E)elements[--size];<span class="comment">//</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(elements.length==size)</span><br><span class="line">			elements=Arrays.copyOf(elements, <span class="number">2</span>*size+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>上述优先选择的是第二种方案，第一种禁止数组类型的非受检转换比禁止标量类型更加危险，并且它需要多次转换<code>E[]</code>，而第二是是多次转换<code>E</code></p>
</blockquote>
<h2 id="第27条：优先考虑泛型方法">第27条：优先考虑泛型方法</h2><p>关于泛型方法和非泛型方法可以见下面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 原生类型的书写，类型不安全，并且还会产生警告</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set <span class="title">union2</span><span class="params">(Set s1,Set s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Set result=<span class="keyword">new</span> HashSet(s1);</span><br><span class="line">	result.addAll(s2);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 泛型方法，类型安全</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;E&gt; s1,Set&lt;E&gt; s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Set&lt;E&gt; result=<span class="keyword">new</span> HashSet&lt;E&gt;(s1);</span><br><span class="line">	result.addAll(s2);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很明显，泛型方法更加安全，并且简单易用。</p>
<blockquote>
<p>使用泛型方法就像类型异性，还应该将现有的方法泛型化，使新用户使用起来更加轻松，且不会平均破坏现有的客户端。</p>
</blockquote>
<h2 id="第28条:利用有限制通配符来提升API的灵活性">第28条:利用有限制通配符来提升API的灵活性</h2><p>针对第26条中泛型<code>Stack</code>的实现方法，如果现在需要添加<code>pushAll</code>和<code>popAll</code>这两个方法，为了让他们用起来更加顺手，那么应该这么写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 所有E的子类的集合都可以添加进来</span><br><span class="line"> *<span class="javadoctag"> @param</span> iter</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterable&lt;? extends E&gt; iter)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(E e:iter)</span><br><span class="line">		<span class="keyword">this</span>.push(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 可以将elements里面的元素全部弹出到E得超类中</span><br><span class="line"> *<span class="javadoctag"> @param</span> dst</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; dst)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!isEmpty())</span><br><span class="line">		dst.add(pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>使用通配符能让API变得更加灵活，在编写广泛使用的类库时，一定适当地利用通配符类型。</p>
</blockquote>
<h2 id="第29条：优先考虑类型安全的异构容器">第29条：优先考虑类型安全的异构容器</h2><blockquote>
<p>泛型往往会被用户参数化了的容器，每个容器有固定数目的类型参数。但是你可能需要更加灵活地容器，比如数据库的表可以有任意多得列，在<code>Java</code>中，解决这个问题的做法就是将建参数化而不是容器参数化。可以使用类类型<code>Class</code>来作为键值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;Class&lt;?&gt;,Object&gt; favorites=<span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;,Object&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 存值 </span><br><span class="line">	 *<span class="javadoctag"> @param</span> type 这个是键，每个键的类型都是不同的</span><br><span class="line">	 *<span class="javadoctag"> @param</span> instance 这个就是值</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type,T instance)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(type==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Type is null"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="javadoc">/**</span><br><span class="line">		 * 这里加上cast可以防止用户恶意改传类型</span><br><span class="line">		 */</span></span><br><span class="line">		favorites.put(type, type.cast(instance));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFavorites</span><span class="params">(Class&lt;T&gt; type)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="javadoc">/**</span><br><span class="line">		 * 这里的cast转换是安全的，因为放入的都是对应T的类型的值</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="keyword">return</span> type.cast(favorites.get(type));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>Favorites</code>类型里面的键都不同类型的，这里将<code>Favorites</code>称为异构容器。</p>
<p>它又两个局限性：</p>
<ol>
<li>用户可以轻松地破坏<code>Favorites</code>的实例安全（可以用<code>put</code>方法中<code>cast</code>来避免）</li>
<li>它只能用于可具体化的类ing中（比如List<string>这个类型你就不能传过去）</string></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>泛型，可以告诉编译器每个集合中接受哪些对象类型，编译器会自动地为你的插入进行转化，并在编译时告知是否插入了类型错误的对象。(貌似<code>Java</code>里面的泛型都是<strong>伪泛型</strong>吧-_-|)</p>
<h2 id="第23条：请不要再新]]>
    </summary>
    
      <category term="Java" scheme="http://yyl8781697.github.io/tags/Java/"/>
    
      <category term="Effective Java" scheme="http://yyl8781697.github.io/categories/Effective-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自己煮：泡椒牛蛙]]></title>
    <link href="http://yyl8781697.github.io/2015/05/16/Food/Sauteed-Bullfrog-with-Pickled-Peppers/"/>
    <id>http://yyl8781697.github.io/2015/05/16/Food/Sauteed-Bullfrog-with-Pickled-Peppers/</id>
    <published>2015-05-16T14:38:59.000Z</published>
    <updated>2015-05-16T15:02:45.000Z</updated>
    <content type="html"><![CDATA[<pre><code>泡椒牛蛙是一道色香味俱全的汉族名菜，属于川菜系。最常见又易烹制，成菜后味咸鲜，肉细嫩，色红亮，泡菜香气浓郁。
</code></pre><h2 id="食材">食材</h2><ul>
<li>牛蛙：2只</li>
<li>油、料酒~~~~</li>
<li>生姜、大蒜：适量</li>
<li>莴笋：适量（炒到牛蛙里面的莴笋特别好吃）</li>
<li>小米椒：一点点就好了（最好还有红灯笼椒，但是没买到-_-）</li>
</ul>
<p><img src="/img/Sauteed-Bullfrog/1cailiao.jpg" alt=""></p>
<h2 id="预煮牛蛙">预煮牛蛙</h2><p>将洗干净切好的牛蛙倒入热水中煮2~3分钟<br><br><img src="/img/Sauteed-Bullfrog/2yuzhu.jpg" alt=""></p>
<p>然后直接捞出<br><br><img src="/img/Sauteed-Bullfrog/3yuzhuchuguo.jpg" alt=""></p>
<h2 id="炒莴笋">炒莴笋</h2><p>先热油锅<br><br><img src="/img/Sauteed-Bullfrog/4reyouguo.jpg" alt=""></p>
<p>放入生姜大蒜炒出香味之后将莴笋放入油锅爆炒<br><br><img src="/img/Sauteed-Bullfrog/5chaowosun.jpg" alt=""></p>
<p>然后放入小米椒（注意这个很辣的，所以要看个人口味适量而为之）<br><img src="/img/Sauteed-Bullfrog/6fangxiaomijiao.jpg" alt=""></p>
<h2 id="炒牛蛙">炒牛蛙</h2><p>莴笋爆炒2分钟之后将之前预煮过的牛蛙倒入油锅一起炒<br><img src="/img/Sauteed-Bullfrog/7yiqichao.jpg" alt=""></p>
<p>还顺再放点啤酒/料酒，炒出香味之后放入水<br><br><img src="/img/Sauteed-Bullfrog/8fangshui.jpg" alt=""></p>
<h2 id="出锅">出锅</h2><p>盖上锅盖等几分钟之后放入盐味精以及其他配料即可出锅<br><img src="/img/Sauteed-Bullfrog/9chuguo.jpg" alt=""></p>
<p>洗锅开吃~~~~哈哈！</p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>泡椒牛蛙是一道色香味俱全的汉族名菜，属于川菜系。最常见又易烹制，成菜后味咸鲜，肉细嫩，色红亮，泡菜香气浓郁。
</code></pre><h2 id="食材">食材</h2><ul>
<li>牛蛙：2只</li>
<li>油、料酒~~~~</li>
<li>]]>
    </summary>
    
      <category term="Food" scheme="http://yyl8781697.github.io/tags/Food/"/>
    
      <category term="Food" scheme="http://yyl8781697.github.io/categories/Food/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac通过ssh连接到Centos时一些问题的解决]]></title>
    <link href="http://yyl8781697.github.io/2015/05/16/Linux/Mac-ssh-Centos-Problem-List/"/>
    <id>http://yyl8781697.github.io/2015/05/16/Linux/Mac-ssh-Centos-Problem-List/</id>
    <published>2015-05-16T02:26:53.000Z</published>
    <updated>2015-05-16T02:53:09.000Z</updated>
    <content type="html"><![CDATA[<p>Linux版本：Centos6.5<br>Mac版本：OS X Yosemite 10.10.2</p>
<h2 id="LC_CTYPE:_cannot_change_locale_(UTF-8)">LC_CTYPE: cannot change locale (UTF-8)</h2><p>通过ssh连接到linux，会出现如下警告：</p>
<pre><code>-<span class="string">bash:</span> <span class="string">warning:</span> <span class="string">setlocale:</span> <span class="string">LC_CTYPE:</span> cannot change locale (UTF-<span class="number">8</span>): No such file or directory
</code></pre><p>这是由于没有找到对应的语言环境导致的：<br>按一下命令步骤操作即可修复：<br>首先</p>
<pre><code>sudo vi <span class="regexp">/etc/</span>ssh_cofig
</code></pre><p>然后将该文件中的SendEnv LANG LC_*这一行用#进行注释</p>
<pre><code><span class="id">#SendEnv</span> LANG LC_*
</code></pre><p>参考:<a href="http://www.cyberciti.biz/faq/os-x-terminal-bash-warning-setlocale-lc_ctype-cannot-change-locale/" target="_blank" rel="external">OS X Terminal: -bash: warning: setlocale: LC_CTYPE: cannot change locale (UTF-8): No such file or directory Fix</a></p>
<h2 id="Write_failed:_Broken_pipe">Write failed: Broken pipe</h2><p>通过ssh连接到linux，有时候会莫名其妙的出现错误：</p>
<pre><code><span class="tag">Write</span> <span class="rule"><span class="attribute">failed</span>:<span class="value"> Broken pipe</span></span>
</code></pre><p>看资料说的是由于长时间未操作造成的，解决方法为在Mac端的~/.ssh/config文件中添加：</p>
<pre><code><span class="title">ServerAliveInterval</span> <span class="number">60</span>
</code></pre><p>参考：<a href="http://www.cnblogs.com/dudu/archive/2013/02/07/ssh-write-failed-broken-pipe.html" target="_blank" rel="external">解决ssh的”Write failed: Broken pipe”问题</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Linux版本：Centos6.5<br>Mac版本：OS X Yosemite 10.10.2</p>
<h2 id="LC_CTYPE:_cannot_change_locale_(UTF-8)">LC_CTYPE: cannot change locale (UTF-]]>
    </summary>
    
      <category term="Linux" scheme="http://yyl8781697.github.io/tags/Linux/"/>
    
      <category term="ssh" scheme="http://yyl8781697.github.io/tags/ssh/"/>
    
      <category term="Linux" scheme="http://yyl8781697.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim命令合集(转载)]]></title>
    <link href="http://yyl8781697.github.io/2015/05/14/Linux/Vim-Command-List/"/>
    <id>http://yyl8781697.github.io/2015/05/14/Linux/Vim-Command-List/</id>
    <published>2015-05-14T13:32:08.000Z</published>
    <updated>2015-05-16T02:12:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="命令历史">命令历史</h2><p>以<code>:</code>和<code>/</code>开头的命令都有历史纪录，可以首先键入<code>:</code>或<code>/</code>然后按上下箭头来选择某个历史命令。</p>
<h2 id="启动vim">启动vim</h2><p>在命令行窗口中输入以下命令即可</p>
<ul>
<li><code>vim</code> 直接启动vim</li>
<li><code>vim filename</code> 打开vim并创建名为filename的文件</li>
</ul>
<h2 id="文件命令">文件命令</h2><ul>
<li><code>vim file</code>  打开单个文件</li>
<li><code>vim file1 file2 file3 …</code>  同时打开多个文件</li>
<li><code>:open file</code>  在vim窗口中打开一个新文件</li>
<li><code>:split file</code>  在新窗口中打开文件</li>
<li><code>:bn</code>  切换到下一个文件</li>
<li><code>:bp</code>  切换到上一个文件</li>
<li><code>:args</code>  查看当前打开的文件列表，当前正在编辑的文件会用[]括起来。</li>
<li>打开远程文件，比如ftp或者share folder<br><code>:e ftp://192.168.10.76/abc.txt</code><br><code>:e \qadrive\test\1.txt</code></li>
</ul>
<h2 id="vim的模式">vim的模式</h2><ul>
<li>正常模式（按<code>Esc</code>或<code>Ctrl+[</code>进入） 左下角显示文件名或为空</li>
<li>插入模式（按<code>i</code>键进入） 左下角显示—INSERT—</li>
<li>可视模式（不知道如何进入） 左下角显示—VISUAL—</li>
</ul>
<h2 id="导航命令">导航命令</h2><ul>
<li><code>%</code> 括号匹配</li>
</ul>
<h2 id="插入命令">插入命令</h2><ul>
<li><code>i</code> 在当前位置生前插入</li>
<li><code>I</code> 在当前行首插入</li>
<li><code>a</code> 在当前位置后插入</li>
<li><code>A</code> 在当前行尾插入</li>
<li><code>o</code> 在当前行之后插入一行</li>
<li><code>O</code> 在当前行之前插入一行</li>
</ul>
<h2 id="查找命令">查找命令</h2><ul>
<li><code>/text</code>　　查找text，按n健查找下一个，按N健查找前一个。</li>
<li><code>?text</code>　　查找text，反向查找，按n健查找下一个，按N健查找前一个。</li>
<li>vim中有一些特殊字符在查找时需要转义　　.*[]^%/?~$</li>
<li><code>:set ignorecase</code>　　忽略大小写的查找</li>
<li><code>:set noignorecase</code>　　不忽略大小写的查找</li>
<li>查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。</li>
<li><code>:set hlsearch</code>　　高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。</li>
<li><code>:set nohlsearch</code>　　关闭高亮搜索显示</li>
<li><code>:nohlsearch</code>　　关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。</li>
<li><code>:set incsearch</code>　　逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。</li>
<li><code>:set wrapscan</code>　　重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。</li>
</ul>
<h2 id="替换命令">替换命令</h2><ul>
<li><code>ra</code> 将当前字符替换为a，当期字符即光标所在字符。</li>
<li><code>s/old/new/</code> 用old替换new，替换当前行的第一个匹配</li>
<li><code>s/old/new/g</code> 用old替换new，替换当前行的所有匹配</li>
<li><code>%s/old/new/</code> 用old替换new，替换所有行的第一个匹配</li>
<li><code>%s/old/new/g</code> 用old替换new，替换整个文件的所有匹配</li>
<li><code>:10,20 s/^/</code>    /g 在第10行知第20行每行前面加四个空格，用于缩进。</li>
<li><code>ddp</code> 交换光标所在行和其下紧邻的一行。</li>
</ul>
<h2 id="移动命令">移动命令</h2><ul>
<li><code>h</code> 左移一个字符</li>
<li><code>l</code> 右移一个字符，这个命令很少用，一般用<code>w</code>代替。</li>
<li><code>k</code> 上移一个字符</li>
<li><code>j</code> 下移一个字符</li>
</ul>
<p>以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！<esc>，这里的Esc是必须的，否则命令不生效。</esc></p>
<ul>
<li><code>w</code> 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。</li>
<li><code>b</code> 向后移动一个单词 2b 向后移动2个单词</li>
<li><code>e</code>，同w，只不过是光标停在单词尾部</li>
<li><code>ge</code>，同b，光标停在单词尾部。</li>
<li><code>^</code> 移动到本行第一个非空白字符上。</li>
<li><code>0</code>（数字0）移动到本行第一个字符上，</li>
<li><code>&lt;HOME&gt;</code> 移动到本行第一个字符。同0健。</li>
<li><code>$</code> 移动到行尾 3$ 移动到下面3行的行尾</li>
<li><code>gg</code> 移动到文件头。 = <code>[[</code></li>
<li><code>G</code>（shift + g） 移动到文件尾。 = <code>]]</code></li>
<li><code>f</code>（find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。</li>
<li><code>F</code> 同f，反向查找。</li>
<li>跳到指定行，冒号+行号，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行。</li>
<li><code>Ctrl + e</code> 向下滚动一行</li>
<li><code>Ctrl + y</code> 向上滚动一行</li>
<li><code>Ctrl + d</code> 向下滚动半屏</li>
<li><code>Ctrl + u</code> 向上滚动半屏</li>
<li><code>Ctrl + f</code> 向下滚动一屏</li>
<li><code>Ctrl + b</code> 向上滚动一屏</li>
</ul>
<h2 id="撤销和重做">撤销和重做</h2><ul>
<li><code>u</code> 撤销（Undo）</li>
<li><code>U</code> 撤销对整行的操作</li>
<li><code>Ctrl + r</code> 重做（Redo），即撤销的撤销。</li>
</ul>
<h2 id="删除命令">删除命令</h2><ul>
<li><code>x</code> 删除当前字符</li>
<li><code>3x</code> 删除当前光标开始向后三个字符</li>
<li><code>X</code> 删除当前字符的前一个字符。<code>X</code>=<code>dh</code></li>
<li><code>dl</code> 删除当前字符， <code>dl</code>=<code>x</code></li>
<li><code>dh</code> 删除前一个字符</li>
<li><code>dd</code> 删除当前行</li>
<li><code>dj</code> 删除上一行</li>
<li><code>dk</code> 删除下一行</li>
<li><code>10d</code> 删除当前行开始的10行。</li>
<li><code>D</code> 删除当前字符至行尾。<code>D</code>=<code>d$</code></li>
<li><code>d$</code> 删除当前字符之后的所有字符（本行）</li>
<li><code>kdgg</code> 删除当前行之前所有行（不包括当前行）</li>
<li><code>jdG</code>（jd shift + g）   删除当前行之后所有行（不包括当前行）</li>
<li><code>:1,10d</code> 删除1-10行</li>
<li><code>:11,$d</code> 删除11行及以后所有的行</li>
<li><code>:1,$d</code> 删除所有行</li>
<li><code>J</code>(shift + j)　　删除两行之间的空行，实际上是合并两行。</li>
</ul>
<h2 id="拷贝和粘贴">拷贝和粘贴</h2><ul>
<li><code>yy</code> 拷贝当前行</li>
<li><code>nyy</code> 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。</li>
<li><code>p</code>  在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。</li>
<li><code>shift+p</code> 在当前行前粘贴</li>
<li><code>:1,10 co 20</code> 将1-10行插入到第20行之后。</li>
<li><code>:1,$ co $</code> 将整个文件复制一份并添加到文件尾部。</li>
<li>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制</li>
<li><code>ddp</code>交换当前行和其下一行</li>
<li><code>xp</code>交换当前字符和其后一个字符</li>
</ul>
<h2 id="剪切命令">剪切命令</h2><ul>
<li>正常模式下按<code>v</code>（逐字）或<code>V</code>（逐行）进入可视模式，然后用<code>jklh</code>命令移动即可选择某些行或字符，再按d即可剪切</li>
<li><code>ndd</code> 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴</li>
<li><code>:1,10d</code> 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。</li>
<li><code>:1, 10 m 20</code> 将第1-10行移动到第20行之后。</li>
</ul>
<h2 id="退出命令">退出命令</h2><ul>
<li><code>:wq</code> 保存并退出</li>
<li><code>ZZ</code> 保存并退出</li>
<li><code>:q!</code> 强制退出并忽略所有更改</li>
<li><code>:e!</code> 放弃所有修改，并打开原来文件。</li>
</ul>
<h2 id="窗口命令">窗口命令</h2><ul>
<li><code>:split</code>或<code>new</code> 打开一个新窗口，光标停在顶层的窗口上</li>
<li><code>:split file</code>或<code>:new file</code> 用新窗口打开文件</li>
<li><code>split</code>打开的窗口都是横向的，使用<code>vsplit</code>可以纵向打开窗口。</li>
<li><code>Ctrl+ww</code> 移动到下一个窗口</li>
<li><code>Ctrl+wj</code> 移动到下方的窗口</li>
<li><code>Ctrl+wk</code> 移动到上方的窗口</li>
</ul>
<blockquote>
<p>关闭窗口</p>
</blockquote>
<ul>
<li><code>:close</code> 最后一个窗口不能使用此命令，可以防止意外退出vim。</li>
<li><code>:q</code> 如果是最后一个被关闭的窗口，那么将退出vim。</li>
<li><code>ZZ</code> 保存并退出。</li>
</ul>
<blockquote>
<p>关闭所有窗口，只保留当前窗口</p>
</blockquote>
<ul>
<li><code>:only</code></li>
</ul>
<blockquote>
<p>录制宏</p>
</blockquote>
<ul>
<li>按<code>q</code>键加任意字母开始录制，再按<code>q</code>键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。</li>
</ul>
<h2 id="执行shell命令">执行shell命令</h2><ul>
<li><code>:!command</code></li>
<li><code>:!ls</code> 列出当前目录下文件</li>
<li><code>:!perl -c script.pl</code> 检查perl脚本语法，可以不用退出vim，非常方便。</li>
<li><code>:!perl script.pl</code> 执行perl脚本，可以不用退出vim，非常方便。</li>
<li><code>:suspend</code>或<code>Ctrl - Z</code> 挂起vim，回到shell，按fg可以返回vim。</li>
</ul>
<h2 id="注释命令">注释命令</h2><ul>
<li>perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#</li>
<li><code>3,5 s/^/#/g</code> 注释第3-5行</li>
<li><code>3,5 s/^#//g</code> 解除3-5行的注释</li>
<li><code>1,$ s/^/#/g</code> 注释整个文档。</li>
<li><code>:%s/^/#/g</code> 注释整个文档，此法更快。</li>
</ul>
<h2 id="帮助命令">帮助命令</h2><ul>
<li><code>:help</code> or <code>F1</code> 显示整个帮助</li>
<li><code>:help xxx</code> 显示xxx的帮助，比如 <code>:help i</code>, <code>:help CTRL-[</code>（即<code>Ctrl+[</code>的帮助）。</li>
<li><code>:help ‘number’</code> Vim选项的帮助用单引号括起</li>
<li><code>:help &lt;Esc&gt;</code> 特殊键的帮助用<code>&lt;&gt;<code>扩起</code></code></li>
<li><code>:help -t</code> Vim启动参数的帮助用-</li>
<li><code>:help i<em>&lt;Esc&gt;</em></code> 插入模式下Esc的帮助，某个模式下的帮助用模式主题的模式</li>
<li>帮助文件中位于<code>||</code>之间的内容是超链接，可以用<code>Ctrl+]</code>进入链接，<code>Ctrl+o</code>（<code>Ctrl + t</code>）返回</li>
</ul>
<h2 id="其他非编辑命令">其他非编辑命令</h2><ul>
<li><code>.</code> 重复前一次命令</li>
<li><code>:set ruler?</code>　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看</li>
<li><code>:scriptnames</code>　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。</li>
<li><p><code>:set list</code> 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。</p>
</li>
<li><p>Vim教程<br>在Unix系统上 $ vimtutor<br>在Windows系统上 :help tutor</p>
</li>
<li><p><code>:syntax</code> 列出已经定义的语法项</p>
</li>
<li><code>:syntax clear</code> 清除已定义的语法规则</li>
<li><code>:syntax case match</code> 大小写敏感，int和Int将视为不同的语法元素</li>
<li><code>:syntax case ignore</code> 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</li>
</ul>
<h2 id="转载说明">转载说明</h2><p>转载说明：这篇文章是我从<a href="http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html" target="_blank">http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html</a>转载过来，它的确写得很清晰，希望转载过来以后自己可以当字典来用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="命令历史">命令历史</h2><p>以<code>:</code>和<code>/</code>开头的命令都有历史纪录，可以首先键入<code>:</code>或<code>/</code>然后按上下箭头来选择某个历史命令。</p>
<h2 id="启动vim">]]>
    </summary>
    
      <category term="Linux" scheme="http://yyl8781697.github.io/tags/Linux/"/>
    
      <category term="Vim" scheme="http://yyl8781697.github.io/tags/Vim/"/>
    
      <category term="Linux" scheme="http://yyl8781697.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[记录在Hadoop2.2.0中剔除一个DataNode]]></title>
    <link href="http://yyl8781697.github.io/2015/05/10/Hadoop/Hadoop-Remove-DataNode/"/>
    <id>http://yyl8781697.github.io/2015/05/10/Hadoop/Hadoop-Remove-DataNode/</id>
    <published>2015-05-10T14:33:45.000Z</published>
    <updated>2015-05-11T15:40:54.000Z</updated>
    <content type="html"><![CDATA[<p>最近在<code>Haddop</code>环境下跑论文里的对比试验，不过这两天在跑Job时偶然会出现<strong>Job Failed</strong>的问题，看日志就是其中一台机器<strong>Connect Timeout</strong>了，在WebUI上点击这台机器IP的各种UI界面也是开不了，<code>HDFS</code>还连不上-_-|，之前也遇到过这种问题，解决方法简单粗暴：</p>
<ol>
<li>重启<code>Haddop</code>集群：一般重启一下还正好了</li>
</ol>
<ul>
<li>停<code>Haddop</code>集群，然后重启每台物理机，然后再开启<code>Hadoop</code>集群：这么做一般问题就可以解决-_-|</li>
<li>还有一种就是直接去<code>Linux</code>上删除<code>dfs</code>文件目录，重新初始化<code>HDFS</code>：这么做效果虽达到了，但是。。。向<code>HDFS</code>传数据还很久一段时间。。</li>
</ul>
<p>今天第1、2种方法试了都不行，第三种方法也太麻烦了（集群有15台<code>DataNode</code>+1台<code>NameNode</code>，重新初始化每次都要去每个机器上删除文件夹再新建），由于时间受限，就想尝试去动态的直接把那个老是异常的节点去掉得了，赶紧查了下面一些资料：</p>
<ul>
<li><a href="http://blog.chinaunix.net/xmlrpc.php?r=blog/article&amp;uid=23916356&amp;id=3258527" target="_blank" rel="external">http://blog.chinaunix.net/xmlrpc.php?r=blog/article&amp;uid=23916356&amp;id=3258527</a></li>
<li><a href="http://www.itpub.net/thread-1866448-1-1.html" target="_blank" rel="external">http://www.itpub.net/thread-1866448-1-1.html</a></li>
<li><a href="http://www.programgo.com/article/9436398293/" target="_blank" rel="external">http://www.programgo.com/article/9436398293/</a></li>
</ul>
<p>按参考上得现在hdfs-site.xml中添加：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--要摘除的datanode--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.hosts.exclude<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">value</span>&gt;</span>/home/nbu/hadoop2.2.0/etc/hadoop/exclude<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后自己再相应目录下新建exclude文件并添加我要去掉的节点IP<br><br>再执行执行<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfsadmin -refreshNodes</span><br></pre></td></tr></table></figure></p>
<p>然后再需要摘除节点上去执行<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop-daemon.sh stop datanode</span><br></pre></td></tr></table></figure></p>
<p>接下来就可以在WebUI中看到我要去掉节点的状态为<strong>Decmission in Progress</strong></p>
<p><img src="/img/hadoop-remove-datanode/process.jpg" alt=""></p>
<p>他们都说这个状态是正在将摘除节点的数据拷贝到其他可用节点，拷贝完之后不会变为我也就信了，可是我过了好几分钟我的状态一直是这个，当前可用集群的节点数量也是大于拷贝数量的，但是Last Contact的值一直在增加，不知道是不是那台机器上出问题了，然后与<code>NameNode</code>的心跳不正常导致的。十几分钟之后，这个节点没有出现在<code>Live Nodes</code>中了，但是他变为<code>Dead Node</code>里边去了，这回估计是直接超时了。<br><br><img src="/img/hadoop-remove-datanode/dead.jpg" alt=""><br>那怎么办？好像动态移除失败了？没辙，直接去<code>NameNode</code>机器上将<code>slaves</code>文件中将那个摘除的IP去掉，拷贝到各个<code>DataNode</code>上去。然后再重新启动<code>Hadoop</code>，这回重启了之后集群的hdfs上的数据皆正常^_^，那个需要移除的节点也不在集群中了，我又可以欢快得跑程序了。</p>
<blockquote>
<p>不知道刚刚摘除的过程哪一步错了，不过最终还是达到我需要的摘除目的^_^，下次有时间再好好尝试尝试~</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在<code>Haddop</code>环境下跑论文里的对比试验，不过这两天在跑Job时偶然会出现<strong>Job Failed</strong>的问题，看日志就是其中一台机器<strong>Connect Timeout</strong>了，在WebUI上点击这]]>
    </summary>
    
      <category term="Hadoop" scheme="http://yyl8781697.github.io/tags/Hadoop/"/>
    
      <category term="Hadoop" scheme="http://yyl8781697.github.io/categories/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Effective Java》第四章：类和接口]]></title>
    <link href="http://yyl8781697.github.io/2015/05/08/Effective%20Java/Class-And-Interface/"/>
    <id>http://yyl8781697.github.io/2015/05/08/Effective Java/Class-And-Interface/</id>
    <published>2015-05-08T14:39:56.000Z</published>
    <updated>2015-05-23T14:31:28.000Z</updated>
    <content type="html"><![CDATA[<p>类和接口是Java程序设计语言的核心，它们也是Java语言的基本抽象单元。</p>
<h2 id="第13条：使类和成员的可访问性最小化">第13条：使类和成员的可访问性最小化</h2><blockquote>
<p>尽可能使每个类或者成员不被外界访问。</p>
</blockquote>
<p><code>Java</code>的4种访问级别：</p>
<ul>
<li>私有的<code>private</code>：只有在申明该成员的类的内部才可以访问。</li>
<li>包级私有的<code>package-private</code>：包内的任何类都可以访问这个成员，（<strong>这个是默认的访问级别</strong>）</li>
<li>受保护的<code>protected</code>：子类可以访问超类的<code>protected</code>成员，<strong>但是还有这个<code>protected</code>成员类的包内的任何类也可以访问</strong>。</li>
<li>公有的<code>public</code>：任何地方都可以访问这个成员。</li>
</ul>
<blockquote>
<p>如何方法覆盖了超类中的中的一个方法，子类中的访问级别就不允许低于超类的访问级别。</p>
</blockquote>
<p>这样可以确保使用超类的实例的地方也可以使用子类的实例。</p>
<blockquote>
<p>实例域是不能公有的。</p>
</blockquote>
<p>其实就是建议类里面只暴露<code>final</code>修饰的变量成员，其他变量一律不要暴露。</p>
<blockquote>
<p>长度非零的数组总是可变的。</p>
</blockquote>
<p>就算你使用<code>static final</code>关键字将一个数组成员暴露出来，但是这个数组成员的内容还是可以被外部给修改的。你可以使用</p>
<ul>
<li>创建不可变量列表</li>
<li>克隆这个对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 这里暴露的变量别看是 static final修饰的，但是数组里面的内容还是可以修改的。</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] DATA=&#123;<span class="string">"tom"</span>,<span class="string">"peter"</span>,<span class="string">"lily"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 创建不可变量列表</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; VDATA=Collections.unmodifiableList(Arrays.asList(DATA));</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 直接使用克隆</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CDATA()&#123;</span><br><span class="line">	<span class="keyword">return</span> DATA.clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 我更加推荐这种  这里需要将DATA的访问级别设置为private</span><br><span class="line"> *<span class="javadoctag"> @param</span> i</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> DATA[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>总而言之，你应该始终尽可能的降低可访问性，除了公有<span class="keyword">static</span> <span class="keyword">final</span>域的特殊情形之外，公有的类都不应该包含公有域，并且要确保公有<span class="keyword">static</span> <span class="keyword">final</span>所引用的对象时不可变的。
</code></pre><h2 id="第14条：在类中使用访问方法而非公有域">第14条：在类中使用访问方法而非公有域</h2><p>这条其实就是对应上面第13条中的公有域解说那部分，除了不要暴露可变的对象外，还有：</p>
<ul>
<li>如果有成员需要公开，最好使用<code>getter</code>和<code>setter</code>方法。</li>
<li>暴露不可变对象的有有域时可以在设置值时加入一些约束条件。</li>
</ul>
<h2 id="第15条：使可变最小化">第15条：使可变最小化</h2><blockquote>
<p>不可变类比可变类更加易于设计、实现和使用，它们不容易出错，且更加安全。</p>
</blockquote>
<p>成为不可变类，要遵循下面五条规则：</p>
<ul>
<li>不要提供任何会修改对象状态的方法</li>
<li>保证类不可被扩展</li>
<li>所使用的域都是<code>final</code>的</li>
<li>所使用的域都是私有的</li>
<li>确保对于任何可变组件的互斥访问(如果类具有指向可变对象的域，则必须保证)。</li>
</ul>
<p>不可变对象的优点：</p>
<ol>
<li>不可变对象只有一种状态，即被创建时的状态。</li>
<li>不可变对象本质上是线程安全的，可以被自由的共享。</li>
<li>不可变对象还可以共享它们的内部信息。</li>
<li>不可变对象为其他对象提供了大量的构件。</li>
</ol>
<p>不可变类真正唯一的缺点是：对于每个不同的值都需要一个单独的对象（这样创建对象的代价就会很高啊~-_-!!）</p>
<blockquote>
<p>为了确保类的不可变性，该类绝对不允许自身被子类化</p>
</blockquote>
<ul>
<li><p>将类用<code>final</code>关键字标记</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 我肯定不能被继承了</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="comment">//ToDo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将构造设置为<code>private</code>访问权限,然后开放一个公有的静态工厂来代替构造器。（256个赞，推荐^_^）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 你看我还能被继承嘛？^_^</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 我不让外人调用</span><br><span class="line"> *<span class="javadoctag"> @param</span> str</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">(String str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//ToDo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">valueOf</span><span class="params">(String str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 在这里进行构造函数的调用</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Test(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>还有：</p>
<ul>
<li>坚决不要为每个<code>get</code>方法编写一个相应的<code>set</code>方法。</li>
<li>除非令人有信服的理由使会变成非<code>final</code>的，否则每个域都是<code>final</code>（恩，总之多用<code>final</code>没错）</li>
</ul>
<h2 id="第16条：符合优于继承">第16条：符合优于继承</h2><ul>
<li>这里不推荐继承的主要原因是子类必须跟着其超类改变而改变，因而打破了封装性。。。-_-||</li>
<li>不用扩展现有类，而是在新的类里面增加一个私有域，它引用现有类的一个实力。在新类中主要去实现转发功能。</li>
</ul>
<blockquote>
<p>这里我想说如果是使用符合实现相同的功能将大大增加代码量。</p>
</blockquote>
<h2 id="第17条：要么为继承而设计并提供文档，要么禁止继承">第17条：要么为继承而设计并提供文档，要么禁止继承</h2><p>如果该类允许被继承，则最好：</p>
<ul>
<li>对允许被重写的类方法添加足够的文档说明，如果覆盖了这个类之后会对其他的方法产生怎么样的影响。</li>
<li>为了能让子类进入超类的内部工作流中，超类必须通过某种形式提供适当的钩子(钩子),这种形式可以是精心得选择的受保护的类，也可以是受保护的域。</li>
</ul>
<h2 id="第18条：接口优于抽象类">第18条：接口优于抽象类</h2><blockquote>
<p>抽象类只能被单继承，而接口则没有此约束。</p>
</blockquote>
<p>使用接口还有以下几个优势：</p>
<ul>
<li>现有的类可以很容易实现被更新，以实现新的接口。<br>  只需要定义一个新的接口添加相关方法的声明，然后在该类中<code>implements</code>该接口并实现那些方法即可。</li>
<li>接口是定义mixin（混合类型）的理想选择。<br>  <code>mixin</code>是指类除了实现它的基本类型之外，还可以实现这个<code>mixin</code>类型，以表明它提供了某种可供选择的行为，比如，<code>Comparable</code>是一个<code>mixin</code>接口.</li>
<li>接口允许我们构造非层次接口的类型框架（因为接口可以多继承啊）。</li>
</ul>
<h2 id="第19条：接口只用于定义类型">第19条：接口只用于定义类型</h2><blockquote>
<p>接口应该只被用来定义类型，它们不应该被用来导出常量（常量接口是一种不被推荐的用法）。</p>
</blockquote>
<h2 id="第20条：类层次优于标签类">第20条：类层次优于标签类</h2><p>什么是标签类？看下面那个类就知道了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Figure</span></span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> Shape&#123;RECTANGLE,CIRCLE&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">final</span> Shape shape;<span class="comment">//当前这个类的标志</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">double</span> length;</span><br><span class="line">	<span class="keyword">double</span> width;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">double</span> radius;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//表示圆</span></span><br><span class="line">	Figure(<span class="keyword">double</span> radius)&#123;</span><br><span class="line">		<span class="keyword">this</span>.shape=Shape.CIRCLE;</span><br><span class="line">		<span class="keyword">this</span>.radius=radius;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//表示矩形</span></span><br><span class="line">	Figure(<span class="keyword">double</span> length,<span class="keyword">double</span> width)&#123;</span><br><span class="line">		<span class="keyword">this</span>.shape=Shape.RECTANGLE;</span><br><span class="line">		<span class="keyword">this</span>.length=length;</span><br><span class="line">		<span class="keyword">this</span>.width=width;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//求面积</span></span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">switch</span>(<span class="keyword">this</span>.shape)<span class="comment">//只能使用switch类判断</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> RECTANGLE:<span class="keyword">return</span> length*width;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> CIRCLE:<span class="keyword">return</span> Math.PI*(radius*radius);<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:<span class="keyword">throw</span> AssertionError();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个类里面其实有求圆的面积和矩形的面积，用一个shape标志类区别，但是这样的类<strong>过于冗长，容易出错，并且效率低下</strong>(这个一般人都知道吧？)<br><br>那如何使用类层次类实现上述功能？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类层次的基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Figure</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//圆形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Figure</span></span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">double</span> radius;</span><br><span class="line">	</span><br><span class="line">	Circle(<span class="keyword">double</span> radius)&#123;</span><br><span class="line">		<span class="keyword">this</span>.radius=radius;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Math.PI*(radius*radius);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩形类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Figure</span></span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">double</span> length;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">double</span> width;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//表示矩形</span></span><br><span class="line">	Rectangle(<span class="keyword">double</span> length,<span class="keyword">double</span> width)&#123;</span><br><span class="line">		<span class="keyword">this</span>.length=length;</span><br><span class="line">		<span class="keyword">this</span>.width=width;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.length*<span class="keyword">this</span>.width;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用类层次类完成上述功能是不是其结构明显简介了许多，并且它还极其容易扩展：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正方形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">	Square(<span class="keyword">double</span> length,<span class="keyword">double</span> width)&#123;</span><br><span class="line">		<span class="keyword">super</span>(length,width);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>所以，标签类很少有适用的适合，当你想要编写一个包含显式包含标签域的类，就应该考虑使用类层次来代替该类。</p>
</blockquote>
<h2 id="第21条：用函数对象表示策略">第21条：用函数对象表示策略</h2><blockquote>
<p><code>Java</code>里面无法适用函数指针、代理，lambda表达式，当<code>Java</code>需要实现将一个方法作为参数传入方法的功能时往往使用类引用来完成。</p>
</blockquote>
<p>它往往是：</p>
<p>1.定义一个有某个特定方法的对象<code>A</code>。<br>2.<code>B/C/D…</code>去继承A实现该特定方法。<br>3.在方法参数作为传参的功能中去传递对象<code>A</code>，每次都是执行对象<code>A</code>的特定方法。<br>4.在调用该功能方法使用<code>A a=new B/C/D()</code>这种方法实例化并传入。</p>
<blockquote>
<p>注：该方式最有代表性的就是<code>java.util.Comparator</code>类的使用。</p>
</blockquote>
<h2 id="第22条：优先考虑静态成员类">第22条：优先考虑静态成员类</h2><p>嵌套类是指被定义在另一个类的内部类，它有四种写法：</p>
<ul>
<li>静态成员类<br>  可以使用<code>外围类名.静态成员类</code>的形式来进行访问，它可以直接方法外围里面的静态成员。</li>
<li>非静态成员类<br>  可以使用<code>外围类的实例名.非静态成员类</code>的形式来进行访问，它可以方法外围类实例里面的方法。例如<code>Adapter</code>类。</li>
<li>匿名类<br>  匿名类可以直接使用没不需要被声明，但是他不能为<code>instantceof</code>，无法将他们实例化等。例如<code>Runnabel</code>、<code>Thread</code>时直接传递的实例。</li>
<li><p>局部类<br>  （没见过），它可以在“任何声明局部变量”的地方都可以声明局部类，也遵循同样的作用域规则。</p>
<p>  每种嵌套类都有自己的用途，但是静态成员类相对来说开销较少，功能交全，比较推荐。</p>
</li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>类和接口是Java程序设计语言的核心，它们也是Java语言的基本抽象单元。</p>
<h2 id="第13条：使类和成员的可访问性最小化">第13条：使类和成员的可访问性最小化</h2><blockquote>
<p>尽可能使每个类或者成员不被外界访问。</p>
</blo]]>
    </summary>
    
      <category term="Java" scheme="http://yyl8781697.github.io/tags/Java/"/>
    
      <category term="Effective Java" scheme="http://yyl8781697.github.io/categories/Effective-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Java的Clone，你这些都知道吗？]]></title>
    <link href="http://yyl8781697.github.io/2015/05/03/Java%20Base/You-Donnot-Kown-About-The-Clone/"/>
    <id>http://yyl8781697.github.io/2015/05/03/Java Base/You-Donnot-Kown-About-The-Clone/</id>
    <published>2015-05-03T14:59:55.000Z</published>
    <updated>2015-06-03T16:38:49.000Z</updated>
    <content type="html"><![CDATA[<p><br><br><br><br><br></p>
<h2 id="clone()_元定义">clone() 元定义</h2><p>啥都不说，先看下源码中<code>Object.clone()</code>的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * Creates and returns a copy of this object.  The precise meaning</span><br><span class="line"> * of "copy" may depend on the class of the object. The general</span><br><span class="line"> * intent is that, for any object &#123;@code x&#125;, the expression:</span><br><span class="line"> * &lt;blockquote&gt;</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * x.clone() != x&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line"> * will be true, and that the expression:</span><br><span class="line"> * &lt;blockquote&gt;</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * x.clone().getClass() == x.getClass()&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line"> * will be &#123;@code true&#125;, but these are not absolute requirements.</span><br><span class="line"> * While it is typically the case that:</span><br><span class="line"> * &lt;blockquote&gt;</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * x.clone().equals(x)&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line"> * will be &#123;@code true&#125;, this is not an absolute requirement.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * By convention, the returned object should be obtained by calling</span><br><span class="line"> * &#123;@code super.clone&#125;.  If a class and all of its superclasses (except</span><br><span class="line"> * &#123;@code Object&#125;) obey this convention, it will be the case that</span><br><span class="line"> * &#123;@code x.clone().getClass() == x.getClass()&#125;.</span><br><span class="line"> * 创建和返回对象的拷贝需要满足</span><br><span class="line"> * x.clone()!=x （拷贝返回的东西不能用原来的地址啊~^_^）</span><br><span class="line"> * x.clone().getClass==x.getClass() （这个不是绝对的，可以返回子类）</span><br><span class="line"> * x.clone().equals(x) （拷贝了之后当然两个对象时相等的~，这个也不是绝对的，比如有序    	列化唯一ID的字段）</span><br><span class="line"> * </span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * By convention, the object returned by this method should be independent</span><br><span class="line"> * of this object (which is being cloned).  To achieve this independence,</span><br><span class="line"> * it may be necessary to modify one or more fields of the object returned</span><br><span class="line"> * by &#123;@code super.clone&#125; before returning it.  Typically, this means</span><br><span class="line"> * copying any mutable objects that comprise the internal "deep structure"</span><br><span class="line"> * of the object being cloned and replacing the references to these</span><br><span class="line"> * objects with references to the copies.  If a class contains only</span><br><span class="line"> * primitive fields or references to immutable objects, then it is usually</span><br><span class="line"> * the case that no fields in the object returned by &#123;@code super.clone&#125;</span><br><span class="line"> * need to be modified.</span><br><span class="line"> * 教我们实现clone方法的时候先调用super.clone(),克隆出的对象上添加自己当前类所需要的元素</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The method &#123;@code clone&#125; for class &#123;@code Object&#125; performs a</span><br><span class="line"> * specific cloning operation. First, if the class of this object does</span><br><span class="line"> * not implement the interface &#123;@code Cloneable&#125;, then a</span><br><span class="line"> * &#123;@code CloneNotSupportedException&#125; is thrown. Note that all arrays</span><br><span class="line"> * are considered to implement the interface &#123;@code Cloneable&#125; and that</span><br><span class="line"> * the return type of the &#123;@code clone&#125; method of an array type &#123;@code T[]&#125;</span><br><span class="line"> * is &#123;@code T[]&#125; where T is any reference or primitive type.</span><br><span class="line"> * Otherwise, this method creates a new instance of the class of this</span><br><span class="line"> * object and initializes all its fields with exactly the contents of</span><br><span class="line"> * the corresponding fields of this object, as if by assignment; the</span><br><span class="line"> * contents of the fields are not themselves cloned. Thus, this method</span><br><span class="line"> * performs a "shallow copy" of this object, not a "deep copy" operation.</span><br><span class="line"> * 如果对象没有实现Cloneable接口而又调用了super.clone  就是抛出CloneNotSupportedException异常</span><br><span class="line"> * 默认所有的数组都是继承了Cloneable接口的，它返回的是该数组类型的数组(T[] -_-)，但是 *拷贝的时候直接是使用了那么些类型的对象，并没有使用它们的拷贝，所以数据的拷贝只是一</span><br><span class="line"> * 个“浅拷贝”</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The class &#123;@code Object&#125; does not itself implement the interface</span><br><span class="line"> * &#123;@code Cloneable&#125;, so calling the &#123;@code clone&#125; method on an object</span><br><span class="line"> * whose class is &#123;@code Object&#125; will result in throwing an</span><br><span class="line"> * exception at run time.</span><br><span class="line"> * Object类并没有实现Cloneable接口，所以你如果调用了Oject.clone方法话就会抛出异常，</span><br><span class="line"> * （但是在在这里可以看到Object的clone方法是protected的，该方法是无法直接调用的，除非</span><br><span class="line"> * 你使用反射来进行调用）</span><br><span class="line"> *</span><br><span class="line"> *<span class="javadoctag"> @return</span>     a clone of this instance.</span><br><span class="line"> *<span class="javadoctag"> @exception</span>  CloneNotSupportedException  if the object's class does not</span><br><span class="line"> *               support the &#123;@code Cloneable&#125; interface. Subclasses</span><br><span class="line"> *               that override the &#123;@code clone&#125; method can also</span><br><span class="line"> *               throw this exception to indicate that an instance cannot</span><br><span class="line"> *               be cloned.</span><br><span class="line"> *<span class="javadoctag"> @see</span> java.lang.Cloneable</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>Cloneable</code>接口并不含任何方法，但是实现它的时候<code>Object</code>的<code>clone</code>方法就会返回该对象的逐域拷贝，否则就会抛出<code>CloneNotSupportedException</code>异常</p>
<p>注意，在java1.5以后的版本中<code>clone()</code>引入了协变返回类型，额可以直接直接支持指定类的返回，不必必须返回<code>Object</code></p>
</blockquote>
<h2 id="clone不伤害源对象">clone不伤害源对象</h2><p><code>clone()</code>的原则就是必须确保不会伤害到原始的对象，并确保正确地创建被克隆中的约束条件。<br>实现克隆最基本的方法是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] elements=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 进行数组的打印</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"\r\nprint"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.elements.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.print(elements[i]+<span class="string">"#"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CloneTest <span class="title">clone</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		CloneTest ret=<span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			ret=(CloneTest)<span class="keyword">super</span>.clone();<span class="comment">//调用超类的clone</span></span><br><span class="line">		&#125;<span class="keyword">catch</span>(CloneNotSupportedException cs)</span><br><span class="line">		&#123;</span><br><span class="line">			cs.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是他会破坏原有对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CloneTest t1=<span class="keyword">new</span> CloneTest();</span><br><span class="line">t1.elements[<span class="number">0</span>]=<span class="number">4</span>;</span><br><span class="line">t1.elements[<span class="number">1</span>]=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">CloneTest t2=t1.clone();</span><br><span class="line">t2.elements[<span class="number">1</span>]=<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">t1.print();</span><br><span class="line">t2.print();</span><br></pre></td></tr></table></figure>
<p>返回的是：</p>
<pre><code><span class="id">print</span>
<span class="number">4#6#</span><span class="number">0#0#</span><span class="number">0#0#</span><span class="number">0#0#</span><span class="number">0#0#</span>
<span class="id">print</span>
<span class="number">4#6#</span><span class="number">0#0#</span><span class="number">0#0#</span><span class="number">0#0#</span><span class="number">0#0#</span>
</code></pre><p>这是因为该方法仅仅只是调用了超类的克隆方法，完了之后克隆出来的对象的<code>elements</code>元素还是与原对象一样。</p>
<p>所以一般在编写<code>clone()</code>之后，再在克隆出的对象上添加自己当前类所需要的元素，上述可以这么修改:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CloneTest <span class="title">clone</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	CloneTest ret=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		ret=(CloneTest)<span class="keyword">super</span>.clone();</span><br><span class="line">		ret.elements=<span class="keyword">this</span>.elements.clone();<span class="comment">//复制出来一个新的副本</span></span><br><span class="line">	&#125;<span class="keyword">catch</span>(CloneNotSupportedException cs)</span><br><span class="line">	&#123;</span><br><span class="line">		cs.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在先前的测试代码之后得到的是</p>
<pre><code><span class="id">print</span>
<span class="number">4#5#</span><span class="number">0#0#</span><span class="number">0#0#</span><span class="number">0#0#</span><span class="number">0#0#</span>
<span class="id">print</span>
<span class="number">4#6#</span><span class="number">0#0#</span><span class="number">0#0#</span><span class="number">0#0#</span><span class="number">0#0#</span>
</code></pre><p>简而言之，所有实现了<code>Cloneable</code>的类都应该调用一个共有的方法覆盖<code>clone</code>，此公有的方法首先调用<code>super.clone()</code>，然后修正任何需要修正的域（其实就是对当前自己类上的元素单独<code>clone()</code>）。</p>
<h2 id="数组的clone">数组的clone</h2><p>引用的一个类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String name=<span class="string">""</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对数组进行<code>clone()</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A[] a=<span class="keyword">new</span> A[<span class="number">2</span>];</span><br><span class="line">a[<span class="number">0</span>]=<span class="keyword">new</span> A(<span class="string">"tom"</span>);</span><br><span class="line">a[<span class="number">0</span>]=<span class="keyword">new</span> A(<span class="string">"peter"</span>);</span><br><span class="line"></span><br><span class="line">A[] b=a.clone();</span><br><span class="line">b[<span class="number">0</span>].name=<span class="string">"lili"</span>;、<span class="comment">//修改克隆对象的值</span></span><br><span class="line"></span><br><span class="line">System.out.println(a[<span class="number">0</span>].name);</span><br></pre></td></tr></table></figure></p>
<p>最终的输出为</p>
<pre><code>lili
</code></pre><p>可以发现原有数组A的数据被他克隆出来的数组给修掉了，所以数组在执行<code>clone()</code>时并没有将数据类型的对象进行克隆，只是使用了它，这里也就是一个浅复制。（对于这种情况我们特别要注意~）</p>
<h2 id="使用循环代替递归拷贝">使用循环代替递归拷贝</h2><p>在<code>HashTable</code>中是使用一个列表数组来存储具体数据，在对<code>HashTable</code>进行拷贝时他的源码是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * Creates a shallow copy of this hashtable. All the structure of the</span><br><span class="line"> * hashtable itself is copied, but the keys and values are not cloned.</span><br><span class="line"> * This is a relatively expensive operation.</span><br><span class="line"> *</span><br><span class="line"> *<span class="javadoctag"> @return</span>  a clone of the hashtable</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Hashtable&lt;K,V&gt; t = (Hashtable&lt;K,V&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        t.table = <span class="keyword">new</span> Entry[table.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = table.length ; i-- &gt; <span class="number">0</span> ; ) &#123;</span><br><span class="line">            t.table[i] = (table[i] != <span class="keyword">null</span>)</span><br><span class="line">                ? (Entry&lt;K,V&gt;) table[i].clone() : <span class="keyword">null</span>;<span class="comment">//这里调用Entry的clone方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        t.keySet = <span class="keyword">null</span>;</span><br><span class="line">        t.entrySet = <span class="keyword">null</span>;</span><br><span class="line">        t.values = <span class="keyword">null</span>;</span><br><span class="line">        t.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来看下<code>Entry.clone()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value,</span><br><span class="line">                          (next==<span class="keyword">null</span> ? <span class="keyword">null</span> : (Entry&lt;K,V&gt;) next.clone()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从它的方法中我们可以看出来他是使用递归来进行调用的，不断进行递归执行自己的<code>clone</code>时自己的链表增长来满足<code>clone</code>，这可以说是一种比较简洁的方法，但是问题是出在递归，我们都知道执行递归方法时如果递归太深可能会触发虚拟机中最大stack数量的阈值导致抛<code>StackOverflow</code>的异常，并且执行一个方法本身也是一个比较耗资源的的操作，所以如果遇到这种情况可以考虑使用循环来完成这种需求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用循环来代替递归</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Entry result=<span class="keyword">new</span> Entry(key,value,next);</span><br><span class="line">	<span class="keyword">for</span>(Entry p=result;p.next!=<span class="keyword">null</span>;p=p.next)</span><br><span class="line">	&#123;</span><br><span class="line">		p.next=<span class="keyword">new</span> Entry(p.next.key,p.next.value,p.next.next);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对此我们可以看下jdk1.2之后出来的<code>HashMap</code>里面的<code>clone</code>方法，他在<code>super.clone()</code>完了之后调用<code>inflateTable()</code>方法重新初始化了一个数组，然后再调用<code>putAllForCreate()</code>方法用循环的方式将现有数据进行添加进去完成<code>clone()</code></p>
<h2 id="可以考虑使用拷贝构造器来代码clone方法">可以考虑使用拷贝构造器来代码clone方法</h2><p>该功能的类的拷贝构造器相比<code>clone()</code>方法来说有以下几个好处：</p>
<ul>
<li>在该构造器可以有参数</li>
<li>支持final类型定义的变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span></span>&#123;</span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">int</span>[] elements=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	    <span class="javadoc">/**</span><br><span class="line">	     * 进行数组的打印</span><br><span class="line">	     */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span><br><span class="line">	    </span>&#123;</span><br><span class="line">	        System.out.println(<span class="string">"\r\nprint"</span>);</span><br><span class="line">	        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.elements.length;i++)</span><br><span class="line">	        &#123;</span><br><span class="line">	            System.out.print(elements[i]+<span class="string">"#"</span>);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">CloneTest</span><span class="params">()</span></span><br><span class="line">	    </span>&#123;&#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">CloneTest</span><span class="params">(CloneTest test)</span></span>&#123;</span><br><span class="line">	    	CloneTest ret=test;</span><br><span class="line">	    	ret.elements=test.elements.clone();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话就可以使用构造函数来进行对象的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CloneTest t1=<span class="keyword">new</span> CloneTest();</span><br><span class="line">t1.elements[<span class="number">0</span>]=<span class="number">4</span>;</span><br><span class="line">t1.elements[<span class="number">1</span>]=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">CloneTest t2=<span class="keyword">new</span> CloneTest(t1);</span><br><span class="line">t2.elements[<span class="number">1</span>]=<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">t1.print();</span><br><span class="line">t2.print();</span><br></pre></td></tr></table></figure></p>
<h2 id="总结">总结</h2><p>最后，关于<code>clone()</code>方法有以下几个注意点：</p>
<ul>
<li>将出现递归<code>clone()</code>的时候尽量使用循环迭代来代替。</li>
<li>如果是线程安全的类要实现<code>clone()</code>，那些这个<code>clone()</code>也必须进行同步。</li>
<li>关于自身域的修正如果是遇到<code>final</code>类型的，那么这两者是不兼容的。</li>
<li>另一个实现对象拷贝的方式就是提供一个拷贝构造器，该构造器比<code>clone()</code>方法的一个优势就是它可以传参数。</li>
<li>当前类没有继承<code>Cloneable</code>接口时，如果到<code>clone()</code>方法里面调用了<code>super.clone()</code>方法就是抛出<code>CloneNotSupportedException</code>异常。</li>
</ul>
<h2 id="参考">参考</h2><p>《Effective Java中文版》第11条</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><br><br><br><br><br></p>
<h2 id="clone()_元定义">clone() 元定义</h2><p>啥都不说，先看下源码中<code>Object.clone()</code>的定义：<br><figure class="highlight j]]>
    </summary>
    
      <category term="Java" scheme="http://yyl8781697.github.io/tags/Java/"/>
    
      <category term="Java Base" scheme="http://yyl8781697.github.io/categories/Java-Base/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Effective Java》第三章：对于所有对象都通用的方法]]></title>
    <link href="http://yyl8781697.github.io/2015/05/03/Effective%20Java/The-Methods-General-To-All-Object/"/>
    <id>http://yyl8781697.github.io/2015/05/03/Effective Java/The-Methods-General-To-All-Object/</id>
    <published>2015-05-03T14:59:34.000Z</published>
    <updated>2015-05-04T14:47:39.000Z</updated>
    <content type="html"><![CDATA[<h1 id="对于所有对象都通用的方法">对于所有对象都通用的方法</h1><p>类在继承时，它的所有非<code>final</code>方法都用明确得通用约定，他们都是被设计为要被覆盖的，对于任何一个类，在覆盖这些方法的时候，都需要遵循这些通用的约定，如果做不到这一点，其他依赖于这些约定的类将无法结合该类一起工作。</p>
<h2 id="第8条：覆盖equals时请遵守通用约定">第8条：覆盖equals时请遵守通用约定</h2><blockquote>
<p>我们都知道<code>equals</code>方法称被用于判断两个对象是否相等（除地址外），那你知道该方法应该被如何设计呢？</p>
</blockquote>
<p><code>equals</code>方法需要遵循的约定：</p>
<ul>
<li><strong>自反性</strong>：对于任何非<code>null</code>的引用值<code>x</code>，<code>x.equals(x)</code>必须要<code>true</code>，也就是自己一定要和自己相等啊。</li>
<li><strong>对称性</strong>：对于任何非<code>null</code>的引用值<code>x</code>和<code>y</code>，当前仅当<code>y.equals(x)=true</code>时，<code>x.equals(y)=true</code>一定成立。</li>
<li><strong>传递性</strong>：对于任何非<code>null</code>的引用值<code>x</code>、<code>y</code>和<code>z</code>，如果<code>x.equals(y)=true</code>、<code>y.equals(z)=true</code>，则<code>x.equals(z)=true</code>一定成立，关于这点，写代码时难点主要是在有子类、超类同时存在的情况下比较难搞。。</li>
<li><strong>一致性</strong>：对于任何非<code>null</code>的引用值<code>x</code>和<code>y</code>，只要<code>equals</code>的比较操作在对象中所用的信息没有被修改，多次调用<code>x.equals(y)</code>返回的值一定相等。</li>
<li>对于任何非<code>null</code>的引用值<code>x</code>，<code>x.equals(null)</code>一定为<code>false</code>，关于这一条，不必要在<code>equals</code>方法是使用<code>null</code>的判断。</li>
</ul>
<p>对于这些约束，编写<code>equals</code>有下面几个诀窍：</p>
<ol>
<li><strong>使用<code>==</code>操作符检查“参数是否为这个对象的引用”</strong>（就是判断对象是否地址相等）</li>
<li><strong>使用<code>instanceof</code>操作符检查“参数是否为正确的类型”</strong>（判断对比的参数是否为本类或者超类，同时可以判断null值）</li>
<li><strong>把参数转为正确的类型</strong>（强转了之后才能进行下一步的具体值的判断^_^）</li>
<li><strong>对于该类中的每个关键域，检查参数中的域是否与该对象中对应域相匹配</strong>（说实话，这个没怎么看懂-_-）</li>
<li><strong>当编写完<code>equals</code>方法之后、应该问自己三个问题：他们是否是对称的、传递的、一致性的</strong>（这不是常见的几个约束嘛？最好是需要满足，同时最好还得有单元测试去确保）</li>
</ol>
<p>一般<code>equals</code>一般通用的写法是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span><span class="comment">//注意这里传的是Object类型，不是具体的类型，不然就是重载了，而不是重写</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//这一步很重要，一个是可以判断当前o是否为本类型或者他的超类，另外这里如果o为null的话会直接返回false</span></span><br><span class="line">	<span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> MyType))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	MyType mt=(MyType)<span class="number">0</span>;<span class="comment">//将obj转为本类型之后再操作</span></span><br><span class="line"> 	</span><br><span class="line">	<span class="comment">//Todo 根据自己业务写的实际的判断情况、如果涉及子类超类的可以使用递归调用，完了之后进行布尔值的返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>建议：如果你无法确保你自己写的<code>equals</code>满足上述约束，那就不要去重写这个<code>equals</code>方法的，因为超类的该方法一般也是适用于子类的（懒人模式）。</p>
</blockquote>
<h2 id="第9条：覆盖equals时总要覆盖hashCode">第9条：覆盖equals时总要覆盖hashCode</h2><blockquote>
<p>地球人都知道调用<code>hashCode</code>方法可以得到该对象的散列值（Hash值）</p>
</blockquote>
<p>先来看一下<code>hashCode</code>方法的相关通用约束：</p>
<ol>
<li>在程序执行时，只要<code>equals</code>方法所用到的对象没有被修改，得到的<code>hashCode</code>的值一定还是原来的值。</li>
<li>相等的对象必须具有相等散列码。</li>
</ol>
<ul>
<li>不相等的对象他们的散列码一定不相等。</li>
</ul>
<p>所以，为了不违反第2条约束，在覆盖了<code>equals</code>方法之后一定要覆盖<code>hashCode</code>。</p>
<p>一个好的散列函数通常倾向于“为不相等的对象产生不相等的散列码”，散列函数应该把集合中不相等的实例均匀的分不到所有的可能额散列值上，如果想完全达到这样的效果是非常困难的，但是可以使用相对接近的理想情形并不困难（具体散列步骤请移步原文去参考-_-）</p>
<h2 id="第10条：始终要覆盖toString">第10条：始终要覆盖toString</h2><p>我们在打印一个类时，是不是会经常看到一个类的名称，以及一个@符号，接着是散列码的无符号十六进制数，列如：“PhoneNumber<br>@163b91”，这样的打印信息对于开发者来说几乎是无意义的，所以“建议所有的子类都要覆盖这个<code>toString</code>”方法。</p>
<p><code>toString</code>在编写时没有那么多的通用约束，但是尽量能表达该类的信息，当然也可以编写含有你特征格式的<code>toString</code>返回值，比如<code>XML</code>格式，这种方式需要在注释里面特别说明。</p>
<blockquote>
<p>PS：建议是好的，但是每写一个类都去覆盖他的<code>toString</code>方法会不会太累？个人觉得如果没有用到<code>println</code>,<code>printf</code>之类的方法不去覆盖也是ok的^_^</p>
</blockquote>
<h2 id="第11条：谨慎地覆盖clone">第11条：谨慎地覆盖clone</h2><blockquote>
<p><code>Cloneable</code>接口并不含任何方法，但是实现它的时候<code>Object</code>的<code>clone</code>方法就会返回该对象的逐域拷贝，否则就会抛出<code>CloneNotSupportedException</code>异常</p>
</blockquote>
<p>创建和返回对象的拷贝需要满足(这几点其实在<code>Object.clone()</code>的源码中)：</p>
<ol>
<li><code>x.clone()!=x</code>  （拷贝返回的东西不能用原来的地址啊~^_^）</li>
<li><code>x.clone().getClass==x.getClass()</code> </li>
<li><code>x.clone().equals(x)</code>  （拷贝了之后当然两个对象时相等的~）</li>
</ol>
<blockquote>
<p>注意，在java1.5以后的版本中<code>clone()</code>引入了协变返回类型，额可以直接直接支持指定类的返回，不必必须返回<code>Object</code></p>
</blockquote>
<p><code>clone()</code>的原则就是必须确保不会伤害到原始的对象，并确保正确地创建被克隆中的约束条件。<br>实现克隆最基本的方法是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] elements=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 进行数组的打印</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"\r\nprint"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.elements.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.print(elements[i]+<span class="string">"#"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CloneTest <span class="title">clone</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		CloneTest ret=<span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			ret=(CloneTest)<span class="keyword">super</span>.clone();<span class="comment">//调用超类的clone</span></span><br><span class="line">		&#125;<span class="keyword">catch</span>(CloneNotSupportedException cs)</span><br><span class="line">		&#123;</span><br><span class="line">			cs.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是他会破坏原有对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CloneTest t1=<span class="keyword">new</span> CloneTest();</span><br><span class="line">t1.elements[<span class="number">0</span>]=<span class="number">4</span>;</span><br><span class="line">t1.elements[<span class="number">1</span>]=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">CloneTest t2=t1.clone();</span><br><span class="line">t2.elements[<span class="number">1</span>]=<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">t1.print();</span><br><span class="line">t2.print();</span><br></pre></td></tr></table></figure>
<p>返回的是：</p>
<pre><code><span class="id">print</span>
<span class="number">4#6#</span><span class="number">0#0#</span><span class="number">0#0#</span><span class="number">0#0#</span><span class="number">0#0#</span>
<span class="id">print</span>
<span class="number">4#6#</span><span class="number">0#0#</span><span class="number">0#0#</span><span class="number">0#0#</span><span class="number">0#0#</span>
</code></pre><p>这是因为该方法仅仅只是调用了超类的克隆方法，完了之后克隆出来的对象的<code>elements</code>元素还是与原对象一样。</p>
<p>所以一般在编写<code>clone()</code>之后，再在克隆出的对象上添加自己当前类所需要的元素，上述可以这么修改:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CloneTest <span class="title">clone</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	CloneTest ret=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		ret=(CloneTest)<span class="keyword">super</span>.clone();</span><br><span class="line">		ret.elements=<span class="keyword">this</span>.elements.clone();<span class="comment">//复制出来一个新的副本</span></span><br><span class="line">	&#125;<span class="keyword">catch</span>(CloneNotSupportedException cs)</span><br><span class="line">	&#123;</span><br><span class="line">		cs.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在先前的测试代码之后得到的是</p>
<pre><code><span class="id">print</span>
<span class="number">4#5#</span><span class="number">0#0#</span><span class="number">0#0#</span><span class="number">0#0#</span><span class="number">0#0#</span>
<span class="id">print</span>
<span class="number">4#6#</span><span class="number">0#0#</span><span class="number">0#0#</span><span class="number">0#0#</span><span class="number">0#0#</span>
</code></pre><p>简而言之，所有实现了<code>Cloneable</code>的类都应该调用一个共有的方法覆盖<code>clone</code>，此公有的方法首先调用<code>super.clone()</code>，然后修正任何需要修正的域（其实就是对当前自己类上的元素单独<code>clone()</code>）。</p>
<p>最后，关于<code>clone()</code>方法有以下几个注意点：</p>
<ul>
<li>将出现递归<code>clone()</code>的时候尽量使用循环迭代来代替。</li>
<li>如果是线程安全的类要实现<code>clone()</code>，那些这个<code>clone()</code>也必须进行同步。</li>
<li>关于自身域的修正如果是遇到<code>final</code>类型的，那么这两者是不兼容的。</li>
<li>另一个实现对象拷贝的方式就是提供一个拷贝构造器，该构造器比<code>clone()</code>方法的一个优势就是它可以传参数。</li>
<li>当前类没有继承<code>Cloneable</code>接口时，如果掉<code>clone()</code>方法里面调用了<code>super.clone()</code>方法就会抛出<code>CloneNotSupportedException</code>异常。</li>
</ul>
<h2 id="第12条：考虑实现Comparable接口">第12条：考虑实现Comparable接口</h2><blockquote>
<p><code>compareTo</code>方法是<code>Compareable</code>接口中唯一的方法，它不但可以进行简单的等同性比较外，而且允许执行顺序比较。</p>
</blockquote>
<p>其实<code>Comparable</code>与<code>equals</code>的约定是极其像的：</p>
<ul>
<li>自反性</li>
<li>对称性</li>
<li>传递性</li>
</ul>
<p>与<code>equals</code>不同的是，在跨域不同类的时候，<code>compareTo</code>可以不做比较，如果两个待比较的对象时不同引用的对象，<code>compareTo</code>可以抛出<code>ClassCastExcetpion</code>异常。</p>
<blockquote>
<p><code>compareTo</code>方法在执行时，如果小于被比值，返回-1（也可以其他负数），或者等于比较值，此时返回0，否则都是大于0的情况就返回false。</p>
</blockquote>
<p>关于在有多个关键域都需要进行对比时，可以使用减法差值来减少编码的代码量。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="对于所有对象都通用的方法">对于所有对象都通用的方法</h1><p>类在继承时，它的所有非<code>final</code>方法都用明确得通用约定，他们都是被设计为要被覆盖的，对于任何一个类，在覆盖这些方法的时候，都需要遵循这些通用的约定，如果做不到这一点，其他]]>
    </summary>
    
      <category term="Java" scheme="http://yyl8781697.github.io/tags/Java/"/>
    
      <category term="Effective Java" scheme="http://yyl8781697.github.io/categories/Effective-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我眼中的Scala-简洁不简单]]></title>
    <link href="http://yyl8781697.github.io/2015/04/26/Scala/Scala-In-My-Eyes/"/>
    <id>http://yyl8781697.github.io/2015/04/26/Scala/Scala-In-My-Eyes/</id>
    <published>2015-04-26T12:53:19.000Z</published>
    <updated>2015-04-26T02:33:02.000Z</updated>
    <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;由于实验需要在半年前开始接触<code>Scala</code>，之前也学习/使用过<a href="http://www.tiobe.com/content/paperinfo/tpci/tpci_definition.htm" target="_blank" rel="external">TIOBE</a>榜上Top20中一半左右的编程语言，感觉还是<code>Scala</code>给我印象最深，最近没怎么做相关的开发感觉都开始慢慢淡忘了，上周在技术分享时我对<code>Scala</code>作了一些总结，顺便在这里写下。</p>
<blockquote>
<p><code>Scala</code>注意，本文主要是描述我所了解的<code>Scala</code>相关的基础语法，和<code>Java</code>相同得在这里就不再累赘。</p>
</blockquote>
<h2 id="我眼中的Scala">我眼中的Scala</h2><pre><code><span class="keyword">Scala</span>是一种基于JVM的编程语言，集成了面向对象和函数式编程的特性，既能处理脚本化得临时任务，又能处理高并发场景下分布式大数据应用。
</code></pre><p>&#160; &#160; &#160; &#160;<code>Java</code>就是因为有<code>JVM</code>虚拟机才成就了现在的辉煌，<code>Scala</code>同样是运行在<code>JVM</code>，大致可以看做Java的升级版，由于现在大数据大势所趋，各种大数据框架的出现导致了<code>Scala</code>强势崛起！<br>&#160; &#160; &#160; &#160;编程初学者最先接触的应该就是”Hello,World”，而WordCount可以看做大数据编程的入门必学技能，所以现在我们在”Hello,World”上实现CharCount：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Scala Application</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">str=</span>"<span class="title">Hello</span>,<span class="title">wrold</span>"</span><br><span class="line"></span><span class="function"><span class="keyword">val</span> <span class="title">data=str</span></span><br><span class="line"></span>	.split(<span class="type">Array</span>(',',' '))</span><br><span class="line">	.flatMap(<span class="keyword">for</span>(c&lt;-_) <span class="keyword">yield</span> (c,<span class="number">1</span>))  <span class="comment">//好Api</span></span><br><span class="line">	.groupBy(_._1)</span><br><span class="line">	.mapValues(_.size)</span><br><span class="line">		</span><br><span class="line">println(data)</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;假如你是用<code>Java</code>程序来写，最方便的莫过于<code>HashMap</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java Application</span></span><br><span class="line">String str=<span class="string">"Hello,World"</span>;</span><br><span class="line">HashMap&lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(Character ch:str.toCharArray())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="string">","</span>.equals(ch))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!map.containsKey(ch))</span><br><span class="line">		&#123;</span><br><span class="line">			map.put(ch, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		map.put(ch, map.get(ch)+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure></p>
<p>其结果为</p>
<pre><code><span class="built_in">Map</span>(e <span class="subst">-&gt; </span><span class="number">1</span>, l <span class="subst">-&gt; </span><span class="number">3</span>, H <span class="subst">-&gt; </span><span class="number">1</span>, r <span class="subst">-&gt; </span><span class="number">1</span>, w <span class="subst">-&gt; </span><span class="number">1</span>, o <span class="subst">-&gt; </span><span class="number">2</span>, d <span class="subst">-&gt; </span><span class="number">1</span>)
</code></pre><p>从上面的程序中看出<code>Scala</code>的几大特点：</p>
<ul>
<li>链式操作</li>
<li>变量不变性</li>
<li>丰富的Api</li>
<li><strong>简洁不简单</strong>(<em>不需要加分号，返回值时不需要return关键字，还有强大的语法糖</em>)</li>
</ul>
<p>现在已经有非常多优秀的项目都是使用<code>Scala</code>来编写的：</p>
<ul>
<li><a href="http://spark.apache.org/" target="_blank" rel="external">Spark</a>：不用多说，感觉最近<code>Scala</code>的崛起就是因为该项目的横空出世</li>
<li><a href="http://akka.io/" target="_blank" rel="external">Akka</a>：分布式、高并发、高可伸缩性的消息驱动模型</li>
<li><a href="http://akka.io/" target="_blank" rel="external">Kafka</a>：一个高吞吐量的分布式消息系统</li>
<li><a href="https://www.playframework.com/" target="_blank" rel="external">play</a>：一个高性能的Web框架，据说最近版本用Scala重写了</li>
<li>据说Twitter公司好多中间件都是使用Scala来编写的</li>
</ul>
<h2 id="编程IDE">编程IDE</h2><p>&#160; &#160; &#160; &#160;目前编写<code>Scala</code>程序有两种比较流行的IDE：<a href="http://scala-ide.org/" target="_blank" rel="external">Eclipse for Scala</a>、<a href="http://www.jetbrains.com/idea/download/" target="_blank" rel="external">idea community edition</a>，注意，eclipse版感觉功能没idea强，但是速度要比idea快（可能是自己电脑配置差的原因），还有下载idea时要下载社区版，他是免费的。<br>&#160; &#160; &#160; &#160;当然如果是初学者的话还是建议使用万能sublime text来写，自己添加一个插件就好。Tools-&gt;Build System-&gt;New Build System…，然后输入：</p>
<pre><code>{
    "<span class="attribute">cmd</span>": <span class="value">[<span class="string">"scala"</span>,<span class="string">"$file"</span>]</span>,
    "<span class="attribute">selector</span>": <span class="value">[<span class="string">"source.scala"</span>]</span>,
    "<span class="attribute">shell</span>": <span class="value"><span class="string">"true"</span>
</span>}
</code></pre><p>这样<code>Scala</code>后缀的程序在Sublime中直接使用<code>Ctrl+B</code>即可运行</p>
<h2 id="变量定义">变量定义</h2><blockquote>
<p>标准格式：{val|var} 变量名[:类型]=[new]Class</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val a=<span class="number">5</span>   <span class="comment">//推断为Int类型</span></span><br><span class="line">val b:Int=<span class="number">5</span>  <span class="comment">//显示的指定为Int类型</span></span><br><span class="line">val c=<span class="number">5f</span>  <span class="comment">//表示Float类型</span></span><br><span class="line">val str:Option[String]  <span class="comment">//表示可空类型</span></span><br></pre></td></tr></table></figure>
<h2 id="函数定义">函数定义</h2><blockquote>
<p>标准格式：def 方法名(参数列表)[:返回类型]={//方法体}</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////推断返回String</span></span><br><span class="line"><span class="function">def <span class="title">hello</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="string">"Hello"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定返回类型</span></span><br><span class="line"><span class="function">def <span class="title">hello</span><span class="params">()</span>:String</span>=</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"Hello"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简写</span></span><br><span class="line"><span class="function">def <span class="title">hello</span><span class="params">()</span>:String</span>=<span class="string">"Hello"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//传参数，多个用逗号隔开</span></span><br><span class="line"><span class="function">def <span class="title">hello</span><span class="params">(word:String)</span>:String</span>=<span class="string">"Hello"</span>+word</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意函数返回时不需要写return</span></span><br></pre></td></tr></table></figure>
<h2 id="变量不变性">变量不变性</h2><p><code>Scala</code>编程最为推崇的就是变量不变性：变量一旦定义了之后不再改变</p>
<ul>
<li>符合大数据的思想，比如分布式文件系统上只能进行增和删除操作，并没有修改操作</li>
<li>在多线程环境下这个变量是安全的</li>
</ul>
<p>在<code>Scala</code>中有两种类型的不变性</p>
<ul>
<li><code>val</code> vs <code>var</code></li>
</ul>
<p>如果用<code>val</code>定义之后这个变量则不能再被其他变量进行赋值，但是可以对其内容进行修改，<code>val</code>定义的变量就没有这个限制。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable.Map  <span class="comment">//显示得先导入可变的Map包</span></span><br><span class="line"></span><br><span class="line">val a=<span class="number">5</span></span><br><span class="line">a=<span class="number">6</span> <span class="comment">//则会报错：reassignment to val</span></span><br><span class="line"><span class="comment">//如果a用var定义则无影响</span></span><br><span class="line"></span><br><span class="line">val map=Map(<span class="number">1</span>-&gt;<span class="number">2</span>)</span><br><span class="line">map.put(<span class="number">2</span>,<span class="number">3</span>) <span class="comment">//这里是修改了变量的内容</span></span><br><span class="line">map.foreach(println(<span class="number">_</span>)) <span class="comment">//会输出(2,3),(1,2)</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>immutable</code> vs <code>mutable</code></li>
</ul>
<p>如果定义的变量属于<code>immutable</code>包，则定义之后该变量的内容再不能再被修改（不显式导入默认为该包下的类型），<code>mutable</code>包下面的类则无此限制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val immap=Map(<span class="number">1</span>-&gt;<span class="number">2</span>)<span class="comment">//默认为immutable包下面的类</span></span><br><span class="line">immap.put(<span class="number">2</span>,<span class="number">3</span>) <span class="comment">//这里是修改了变量的内容 ，但是会报错 value put is not a member of scala.collection.immutable.Map</span></span><br><span class="line"></span><br><span class="line">val map=scala.collection.mutable.Map(<span class="number">1</span>-&gt;<span class="number">2</span>) <span class="comment">//显式指定包</span></span><br><span class="line">map.put(<span class="number">2</span>,<span class="number">3</span>) <span class="comment">//可以正常执行</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>val x=scala.collection.mutable.Type()</code>可以理解为指针常量，指向的地址不可以重新赋值，但内容可以改变<br><code>var x=scala.collection.immutable.Type()</code>可以理解为常量指针，指向的地址可以变，但内容不可以重新赋值</p>
</blockquote>
<h2 id="控制结构和函数">控制结构和函数</h2><h3 id="加强版的if">加强版的if</h3><p><code>if</code>除了正常的逻辑判断外，还可以直接返回相应的值，并且还支持返回不同类型的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val a=<span class="keyword">if</span>(<span class="keyword">false</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="string">"2"</span></span><br><span class="line">a match&#123;</span><br><span class="line">	<span class="keyword">case</span> x:Int=&gt;println(<span class="string">"Int"</span>)  <span class="comment">//true时a=1</span></span><br><span class="line">	<span class="keyword">case</span> x:String=&gt;println(<span class="string">"String"</span>) <span class="comment">//false时a="2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该功能在实际编程中灰常有用，之前写Java的时候都不得不在if外先定义变量，再在里面赋值-_-</p>
</blockquote>
<h3 id="带有守卫条件的for">带有守卫条件的for</h3><p>守卫是什么东东？你可以理解为<code>for</code>里面的条件控制<br>先来看下<code>Scala</code>的<code>for</code>循环（与传统的三层for结构大不相同，不过与传统的foreach有点类似）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i&lt;-<span class="number">0</span> until <span class="number">5</span>) println(i) <span class="comment">//可以输出0,1,2,3,4</span></span><br></pre></td></tr></table></figure>
<p>那如果我需要双重循环呢?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i&lt;-<span class="number">0</span> to <span class="number">5</span>;j&lt;-i+<span class="number">1</span> to <span class="number">5</span>) println(i*j) <span class="comment">//大致就是5*5下三角的矩阵相乘值</span></span><br></pre></td></tr></table></figure></p>
<p>再来看一下守卫<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i&lt;-<span class="number">0</span> to <span class="number">5</span>;<span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>) println(i) <span class="comment">//输出0,2,4</span></span><br></pre></td></tr></table></figure></p>
<p>这个守卫表示只有<code>i%2==0</code>的情况下才会进入循环体，这样是不是很方便。</p>
<h3 id="没有continue、break的while">没有continue、break的while</h3><p>这个我就不吐槽了，<code>Scala</code>作者竟然认为<code>continue</code>、<code>break</code>这两个这么顺手控制循环的功能是没用的，完全可以在守卫中加入条件判断来控制，这叫我们这帮C系狗情何以堪-_-</p>
<h2 id="数组">数组</h2><p>数组作为绝大多数编程语言中的一个经典类型，在<code>Scala</code>是不支持<code>[]</code>这种定义的，而是用<code>Array</code>来定义。</p>
<blockquote>
<p>标准格式：[val|var] 变量名[:Array[数组类型]]=Array(…)|new Array(..)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val array:Array[Int]=<span class="keyword">new</span> Array[Int](<span class="number">5</span>)</span><br><span class="line">println(<span class="string">"array.length="</span>+array.length)  <span class="comment">//输出长度为5</span></span><br><span class="line"></span><br><span class="line">val array2=Array(<span class="string">"Mary"</span>,<span class="string">"had"</span>,<span class="string">"a"</span>,<span class="string">"little"</span>,<span class="string">"cat"</span>) <span class="comment">//直接按内容进行初始化</span></span><br><span class="line">println(array2.mkString(<span class="string">"#"</span>))<span class="comment">//</span></span><br><span class="line">println(<span class="string">"the index is 2="</span>+array2(<span class="number">3</span>))<span class="comment">//取索引为3的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">val array3:Array[(String,Int)]=Array((<span class="string">"xiaoming"</span>,<span class="number">23</span>),(<span class="string">"xiaohong"</span>,<span class="number">22</span>))<span class="comment">//使用元祖作为数组内容</span></span><br><span class="line">array3.foreach(println(<span class="number">_</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">val matrix =Array.ofDim[Double](<span class="number">3</span>,<span class="number">4</span>)<span class="comment">//定义二维数组</span></span><br></pre></td></tr></table></figure>
<h2 id="类和伴生对象、特质">类和伴生对象、特质</h2><h3 id="类">类</h3><blockquote>
<p>定义：class 类名(构造参数列表) extends,with 继承的类或者接口</p>
</blockquote>
<p>与其他的面向对眼语言不同，<code>Scala</code>中的类支持直接在类名后跟随构造函数列表</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Person(name:String)&#123;</span><br><span class="line"></span><br><span class="line">	private var age:Int=0;</span><br><span class="line"></span><br><span class="line">	def this(name:String,age:Int)</span><br><span class="line">	&#123;</span><br><span class="line">		this(name);//一定要调用上一层的构造函数</span><br><span class="line">		this.age=age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	def getName=this.name//函数如果无参 可以去掉括号</span><br><span class="line"></span><br><span class="line">	def getAge=this.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val p1=new Person("tom")</span><br><span class="line">println(p1.getName)</span><br><span class="line">val p2=new Person("tom",25)</span><br><span class="line">println(p2.getAge)</span><br></pre></td></tr></table></figure>
<h3 id="伴生对象">伴生对象</h3><p>类没有静态方法或者静态字段，需要用<code>Object</code>这个语法结构来达到同样的目的，一个<code>Object</code>一般与对应的类要在同一个文件中（通过<code>Object</code>就可以实现传说中的不用<code>new</code>关键词来实例化对象）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Student(name:String)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	def getName()=name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object Student&#123;</span><br><span class="line"></span><br><span class="line">	//这个伴生对象可以和他的class共享变量</span><br><span class="line">	def apply(name:String):Student=</span><br><span class="line">	&#123;</span><br><span class="line">		new Student(name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val stu1=new Student("tom");</span><br><span class="line">println(stu1.getName)</span><br><span class="line">val stu2=Student("peter");//这里其实是调用了Object的apply方法  </span><br><span class="line">println(stu2.getName)</span><br></pre></td></tr></table></figure>
<p>啥都不是说了，没有<code>static</code>是有点奇怪，但是这个<code>Object</code>也不错啊，用习惯就好了(^_^)</p>
<h3 id="接口的加强版-特质">接口的加强版-特质</h3><p>当然<code>Scala</code>里面也是没有<code>Interface</code>这种东西的，而是用<code>trait</code>特质来代替，这个特质类似接口，但是他可以自己实现方法（惊呆了,-_-），这样一来<code>Scala</code>就支持传说中的多继承了，关于多继承里面的菱形问题<code>Scala</code>是通过最后一个相同名称的方法来解决的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">trait Logger&#123;</span><br><span class="line">	<span class="function">def <span class="title">log</span><span class="params">(msg:String)</span></span>&#123;&#125;<span class="comment">//直接在特质里面实现了方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait ConsoleLogger extends Logger &#123;</span><br><span class="line">	<span class="function">override def <span class="title">log</span><span class="params">(msg:String)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		println(msg)<span class="comment">//特质之间能直接继承</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用width来实现多继承</span></span><br><span class="line"><span class="comment">//class ConsoleLogger extends Logger with Cloneable with Serializable</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> var balance:Double=<span class="number">100</span></span><br><span class="line">	def getBalance=balance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关于Scala的多继承就是通过继承特征来实现的  with trait 可以一下下去</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaveingsAccount</span> <span class="keyword">extends</span> <span class="title">Account</span> <span class="title">with</span> <span class="title">Logger</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function">def <span class="title">withdraw</span><span class="params">(amount:Double)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(amount&gt;balance)</span><br><span class="line">		&#123;</span><br><span class="line">			log(<span class="string">"amount&gt;balance,can't withdraw"</span>)</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			log(<span class="string">"withdraw"</span>+amount)</span><br><span class="line">			balance-=amount;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(<span class="string">"s111111111"</span>)</span><br><span class="line">val s=<span class="keyword">new</span> SaveingsAccount();</span><br><span class="line">s.withdraw(<span class="number">101</span>);</span><br><span class="line">s.withdraw(<span class="number">34</span>);</span><br><span class="line">println(<span class="string">"remain"</span>+s.getBalance)</span><br><span class="line"></span><br><span class="line">println(<span class="string">"\r\ns222222222"</span>)</span><br><span class="line">val s2=<span class="keyword">new</span> SaveingsAccount() with ConsoleLogger;<span class="comment">//这个with其实是可以写到SaveingsAccount类上面的，写在这里只是为了说明Scala的灵活，实在是太灵活了。。</span></span><br><span class="line">s2.withdraw(<span class="number">101</span>);</span><br><span class="line">s2.withdraw(<span class="number">34</span>);</span><br><span class="line">println(<span class="string">"remain"</span>+s2.getBalance)</span><br></pre></td></tr></table></figure>
<p>输出的结果为：</p>
<pre><code>s111111111
remain66.0

s222222222
amount&gt;balance,can<span class="operator">'</span>t withdraw
withdraw34.0
remain66.0
</code></pre><h2 id="柯里化">柯里化</h2><blockquote>
<p>可以将函数的参数列表使用多个括号分类来调用（在其他地方没见过吧~^_^）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">mul</span><span class="params">(x:Int,y:Int)</span></span>=x*y  <span class="comment">//普通青年</span></span><br><span class="line"><span class="function">def <span class="title">mulOneAtATime</span><span class="params">(x:Int)</span></span>=(y:Int)=&gt;x*y  <span class="comment">//2B青年  </span></span><br><span class="line"><span class="function">def <span class="title">mulSample</span><span class="params">(x:Int)</span><span class="params">(y:Int)</span><span class="params">(z:Int)</span></span>=x*y*z<span class="comment">//文艺青年</span></span><br><span class="line"></span><br><span class="line">val x=<span class="number">5</span></span><br><span class="line">val y=<span class="number">6</span></span><br><span class="line">println(<span class="string">"mul"</span>,mul(x,y))</span><br><span class="line">println(<span class="string">"mulOneAtATime"</span>,mulOneAtATime(x)(y))</span><br><span class="line">println(<span class="string">"mulSample"</span>,mulSample(x)(y)(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>一般我们在一个函数中如果需要传的参数可以分为几个类别，这样使用柯里化可以让整个函数的调用更加清晰一点。（恩，的确也是）</p>
<h2 id="模式匹配和样例类">模式匹配和样例类</h2><h3 id="模式匹配">模式匹配</h3><blockquote>
<p>模式匹配<code>match</code>是一个更好的<code>switch</code></p>
</blockquote>
<p><code>Scala</code>的<code>match</code>除了可以匹配确定值以外，他还有：</p>
<ul>
<li>可以匹配数组、元祖、样例类等</li>
<li>可以在匹配时加入守卫（就是匹配的判断条件啦^_^）</li>
<li>可以在模式匹配之后进行值的返回</li>
<li>不会有意外掉落到下一个分支问题（也就是没有<code>break</code>）</li>
<li>如果得不到匹配会跑出异常，所以如果不确保能全部覆盖匹配则再最后用<code>_</code>占位符来匹配所有情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">val ch:Char=<span class="string">'-'</span></span><br><span class="line">val sign=<span class="number">5</span>;</span><br><span class="line">val result =ch match&#123;<span class="comment">//有返回值</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">'+'</span>=&gt;sign+<span class="number">1</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">'-'</span>=&gt;sign-<span class="number">1</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">_</span>=&gt;sign</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行是否大于5的判断</span></span><br><span class="line">val flag=<span class="number">5</span></span><br><span class="line">flag match&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">_</span> <span class="keyword">if</span> flag&gt;<span class="number">5</span>=&gt;println(<span class="string">"&gt;5"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">_</span> <span class="keyword">if</span> flag&lt;<span class="number">5</span>=&gt;println(<span class="string">"&lt;5"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">_</span> =&gt;println(flag)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用类型来进行匹配</span></span><br><span class="line">val obj=<span class="keyword">if</span>(<span class="keyword">false</span>) <span class="number">5</span> <span class="keyword">else</span> <span class="string">"5"</span></span><br><span class="line">obj match&#123;</span><br><span class="line">	<span class="keyword">case</span> obj:Int=&gt;println(<span class="string">"i am Int"</span>)</span><br><span class="line">	<span class="keyword">case</span> obj:String=&gt;println(<span class="string">"i am String"</span>)</span><br><span class="line">	<span class="keyword">case</span> obj:BigInt=&gt;println(<span class="string">"i am bigint"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">_</span>=&gt;println(<span class="string">"i am any"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配数组</span></span><br><span class="line">val arr=Array(<span class="number">0</span>,<span class="number">7</span>)</span><br><span class="line">arr match&#123;</span><br><span class="line">	<span class="function"><span class="keyword">case</span> <span class="title">Array</span><span class="params">(<span class="number">0</span>)</span></span>=&gt;println(<span class="string">"0"</span>) <span class="comment">//匹配只有一个0的数组</span></span><br><span class="line">	<span class="function"><span class="keyword">case</span> <span class="title">Array</span><span class="params">(x,y)</span></span>=&gt;println(x+<span class="string">"+"</span>+y)  <span class="comment">//匹配含有两个元素的数组</span></span><br><span class="line">	<span class="function"><span class="keyword">case</span> <span class="title">Array</span><span class="params">(<span class="number">0</span>,_*)</span></span>=&gt;println(<span class="string">"start 0"</span>) <span class="comment">//匹配以0为第一个元素的数组</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">_</span>=&gt;println(<span class="string">"any"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配元组</span></span><br><span class="line">val tuple=(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">tuple match&#123;</span><br><span class="line">	<span class="keyword">case</span> (<span class="number">_</span>,<span class="number">2</span>)=&gt;println(<span class="string">"end2"</span>)<span class="comment">//匹配以2结尾的元组</span></span><br><span class="line">	<span class="keyword">case</span> (<span class="number">1</span>,<span class="number">_</span>)=&gt;println(<span class="string">"start 1"</span>)<span class="comment">//匹配以1开头的元组</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">_</span>=&gt;println(<span class="string">"nothing"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS:功能很强大吧，在<code>Scala</code>的程序里面随处都可以看到<code>match</code>，甚至很多情况下使用<code>match</code>来完成<code>if-else</code>的操作</p>
</blockquote>
<h3 id="样例类">样例类</h3><blockquote>
<p>样例类是一种特殊的类，它们经过优化以被用于模式匹配</p>
</blockquote>
<p>你可以把样例类看做一个结构体，里面定义数据类型，然后在<code>match</code>操作的时候得以方便得传参</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">abstract class Amount  //定义一个抽象类</span><br><span class="line">case class Dollar(value:Double) extends Amount  //定义一个美元得样例类 继承了Amount</span><br><span class="line">case class Currency(value:Double,unit:String) extends Amount  //顶一个现金的抽象类  也是继承了Amount</span><br><span class="line"></span><br><span class="line">case object Nothing extends Amount</span><br><span class="line"></span><br><span class="line">val amt:Amount=Currency(6,"$") //实例化一个样例类 注意没有new</span><br><span class="line">amt match&#123;//使用样例类进行模式匹配</span><br><span class="line">	case Dollar(x)=&gt;println(x)</span><br><span class="line">	case Currency(value,unit)=&gt;println("oh,i get "+value+unit)//在这里得到了匹配，看到没？可以传参数</span><br><span class="line">	case Nothing=&gt;println("nothing")</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS：<code>Scala</code>的框架中样例类也用的特别多，比如说<a href="http://spark.apache.org/" target="_blank" rel="external">Spark</a></p>
</blockquote>
<h2 id="Actor">Actor</h2><blockquote>
<p><code>Actor</code>提供了并发程序中与传统的基于锁结构不同的另一个选择</p>
</blockquote>
<p>他有两种发送消息的方式：</p>
<ul>
<li><code>actor!message</code>:发送消息之后非阻塞的，也没有返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.actors.Actor</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HiActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123; <span class="comment">//自定义一个actor类，它一定是要继承Actor</span></span><br><span class="line">	<span class="function">def <span class="title">act</span><span class="params">()</span><span class="comment">//重写该方法</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			receive &#123;<span class="comment">//在这里接收消息，其实这里就是一个模式匹配</span></span><br><span class="line">				<span class="keyword">case</span> <span class="string">"Hi"</span>=&gt;println(<span class="string">"hello!"</span>)</span><br><span class="line">				<span class="keyword">case</span> <span class="string">"Goodbye"</span>=&gt;println(<span class="string">"bye bye!"</span>)</span><br><span class="line">				<span class="keyword">case</span> <span class="number">_</span> =&gt;println(<span class="string">"i don't know"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val act=<span class="keyword">new</span> HiActor</span><br><span class="line">act.start <span class="comment">//一定要启动之后才能发送</span></span><br><span class="line"></span><br><span class="line">println(<span class="string">"send Hi"</span>)</span><br><span class="line">act!<span class="string">"Hi"</span></span><br><span class="line">println(<span class="string">"send Goodbye"</span>)</span><br><span class="line">act!<span class="string">"Goodbye"</span></span><br></pre></td></tr></table></figure>
<p>这样就会输出</p>
<pre><code>send Hi
send Goodbye
hello!
<span class="built_in">bye</span> <span class="built_in">bye</span>!
</code></pre><ul>
<li><code>actor!?message</code>:发送消息之后会阻塞下面代码的执行，而且还是可以得到返回值的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.actors.Actor</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> var balance=<span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">	def getBalance=<span class="function">balance</span><br><span class="line">	def <span class="title">act</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//使用样例类来进行匹配</span></span><br><span class="line">			receive &#123;</span><br><span class="line">				<span class="function"><span class="keyword">case</span> <span class="title">Desposit</span><span class="params">(amount)</span></span>=&gt;</span><br><span class="line">					println(<span class="string">"Desposit "</span>+amount)</span><br><span class="line">					balance+=amount</span><br><span class="line">					sender!<span class="function"><span class="keyword">true</span></span><br><span class="line">				<span class="keyword">case</span> <span class="title">WidthDraw</span><span class="params">(amount)</span></span>=&gt;</span><br><span class="line">					<span class="keyword">if</span>(balance&lt;amount)</span><br><span class="line">					&#123;</span><br><span class="line">						println(<span class="string">"the balance less than amount"</span>)</span><br><span class="line">						sender!<span class="keyword">false</span></span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						println(<span class="string">"WidthDraw"</span>+amount)</span><br><span class="line">						balance-=amount</span><br><span class="line">						sender!<span class="keyword">true</span></span><br><span class="line">					&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">case</span> class <span class="title">Desposit</span><span class="params">(amount:Double)</span>  <span class="comment">//存钱的样例类</span></span><br><span class="line"><span class="keyword">case</span> class <span class="title">WidthDraw</span><span class="params">(amount:Double)</span> <span class="comment">//取钱的样例类</span></span><br><span class="line"></span><br><span class="line">val account</span>=<span class="keyword">new</span> AccountActor</span><br><span class="line">account.start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果使用非阻塞的，整个存取钱的系统会不正常</span><br><span class="line">println(account!WidthDraw(100))</span><br><span class="line">println(account!Desposit(100))</span><br><span class="line">println(account!WidthDraw(50))</span><br><span class="line">println("account.getBalance"+account.getBalance)*/</span></span><br><span class="line"></span><br><span class="line">println(account!?WidthDraw(<span class="number">100</span>))<span class="comment">//取100  会说钱不够，没法取</span></span><br><span class="line">println(account!?Desposit(<span class="number">100</span>))<span class="comment">//存100</span></span><br><span class="line">println(account!?WidthDraw(<span class="number">50</span>))<span class="comment">//再取50</span></span><br><span class="line">println(<span class="string">"account.getBalance"</span>+account.getBalance)<span class="comment">//可以正常取钱</span></span><br></pre></td></tr></table></figure>
<p>输出的结果为：</p>
<pre><code><span class="keyword">the</span> balance <span class="keyword">less than</span> amount
<span class="constant">false</span>
Desposit <span class="number">100.0</span>
<span class="constant">true</span>
WidthDraw50.0
<span class="constant">true</span>
account.getBalance50.0
</code></pre><blockquote>
<p>PS:大名鼎鼎的<code>AKKA</code>就是基于<code>Actor</code>来实现的，是分布式、高并发的消息驱动框架（听听就是高大上~^_^）</p>
</blockquote>
<h2 id="隐式转换">隐式转换</h2><p>你知否曾希望某个类有某个方法，而这个类的作者却没有提供你？</p>
<blockquote>
<p>所谓隐式转换函数指的是那种以<code>implicit</code>关键字声明的带有单个参数的函数。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//定义一个现金转换类</span><br><span class="line">class Currency(val value:Double)&#123;</span><br><span class="line">	def $2y=value*6 //美元转人民币</span><br><span class="line">	def y2$=value/6 //人民币转美元</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//普通用法就是需要自己去实例化一个Currency类再去</span><br><span class="line">val money=new Currency(100.0)</span><br><span class="line">println(money.$2y) //执行去转换的方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//这里使用隐式转换</span><br><span class="line">implicit def double2Currency(value:Double)=new Currency(value)</span><br><span class="line">println(100.$2y)//就可以直接在数字上使用该现金转换的方法了</span><br><span class="line">//A：有同学可能要问了，这不是double转为Currency的嘛？怎么Int类型也能用？</span><br><span class="line">//Q：不错，100是Int类型，但是这里默认是带有Int 转 Double的隐式转换</span><br></pre></td></tr></table></figure>
<p>在使用隐式转换时只需要确保调用之前 已经直接了定义的隐式转换方法即可，而且一般定义转换名称为<code>元类型2目标类型</code>，这样比较好记啊(^_^)</p>
<blockquote>
<p>Note:在Scala编写框架时他的功能类往往不会直接暴露出来，而是通过隐式转换的方式来让用调用 （这点可以让你的框架代码结构非常清晰，但是。。。你要看源码实际调用类的时候就很难找到了）</p>
</blockquote>
<h2 id="还有还有">还有还有</h2><ul>
<li>元组：这不是元祖月饼-_-，接触过<code>Python</code>的同学应该都知道吧</li>
<li><code>List,Map,etc</code>的集合类</li>
<li>万能占位符<code>_</code>，懒人模式用的，因为有时候懒得想变量</li>
<li><code>lazy</code> 懒加载，在调用的时候才会加载。。明显有好处嘛^_^</li>
<li>用索引取值一般用圆括号<code>(i)</code>，定义变量类型、泛型一般用方括号<code>[K,V]</code></li>
<li>其他的好也好多都不熟悉了 -_-</li>
</ul>
<h2 id="参考">参考</h2><ul>
<li>《快学Scala》</li>
<li>《Scala编程-中文版》</li>
<li><a href="http://www.scala-lang.org/" target="_blank" rel="external">Scala</a></li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>&#160; &#160; &#160; &#160;由于实验需要在半年前开始接触<code>Scala</code>，之前也学习/使用过<a href="http://www.tiobe.com/content/paperinfo/tpci/tpci_definition]]>
    </summary>
    
      <category term="Scala" scheme="http://yyl8781697.github.io/tags/Scala/"/>
    
      <category term="Scala" scheme="http://yyl8781697.github.io/categories/Scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Effective Java》第二章：创建和销毁对象]]></title>
    <link href="http://yyl8781697.github.io/2015/04/22/Effective%20Java/Create-Destory-Object/"/>
    <id>http://yyl8781697.github.io/2015/04/22/Effective Java/Create-Destory-Object/</id>
    <published>2015-04-22T12:33:05.000Z</published>
    <updated>2015-04-25T08:51:52.000Z</updated>
    <content type="html"><![CDATA[<p>本章的主题是创建和销毁对象：何时以及如何创建对象，何时以及如何避免创建对象，如何确保它们能够适时得销毁，以及如何管理对象和销毁之前必须进行的各种清理动作。</p>
<h2 id="第1条：考虑用静态工厂方法代替构造器">第1条：考虑用静态工厂方法代替构造器</h2><blockquote>
<p>这条感觉就是推荐我们尽量使用静态方法来生成实例对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b?Boolean.TRUE:Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>推荐的理由如下：</p>
<ol>
<li>静态构造方法有自己的名称。（这理由是不是有点。。，个人感觉绝大部分程序猿在创建对象时都是首先尝试<code>new Construct()</code>）</li>
<li>不必在每次调用它们时都创建一个新的对象。(单例中比较常用吧)</li>
<li>它们可以返回原返回类型的任何子类型的对象。（<strong>这个特征的确是比较有优势一点</strong>）</li>
<li>在创建参数化类型实例的时候，它们使代码变得更加简洁。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通是需要这么干的</span></span><br><span class="line">Map&lt;String,List&lt;String&gt;&gt; m=<span class="keyword">new</span> HashMap&lt;String,List&lt;String&gt;&gt;();</span><br><span class="line"><span class="comment">//使用了第4条直接这么干就好了（但是实际上HashMap也没提供这个功能啊-_-）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;K,V&gt; HashMap&lt;K,V&gt; newInstance()&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;K,V&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然使用这种静态方法也有缺点：</p>
<ol>
<li>类如何不含有公有的或者受保护的构造器，就不能子类化。</li>
<li>它们与其他的静态方法实际上没有任何区别。</li>
</ol>
<p>一些静态工厂方法的惯用名称（也的确常见）：</p>
<ul>
<li>ValueOf</li>
<li>of</li>
<li>getInstance</li>
<li>newInstance</li>
<li>getType</li>
<li>newType</li>
</ul>
<h2 id="第2条：遇到多个构造器参数的时候要考虑用构建器">第2条：遇到多个构造器参数的时候要考虑用构建器</h2><p>当你的<code>Class</code>有多个自定义参数需要初始化的时候-_-</p>
<h3 id="重叠构造器">重叠构造器</h3><p>你可能会使用重叠构造器来编写代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="comment">//field</span></span><br><span class="line">	Test(arg1)<span class="comment">//</span></span><br><span class="line">	Test(arg1,arg2)<span class="comment">//</span></span><br><span class="line">	Test(arg1,arg2,arg3)<span class="comment">//</span></span><br><span class="line">	Test(arg1,arg2,arg3,arg4)<span class="comment">//</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是当需要初始化的参数实在太多的时候，这个<code>Class</code>的构造函数很快就会失去控制，而且在调用构造器的时候也会因为要初始化的参数太多而弄混。</p>
<h3 id="使用setter方法来设置参数">使用setter方法来设置参数</h3><p>即<code>JavaBean</code>模式，在这种模式下调用一个无参构造器来创建对象，然后调用setter方法来设置每个必要的参数，以及每个可选参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="comment">//field</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(arg1)</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArg1</span><span class="params">(arg1)</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArg1</span><span class="params">(arg2)</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArg1</span><span class="params">(arg3)</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArg1</span><span class="params">(arg4)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种模式弥补重叠构造器模式的不足，创建对象实例很容易，并且代码读起来也很容易：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Test test=<span class="keyword">new</span> Test();</span><br><span class="line">test.setArg1(..)</span><br><span class="line">test.setArg2(..)</span><br><span class="line">test.setArg3(..)</span><br><span class="line">test.setArg4(..)</span><br></pre></td></tr></table></figure>
<p>但是它有一个严重的缺点，就是这个构造过程被分到几个不同的调用中时，该对象可能处于不一致的状态。-_-</p>
<h3 id="使用Builder模式">使用Builder模式</h3><p>它既能保证那重叠构造器那样安全，也能保证像<code>JavaBean</code>那样有好的可读性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="comment">//field</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">		<span class="comment">//filed=builder.filed...</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">		<span class="comment">//field</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArg1</span><span class="params">(arg1)</span></span>&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArg1</span><span class="params">(arg2)</span></span>&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArg1</span><span class="params">(arg3)</span></span>&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArg1</span><span class="params">(arg4)</span></span>&#123;&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Test <span class="title">build</span><span class="params">()</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Test(<span class="keyword">this</span>);<span class="comment">//通过内部类构造该类</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种模式其实是生成一个内部类，在内部类中通过<code>setter</code>方法设置相应的字段，然后调用<code>build</code>方法生成真正需要的<code>Class</code>实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Test test=<span class="keyword">new</span> Test.Builder()</span><br><span class="line">				.setArg1()</span><br><span class="line">				.setArg2()</span><br><span class="line">				.setArg3()</span><br><span class="line">				.setArg4()</span><br><span class="line">				.build()</span><br></pre></td></tr></table></figure>
<p>这个方法十分灵活，可以通过构建一个builder来构建多个对象，builder的参数可以在构建期间进行调整，也可以随不同的对象而改变。<br><br>此时，我们可以将这个builder定义为一个通用的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以通过创建接口来创建更多的实例对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Builder&lt;Test&gt; builderTest=<span class="keyword">new</span> Test.Builder()</span><br><span class="line">.setArg1()</span><br><span class="line">.setArg2()</span><br><span class="line">.setArg3()</span><br><span class="line">.setArg4()</span><br><span class="line"></span><br><span class="line">builderTest.build()</span><br></pre></td></tr></table></figure>
<p>Builder模式也有不足之处，为了创建对象，必须创建它的构建器，虽然创建构建器的开销在实践中不是那么明显，但是在某些十分注重性能的情况下，可能会成功问题。<br><br>简而言之，如果累的构造器或者静态工厂中具有多个参数，设计这种类时,Builder模式模式是一个不错的选择。</p>
<h2 id="第3条：用私有的构造器或者枚举类型强化Singleton属性">第3条：用私有的构造器或者枚举类型强化Singleton属性</h2><p>单例模式估计是大家在《设计模式》中最早接触的一种，也是较为常用的一种模式，从它的线程安全性和运行效率性上考虑，我们所了解的应该有这么几种类型的单例写法<sup>1<sup>：</sup></sup></p>
<ul>
<li>懒汉式单例</li>
<li>饿汉式单例</li>
<li>登记式单例</li>
</ul>
<p>除了上述，书本极力推荐的一种是<strong>单元素枚举类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Elvis&#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span></span>&#123;<span class="comment">//...&#125;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法无偿的提供了序列化机制，绝对防止多次实例化。但是由于为了使用单例将”类”改为了”枚举”，这样就是导致丢掉一些类的特征，比如说继承，因为枚举是默认继承<code>java.lang.Enum</code>。</p>
<h2 id="第4条：通过私有构造器强化不可实例化的能力">第4条：通过私有构造器强化不可实例化的能力</h2><p>当你的类里面只包含静态方法和静态变量时（比如说工具类），那么请在该类上添加一个私有的构造器，这样可以保护该类，同时也不会误导用户。<br><br>当然这么写有个副作用就是这个类就不能被继承了，子类就没有访问超类的构造器可用了。</p>
<h2 id="第5条：避免创建不必要的对象">第5条：避免创建不必要的对象</h2><p>一般来说，最好能重用对象而不是在每次需要的时候就创建一个项目功能的新对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String s=<span class="keyword">new</span> String(<span class="string">"stringette"</span>);<span class="comment">//不要这么做</span></span><br><span class="line">String s=<span class="string">"stringette"</span>;<span class="comment">//在同一台虚拟机中运行时，该对象会被重用</span></span><br></pre></td></tr></table></figure>
<p>几大重用的关键点：</p>
<ul>
<li>对于同时提供了静态工厂方法和构造器的不可变类，通常可以使用静态工厂方法，以免创建不必要的对象。</li>
<li>可以重用那些已知不会被修改的可变对象。</li>
<li>优先使用基本类型而不是装箱类型。</li>
</ul>
<blockquote>
<p>本条目并不是暗示“创建对象的代价非常昂贵，我们应该要尽量避免对象的创建”</p>
</blockquote>
<h2 id="第6条：消除过期的引用">第6条：消除过期的引用</h2><p>这条就是描述过期的引用会存在内存泄露的问题，那我们程序猿该如何处理呢？</p>
<blockquote>
<p>类要是自己管理内存，程序猿就应该警惕内存泄露问题。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 简单的栈结构的实现</span><br><span class="line"> *<span class="javadoctag"> @author</span> yyl  form Effective Java</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object[] elements;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPCAITY=<span class="number">16</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		elements=<span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPCAITY];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		ensureCapacity();<span class="comment">//确保容量足够</span></span><br><span class="line">		elements[size++]=e;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">		<span class="keyword">return</span> elements[--size];<span class="comment">//</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(elements.length==size)</span><br><span class="line">			elements=Arrays.copyOf(elements, <span class="number">2</span>*size+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是一个简单的栈结构的实现，但是在元素被多次<code>pop()</code>之后，<code>Object[]</code>里面索引大于<code>size</code>的对象不在可用，但是由于他们还是存储在数组中，所以垃圾回收机制不会处理这些对象，最终会造成内存泄露。<br><br>可以用下面的方法来修复：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">	Object ret=elements[--size];</span><br><span class="line">	elements[size]=<span class="keyword">null</span>;<span class="comment">//清空引用</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述只是一个特征，这条并不是教我们对于每个对象引用不再用到时就将它清空，其实没有这个必要，这样做会把代码弄得很乱，清除过期引用最好的方法是让包含该引用变量结束生命周期。</p>
<blockquote>
<p>内存泄露另一种常见的来源是缓存</p>
</blockquote>
<p> 当对象放入缓存中很容易被遗忘，然而它会长期存储在内存中，这样可以使用<code>WeakHashMap</code>来代表缓存，当缓存的项过期之后，他们会被自动删除。<br><br>也可以使用<code>LinkedHashMap</code>来实现LRU缓存，当容量满时会删除最久一个没有用过的项。</p>
<blockquote>
<p>内存泄露的第三个常见的来源是监听器和其他回调</p>
</blockquote>
<p>比如说你注册了某些Api的回调，但是没有显示的取消注册，这样他们会越积越多。~~~~</p>
<h2 id="第7条：避免终结方法">第7条：避免终结方法</h2><blockquote>
<p>终结方法（<code>finalizer</code>）通常是不可预测的，也是很危险的，一般情况下是不必要的。</p>
</blockquote>
<p>避免的原因有如下几个：</p>
<ul>
<li><p>不能保证被及时的执行。<br><br>因为进行<code>gc</code>时终结方法的优先级一般比其他的要低，注重时间的任务不应该用终结方法来完成，比如在<code>finalizer</code>中关闭已打开的文件</p>
</li>
<li><p>JVM不会保证他们会被执行。<br><br>不应该依赖终结方法来更新中重要的持久状态。</p>
</li>
<li><p>终结方法可能会有非常重要的性能损失。</p>
</li>
</ul>
<p>所以如果在自己的类中真实的需要将对象终止，则自己最好提供一个显示的终止方法，并且要求编码人员再不需要该对象时进行显示掉调用终止方法，比如<code>file.close</code><br></p>
<p>当然终结方法也不是一无是处：</p>
<ol>
<li>当对象的所有者忘记调用前面段落中建议的显示终止方法时，可以用终止方法在日志中记录记录警告或者再显示的调用该终止方法</li>
<li>与对象的本地对等体有关。大概是普通对象通过<code>native method</code>委托给一个本地对象，而这个本地对象时不受<code>jVM</code>管理的。但是可以使用终结方法来完成必要资源释放，它可以是本地方法，也可以条用本地方法。</li>
</ol>
<blockquote>
<p>注意：<code>finalizer</code>方法链不会自动的执行，所以在自定义<code>finalizer</code>时最好显示得调用<code>super.finalizer()</code></p>
</blockquote>
<h2 id="参考">参考</h2><ol>
<li><a href="http://blog.csdn.net/jason0539/article/details/23297037" target="_blank" rel="external">http://blog.csdn.net/jason0539/article/details/23297037</a></li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>本章的主题是创建和销毁对象：何时以及如何创建对象，何时以及如何避免创建对象，如何确保它们能够适时得销毁，以及如何管理对象和销毁之前必须进行的各种清理动作。</p>
<h2 id="第1条：考虑用静态工厂方法代替构造器">第1条：考虑用静态工厂方法代替构造器</h2><blo]]>
    </summary>
    
      <category term="Java" scheme="http://yyl8781697.github.io/tags/Java/"/>
    
      <category term="Effective Java" scheme="http://yyl8781697.github.io/categories/Effective-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Java枚举的重写]]></title>
    <link href="http://yyl8781697.github.io/2015/04/21/Java%20Base/Enum-Override/"/>
    <id>http://yyl8781697.github.io/2015/04/21/Java Base/Enum-Override/</id>
    <published>2015-04-21T12:34:28.000Z</published>
    <updated>2015-04-25T07:19:00.000Z</updated>
    <content type="html"><![CDATA[<p>对于Java枚举我之前所知道的是<sup>1</sup>：</p>
<ol>
<li>枚举本身就是一个类。</li>
<li>它不能有<code>public</code>的构造函数，这样做可以保证客户代码没有办法新建一个enum的实例。     </li>
<li>所有枚举值都是<code>public static final</code>的。注意这一点只是针对于枚举值，我们可以和在普通类里面定义变量一样定义其它任何类型的非枚举变量，这些变量可以用任何你想用的修饰符。     </li>
<li>Enum默认实现了<code>java.lang.Comparable</code>接口。     </li>
<li>Enum覆载了了<code>toString</code>方法，因此我们如果调用<code>Color.Blue.toString()</code>,默认返回字符串”Blue”.</li>
<li>Enum提供了一个<code>valueOf</code>方法，这个方法和<code>toString</code>方法是相对应的。调用<code>valueOf(“Blue”)</code>将返回<code>Color.Blue</code>.因此我们在自己重写<code>toString</code>方法的时候就要注意到这一点，一般来说应该相对应地重写<code>valueOf</code>方法。     </li>
<li>Enum还提供了<code>values</code>方法，这个方法使你能够方便的遍历所有的枚举值</li>
<li>Enum还有一个<code>oridinal</code>的方法，这个方法返回枚举值在枚举类种的顺序。</li>
</ol>
<p>《Effective Java》中写着单例模式推荐的方式是使用<strong>单元素的枚举类</strong>实现，在查资料过程中竟然发现枚举值里面还能重写枚举的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 单元素的枚举类型的 单例</span><br><span class="line"> *<span class="javadoctag"> @author</span> yyl</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Person &#123;</span><br><span class="line">	<span class="comment">//这里每一个枚举项都可以看做一个单例实例</span></span><br><span class="line">	instance,</span><br><span class="line">	him&#123;</span><br><span class="line">		<span class="annotation">@Override</span> </span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"gays:"</span>+str;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	she&#123;</span><br><span class="line">		<span class="annotation">@Override</span> </span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"girls:"</span>+str;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String str)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Hello:"</span>+str;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用单例的方式来调用<code>sayHello</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Person.instance.sayHello(<span class="string">"tom"</span>));</span><br><span class="line">System.out.println(Person.him.sayHello(<span class="string">"tom"</span>));</span><br><span class="line">System.out.println(Person.she.sayHello(<span class="string">"tom"</span>));</span><br></pre></td></tr></table></figure>
<p>可以看到其输出为：</p>
<pre><code><span class="label">Hello:</span>tom
<span class="label">gays:</span>tom
<span class="label">girls:</span>tom
</code></pre><h2 id="参考">参考</h2><ol>
<li><a href="http://www.cnblogs.com/rollenholt/archive/2012/11/27/2790402.html" target="_blank" rel="external">http://www.cnblogs.com/rollenholt/archive/2012/11/27/2790402.html</a></li>
<li><a href="http://www.cnblogs.com/hemingwang0902/archive/2011/12/29/2306263.html" target="_blank" rel="external">http://www.cnblogs.com/hemingwang0902/archive/2011/12/29/2306263.html</a></li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于Java枚举我之前所知道的是<sup>1</sup>：</p>
<ol>
<li>枚举本身就是一个类。</li>
<li>它不能有<code>public</code>的构造函数，这样做可以保证客户代码没有办法新建一个enum的实例。     </li>
<li>所有枚]]>
    </summary>
    
      <category term="Java" scheme="http://yyl8781697.github.io/tags/Java/"/>
    
      <category term="Java Base" scheme="http://yyl8781697.github.io/categories/Java-Base/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自己煮：可口又美味的可乐鸡翅]]></title>
    <link href="http://yyl8781697.github.io/2015/04/19/Food/Coke-Chicken-feet/"/>
    <id>http://yyl8781697.github.io/2015/04/19/Food/Coke-Chicken-feet/</id>
    <published>2015-04-19T12:23:47.000Z</published>
    <updated>2015-04-24T12:35:32.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>喜欢啃鸡爪，喜欢各种做法的鸡爪，包括泡椒凤爪，鸡爪煲，红烧鸡爪等。<br>咱这次做了一次可乐鸡爪，哈哈</p>
</blockquote>
<h2 id="食材">食材</h2><ul>
<li>鸡爪：10个</li>
<li>油、料酒、酱油~~~~</li>
<li>生姜、大蒜：适量</li>
<li>八角、香叶：适量</li>
<li>辣椒：一点点就好了</li>
<li>可乐（别太少了，估计3.5元的小瓶装可能不够）</li>
</ul>
<h2 id="步骤">步骤</h2><h3 id="准备">准备</h3><p><img src="/img/Coke-Chicken-feet/1.ready.jpg" alt=""><br><br>首先每个鸡爪切成两半，这是为什么呢？</p>
<ul>
<li>一个是方便煮熟</li>
<li>另一个是方便啃（不然整个鸡爪啃的时候很容易把汁碰到脸）</li>
<li>当然，如果你喜欢啃整个就跳过这一步</li>
</ul>
<h3 id="预煮">预煮</h3><p><img src="/img/Coke-Chicken-feet/2.ruguo.jpg" alt=""><br><br>将切好的鸡爪丢进清水中煮，这个时候可以放一点点生姜和少许料酒，大概煮十分钟左右，如果不煮的话也可以把鸡爪先放进电饭煲中蒸一下（正好煮饭）。<br><br>如果不经过预煮的话很难讲鸡爪煮熟（第一次我就遇到了这种情况）<br><img src="/img/Coke-Chicken-foot/3.zhenghao.jpg" alt=""><br><br>将鸡爪煮到5分熟之后是这样的</p>
<h3 id="爆炒">爆炒</h3><p><img src="/img/Coke-Chicken-feet/4.baochao.jpg" alt=""><br><br>在锅里面放入少许油，等油热了之后把生姜、大蒜、辣椒丢进去把油炒香，然后放预煮之后的鸡爪。<br>注意这里千万要把火开小，因为预煮捞出来的鸡爪带有水分，很容易将油爆起来-_-|<br><br>爆炒几十秒之后放入少许酱油和料酒，接下来就可以放可乐了。<br><img src="/img/Coke-Chicken-feet/5.fangkele.jpg" alt=""><br></p>
<blockquote>
<p>注意：放的可乐一定要将全部的鸡爪淹没掉，这样味道才好。<br>此时可以放一片八角和香叶。</p>
</blockquote>
<h3 id="正煮Ing_&amp;_收汁">正煮Ing &amp; 收汁</h3><p>接下来就是等待的煮，水开之后可以把火适当的关小一点，还有关于口味此时可以稍微放一些盐</p>
<blockquote>
<p>别放太多，因为之前已经放过酱油了<br>大概20~30分钟之后就会慢慢收汁了，香味也都出来了。</p>
</blockquote>
<p><img src="/img/Coke-Chicken-feet/6.shouzhi.jpg" alt=""><br></p>
<hr>
<h3 id="出锅">出锅</h3><p>出锅之前放一点点味精，如果有胡椒粉的话也可以适当稍微倒一点点进去，这样比较香<br><img src="/img/Coke-Chicken-feet/7.chuguo.jpg" alt=""><br></p>
<p>洗锅开吃~~~~哈哈！</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>喜欢啃鸡爪，喜欢各种做法的鸡爪，包括泡椒凤爪，鸡爪煲，红烧鸡爪等。<br>咱这次做了一次可乐鸡爪，哈哈</p>
</blockquote>
<h2 id="食材">食材</h2><ul>
<li>鸡爪：10个</li>
<li>油、料酒、酱油~~~]]>
    </summary>
    
      <category term="Food" scheme="http://yyl8781697.github.io/tags/Food/"/>
    
      <category term="Food" scheme="http://yyl8781697.github.io/categories/Food/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[org.apache.hadoop.fs.LocalFileSystem cannot be cast to org.apache.hadoop.hdfs.DistributedFileSystem]]></title>
    <link href="http://yyl8781697.github.io/2015/04/16/Hadoop/Hadoop-LocalFileSystem-cannot-cast-DistributedFileSystem/"/>
    <id>http://yyl8781697.github.io/2015/04/16/Hadoop/Hadoop-LocalFileSystem-cannot-cast-DistributedFileSystem/</id>
    <published>2015-04-16T13:24:55.000Z</published>
    <updated>2015-04-25T07:18:46.000Z</updated>
    <content type="html"><![CDATA[<p>将自己之前写好的hadoop程序拷贝给师弟时候总是会报下面的错：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassCastException: org.apache.hadoop.fs.LocalFileSystem cannot be cast to org.apache.hadoop.hdfs.DistributedFileSystem</span><br><span class="line">	at hadoop.mapreduce.ali.recommend.common.HdfsHelper.&lt;clinit&gt;(HdfsHelper.java:<span class="number">25</span>)</span><br><span class="line">	at hadoop.mapreduce.ali.recommend.LogisticRegression.LRProgram.run(LRProgram.java:<span class="number">53</span>)</span><br><span class="line">	at hadoop.mapreduce.ali.recommend.LogisticRegression.LRProgram.main(LRProgram.java:<span class="number">23</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>字面自已上就是本地文件不能转为分布式文件</strong>，自己在输入文件上加hdfs前缀也是无济于事，搜索关键字了半天也没找到匹配的方案，后来终于在一个博客找到了解决方案：<br><br>将<code>hadoop/conf/</code>下面的<code>core-site.xml</code>和<code>hdfs-site.xml</code>复制到工程文件的<code>/bin/</code>目录下面就可以了（使用的是Eclipse的IDE），坑爹。</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>将自己之前写好的hadoop程序拷贝给师弟时候总是会报下面的错：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><spa]]>
    </summary>
    
      <category term="Hadoop" scheme="http://yyl8781697.github.io/tags/Hadoop/"/>
    
      <category term="Hadoop" scheme="http://yyl8781697.github.io/categories/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 源码学习之java.util.LinkedHashMap]]></title>
    <link href="http://yyl8781697.github.io/2015/04/15/Java%20Source/Java-LinkedHashMap/"/>
    <id>http://yyl8781697.github.io/2015/04/15/Java Source/Java-LinkedHashMap/</id>
    <published>2015-04-15T08:06:15.000Z</published>
    <updated>2015-04-25T07:19:26.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><code>LinkedHashMap</code>是基于<code>HashMap</code>实现的，但是与之不同的是<code>LinkedHashMap</code>在遍历取值时可以保序，这是通过双向链表来实现的。</p>
</blockquote>
<p>我们知道<code>HashMap</code>在增删改查方面非常高效，但是遗憾的时候在迭代遍历<code>HashMap</code>时是不保序的，常常我们有时候即需要这种高效的操作，同时还希望在遍历数据集时要保序的需求，所以这个时候<code>LinkedHashMap</code>就出来了，接下来文本讲解<code>LinkedHashMap</code>是如何基于<code>HashMap</code>来完成遍历保序的功能。</p>
<h2 id="LinkedHashMap的定义">LinkedHashMap的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从<code>LinkedHashMap</code>的定义中可以很清晰的看到它就是基于<code>HashMap</code>来进行实现的，但是这里不理解的是为何它还要继承<code>Map</code>接口？因为<code>HashMap</code>已经继承了<code>Map</code>接口了，<code>LinkedHashMap</code>这样干是不是没必要，后来我也查了资料，也没有明确得答案，也有人说<code>LinkedHashMap</code>这样继承没有为什么，你懂就好了。-_-</p>
<h2 id="私有变量">私有变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * The head of the doubly linked list.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; header;<span class="comment">//双向链表的头部</span></span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span><br><span class="line"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span><br><span class="line"> * 定义LinkedHashMap遍历时的顺序,</span><br><span class="line"> *<span class="javadoctag"> @serial</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>
<p>上面源码中是<code>LinkedHashMpa</code>的两个比较重要的私有变量：</p>
<ul>
<li>header：该变量是双向链表的头部，<code>LinkedHashMap</code>是通过维护这个双向链表来实现保序的，该变量是一个<code>Entry</code>类型，在下文是详细讲解。</li>
<li>accessOrder：当accessOrder为true时遍历使用访问顺序（基于此可以实现LRU缓存），当accessOrder为false时使用插入顺序（默认）。</li>
</ul>
<h2 id="构造函数">构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance</span><br><span class="line"> * with the specified initial capacity and load factor.</span><br><span class="line"> *</span><br><span class="line"> *<span class="javadoctag"> @param</span>  initialCapacity the initial capacity</span><br><span class="line"> *<span class="javadoctag"> @param</span>  loadFactor      the load factor</span><br><span class="line"> *<span class="javadoctag"> @throws</span> IllegalArgumentException if the initial capacity is negative</span><br><span class="line"> *         or the load factor is nonpositive</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance</span><br><span class="line"> * with the specified initial capacity and a default load factor (0.75).</span><br><span class="line"> *</span><br><span class="line"> *<span class="javadoctag"> @param</span>  initialCapacity the initial capacity</span><br><span class="line"> *<span class="javadoctag"> @throws</span> IllegalArgumentException if the initial capacity is negative</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance</span><br><span class="line"> * with the default initial capacity (16) and load factor (0.75).</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * Constructs an insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with</span><br><span class="line"> * the same mappings as the specified map.  The &lt;tt&gt;LinkedHashMap&lt;/tt&gt;</span><br><span class="line"> * instance is created with a default load factor (0.75) and an initial</span><br><span class="line"> * capacity sufficient to hold the mappings in the specified map.</span><br><span class="line"> *</span><br><span class="line"> *<span class="javadoctag"> @param</span>  m the map whose mappings are to be placed in this map</span><br><span class="line"> *<span class="javadoctag"> @throws</span> NullPointerException if the specified map is null</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(m);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the</span><br><span class="line"> * specified initial capacity, load factor and ordering mode.</span><br><span class="line"> *</span><br><span class="line"> *<span class="javadoctag"> @param</span>  initialCapacity the initial capacity</span><br><span class="line"> *<span class="javadoctag"> @param</span>  loadFactor      the load factor</span><br><span class="line"> *<span class="javadoctag"> @param</span>  accessOrder     the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for</span><br><span class="line"> *         access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order</span><br><span class="line"> *<span class="javadoctag"> @throws</span> IllegalArgumentException if the initial capacity is negative</span><br><span class="line"> *         or the load factor is nonpositive</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span><br><span class="line">                     <span class="keyword">float</span> loadFactor,</span><br><span class="line">                     <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;<span class="comment">//只有这里才能显示的将accessOrder置为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>LinkedHashMap</code>的构造函数中可以了解到：</p>
<ul>
<li>一般都是直接调用了父类<code>HashMap</code>的构造函数</li>
<li>绝大部门构造函数中将accessOrder默认为false，只有在最后一个构造函数中可以显示得将accessOrder置为你所需要的属性。</li>
</ul>
<p>注意，在初始化父类<code>HashMap</code>的构造函数的时会调用一个<code>init()</code>的方法，在<code>LinkedHashMap</code>重写了该方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * Called by superclass constructors and pseudoconstructors (clone,</span><br><span class="line"> * readObject) before any entries are inserted into the map.  Initializes</span><br><span class="line"> * the chain.</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    header = <span class="keyword">new</span> Entry&lt;&gt;(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    header.before = header.after = header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以发现该方法额外初始化了双向链表的表头：<br><br><img src="/img/Java-LinkedHashMap/init_head.png" alt=""></p>
<h2 id="containsValue">containsValue</h2><p>为什么要讲这个不起眼的方法呢？因为在<code>LinkedHashMap</code>中利用自己双向链表来优化这个是否包含值的方法。<br><br><code>HashMap</code>:<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span><br><span class="line"> * specified value.</span><br><span class="line"> *</span><br><span class="line"> * @param value value whose presence in this map is to be tested</span><br><span class="line"> * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span><br><span class="line"> *         specified value</span><br><span class="line"> */</span><br><span class="line">public boolean containsValue(Object value) &#123;</span><br><span class="line">    if (value == null)</span><br><span class="line">        return containsNullValue();</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    for (int i = 0; i &lt; tab.length ; i++)</span><br><span class="line">        for (Entry e = tab[i] ; e != null ; e = e.next)</span><br><span class="line">            if (value.equals(e.value))</span><br><span class="line">                return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;code&gt;LinkedHashMap&lt;/code&gt;:&lt;br /&gt;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line"> * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span><br><span class="line"> * specified value.</span><br><span class="line"> *</span><br><span class="line"> * @param value value whose presence in this map is to be tested</span><br><span class="line"> * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span><br><span class="line"> *         specified value</span><br><span class="line"> */</span><br><span class="line">public boolean containsValue(Object value) &#123;</span><br><span class="line">    // Overridden to take advantage of faster iterator</span><br><span class="line">	//重写了HashMap中的方法，直接使用遍历双向链表来做</span><br><span class="line">    if (value==null) &#123;</span><br><span class="line">        for (Entry e = header.after; e != header; e = e.after)</span><br><span class="line">            if (e.value==null)</span><br><span class="line">                return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (Entry e = header.after; e != header; e = e.after)</span><br><span class="line">            if (value.equals(e.value))</span><br><span class="line">                return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从两者的源码中更可以看出，虽然两者最坏都是需要进行<code>table.size</code>次的<code>equals</code>比较，但是在<code>HashMap</code>中会遍历整个<code>table</code>，我们知道有<code>loadFactor</code>的存在，所以<code>table</code>中还是比较稀疏的，那这样的话<code>HashMap</code>会进行很多无谓的遍历，而在<code>LinkedHashMap</code>中里面是都是紧凑的，使用这种方法来遍历要比<code>HashMap</code>的性能提升了不少。</p>
<h2 id="LinkedHashMap-Entry">LinkedHashMap.Entry</h2><p>该<code>Entry</code>从<code>HashMap</code>继承而来，也正是因为有它才可以完整的实现双向链表。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * LinkedHashMap entry.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// These fields comprise the doubly linked list used for iteration.</span></span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line"></span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="javadoc">/**</span><br><span class="line">     * Removes this entry from the linked list.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;<span class="comment">//it will be invoked while user use the remove(Obj) method</span></span><br><span class="line">        before.after = after;</span><br><span class="line">        after.before = before;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="javadoc">/**</span><br><span class="line">     * Inserts this entry before the specified existing entry in the list.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;<span class="comment">//if the existngEntry is head</span></span><br><span class="line">        after  = existingEntry;</span><br><span class="line">        before = existingEntry.before;</span><br><span class="line">        before.after = <span class="keyword">this</span>;</span><br><span class="line">        after.before = <span class="keyword">this</span>;<span class="comment">//insert the this node to the first head</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="javadoc">/**</span><br><span class="line">     * This method is invoked by the superclass whenever the value</span><br><span class="line">     * of a pre-existing entry is read by Map.get or modified by Map.set.</span><br><span class="line">     * If the enclosing Map is access-ordered, it moves the entry</span><br><span class="line">     * to the end of the list; otherwise, it does nothing.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class="line">        <span class="keyword">if</span> (lm.accessOrder) &#123;</span><br><span class="line">            lm.modCount++;</span><br><span class="line">            remove();</span><br><span class="line">            addBefore(lm.header);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">        remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>从<code>Entry</code>中可以看到，它自己定义了两个变量<code>before</code>,<code>after</code>，分别是指向双向链表的两端。<br></li>
<li><code>addBefore</code>是实现链表的核心，它是在<code>createEntry</code>的重写方法中被调用，传的<em>existingEntry</em>参数总是<code>header</code>其实该链表是一个收尾相连的链表，每次添加的新元素都是连接到<code>header</code>的前面：如下图（其中绿色的线表示下一次插入时会修改该指向）<br>  <img src="/img/Java-LinkedHashMap/double_link.png" alt=""></li>
<li><code>recordAccess</code>方法就是实现<code>LinkedHashMap</code>有以访问顺序遍历的功能，每次使用<code>put</code>和<code>get</code>都是调用它，当开启<code>accessOrder</code>时，首先会讲当前元素移除，但是会讲它再次插入到<code>header</code>的后面。</li>
<li>在说一下关于双向链表的删除，我们知道平常都是调用<code>HashMap.remove(obj)</code>来进行键值对的删除的，看过我之前写的<a href="http://kubicode.me/2015/03/27/Java-HashMap/" target="_blank" rel="external">HashMap</a>的小伙伴都知道其实是调用了<code>removeEntryForKey</code>方法才进行真正的查找删除，该删除时又会调用<code>recordRemoval</code>方法，该方法在<code>HashMap.Entry</code>中是一个没有任何实现的方法，在<code>LinkedHashMap.Entry</code>中进行重写，直接调用<code>remove</code>方法进行链表节点的删除。</li>
</ul>
<h2 id="LinkedHashIterator">LinkedHashIterator</h2><p>不用多说，经历了上面层层的重写之后，<code>LinkedHashMap</code>最终是靠这个迭代器来实现保序遍历的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; nextEntry    = header.after;</span><br><span class="line">    Entry&lt;K,V&gt; lastReturned = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="javadoc">/**</span><br><span class="line">     * The modCount value that the iterator believes that the backing</span><br><span class="line">     * List should have.  If this expectation is violated, the iterator</span><br><span class="line">     * has detected concurrent modification.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextEntry != header;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line"></span><br><span class="line">        LinkedHashMap.<span class="keyword">this</span>.remove(lastReturned.key);</span><br><span class="line">        lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt; nextEntry() &#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (nextEntry == header)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">        Entry&lt;K,V&gt; e = lastReturned = nextEntry;</span><br><span class="line">        nextEntry = e.after;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有了上面维护的双向链表之后，保序的迭代器也变得异常简单了，从上面的源码中可以很清晰的看到该迭代器每次都是使用<code>e.after</code>作为<code>next</code>的值，而这个双向链表是有序的（默认是插入序，也可以设置成访问序），所以在遍历<code>LinkedHashMap</code>时可以保序取值。</p>
<h2 id="实现LRUCache">实现LRUCache</h2><p><a href="http://baike.baidu.com/link?url=tS6nKqjNDes0mdnSwehA1oGo4XcKRcrI3wzunHLRa0VUTf9ByHj4E6AF4hKOtrxnBhm9qaPCvcjX59mSChOxIq" target="_blank" rel="external">LRUCache</a>是一种常用的缓存策略，该策略的原理就是当缓存容量满时删除掉最少使用的缓存，这个算法可以使用<code>LinkedHashMap</code>来很方便的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 实现基于LinkedHashMap的LRUCache</span><br><span class="line"> *<span class="javadoctag"> @author</span> yyl</span><br><span class="line"> *</span><br><span class="line"> *<span class="javadoctag"> @param</span> &lt;K&gt;</span><br><span class="line"> *<span class="javadoctag"> @param</span> &lt;V&gt;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxCacheNum=<span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> length)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(<span class="number">10</span>,<span class="number">0.75f</span>,<span class="keyword">true</span>);<span class="comment">//这里第三个参数一定要为true，这样就表示该LinkedHashMap是使用了访问速度来链表</span></span><br><span class="line">		<span class="keyword">this</span>.maxCacheNum=length;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 重写删除最少用元素的方法</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="annotation">@Override</span> </span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size()&gt;maxCacheNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里只需要重写<code>removeEldestEntry</code>这个方法即可，该方法在添加元素的时候会被调用，如果当前链表中的元素个数大于设定的最大个数，则删除最少使用的元素。注意 这个缓存在构造<code>LinkedHashMap</code>的时候一定要将<code>accessOrder</code>设置为<code>true</code>，这样<code>LinkedHashMap</code>的双向链表就会维护一个访问顺序的链表。</p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://tomyz0223.iteye.com/blog/1035686" target="_blank" rel="external">http://tomyz0223.iteye.com/blog/1035686</a></li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><code>LinkedHashMap</code>是基于<code>HashMap</code>实现的，但是与之不同的是<code>LinkedHashMap</code>在遍历取值时可以保序，这是通过双向链表来实现的。</p>
</blockq]]>
    </summary>
    
      <category term="Java" scheme="http://yyl8781697.github.io/tags/Java/"/>
    
      <category term="Java Source" scheme="http://yyl8781697.github.io/categories/Java-Source/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 源码学习之java.util.HashSet]]></title>
    <link href="http://yyl8781697.github.io/2015/04/14/Java%20Source/Java-HashSet/"/>
    <id>http://yyl8781697.github.io/2015/04/14/Java Source/Java-HashSet/</id>
    <published>2015-04-14T08:06:15.000Z</published>
    <updated>2015-04-25T07:19:16.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><code>HashSet</code>在针对单个项的增删改几乎具有O(1)的性能，也常常被用于快速查找需要下的集合存储，相信各位这些特性很容易联想到<code>HashMap</code>，那么各位了解这两者的区别和联系不？</p>
</blockquote>
<p>看了源代码估计大家会大吃一惊，这，这<code>HashSet</code>不就是<code>HashMap</code>的简化无<code>value</code>版本嘛？对，<code>HashSet</code>就是基于<code>HashMap</code>实现的(通过组合的方式)，并且几乎所有方法都是调用了<code>HashMap</code>的<code>api</code>，最大的区别是将<code>HashMap</code>的<code>value</code>直接用<code>new Object()</code>对象来替换了。所以你可以这么认为：<br><br><code>HashSet&lt;T&gt; hashSet=new HashMap&lt;T,Object&gt;()</code></p>
<h2 id="构造函数">构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5024744406713321676L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;<span class="comment">//这就是存储HashSet的实体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span><br><span class="line"> * default initial capacity (16) and load factor (0.75).</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * Constructs a new set containing the elements in the specified</span><br><span class="line"> * collection.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with default load factor</span><br><span class="line"> * (0.75) and an initial capacity sufficient to contain the elements in</span><br><span class="line"> * the specified collection.</span><br><span class="line"> *</span><br><span class="line"> *<span class="javadoctag"> @param</span> c the collection whose elements are to be placed into this set</span><br><span class="line"> *<span class="javadoctag"> @throws</span> NullPointerException if the specified collection is null</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span><br><span class="line"> * the specified initial capacity and the specified load factor.</span><br><span class="line"> *</span><br><span class="line"> *<span class="javadoctag"> @param</span>      initialCapacity   the initial capacity of the hash map</span><br><span class="line"> *<span class="javadoctag"> @param</span>      loadFactor        the load factor of the hash map</span><br><span class="line"> *<span class="javadoctag"> @throws</span>     IllegalArgumentException if the initial capacity is less</span><br><span class="line"> *             than zero, or if the load factor is nonpositive</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span><br><span class="line"> * the specified initial capacity and default load factor (0.75).</span><br><span class="line"> *</span><br><span class="line"> *<span class="javadoctag"> @param</span>      initialCapacity   the initial capacity of the hash table</span><br><span class="line"> *<span class="javadoctag"> @throws</span>     IllegalArgumentException if the initial capacity is less</span><br><span class="line"> *             than zero</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中可以发现<code>HashSet</code>是使用<code>HashMap</code>来存储的，并且在各个构造函数中均是直接初始化<code>HashMap</code>。</p>
<h2 id="add,contains方法">add,contains方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains the specified element.</span><br><span class="line"> * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this set</span><br><span class="line"> * contains an element &lt;tt&gt;e&lt;/tt&gt; such that</span><br><span class="line"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;.</span><br><span class="line"> *</span><br><span class="line"> *<span class="javadoctag"> @param</span> o element whose presence in this set is to be tested</span><br><span class="line"> *<span class="javadoctag"> @return</span> &lt;tt&gt;true&lt;/tt&gt; if this set contains the specified element</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * Adds the specified element to this set if it is not already present.</span><br><span class="line"> * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if</span><br><span class="line"> * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that</span><br><span class="line"> * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.</span><br><span class="line"> * If this set already contains the element, the call leaves the set</span><br><span class="line"> * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.</span><br><span class="line"> *</span><br><span class="line"> *<span class="javadoctag"> @param</span> e element to be added to this set</span><br><span class="line"> *<span class="javadoctag"> @return</span> &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified</span><br><span class="line"> * element</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>HashSet</code>两个最常用方法的源码中也可以看到，<code>contains</code>方法其实就是调用了<code>containsKey</code>，复杂度为<code>O(1)</code>，而<code>add</code>方法在插入值的时候是使用了<code>put(e,PRESENT)</code>来操作，这个<code>PRESENT</code>其实是一个<code>Object</code>的常量。<br><br>其余方法也不再多看，基本和上面的一个套路。</p>
<h2 id="总结">总结</h2><p>为什么<code>HashSet</code>在实现上是完全用了<code>HashMap</code>的<code>api</code>的，一个<code>Key-Value</code>型，一个<code>Key</code>型，除了这种转换有没有其他可以更加高效的方法呢？<br>（下面只是LZ想想的，个人想法而已）<br><code>HashMap</code>使用了链表+数组的方式实现了<code>Key-Value</code>的存储，其增删改的性能已经几乎接近了<code>O(1)</code>，而<code>HashSet</code>的出现时为了存储<code>Key</code>型的数据，被<code>Key-Value</code>包含在内，完全可以使用<code>HashMap</code>来实现，至于这里使用常量<code>Object</code>来替换里面的<code>value</code>，我们都知道常量<code>Object</code>都是存储在方法区中，并且这里只有一份副本，<code>HashSet</code>存在多个项并不会增加方法区中的存储，所以关于<code>Object</code>的替换产生的开销很好，并且<code>HashMap</code>在原理已经很好了，没必要再去重复造轮子，所以个人觉得<code>HashSet</code>在实现上用了<code>HashMap</code>的封装还是比较合理的。<br><br>那么既然<code>HashSet</code>是基于<code>HashMap</code>先实现的，那么它也应该有如下几大特征：</p>
<ul>
<li>多线程不安全</li>
<li>项的增删改查的复杂度几乎为<code>O(1)</code>，所以也常被用于集合元素的查找</li>
<li>支持<code>null</code>的值</li>
<li><code>loadFactor</code>越大，<code>hash</code>冲突的概率越大，<code>table</code>的利用率越大，反之都越小</li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><code>HashSet</code>在针对单个项的增删改几乎具有O(1)的性能，也常常被用于快速查找需要下的集合存储，相信各位这些特性很容易联想到<code>HashMap</code>，那么各位了解这两者的区别和联系不？</p>
</bloc]]>
    </summary>
    
      <category term="Java" scheme="http://yyl8781697.github.io/tags/Java/"/>
    
      <category term="Java Source" scheme="http://yyl8781697.github.io/categories/Java-Source/"/>
    
  </entry>
  
</feed>