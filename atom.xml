<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Kubi Code'Blog]]></title>
  <subtitle><![CDATA[The palest ink is better than the best memory.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yyl8781697.github.io/"/>
  <updated>2015-06-26T14:24:31.000Z</updated>
  <id>http://yyl8781697.github.io/</id>
  
  <author>
    <name><![CDATA[Kubi Code]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[《Effective Java》第十章：并发]]></title>
    <link href="http://yyl8781697.github.io/2015/06/25/Effective%20Java/Concurrent/"/>
    <id>http://yyl8781697.github.io/2015/06/25/Effective Java/Concurrent/</id>
    <published>2015-06-25T02:41:45.000Z</published>
    <updated>2015-06-26T14:24:31.000Z</updated>
    <content type="html"><![CDATA[<p>线程机制是允许同时进行多个活动，并发程序设计比单线程程序设计要困难的多，因为有更多得东西可能会出错，也很难以重现失败。</p>
<h2 id="第66条：同步访问共享的可变数据">第66条：同步访问共享的可变数据</h2><p>关键字<code>synchronized</code>可以保证在同一时刻，只有一个线程可以执行某一个方法，或者某一个代码块，关于这点，有两方面的意义：</p>
<ol>
<li>当一个对象被一个线程修改的时候，可以阻止另一个线程观察到内部不一致的状态</li>
<li>它可以保证进入同步方法或者代码块的每个线程，都可以看到同一个锁保护之前所有的修改<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> stopRequented;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span><br><span class="line"></span>&#123;</span><br><span class="line">	Thread backgroundThread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(!stopRequented)</span><br><span class="line">				i++;</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">"the thread stop now!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	backgroundThread.start();</span><br><span class="line">	Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">	</span><br><span class="line">	stopRequented=<span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>看上面的代码，你运行的时候并没有按你期望的在3秒之后终止程序，这是因为<code>stopRequented</code>这个变量并没有同步，不能进行线程共享<br>虚拟机将那段循环代码可以转为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!stopRequented)</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">		i++;</span><br></pre></td></tr></table></figure></p>
<p>所以解决上述问题的方法就是将其同步：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> stopRequented;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用同步方法来将变量同步</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getStopRequented</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> stopRequented;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setStopRequented</span><span class="params">(<span class="keyword">boolean</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	stopRequented=b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span><br><span class="line"></span>&#123;</span><br><span class="line">	Thread backgroundThread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(!getStopRequented())</span><br><span class="line">					i++;</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">"the thread stop now!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	backgroundThread.start();</span><br><span class="line">	Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">	</span><br><span class="line">	setStopRequented(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一个更为简单的方法是使用共享 变量关键字<code>volatile</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stopRequented;</span><br></pre></td></tr></table></figure></p>
<p>但是<code>volatile</code>使用时得慎用，因为它只保证了关键字的变量是共享的，但是如果涉及其他操作可能会出现问题，比如<code>++</code></p>
<blockquote>
<p>所以还是建议使用<code>synchronized</code>关键字进行同步</p>
</blockquote>
<p>简而言之，当多个线程共享数据时，要么直接共享不可变数据，但是如果在共享可变数据的时候，每个读或者写数据的线程必须执行同步，否则会出现非常多意向不到的问题。</p>
<h2 id="第67条：避免过度的同步">第67条：避免过度的同步</h2><blockquote>
<p>同步虽好，但也不能滥用，过度的同步可能会导致性能降低、死锁，甚至不确定行为</p>
</blockquote>
<p>先来看下面一个简单的观察者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observable</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(ObservableSet&lt;E&gt; set,E e,String action)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableSet</span>&lt;<span class="title">E</span>&gt;</span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;E&gt; list=<span class="keyword">new</span> ArrayList&lt;E&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;Observable&lt;E&gt;&gt; observers=<span class="keyword">new</span> ArrayList&lt;Observable&lt;E&gt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 添加观察者</span><br><span class="line">	 *<span class="javadoctag"> @param</span> o</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observable&lt;E&gt; o)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(observers)</span><br><span class="line">		&#123;</span><br><span class="line">			observers.add(o);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 移除观察者</span><br><span class="line">	 *<span class="javadoctag"> @param</span> o</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observable&lt;E&gt; o)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(observers)</span><br><span class="line">		&#123;</span><br><span class="line">			observers.remove(o);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notefiyAll</span><span class="params">(E e,String action)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(observers)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(Observable&lt;E&gt; o:observers)</span><br><span class="line">				o.notify(<span class="keyword">this</span>, e,action);<span class="comment">//通知</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		list.add(e);</span><br><span class="line">		notefiyAll(e,<span class="string">"add"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你是这么调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span><br><span class="line"></span>&#123;</span><br><span class="line">	ObservableSet&lt;Integer&gt; os=<span class="keyword">new</span> ObservableSet&lt;Integer&gt;();</span><br><span class="line">	os.addObserver(<span class="keyword">new</span> Observable&lt;Integer&gt;()&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(ObservableSet&lt;Integer&gt; set,Integer e,String action)</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"notify:"</span>+action+<span class="string">" "</span>+e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">		os.add(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以得到正确的结果，但是如果有人使坏。。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">os.addObserver(<span class="keyword">new</span> Observable&lt;Integer&gt;()&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(ObservableSet&lt;Integer&gt; set,Integer e,String action)</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"notify:"</span>+action+<span class="string">" "</span>+e);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(e==<span class="number">3</span>)</span><br><span class="line">				set.removeObserver(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure></p>
<p>你便会收到<code>ConcurrentModificationException</code>的异常，这是因为它在遍历过程中对集合元素进行了修改，但是<code>synchronized</code>关键词并无法防止迭代器本身回调到可观察的迭代器中。</p>
<blockquote>
<p>其实估计到了这里有人会问：为什么这里不会发生死锁？<br>因为Java的锁是可以重入的，调用这个程序已经有锁了，因此当该线程试图再次获取该锁时会成功</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">os.addObserver(<span class="keyword">new</span> Observable&lt;Integer&gt;()&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(<span class="keyword">final</span> ObservableSet&lt;Integer&gt; set,Integer e,String action)</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"notify:"</span>+action+<span class="string">" "</span>+e);</span><br><span class="line">			<span class="keyword">if</span>(e==<span class="number">3</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">final</span> Observable&lt;Integer&gt; o=<span class="keyword">this</span>;</span><br><span class="line">				</span><br><span class="line">				ExecutorService executor=Executors.newSingleThreadExecutor();</span><br><span class="line">				<span class="keyword">try</span></span><br><span class="line">				&#123;</span><br><span class="line">					 executor.execute(<span class="keyword">new</span> Runnable()&#123;<span class="comment">//另开一个线程去执行移除操作</span></span><br><span class="line">						 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span><br><span class="line">						 </span>&#123;</span><br><span class="line">							 set.removeObserver(o);</span><br><span class="line">						 &#125;</span><br><span class="line">					 &#125;);</span><br><span class="line">				&#125;<span class="keyword">catch</span>(Exception ex)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(ex.getCause());</span><br><span class="line">				&#125;<span class="keyword">finally</span></span><br><span class="line">				&#123;</span><br><span class="line">					executor.shutdown();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
<p>如果你添加了上述观察者，你就会发现程序就会发生死锁，这是因为后台线程调用了<code>set.removeObserver(o);</code>，它企图锁定<code>observers</code>，但是它无法获得该锁，因为主线程已经有锁了，在这期间主线程一直在等待后台线程完成对观察者的删除，然后就砰，发生死锁了。</p>
<p>关于上述问题的解决，可以使用快照：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notefiyAll</span><span class="params">(E e,String action)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	List&lt;Observable&lt;E&gt;&gt; snapshot=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">synchronized</span>(observers)</span><br><span class="line">	&#123;</span><br><span class="line">		snapshot=<span class="keyword">new</span> ArrayList&lt;Observable&lt;E&gt;&gt;(observers);<span class="comment">//创建快照  其实就是副本</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(Observable&lt;E&gt; o:snapshot)</span><br><span class="line">		o.notify(<span class="keyword">this</span>, e,action);<span class="comment">//通知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>貌似还有可以使用<code>CopyOnWriteArrayList</code>来代替<code>ArrayList</code>，他是通过重新拷贝整个底层数组，在这里实现所有的写操作，由于内部永远不会改动，因此也不需要锁定。（Amz  ^_^）</p>
<p>简而言之，为了避免死锁和数据破坏，尽量限制同步区域内部的工作量。</p>
<h2 id="第68条：executor和task优于线程">第68条：executor和task优于线程</h2><blockquote>
<p>相比<code>Thread</code>而言，本条推荐使用<code>Executor</code></p>
</blockquote>
<p>因为：</p>
<ol>
<li><code>Thread</code>在复杂的需求下需要很多代码来进行精细的控制</li>
<li><code>Executor</code>可以创建工作队列，并进行管理，销毁</li>
<li><code>Executor</code>可以使用<code>executor.execute(args)</code>来支持<code>Runable</code>和<code>callable</code>的方法</li>
<li><code>Executor</code>可以使用<code>executor.shutdown</code>进行优雅的关闭</li>
<li>对于小程序，可以使用<code>Executors.newCachedThreadPool</code>来高效的完成工作</li>
<li>对于大负载的服务器，最好使用<code>Executors.newFixedThreadPool</code></li>
</ol>
<blockquote>
<p>其实<code>Executor</code>感觉起来就是<code>Thread</code>外围的一个封装，提供了创建，管理，关闭等功能，用起来方便而已，不过相信大公司还都是实现自己的线程池</p>
</blockquote>
<h2 id="第69条：并发工具优于wait和notify">第69条：并发工具优于wait和notify</h2><p>Java1.5 以后，应该使用<code>java.util.concurrent</code>包里面的工具来代替<code>wait</code>和<code>notify</code>了，这些工具主要分为三类：</p>
<ol>
<li>Executor Framework</li>
<li>并发集合(Concurrent Collection)</li>
<li>同步器(Synchronizer)</li>
</ol>
<p>这是因为他们提供更加友好以及便捷的API，还有号称更加快的速度（质疑。。。），还有用这些工具实现并发不容易出错（赞同）</p>
<blockquote>
<p>这些工具的简单介绍还是去看书的，它讲的比较散，就不累赘了</p>
</blockquote>
<p>直接来总结：直接使用<code>wait</code>和<code>notify</code>就像用“并发汇编语言”进行编程一样，而<code>java.util.concurrent</code>则提供了更高级的语言。如果真的要使用<code>wait</code>和<code>notify</code>，那么切记要在<code>while</code>循环内部去调用<code>wait</code>，一般情况下，应该优先使用<code>notifyAll</code></p>
<h2 id="第70条：线程安全性的文档化">第70条：线程安全性的文档化</h2><blockquote>
<p>月经建议，因为有异常的文档化、继承的文档化、方法的文档化^_^，这也凸显出了文档化得重要性</p>
</blockquote>
<p>通过查看文档中是否出现<code>synchronized</code>修饰符来判断方法是否是线程安全，这个是错误的，因为：</p>
<ol>
<li>在正常的操作中，javadoc并没有在他的输出中包含<code>synchronized</code></li>
<li>线程安全并不是“要么全有要么全无”，实际上它是有多种安全级别的</li>
</ol>
<p>所以线程的安全级别是文档中非常重要的说明：</p>
<ol>
<li>不可变的：也就是不需要额外的同步</li>
<li>无条件的线程安全：实例是可变的，但是这个类有着足够的内部同步，所以可以被并发使用</li>
<li>有条件的线程安全：除了有些方法为进行安全的冰法使用而需要额外的同步之外，这种线程安全级别与无条件的线程安全级别相同</li>
<li>非线程安全：你必须自己使用并发手段来让他支持并发</li>
<li>线程是对立的：好了，这个类你不管如何做线程都是不安全的-_-（通常是由于没有同步静态数据）</li>
</ol>
<p>类的线程安全说明通常放在他的文档注释中，但是带有特殊线程安全属性的方法则应该在他们自己的文档注释中说明他们的属性。</p>
<p>简而言之：每个类都应该利用字斟句酌的说明线程安全的注解，清楚地在文档中说明他的线程安全属性。</p>
<h2 id="第71条：慎用延迟初始化">第71条：慎用延迟初始化</h2><p>延迟初始化时延迟到需要域的值的时候才将它初始化的这种情况，如果永远不需要这个值，这个域就永远不会被初始化。</p>
<p>但是就像大多数优化一样，对于延迟初始化，最好的建议是“除非绝对必要，否则就不要这么做”。</p>
<p>关于延迟初始化，有大概以下几种方法：</p>
<ul>
<li><p>同步访问方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> FieldType field;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> FieldType <span class="title">getFiled</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(field==<span class="keyword">null</span>)</span><br><span class="line">		field = computeFiledValue();</span><br><span class="line">	<span class="keyword">return</span> field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  该方法最简单，也是最清楚</p>
</li>
<li><p>静态域的延迟初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHoler</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> FieldType field = computeFieldValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> FieldType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> FieldHoler.field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  当getField第一次调用的时候，会读取FieldHoler.field，导致FieldHoler得到初始化，该方法最大的魅力就是不需要同步关键字啊（的确是最大的魅力）</p>
</li>
<li><p>双重检查模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;<span class="comment">//注意要加共享关键字，因为他被初始化之后就不会有锁</span></span><br><span class="line"><span class="function">FieldType getFieldType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">	FieldType result = field;</span><br><span class="line">	<span class="keyword">if</span>(result == <span class="keyword">null</span>)<span class="comment">//第一次检查，看这个域是否被初始化了</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;<span class="comment">//枷锁进行第二次检查</span></span><br><span class="line">			result = field;</span><br><span class="line">			<span class="keyword">if</span>(result == <span class="keyword">null</span>)<span class="comment">//再次判断有没有被初始化</span></span><br><span class="line">			&#123;</span><br><span class="line">				field = result = computeFieldValue();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  该方法的性能很高，可以避免域初始化之后的锁定开销</p>
</li>
<li><p>单重检查模式</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line"><span class="function">FieldType getFieldType <span class="title">getField</span><span class="params">()</span></span>&#123;</span><br><span class="line">	FieldType result = field;</span><br><span class="line">	<span class="keyword">if</span>(result == <span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		field = result = computeFieldValue();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这种方式是要允许这个字段可以被多个线程设置值</p>
</li>
</ul>
<p>其实说了那么多，都说本条的建议是慎用初始化了，所以大多数情况下，这样用是要优于延迟初始化的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rivate <span class="keyword">final</span> FieldType field = computeFieldValue();</span><br></pre></td></tr></table></figure></p>
<p>简而言之：大多数的域应该正常的进行初始化，而不是延迟初始化（感觉也是，除非有特殊情况，不然正常初始化用的放心啊^_^）</p>
<h2 id="第72条：不要依赖于线程调度器">第72条：不要依赖于线程调度器</h2><p>要编写健壮的、响应良好的、可移植的多应用程序，最好的办法是确保可运行的线程的平均数量不明显多余处理器的数量，这样线程调度器就没有更多的选择，你的程序也不会因为更换了环境而影响了性能。</p>
<h2 id="第73条：避免使用线程组">第73条：避免使用线程组</h2><p>线程组的初衷是作为一种隔离applet的机制，当然他是出于安全考虑的，但是现在的线程组的安全价值已经差到根本不在<code>java</code>安全模型的标准工作中提及的地步，并且它还没有很多的功能，而且它们提供许多功能还都是很有缺陷的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>线程机制是允许同时进行多个活动，并发程序设计比单线程程序设计要困难的多，因为有更多得东西可能会出错，也很难以重现失败。</p>
<h2 id="第66条：同步访问共享的可变数据">第66条：同步访问共享的可变数据</h2><p>关键字<code>synchronized</]]>
    </summary>
    
      <category term="Java" scheme="http://yyl8781697.github.io/tags/Java/"/>
    
      <category term="Effective Java" scheme="http://yyl8781697.github.io/categories/Effective-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Effective Java》第九章：异常]]></title>
    <link href="http://yyl8781697.github.io/2015/06/24/Effective%20Java/Exception/"/>
    <id>http://yyl8781697.github.io/2015/06/24/Effective Java/Exception/</id>
    <published>2015-06-23T23:30:23.000Z</published>
    <updated>2015-06-24T11:26:38.000Z</updated>
    <content type="html"><![CDATA[<p>充分发挥异常的优点，可以提高程序的可读性、可靠性和可维护性。如果使用不当，它们也会带来负面影响。</p>
<h2 id="第57条：只针对异常的情况下使用异常">第57条：只针对异常的情况下使用异常</h2><p>先看下如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">		range[i++].climd();</span><br><span class="line">&#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此代码看的如此蛋疼，使用异常来跳过数组越界，其实完全可以用下面的代码代替<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Mountain m:range)</span><br><span class="line">			m.climb();</span><br></pre></td></tr></table></figure></p>
<p>简单明了（我想上面的例子大家都能看出孰优孰劣）<br>不推荐第一种写法的原因是：</p>
<ol>
<li>因为异常机制的设计初衷是用于不正常情形，所以很少会有<code>JVM</code>实现试图对它们进行优化，使得与显示的测试一样快速</li>
<li>把代码放在<code>try-catch</code>块中反而阻止了现代<code>JVM</code>实现本来可能要执行的某些特征优化</li>
<li>对数组进行遍历的标准模式并不会导致冗余检查。有些现代的<code>JVM</code>实现会将它们优化掉</li>
</ol>
<blockquote>
<p>所以，异常应该只用于异常的情况下，它们永远不应该用于正常的控制流</p>
</blockquote>
<h2 id="第58条：对可恢复的情况使用首检异常，对编程错误使用运行时异常">第58条：对可恢复的情况使用首检异常，对编程错误使用运行时异常</h2><p>Java提供了三种可抛出的结构：</p>
<ol>
<li>受检的异常(checked exception)—<code>Exception</code>的子类</li>
<li>运行时异常(run-time exception)—<code>RuntimeException</code>的子类</li>
<li>错误(error)—<code>Error</code>的子类</li>
</ol>
<p>如果期望调用者能够适当得恢复，对于这种情况应该使用受检的异常。通过抛出受检的异常，强迫调用者在一个<code>catch</code>子句中处理该异常，或者将其传播出去。</p>
<p>对于非受检的异常，往往就是属于不可恢复的情形，继续执行下去有害无益。</p>
<ul>
<li>大多数运行时异常都表示前提违例，所谓的前提违例是指没有遵循API中规范建立的约定。例如数组访问的约定指明了下标值必须在零到数组长度之间，不然就会抛<code>ArrayIndexOutBoundsException</code>。</li>
<li>按照惯例，错误往往是表示资源不足、约束失败，或者其他程序无法继续执行的条件。</li>
</ul>
<p>总而言之，对于可恢复的情况，使用受检的异常，对于程序错误，使用运行时异常。</p>
<h2 id="第59条：避免不必须要使用受检的异常">第59条：避免不必须要使用受检的异常</h2><blockquote>
<p>我只想对作者说，wtf，本条都被你翻译得看不懂了-_-</p>
</blockquote>
<p>受检的异常虽好，但是千万别滥用，由于每抛出一个受检的异常，使用者都需要去<code>catch</code>它或者再次抛出去，所以如果能避免这种异常则应该尽量避免，这个时候你可以考虑重构。<br>比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">	obj.action(args);</span><br><span class="line">&#125;<span class="keyword">catch</span>(TheCheckedException e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以重构为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj.actionpermitted(args))<span class="comment">//进行相关处理检查</span></span><br><span class="line">&#123;</span><br><span class="line">	obj.action(args)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="comment">//处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然这个重构只是一个例子，这种重构也并不是万能的。</p>
<h2 id="第60条：优先使用标准的异常">第60条：优先使用标准的异常</h2><p>本条的意思是就算你再牛，也还是建议使用标准的异常而不是自定义的异常，除非标准的异常真的无法满足你的需求，因为：</p>
<ul>
<li>标准的异常已经为广大程序猿熟知</li>
<li>可以使你的API更加易于学习和使用</li>
<li>异常类越少，装在这些类的时间开销也越小(这条是不是有点牵强了，一个大项目中应该不会因为几个自定义的异常类而导致性能差吧-_-)</li>
</ul>
<p>下面对几个最常使用的异常：</p>
<ul>
<li><code>IllegalAargumentException</code>：非<code>null</code>参数值不正确</li>
<li><code>IllegalStateException</code>：对于方法调用而言，对象状态不合适</li>
<li><code>NullPointException</code>：在禁止使用<code>null</code>的情况下参数值为<code>null</code></li>
<li><code>IndexOutOfBoundsException</code>：下标参数值越界</li>
<li><code>ConcurrentModificationException</code>：在禁止冰法修改的情况下，检测到对象的并发修改（在迭代器里面修改了原始数据的值就会抛）</li>
<li><code>UnsupportedOperationException</code>：对象不支持用户请求的方法</li>
</ul>
<p>这里在使用具体异常中并有精确的标准，只是在选取的时候选一个最合适的^_^</p>
<h2 id="第61条：抛出与抽象相对应的异常">第61条：抛出与抽象相对应的异常</h2><p>在调用高层的API时不应该抛出低层的异常，否则会使人不知所措，同时会暴露低层里面的相关实现细节，这个时候就需要异常转译，比如以<code>AbstractSequentialList</code><br>实现了<code>List</code>这个接口，它里面的一个<code>get</code>方法就进行了异常转译：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * Returns the element at the specified position in this list.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This implementation first gets a list iterator pointing to the</span><br><span class="line"> * indexed element (with &lt;tt&gt;listIterator(index)&lt;/tt&gt;).  Then, it gets</span><br><span class="line"> * the element using &lt;tt&gt;ListIterator.next&lt;/tt&gt; and returns it.</span><br><span class="line"> *</span><br><span class="line"> *<span class="javadoctag"> @throws</span> IndexOutOfBoundsException &#123;@inheritDoc&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listIterator(index).next();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);<span class="comment">//这里抛出了更加高层的异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然时候是希望能看到低层的异常，这样可以用于调试，那么你可以使用异常链：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...to something</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(LowerLevelException cause)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//这里抛出高层的异常中会带有低层异常的信息</span></span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> HighLevelException(cause)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>异常转译和异常链也不能被滥用，如果可能，处理来自低层异常的最好做法就是在调用低层方法之前确保它们会执行成功，从而避免它们抛出异常，比如在执行低层方法之前先对需要传递参数的检查就是一个好的方法。</p>
<h2 id="第62条：每个方法抛出的异常都要有文档">第62条：每个方法抛出的异常都要有文档</h2><p>这条的名称就是最好的建议^_^</p>
<ul>
<li>使用要单独的声明受检的异常，并且利用JavaDoc的@throw标记，准确的记录下抛出异常的每个条件（个人感觉非常重要，用这种文档的API就会非常的舒心）</li>
<li>使用JavaDoc的@throws标签记录下一个方法可能抛出的一个未受检异常，但是不要使用throws关键字将未受检的异常包含在方法的声明中（注意@throws标签和throws关键字的区别）</li>
<li>如果一个类中许多方法出于同样的原因而抛出同一个异常，在该类的文档注释中对这个异常建立文档，而不是在每个方法上都去标注（这条不错^_^）</li>
</ul>
<h2 id="第63条：在细节消息中包含能捕获失败的信息">第63条：在细节消息中包含能捕获失败的信息</h2><p>异常数据中最有用的是那些导致异常的硬数据，以<code>IndexOutOfBoundsException</code>为例，该异常抛出时就应该有正确的上界，下界以及没有落入界内的下标值，这样就可以非常轻松的让开发人员了解异常出现的原因以及如何去fix它.</p>
<p>为了确保异常在细节描述中包含足够能捕获失败的信息，最好的方法是在异常的构造器而不是字符串细节中引用这些消息（因为这些字符串细节其实并没有什么卵用），比如<code>IndexOutOfBoundsException</code>就包含了具体参数的构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IndexOutOfBoundsException</span><span class="params">(<span class="keyword">int</span> lowerBound,<span class="keyword">int</span> upperBound,<span class="keyword">int</span> index)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">super</span>(<span class="string">"Lower Bound:"</span>+lowerBound+</span><br><span class="line">			<span class="string">",Upper bound:"</span>+upperBound+</span><br><span class="line">			<span class="string">",Index:"</span>+index);</span><br><span class="line">			</span><br><span class="line">	<span class="keyword">this</span>.lowerBound=lowerBound;</span><br><span class="line">	<span class="keyword">this</span>.upperBound=upperBound;</span><br><span class="line">	<span class="keyword">this</span>.index=index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种构造函数相对于接收字符串类型的构造函数来说更加易于描述异常出现的情况。</p>
<blockquote>
<p>但是我看了JDK源码，<code>IndexOutOfBoundsException</code>并没有这个构造函数啊-_-</p>
</blockquote>
<h2 id="第64条：努力使失败保持原子性">第64条：努力使失败保持原子性</h2><p>当对象抛出异常之后，通常我们期望这个对象仍然保持在一个定义良好的可用状态之中。一般而言，失败的而方法调用应该是对象保持在被调用之前的状态，具有这种属性的方法被称为具有失败原子性。</p>
<p>如果对象时不可变的，那么在方法失败之后该原子性一定还是保持的。<br>如果对象时可变的，就有如下四种方法可以保持原子性：</p>
<ol>
<li>在执行操作之前检查参数的有效性</li>
<li>调整计算处理过程中的顺序，是的任何可能会失败的计算部分在对象被修改之前发生</li>
<li>编写一段回复代码，有它来拦截操作过程中发生的失败，以及使对象回到到操作开始之前的状态上（较为麻烦，但可能是最有效的）</li>
<li>在对象的一份临时拷贝上执行操作，操作完成之后再用临时拷贝代替对象的内容（Collections.sort就是这么干的）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">    Object[] a = list.toArray();<span class="comment">//拷贝一份</span></span><br><span class="line">    Arrays.sort(a);<span class="comment">//排序</span></span><br><span class="line">    ListIterator&lt;T&gt; i = list.listIterator();<span class="comment">//再替换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;a.length; j++) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.set((T)a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为方法规范的一部分，产生的任何异常都应该让对象保持在该方法调用之前的状态。</p>
<h2 id="第65条：不要忽略异常">第65条：不要忽略异常</h2><blockquote>
<p>好比将火警的信号器关掉了，当真正发生火灾的时候，就没有人能看到火警信号了，这结果也许是灾难性的。(形象^_^)</p>
</blockquote>
<p>如果一定要忽略异常，你至少要在<code>catch</code>块中解释为什么可以忽略。<br>还有在关闭<code>FileInputStream</code>的时候，你可以忽略它的异常，因为你还没有改变文件的状态，因此不必执行任何回复动作。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>充分发挥异常的优点，可以提高程序的可读性、可靠性和可维护性。如果使用不当，它们也会带来负面影响。</p>
<h2 id="第57条：只针对异常的情况下使用异常">第57条：只针对异常的情况下使用异常</h2><p>先看下如下代码：<br><figure class="hig]]>
    </summary>
    
      <category term="Java" scheme="http://yyl8781697.github.io/tags/Java/"/>
    
      <category term="Effective Java" scheme="http://yyl8781697.github.io/categories/Effective-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最大子矩阵和的问题]]></title>
    <link href="http://yyl8781697.github.io/2015/06/23/Algorithm/Max-Sum-in-SubMatrix/"/>
    <id>http://yyl8781697.github.io/2015/06/23/Algorithm/Max-Sum-in-SubMatrix/</id>
    <published>2015-06-23T12:28:16.000Z</published>
    <updated>2015-06-23T13:03:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>现有矩阵：
0, -2, -7,  0, 3
9,  2, -6,  2, 5
-<span class="ruby"><span class="number">4</span>, <span class="number">1</span>, -<span class="number">4</span>,  <span class="number">1</span>, <span class="number">6</span>
</span>-<span class="ruby"><span class="number">1</span>, <span class="number">8</span>,  <span class="number">0</span>, -<span class="number">2</span>, <span class="number">2</span>
</span>求该矩阵的一个子矩阵，使子矩阵所有元素的和最大
</code></pre><h2 id="最大子序列">最大子序列</h2><p>在看最大子矩阵之前，先来看一下最大子序列的求解：</p>
<pre><code>给定一个长度为n的一维数组a，请找出此数组的一个子数组,使得此子数组的和sum＝<span class="tag">a</span>[i]+<span class="tag">a</span>[i+<span class="number">1</span>]+……+<span class="tag">a</span>[j]最大（<span class="number">0</span>&lt;=i&lt;=j&lt;=n-<span class="number">1</span>）
比如在序列-<span class="number">2</span>,<span class="number">11</span>,-<span class="number">4</span>,<span class="number">13</span>,-<span class="number">5</span>,-<span class="number">2</span>中，最大子序和为<span class="number">11</span>+(-<span class="number">4</span>)+<span class="number">13</span>=<span class="number">19</span>
</code></pre><p>求解该方法一般使用动态规划<code>b[j]=max{b[j-1]+a[j],a[j]}</code>，简化后的程序为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubSum</span><span class="params">(<span class="keyword">int</span>[] a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> maxSum=<span class="number">0</span>,curSum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		curSum+=a[i];</span><br><span class="line">		<span class="keyword">if</span>(curSum&gt;maxSum)</span><br><span class="line">		&#123;</span><br><span class="line">			maxSum=curSum;</span><br><span class="line">		&#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(curSum&lt;<span class="number">0</span>)</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			curSum=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该解法的复杂度为O(n)</p>
</blockquote>
<h2 id="最大子矩阵">最大子矩阵</h2><blockquote>
<p>最大子矩阵可以借鉴或者转为最大子序列</p>
</blockquote>
<p>假设已经当前最大子矩阵的行数为1，那么其实就是将矩阵分解为4行分别再用子序列求解即可，<br>那如果子矩阵的行数为2呢？我们可以分解为{0,1}行，{1,2}行，{2,3}行求最大和即可，<br>以{0,1}行为例子：<br>0, -2, -7,  0, 3<br>9,  2, -6,  2, 5<br>再该范围内再求最大子矩阵其实就是按列求和转为一维数组再求最大：<br>9,0,-13,2,8<br>就可以知道第3，4列构成的子矩阵为最大。<br>将此思路扩展开到r行，求解方法为将这r行按列求和转为一维矩阵再求最大和，这里的一维矩阵其实就是子列和<br>所以如果当前矩阵一共有N行，再求子矩阵问题时可能出现行的情况一共有(N^2)/2种，为了计算这些情况的子列和，需要加一个辅助矩阵：全部子列和（totalColSum）<br>0, -2, -7,  0, 3<br>9,  0, -13,  2, 8<br>5, 1, -17,  3, 14<br>4, 9,  -17, 1, 16</p>
<p>有了该辅助矩阵，我们就可以轻松求出指定列的子列和：</p>
<ul>
<li>假如当前的子矩阵是{0,1}行，可直接得到子列和为9,0,-13,2,8</li>
<li>假如当前的子矩阵是{1,2}行，可通过totalColSum的第2行减去第0行的数据而得5,3,-4,3,11</li>
</ul>
<p>所以上述思路的全部程序如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubSum2D</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> N, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum=Integer.MIN_VALUE;</span><br><span class="line">	<span class="keyword">int</span>[][] totalColSum = <span class="keyword">new</span> <span class="keyword">int</span>[N][M];<span class="comment">// 所有子列的和</span></span><br><span class="line">	<span class="keyword">int</span>[] subColSum=<span class="keyword">new</span> <span class="keyword">int</span>[M];<span class="comment">//子列的和</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">				totalColSum[i][j] = matrix[i][j];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				totalColSum[i][j] = totalColSum[i - <span class="number">1</span>][j] + matrix[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; N-<span class="number">1</span>; r++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = r; k &lt; N; k++) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>( r==<span class="number">1</span> &amp;&amp; k==<span class="number">3</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				System.out.println(<span class="string">""</span>);</span><br><span class="line">			&#125;</span><br><span class="line">				</span><br><span class="line">			<span class="comment">//构建子列</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(r==k)</span><br><span class="line">				&#123;</span><br><span class="line">					subColSum[j]=matrix[r][j];<span class="comment">//是求单行的情况</span></span><br><span class="line">				&#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(r==<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">					subColSum[j]=totalColSum[k][j];<span class="comment">//以0为起始行</span></span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					subColSum[j]=totalColSum[k][j]-totalColSum[r-<span class="number">1</span>][j];<span class="comment">//以非0为起始行，需要减去前面的</span></span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			sum=Math.max(sum, MaxSubSum.maxSubSum(subColSum));<span class="comment">//转为最大子段和</span></span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它最终的复杂度为O(N*N*M)</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>现有矩阵：
0, -2, -7,  0, 3
9,  2, -6,  2, 5
-<span class="ruby"><span class="number">4</span>, <span class="number]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Reducer端内存不足的情况下如何进行Hadoop的Join（百度面试题）]]></title>
    <link href="http://yyl8781697.github.io/2015/06/21/Hadoop/Hadoop-Join-but-No-Memory-in-Reducer/"/>
    <id>http://yyl8781697.github.io/2015/06/21/Hadoop/Hadoop-Join-but-No-Memory-in-Reducer/</id>
    <published>2015-06-21T00:45:01.000Z</published>
    <updated>2015-06-21T02:53:26.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code><span class="tag">Instance</span>的格式是：
<span class="tag">Lineid</span> <span class="tag">show</span> <span class="tag">clk</span> <span class="tag">fea1</span><span class="pseudo">:slot1</span> <span class="tag">fea2</span><span class="pseudo">:slot2</span> …
<span class="tag">Feature</span>的格式是：
<span class="tag">Fea1</span>\<span class="tag">tweight</span>
<span class="tag">Fea2</span>\<span class="tag">tweight</span>

现在要求计算每个<span class="tag">instance</span>的<span class="tag">feature</span>权重之和，但是<span class="tag">feature</span>数量极多，可能几千万或者几亿，总之无法放入内存。
</code></pre><h2 id="分析">分析</h2><ol>
<li>这是一道很典型的<code>Join</code>操作题目，但是由于是百度的面试题，肯定不会那么简单</li>
<li>假如将Instance作为大表，Feature作为小表，但是Feature已经无法放入内存了，就无法用<code>map-silde</code>来做<code>Join</code>了</li>
<li>所以只能用<code>reduce-silde</code>来做，但是这种方式在<code>Reducer</code>端输入的迭代器中会混杂着Feature的权重和LineId，并且是无序的，所以一般会遍历迭代器，然后将两者分离，但是问题就出在这里了，分离的时候要将LineId保存到一个容器里，这时候极有可能出现OOM，也就是在<code>Reducer</code>端内存不足</li>
</ol>
<h2 id="方法1：将key冗余输出">方法1：将key冗余输出</h2><p>上述分析不是应该要将迭代器重新拷贝到一个容器中才产生的OOM的嘛，那如果这个迭代器里面的数据量不多，拷贝一份也不会出现OOM的异常的话问题就解决了嘛。<br>具体做法就是：</p>
<pre><code>在Mapper端输出的时如果输出feature的话 就以<span class="keyword">N</span>份冗余的副本输出，比如fea1_1,fea1_2,...fea1_N.然后如果输出instance的时候在其key上随机加一个<span class="number">1</span>~<span class="keyword">N</span>的随机数后缀，以保证它在输出之后在Reducer端能与一个正常的feature进去一个迭代器中
</code></pre><p>用图解就是：<br><img src="/img/Hadoop-Join-but-No-Memory-in-Reducer/dup.jpg" alt=""></p>
<p>图(1)中红色区块在shuffle完成之后变得巨大，但是在图2种由于将key冗余输出，也就是将红色区块分而治之了</p>
<p>请允许我帖上全部代码。。。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 百度的面试题  Join的实践  但是任意两个表都无法完全放入内存</span><br><span class="line"> * 这里是用key冗余输出</span><br><span class="line"> *<span class="javadoctag"> @author</span> root</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaiduJoin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * Join的map方法</span><br><span class="line">	 * </span><br><span class="line">	 *<span class="javadoctag"> @author</span> root</span><br><span class="line">	 *</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">Text</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Text outputKey = <span class="keyword">new</span> Text();</span><br><span class="line">		</span><br><span class="line">		<span class="javadoc">/**</span><br><span class="line">		 * 输出副本 可以降低reducer端oom的概率</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DUPLICATE=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Context context)</span></span><br><span class="line">				<span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">			InputSplit s = context.getInputSplit();<span class="comment">// 这里是可以得到分片的name啊</span></span><br><span class="line">			<span class="keyword">if</span> (s.toString().indexOf(<span class="string">"instance"</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="comment">// 表示instance的名称</span></span><br><span class="line">				String[] data = value.toString().split(<span class="string">"\\s+"</span>);</span><br><span class="line">				Text lineId = <span class="keyword">new</span> Text(<span class="string">"l:"</span> + data[<span class="number">0</span>]);</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (data[i].indexOf(<span class="string">":"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">						outputKey.set(<span class="keyword">new</span> Text(data[i].split(<span class="string">":"</span>)[<span class="number">0</span>]</span><br><span class="line">								+(<span class="keyword">int</span>)(Math.random()*DUPLICATE)));<span class="comment">//用随机副本进行稀疏</span></span><br><span class="line">						System.out.println(outputKey.toString());</span><br><span class="line">						context.write(outputKey, lineId);<span class="comment">// 输出feature,lineid</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 表示feature</span></span><br><span class="line">				String[] data = value.toString().split(<span class="string">"\\t"</span>);</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;DUPLICATE;i++)</span><br><span class="line">				&#123;</span><br><span class="line">					outputKey.set(data[<span class="number">0</span>]+i);</span><br><span class="line">					context.write(outputKey, <span class="keyword">new</span> Text(<span class="string">"w:"</span> + data[<span class="number">1</span>]));<span class="comment">// 输出feature,weight</span></span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinReducer</span> <span class="keyword">extends</span></span><br><span class="line">			<span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">DoubleWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;Text&gt; values,</span><br><span class="line">				Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">			LinkedList&lt;String&gt; lindList=<span class="keyword">new</span> LinkedList&lt;String&gt;();<span class="comment">//最容易出现OOM的地方</span></span><br><span class="line">		    DoubleWritable weight=<span class="keyword">null</span>;</span><br><span class="line">		    <span class="keyword">for</span>(Text text:values)</span><br><span class="line">		    &#123;</span><br><span class="line">		        String str=text.toString();</span><br><span class="line">		        <span class="keyword">if</span>(str.indexOf(<span class="string">"l:"</span>)&gt;-<span class="number">1</span>)&#123;</span><br><span class="line">		            <span class="comment">//表示Linid</span></span><br><span class="line">		            lindList.add(str.split(<span class="string">"l:"</span>)[<span class="number">1</span>]);</span><br><span class="line">		        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		        	weight=<span class="keyword">new</span> DoubleWritable(Double.parseDouble(str.split(<span class="string">"w:"</span>)[<span class="number">1</span>]));<span class="comment">//得到对应feautre的权重</span></span><br><span class="line">		        &#125;</span><br><span class="line">		    &#125;</span><br><span class="line">		   </span><br><span class="line">		    <span class="keyword">for</span>(String lineId:lindList)</span><br><span class="line">		    &#123;</span><br><span class="line">		        context.write(<span class="keyword">new</span> IntWritable(Integer.parseInt(lineId)),weight);</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 按行輸出权重的map</span><br><span class="line">	 *<span class="javadoctag"> @author</span> root</span><br><span class="line">	 *</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LineOutMapper</span> <span class="keyword">extends</span></span><br><span class="line">			<span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">DoubleWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> IntWritable lineId = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> DoubleWritable weight=<span class="keyword">new</span> DoubleWritable();</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Context context)</span></span><br><span class="line">				<span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">			String[] data=value.toString().split(<span class="string">"\\t"</span>);</span><br><span class="line">			lineId.set(Integer.parseInt(data[<span class="number">0</span>]));</span><br><span class="line">			weight.set(Double.parseDouble(data[<span class="number">1</span>]));</span><br><span class="line">			context.write(lineId, weight);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 权重求和的reducer</span><br><span class="line">	 *<span class="javadoctag"> @author</span> root</span><br><span class="line">	 *</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightSumReducer</span> <span class="keyword">extends</span></span><br><span class="line">			<span class="title">Reducer</span>&lt;<span class="title">IntWritable</span>, <span class="title">DoubleWritable</span>,<span class="title">IntWritable</span>, <span class="title">DoubleWritable</span>&gt; </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> DoubleWritable result = <span class="keyword">new</span> DoubleWritable();</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(IntWritable key, Iterable&lt;DoubleWritable&gt; values,</span><br><span class="line">				Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">			<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (DoubleWritable val : values) &#123;</span><br><span class="line">				sum += val.get();</span><br><span class="line">			&#125;</span><br><span class="line">			result.set(sum);</span><br><span class="line">			context.write(key, result);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(args.length&lt;<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">"hello,the arguments length can't less 2"</span>);</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="javadoc">/**</span><br><span class="line">		 * 临时的一个目录</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="keyword">final</span> String TEMP_PATH=<span class="string">"/output/temp/"</span>+System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">		FileSystem fs=FileSystem.get(conf);</span><br><span class="line">		<span class="keyword">if</span>(fs.exists(<span class="keyword">new</span> Path(args[<span class="number">1</span>])))</span><br><span class="line">			fs.delete(<span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"start baidu join"</span>);</span><br><span class="line">		<span class="comment">//启动join 的一个job</span></span><br><span class="line">		Job job = Job.getInstance(conf, <span class="string">"baidu join"</span>);</span><br><span class="line">		job.setJarByClass(BaiduJoin.class);</span><br><span class="line">		job.setMapperClass(JoinMapper.class);</span><br><span class="line">		job.setReducerClass(JoinReducer.class);</span><br><span class="line">		job.setOutputKeyClass(Text.class);</span><br><span class="line">		job.setOutputValueClass(Text.class);</span><br><span class="line">		job.setNumReduceTasks(<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span>(String path:args[<span class="number">0</span>].split(<span class="string">";|,"</span>))</span><br><span class="line">			FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(path));<span class="comment">//多目录的输入 用空格隔开</span></span><br><span class="line">		FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(TEMP_PATH));</span><br><span class="line">		job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"start baidu join sum"</span>);</span><br><span class="line">		<span class="comment">//启动权重求和的job</span></span><br><span class="line">		Job jobSum = Job.getInstance(conf, <span class="string">"baidu join sum"</span>);</span><br><span class="line">		jobSum.setJarByClass(BaiduJoin.class);</span><br><span class="line">		jobSum.setMapperClass(LineOutMapper.class);</span><br><span class="line">		jobSum.setReducerClass(WeightSumReducer.class);</span><br><span class="line">		jobSum.setOutputKeyClass(IntWritable.class);</span><br><span class="line">		jobSum.setOutputValueClass(DoubleWritable.class);</span><br><span class="line">		jobSum.setNumReduceTasks(<span class="number">2</span>);</span><br><span class="line">		FileInputFormat.addInputPath(jobSum, <span class="keyword">new</span> Path(TEMP_PATH));</span><br><span class="line">		FileOutputFormat.setOutputPath(jobSum, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">		jobSum.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(fs.exists(<span class="keyword">new</span> Path(TEMP_PATH)))</span><br><span class="line">			fs.delete(<span class="keyword">new</span> Path(TEMP_PATH));<span class="comment">//在这里删除临时目录</span></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法2：二次排序法">方法2：二次排序法</h2><blockquote>
<p>我们知道OOM最大的挑战就是迭代器的拷贝，其实这个迭代器重就一个feature的权重以及海量的lineId，那如果能将这个weight放入迭代器中的首位，其不就可以避免拷贝了嘛。二次排序就可以完成此需求</p>
</blockquote>
<p>其实<code>Hadoop</code>在<code>Mapper</code>到<code>Reducer</code>端的时候本身就经历二次排序，第一次是在<code>Mapper</code>之后，第二次是在<code>Reducer</code>之前，但是他们都是对<code>key</code>进行排序，那如何影响到<code>value</code>呢，其实就是将<code>value</code>放进<code>key</code>中？</p>
<p>详情请看：<a href="http://www.cnblogs.com/xuxm2007/archive/2011/09/03/2165805.html" target="_blank" rel="external">mapreduce的二次排序 SecondarySort</a></p>
<p>按照上面的资料，我们先要建立自己的<code>key</code>的数据类型类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * 自定义的一个特征类型</span><br><span class="line"> * <span class="annotation">@author</span> root</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeatureWritable</span> <span class="keyword">implements</span> <span class="title">WritableComparable</span>&lt;<span class="title">FeatureWritable</span>&gt; </span>&#123;</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 特征名称</span><br><span class="line">	 */</span></span><br><span class="line">	String featureName=<span class="string">""</span>;</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 第二排序名称</span><br><span class="line">	 */</span></span><br><span class="line">	String secondName=<span class="string">""</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String featureName,String secondName)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.featureName=featureName;</span><br><span class="line">		<span class="keyword">this</span>.secondName=secondName;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getFeatureName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> featureName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSecondName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> secondName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		String line=in.readLine();</span><br><span class="line">		String[] data=line.split(<span class="string">"\\t"</span>);</span><br><span class="line">		<span class="keyword">this</span>.featureName=data[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">this</span>.secondName=data[<span class="number">1</span>];</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		String line=String.format(<span class="string">"%s\t%s"</span>, <span class="keyword">this</span>.featureName,<span class="keyword">this</span>.secondName);</span><br><span class="line">		out.write(line.getBytes());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 重写比较方法</span><br><span class="line">	 *<span class="javadoctag"> @param</span> o</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(FeatureWritable o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> ret=-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.featureName.compareTo(o.featureName)==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ret=-<span class="number">1</span>*<span class="keyword">this</span>.secondName.compareTo(o.secondName);<span class="comment">//这里是排序的重点 但是String比较代价大啊</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			ret=<span class="keyword">this</span>.featureName.compareTo(o.featureName);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.featureName.hashCode()&amp;<span class="keyword">this</span>.secondName.hashCode();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(o == <span class="keyword">null</span> || !(o <span class="keyword">instanceof</span> FeatureWritable))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		FeatureWritable fw=(FeatureWritable)o;</span><br><span class="line">		<span class="keyword">return</span> fw.featureName.equals(<span class="keyword">this</span>.featureName)</span><br><span class="line">				&amp;&amp;fw.secondName.equals(<span class="keyword">this</span>.secondName);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> String.format(<span class="string">"%s-%s"</span>,<span class="keyword">this</span>.featureName,<span class="keyword">this</span>.secondName);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再得自己实现一个分区函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeaturePartition</span> <span class="keyword">extends</span> <span class="title">Partitioner</span>&lt;<span class="title">FeatureWritable</span>,<span class="title">Text</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 重写分区的一个方法 分区只和特征名称有关 与具体的值无关</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(FeatureWritable fw, Text value, <span class="keyword">int</span> numPartitions)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> fw.getFeatureName().hashCode()&amp;<span class="number">0xFF</span>*<span class="number">127</span>%numPartitions;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为需要保证同一个feauteName的落到同一个桶中，不然都白搭了。</p>
<p>还需要自己实现一个分组类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 重写分组的一个比较器</span><br><span class="line"> *<span class="javadoctag"> @author</span> root</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupingComparator</span> <span class="keyword">extends</span> <span class="title">WritableComparator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">GroupingComparator</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(FeatureWritable.class, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 特征名称相同的分到一组中</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">    <span class="comment">//Compare two WritableComparables.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(WritableComparable w1, WritableComparable w2)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">		FeatureWritable fw1 = (FeatureWritable) w1;</span><br><span class="line">		FeatureWritable fw2 = (FeatureWritable) w2;</span><br><span class="line">        <span class="comment">//System.out.println(String.format("~~~~%s,%s,%s", fw1,fw2,fw1.getFeatureName().compareTo(fw2.getFeatureName())));</span></span><br><span class="line">		</span><br><span class="line">        <span class="keyword">return</span> fw1.getFeatureName().compareTo(fw2.getFeatureName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样才能让同一个featureName落入同一个迭代器中。<br>最后还要显示的设置你自定义的partition函数以及group函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 在这里设计自定义的partition 和 分组</span><br><span class="line"> */</span></span><br><span class="line">job.setPartitionerClass(FeaturePartition.class);</span><br><span class="line">job.setGroupingComparatorClass(GroupingComparator.class);</span><br></pre></td></tr></table></figure></p>
<p>初步工作就已经完成，现在按Join得大体框架就可以写代码了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 使用二次排序来解决join问题</span><br><span class="line"> *<span class="javadoctag"> @author</span> root</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaiduJoinSecondarySort</span> </span>&#123;</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * Join的map方法</span><br><span class="line">	 * </span><br><span class="line">	 *<span class="javadoctag"> @author</span> root</span><br><span class="line">	 *</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">FeatureWritable</span>, <span class="title">Text</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FeatureWritable outputKey = <span class="keyword">new</span> FeatureWritable();</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Context context)</span></span><br><span class="line">				<span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">			InputSplit s = context.getInputSplit();<span class="comment">// 这里是可以得到分片的name啊</span></span><br><span class="line">			<span class="keyword">if</span> (s.toString().indexOf(<span class="string">"instance"</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="comment">// 表示instance的名称</span></span><br><span class="line">				String[] data = value.toString().split(<span class="string">"\\s+"</span>);</span><br><span class="line">				Text lineId = <span class="keyword">new</span> Text(<span class="string">"l:"</span> + data[<span class="number">0</span>]);</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (data[i].indexOf(<span class="string">":"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">						outputKey.set(data[i].split(<span class="string">":"</span>)[<span class="number">0</span>], lineId.toString());</span><br><span class="line">						context.write(outputKey, lineId);<span class="comment">// 输出feature,lineid</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 表示feature</span></span><br><span class="line">				String[] data = value.toString().split(<span class="string">"\\t"</span>);</span><br><span class="line">			</span><br><span class="line">				outputKey.set(data[<span class="number">0</span>],<span class="string">"w:"</span> + data[<span class="number">1</span>]);</span><br><span class="line">				context.write(outputKey, <span class="keyword">new</span> Text(<span class="string">"w:"</span> + data[<span class="number">1</span>]));<span class="comment">// 输出feature,weight</span></span><br><span class="line">		</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinReducer</span> <span class="keyword">extends</span></span><br><span class="line">			<span class="title">Reducer</span>&lt;<span class="title">FeatureWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">DoubleWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IntWritable lineId=<span class="keyword">new</span> IntWritable();</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(FeatureWritable key, Iterable&lt;Text&gt; values,</span><br><span class="line">				Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line">		    DoubleWritable weight=<span class="keyword">null</span>;</span><br><span class="line">		    <span class="keyword">for</span>(Text text:values)</span><br><span class="line">		    &#123;</span><br><span class="line">		    	System.out.println(text);</span><br><span class="line">		    	String str=text.toString();</span><br><span class="line">		    	<span class="keyword">if</span>(weight==<span class="keyword">null</span> &amp;&amp; str.indexOf(<span class="string">"w"</span>)&gt;-<span class="number">1</span>)</span><br><span class="line">		    	&#123;</span><br><span class="line">		    		weight=<span class="keyword">new</span> DoubleWritable(Double.parseDouble(str.split(<span class="string">"w:"</span>)[<span class="number">1</span>]));<span class="comment">//得到对应feautre的权重</span></span><br><span class="line">		    	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		    		lineId.set(Integer.parseInt(str.split(<span class="string">"l:"</span>)[<span class="number">1</span>]));</span><br><span class="line">		    		context.write(lineId,weight);</span><br><span class="line">		    	&#125;</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 按行輸出权重的map</span><br><span class="line">	 *<span class="javadoctag"> @author</span> root</span><br><span class="line">	 *</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LineOutMapper</span> <span class="keyword">extends</span></span><br><span class="line">			<span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">DoubleWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> IntWritable lineId = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> DoubleWritable weight=<span class="keyword">new</span> DoubleWritable();</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Context context)</span></span><br><span class="line">				<span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">			String[] data=value.toString().split(<span class="string">"\\t"</span>);</span><br><span class="line">			lineId.set(Integer.parseInt(data[<span class="number">0</span>]));</span><br><span class="line">			weight.set(Double.parseDouble(data[<span class="number">1</span>]));</span><br><span class="line">			context.write(lineId, weight);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 权重求和的reducer</span><br><span class="line">	 *<span class="javadoctag"> @author</span> root</span><br><span class="line">	 *</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightSumReducer</span> <span class="keyword">extends</span></span><br><span class="line">			<span class="title">Reducer</span>&lt;<span class="title">IntWritable</span>, <span class="title">DoubleWritable</span>,<span class="title">IntWritable</span>, <span class="title">DoubleWritable</span>&gt; </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> DoubleWritable result = <span class="keyword">new</span> DoubleWritable();</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(IntWritable key, Iterable&lt;DoubleWritable&gt; values,</span><br><span class="line">				Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">			<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (DoubleWritable val : values) &#123;</span><br><span class="line">				sum += val.get();</span><br><span class="line">			&#125;</span><br><span class="line">			result.set(sum);</span><br><span class="line">			context.write(key, result);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(args.length&lt;<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">"hello,the arguments length can't less 2"</span>);</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="javadoc">/**</span><br><span class="line">		 * 临时的一个目录</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="keyword">final</span> String TEMP_PATH=<span class="string">"/output/temp/"</span>+System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">		FileSystem fs=FileSystem.get(conf);</span><br><span class="line">		<span class="keyword">if</span>(fs.exists(<span class="keyword">new</span> Path(args[<span class="number">1</span>])))</span><br><span class="line">			fs.delete(<span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"start baidu join"</span>);</span><br><span class="line">		<span class="comment">//启动join 的一个job</span></span><br><span class="line">		Job job = Job.getInstance(conf, <span class="string">"baidu join"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="javadoc">/**</span><br><span class="line">		 * 在这里设计自定义的partition 和 分组</span><br><span class="line">		 */</span></span><br><span class="line">		job.setPartitionerClass(FeaturePartition.class);</span><br><span class="line">		job.setGroupingComparatorClass(GroupingComparator.class);</span><br><span class="line">		</span><br><span class="line">		job.setJarByClass(BaiduJoinSecondarySort.class);</span><br><span class="line">		job.setMapperClass(JoinMapper.class);</span><br><span class="line">		job.setReducerClass(JoinReducer.class);</span><br><span class="line">		job.setOutputKeyClass(FeatureWritable.class);</span><br><span class="line">		job.setOutputValueClass(Text.class);</span><br><span class="line">		job.setNumReduceTasks(<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span>(String path:args[<span class="number">0</span>].split(<span class="string">";|,"</span>))</span><br><span class="line">			FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(path));<span class="comment">//多目录的输入 用空格隔开</span></span><br><span class="line">		FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(TEMP_PATH));</span><br><span class="line">		job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"start baidu join sum"</span>);</span><br><span class="line">		<span class="comment">//启动权重求和的job</span></span><br><span class="line">		Job jobSum = Job.getInstance(conf, <span class="string">"baidu join sum"</span>);</span><br><span class="line">		jobSum.setJarByClass(BaiduJoinSecondarySort.class);</span><br><span class="line">		jobSum.setMapperClass(LineOutMapper.class);</span><br><span class="line">		jobSum.setReducerClass(WeightSumReducer.class);</span><br><span class="line">		jobSum.setOutputKeyClass(IntWritable.class);</span><br><span class="line">		jobSum.setOutputValueClass(DoubleWritable.class);</span><br><span class="line">		jobSum.setNumReduceTasks(<span class="number">2</span>);</span><br><span class="line">		FileInputFormat.addInputPath(jobSum, <span class="keyword">new</span> Path(TEMP_PATH));</span><br><span class="line">		FileOutputFormat.setOutputPath(jobSum, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">		jobSum.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(fs.exists(<span class="keyword">new</span> Path(TEMP_PATH)))</span><br><span class="line">			fs.delete(<span class="keyword">new</span> Path(TEMP_PATH));<span class="comment">//在这里删除临时目录</span></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的<code>JoinReducer</code>类中可以知道二次排序的方法并没有使用拷贝，然后再看我自己的输出：<br><img src="/img/Hadoop-Join-but-No-Memory-in-Reducer/iter.png" alt=""><br>权重值总是在第一行。</p>
<h2 id="总结">总结</h2><ul>
<li>上述的key冗余法虽然看上去简单粗暴，但是它效果好啊。。。</li>
<li>关于二次排序虽然在<code>reducer</code>端不需要排序，但是它将压力转移给了那两次排序，那么多字符串的比较代价也还是好大的。。感觉慎用。</li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code><span class="tag">Instance</span>的格式是：
<span class="tag">Lineid</span> <span class="tag">show</span> <span cla]]>
    </summary>
    
      <category term="Hadoop" scheme="http://yyl8781697.github.io/tags/Hadoop/"/>
    
      <category term="Hadoop" scheme="http://yyl8781697.github.io/categories/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Spark求解大图的连通组件(第二版)]]></title>
    <link href="http://yyl8781697.github.io/2015/06/18/Spark/Connect-Component-From-Baidu-Interview-Using-Spark-V2/"/>
    <id>http://yyl8781697.github.io/2015/06/18/Spark/Connect-Component-From-Baidu-Interview-Using-Spark-V2/</id>
    <published>2015-06-18T13:23:47.000Z</published>
    <updated>2015-06-21T00:59:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="原因">原因</h2><p>昨天将<a href="http://kubicode.me/2015/06/17/Spark/Connect-Component-From-Baidu-Interview-Using-Spark/" target="_blank" rel="external">此题</a>使用标签传播版PageRank法（标签合并）得到了正确地结果，但是今天想想这个效率也还是蛮低啊：</p>
<ol>
<li>虽然关于标签的存储使用了位图法，但是海量数据下这个标签的存储仍然是一个大得问题</li>
<li>迭代过程中多次对两两标签集合进行合并，还不时的需要<code>clone</code>操作，时间空间开销都是很大</li>
<li>关于迭代停止是判断两个标签集合里面的内容是否相等，需要O（n）的复杂度</li>
<li>最后在判断连通子图时，进行<code>Join</code>的<code>key</code>计算时使用了<code>hashCode</code>，这种方法偷懒的方法很容易造成结果不准确，但是也的确很难用一个唯一的数字来表示一个<code>HashMap</code>了呀</li>
</ol>
<h2 id="所以">所以</h2><p>今天想到了这些标签集合完全可以使用集合中标签的最小值的代替，比如（接上文的cookie）cookeiA的最小值是1，cookeB的最小值是1，cookeC的最小值是3，在迭代时cookieB将消息发给cookieC，cookeC将自己的标签由3更新到了1，这样就很判断cookieA，B,C就是一个人了，而且只需要一个<code>int</code>类型就可以了，不需要额外的开销。</p>
<h2 id="实现">实现</h2><p>今晚修改了一下源码，上面的实现如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">ddef main(args:<span class="type">Array</span>[<span class="type">String</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">conf=new</span> <span class="title">SparkConf</span>(</span>).setAppName(<span class="string">"connect componentV2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">sc=new</span> <span class="title">SparkContext</span>(</span>conf)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">dataSource=List</span>(</span><span class="string">"1 1"</span>,<span class="string">"2 1"</span>,<span class="string">"2 2"</span>,<span class="string">"3 2"</span>,</span><br><span class="line">      <span class="string">"4 3"</span>,<span class="string">"5 3"</span>,<span class="string">"5 4"</span>,<span class="string">"6 4"</span>,<span class="string">"6 5"</span>,<span class="string">"7 5"</span>,</span><br><span class="line">      <span class="string">"8 7"</span>,<span class="string">"9 7"</span>,<span class="string">"9 8"</span>,<span class="string">"9 9"</span>,<span class="string">"10 8"</span>,<span class="string">"11 9"</span>)</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">rdd=sc</span>.<span class="title">parallelize</span>(</span>dataSource).map &#123; x=&gt;&#123;</span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">data=x</span>.<span class="title">split</span>(</span><span class="string">" "</span>)</span><br><span class="line">  (data(<span class="number">0</span>).toLong,data(<span class="number">1</span>).toInt)</span><br><span class="line">&#125;&#125;.cache()</span><br><span class="line"></span><br><span class="line"><span class="comment">//提取顶点</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">vertexRdd=rdd</span>.<span class="title">groupBy</span>(</span>_._1).map(x=&gt;&#123;(x._1,x._2.unzip._2.min)&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="comment">//提取边</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">edgeRdd=rdd</span>.<span class="title">groupBy</span>(</span>_._2).flatMap(x=&gt;&#123;</span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">vertexList=x</span>.<span class="title">_2</span>.<span class="title">toList</span>.<span class="title">unzip</span>.<span class="title">_1</span></span><br><span class="line"></span>  <span class="function"><span class="keyword">val</span> <span class="title">ret=ListBuffer</span>[</span><span class="type">Edge</span>[<span class="type">Option</span>[<span class="type">Int</span>]]]()</span><br><span class="line">  <span class="keyword">for</span>(i&lt;- <span class="number">0</span> until vertexList.size;</span><br><span class="line">      j&lt;-i+<span class="number">1</span> until vertexList.size;</span><br><span class="line">      <span class="keyword">if</span> j&lt;vertexList.size)</span><br><span class="line">  &#123;</span><br><span class="line">    ret.append(<span class="type">Edge</span>(vertexList(i),vertexList(j),<span class="type">None</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ret</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//构成图</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">graph=Graph</span>(</span>vertexRdd,edgeRdd)</span><br><span class="line">println(<span class="string">"init graph"</span>)</span><br><span class="line">graph.triplets.collect().foreach(println(_))</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行pregel计算</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">newG=graph</span>.<span class="title">pregel</span>(</span><span class="type">Int</span>.<span class="type">MaxValue</span>, <span class="number">10000</span>, <span class="type">EdgeDirection</span>.<span class="type">Out</span>)(vprog, sendMsg, mergeMsg)</span><br><span class="line">println(<span class="string">"after pregel"</span>)</span><br><span class="line">newG.triplets.collect().foreach(println(_))</span><br><span class="line"></span><br><span class="line">println(<span class="string">"connect component"</span>)</span><br><span class="line">newG.vertices.groupBy(_._2).map(_._2.unzip._1).collect().foreach(println(_))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 节点数据的更新 就是取最小值</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vprog</span>(</span>vid:<span class="type">VertexId</span>,vdata:<span class="type">Int</span>,message:<span class="type">Int</span>):<span class="type">Int</span>=<span class="type">Math</span>.min(vdata,message)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 发送消息</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendMsg</span>(</span>e:<span class="type">EdgeTriplet</span>[<span class="type">Int</span>, <span class="type">Option</span>[<span class="type">Int</span>]])=&#123;</span><br><span class="line"><span class="keyword">if</span>(e.srcAttr==e.dstAttr)</span><br><span class="line">  <span class="type">Iterator</span>.empty<span class="comment">//迭代停止</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//哎，EdgeDirection.Either好像根本没效果，只能在这里发送双向来模拟无向图</span></span><br><span class="line">  <span class="type">Iterator</span>((e.dstId,e.srcAttr),</span><br><span class="line">      (e.srcId,e.dstAttr))<span class="comment">//将自己发送给邻接顶点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 合并消息</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeMsg</span>(</span>a:<span class="type">Int</span>,b:<span class="type">Int</span>):<span class="type">Int</span>=<span class="type">Math</span>.min(a, b)</span><br></pre></td></tr></table></figure></p>
<p>光光从代码量上就可以看到精简了很多，也更加好理解了，接下来看下结果</p>
<p><img src="/img/Connect-Compoent-V2/result.png" height="400px" width="300px"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="原因">原因</h2><p>昨天将<a href="http://kubicode.me/2015/06/17/Spark/Connect-Component-From-Baidu-Interview-Using-Spark/" target="_blank" r]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Spark" scheme="http://yyl8781697.github.io/tags/Spark/"/>
    
      <category term="Spark" scheme="http://yyl8781697.github.io/categories/Spark/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Spark求解大图的连通组件（百度面试题）]]></title>
    <link href="http://yyl8781697.github.io/2015/06/17/Spark/Connect-Component-From-Baidu-Interview-Using-Spark/"/>
    <id>http://yyl8781697.github.io/2015/06/17/Spark/Connect-Component-From-Baidu-Interview-Using-Spark/</id>
    <published>2015-06-17T15:45:58.000Z</published>
    <updated>2015-06-25T03:57:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>在百度网站上有很多作弊者，现在百度已经使用某种技术将他们标记起来，比如：<br>cookieA和cookieB的标签都为1，他们是代表同一个用户，而cookieB可能又有一个标签2与cookieC相同，此时cookieB和cookieC也是同一个用户，这样其实cookieA,cookieB,cookieC就是一个用户而已，但是百度的数据量很大，现需要找出这批大量数据中的所有作弊者，请使用分布式的方法来求解此问题（可以使用<code>Hadoop</code>,<code>Spark</code>或者其他的任何一种平台）</p>
<blockquote>
<p>当时面试官也说了这个其实就是找连通子图问题</p>
</blockquote>
<h2 id="采样+多源最短路径（失败）">采样+多源最短路径（失败）</h2><p>我最初以为这个图里每个连图子图规模较大，但是个数却不是很多，所以一下子想到的就是：</p>
<ol>
<li>先对大图采样</li>
<li>以采样顶点为起始顶点，利用<code>Spark</code>的<code>Pregel</code>模块来跑多源最短路径</li>
<li>每个源跑完之后标记形成的图就是连通子图</li>
</ol>
<p>但是面试官一直问我该采多少样，你这么多是不是非常不精确之类的，（我当初就在想，这个就是要靠实验来定啊。。。）实在无法给面试官满意的答案，我就转移了个话题，反问：<br>q:请问假如这个图有2亿条边，那么最终形成的连通子图会超过2kw吗？<br>w:他说应该会超过并且可能会多于2kw<br>突然意识到我最初想到的采样方法这么做还真不合适。。。</p>
<h2 id="标签传播版PageRank法">标签传播版PageRank法</h2><p>又思索了片刻，想到了PageRank+标签传播法，该方法使用<code>PageRank</code>的随机游走来求解，与之不同的这里传播的是标签，每次迭代都将自己的标签告诉邻居，邻居收到消息后更新自己的标签（进行union操作），直至迭代再消息合并之后自己的标签无变化时停止迭代。<br>列如cookieB的标签其实是（1，2）在迭代的时候会向cookieA和cookieC发送自己的标签，它们俩收到消息之后进行合并，最终其标签也是（1，2），此时就可以求出cookieA,cookieB,cookieC其实就是一个人了，最重要的时候<code>PageRank</code>很容易使用分布式实现。</p>
<p>好，接下来从代码的角度来讲解此方法：</p>
<h3 id="建立图">建立图</h3><p>由于输入的肯定是文本数据，所以现在需要将输入的建立形成图<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">dataSource=List</span>(</span><span class="string">"1 1"</span>,<span class="string">"2 1"</span>,<span class="string">"2 2"</span>,<span class="string">"3 2"</span>,</span><br><span class="line">          <span class="string">"4 3"</span>,<span class="string">"5 3"</span>,<span class="string">"5 4"</span>,<span class="string">"6 4"</span>,<span class="string">"6 5"</span>,<span class="string">"7 5"</span>,</span><br><span class="line">          <span class="string">"8 7"</span>)</span><br><span class="line">          </span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">rdd=sc</span>.<span class="title">parallelize</span>(</span>dataSource).map &#123; x=&gt;&#123;</span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">data=x</span>.<span class="title">split</span>(</span><span class="string">" "</span>)</span><br><span class="line">  (data(<span class="number">0</span>).toLong,data(<span class="number">1</span>).toInt)</span><br><span class="line">&#125;&#125;.cache()</span><br><span class="line"></span><br><span class="line"><span class="comment">//提取顶点</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">vertexRdd=rdd</span>.<span class="title">groupBy</span>(</span>_._1).map(x=&gt;&#123;</span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">vlabel=Map</span>[</span><span class="type">Int</span>,<span class="type">Int</span>]()  <span class="comment">//这里其实存储的就是一个int  只是用map的位图法来存</span></span><br><span class="line">  x._2.foreach(a=&gt;add2Map(a._2,vlabel))</span><br><span class="line">  </span><br><span class="line">  (x._1,vlabel)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line"><span class="comment">//提取边</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">edgeRdd=rdd</span>.<span class="title">groupBy</span>(</span>_._2).flatMap(x=&gt;&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">vertexList=x</span>.<span class="title">_2</span>.<span class="title">toList</span>.<span class="title">unzip</span>.<span class="title">_1</span></span><br><span class="line"></span>  <span class="function"><span class="keyword">val</span> <span class="title">ret=ListBuffer</span>[</span><span class="type">Edge</span>[<span class="type">Option</span>[<span class="type">Int</span>]]]()</span><br><span class="line">  <span class="keyword">for</span>(i&lt;- <span class="number">0</span> until vertexList.size;</span><br><span class="line">      j&lt;-i+<span class="number">1</span> until vertexList.size;</span><br><span class="line">      <span class="keyword">if</span> j&lt;vertexList.size)</span><br><span class="line">  &#123;</span><br><span class="line">    ret.append(<span class="type">Edge</span>(vertexList(i),vertexList(j),<span class="type">None</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ret</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//构成图</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">graph=Graph</span>(</span>vertexRdd,edgeRdd)</span><br></pre></td></tr></table></figure></p>
<p>这个数据源这里为了方便直接写死了，并且为了顶点id的处理方法暂时使用数字来代替题目中的cookie，从数据源中肉眼可以看到最终的连通子图应该是{1,2,3}和{4，5，6，7}</p>
<h3 id="调用pregel接口">调用pregel接口</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">newG=graph</span>.<span class="title">pregel</span>(</span><span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>](), <span class="number">10000</span>, <span class="type">EdgeDirection</span>.<span class="type">Out</span>)(vprog, sendMsg, mergeMsg)</span><br></pre></td></tr></table></figure>
<p><code>Spark</code>里面的<code>pregel</code>是基于<code>BSP</code>进行实现的，其实就是各种<code>Join</code>，<code>Map</code><br>调用接口的时候还需要额外编写三个方法（更新、发送、合并）</p>
<h3 id="更新方法">更新方法</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 节点数据的更新 就是集合的union</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vprog</span>(</span>vid:<span class="type">VertexId</span>,vdata:<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>],message:<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>]):<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>]=&#123;</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">ret=vdata</span>.<span class="title">clone</span>(</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>((k,v)&lt;-message)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!ret.contains(k))</span><br><span class="line">    ret.put(k, v)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ret.put(k, ret(k)|message(k))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是将两个标签集合进行并集而已</p>
<h3 id="发送方法">发送方法</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 发送消息</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendMsg</span>(</span>e:<span class="type">EdgeTriplet</span>[<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Int</span>], <span class="type">Option</span>[<span class="type">Int</span>]])=&#123;</span><br><span class="line"><span class="keyword">if</span>(equalMap(e.srcAttr,e.dstAttr))</span><br><span class="line">  <span class="type">Iterator</span>.empty<span class="comment">//迭代停止</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//哎，EdgeDirection.Either好像根本没效果，只能在这里发送双向来模拟无向图</span></span><br><span class="line">  <span class="type">Iterator</span>((e.dstId,e.srcAttr.clone()),</span><br><span class="line">      (e.srcId,e.dstAttr.clone()))<span class="comment">//将自己发送给邻接顶点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的发送方法很重要，当一条边上两端顶点的标签集合相同时就停止发送消息，否则就分别想两端发送自己的标签</p>
<h3 id="合并方法">合并方法</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* 合并消息</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeMsg</span>(</span>map1:<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>],map2:<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>]):<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>]=&#123;</span><br><span class="line"><span class="keyword">for</span>((k,v)&lt;-map2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!map1.contains(k))</span><br><span class="line">    map1.put(k, v)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    map1.put(k, map1(k)|map2(k))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>合并方法其实和更新方法很类似，其实就是做了两个标签集合的合并，以减少网络开销</p>
<h3 id="运行结果">运行结果</h3><p>最终将代码打成jar包在<code>Spark</code>上进行运行，其结果如下：<br><img src="/img/Connect-Compoent/result.png" height="400px" width="400px"><br>从结果图种可以发现在跑了<code>pregel</code>之后相连子图的标签都成为一致了，还有最后打印的连通组件（就是子图）也与预期的一致。</p>
<blockquote>
<p>备注：这里的标签使用map版本的位图来存储，减少存储量，增加算法的能力。</p>
</blockquote>
<h2 id="添加完成源码">添加完成源码</h2><p>下面是做实验的完整源码：<code>scala.2.10.4</code>,<code>spark.1.3+hadoop.2.6</code><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里使用位图的方法可以减少标签的存储空间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">SHIFT=0x5</span>   <span class="title">//位移</span></span><br><span class="line"></span>  <span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">MASK=0x1F</span></span><br><span class="line"></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span>(</span>args:<span class="type">Array</span>[<span class="type">String</span>])</span><br><span class="line">  &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">conf=new</span> <span class="title">SparkConf</span>(</span>).setAppName(<span class="string">"connect component"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">sc=new</span> <span class="title">SparkContext</span>(</span>conf)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">dataSource=List</span>(</span><span class="string">"1 1"</span>,<span class="string">"2 1"</span>,<span class="string">"2 2"</span>,<span class="string">"3 2"</span>,</span><br><span class="line">          <span class="string">"4 3"</span>,<span class="string">"5 3"</span>,<span class="string">"5 4"</span>,<span class="string">"6 4"</span>,<span class="string">"6 5"</span>,<span class="string">"7 5"</span>,</span><br><span class="line">          <span class="string">"8 7"</span>)</span><br><span class="line">          </span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">rdd=sc</span>.<span class="title">parallelize</span>(</span>dataSource).map &#123; x=&gt;&#123;</span><br><span class="line">      <span class="function"><span class="keyword">val</span> <span class="title">data=x</span>.<span class="title">split</span>(</span><span class="string">" "</span>)</span><br><span class="line">      (data(<span class="number">0</span>).toLong,data(<span class="number">1</span>).toInt)</span><br><span class="line">    &#125;&#125;.cache()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提取顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">vertexRdd=rdd</span>.<span class="title">groupBy</span>(</span>_._1).map(x=&gt;&#123;</span><br><span class="line">      <span class="function"><span class="keyword">val</span> <span class="title">vlabel=Map</span>[</span><span class="type">Int</span>,<span class="type">Int</span>]()  <span class="comment">//这里其实存储的就是一个int  只是用map的位图法来存</span></span><br><span class="line">      x._2.foreach(a=&gt;add2Map(a._2,vlabel))</span><br><span class="line">      </span><br><span class="line">      (x._1,vlabel)</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//提取边</span></span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">edgeRdd=rdd</span>.<span class="title">groupBy</span>(</span>_._2).flatMap(x=&gt;&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">val</span> <span class="title">vertexList=x</span>.<span class="title">_2</span>.<span class="title">toList</span>.<span class="title">unzip</span>.<span class="title">_1</span></span><br><span class="line"></span>      <span class="function"><span class="keyword">val</span> <span class="title">ret=ListBuffer</span>[</span><span class="type">Edge</span>[<span class="type">Option</span>[<span class="type">Int</span>]]]()</span><br><span class="line">      <span class="keyword">for</span>(i&lt;- <span class="number">0</span> until vertexList.size;</span><br><span class="line">          j&lt;-i+<span class="number">1</span> until vertexList.size;</span><br><span class="line">          <span class="keyword">if</span> j&lt;vertexList.size)</span><br><span class="line">      &#123;</span><br><span class="line">        ret.append(<span class="type">Edge</span>(vertexList(i),vertexList(j),<span class="type">None</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      ret</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构成图</span></span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">graph=Graph</span>(</span>vertexRdd,edgeRdd)</span><br><span class="line">    println(<span class="string">"init graph"</span>)</span><br><span class="line">    graph.triplets.collect().foreach(println(_))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//进行pregel计算</span></span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">newG=graph</span>.<span class="title">pregel</span>(</span><span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>](), <span class="number">10000</span>, <span class="type">EdgeDirection</span>.<span class="type">Out</span>)(vprog, sendMsg, mergeMsg)</span><br><span class="line">    println(<span class="string">"after pregel"</span>)</span><br><span class="line">    newG.triplets.collect().foreach(println(_))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    println(<span class="string">"connect component"</span>)</span><br><span class="line">    newG.vertices.groupBy(_._2.hashCode()).map(_._2.unzip._1).collect().foreach(println(_))</span><br><span class="line">    <span class="comment">//这里暂时用hashCode分组吧-_-  实际情况下大数据量很容易存在hash冲突</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 节点数据的更新 就是集合的union</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">vprog</span>(</span>vid:<span class="type">VertexId</span>,vdata:<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>],message:<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>]):<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>]=&#123;</span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">ret=vdata</span>.<span class="title">clone</span>(</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>((k,v)&lt;-message)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(!ret.contains(k))</span><br><span class="line">        ret.put(k, v)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ret.put(k, ret(k)|message(k))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 发送消息</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sendMsg</span>(</span>e:<span class="type">EdgeTriplet</span>[<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Int</span>], <span class="type">Option</span>[<span class="type">Int</span>]])=&#123;</span><br><span class="line">    <span class="keyword">if</span>(equalMap(e.srcAttr,e.dstAttr))</span><br><span class="line">      <span class="type">Iterator</span>.empty<span class="comment">//迭代停止</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//哎，EdgeDirection.Either好像根本没效果，只能在这里发送双向来模拟无向图</span></span><br><span class="line">      <span class="type">Iterator</span>((e.dstId,e.srcAttr.clone()),</span><br><span class="line">          (e.srcId,e.dstAttr.clone()))<span class="comment">//将自己发送给邻接顶点</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 合并消息</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mergeMsg</span>(</span>map1:<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>],map2:<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>]):<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>]=&#123;</span><br><span class="line">    <span class="keyword">for</span>((k,v)&lt;-map2)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(!map1.contains(k))</span><br><span class="line">        map1.put(k, v)</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        map1.put(k, map1(k)|map2(k))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    map1</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add2Map</span>(</span>v:<span class="type">Int</span>,map:<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">key=v&gt;&gt;SHIFT</span>  <span class="title">//取索引位置</span></span><br><span class="line"></span>    <span class="function"><span class="keyword">val</span> <span class="title">value=1&lt;&lt;</span>(</span>v&amp;<span class="type">MASK</span>)  <span class="comment">//取32的模</span></span><br><span class="line">    <span class="keyword">if</span>(!map.contains(key))</span><br><span class="line">      map.put(key, value)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      map.put(key, map(key)|value)  <span class="comment">//使用位图法进行存储</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 比较两个map是否相等</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">equalMap</span>(</span>map1:<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>],map2:<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>]):<span class="type">Boolean</span>=</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> ret=<span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span>(map1.size==map2.size)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span>((k,v)&lt;-map1;<span class="keyword">if</span> ret)</span><br><span class="line">        ret=map2.contains(k) &amp;&amp; map1(k)==map2(k)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      ret=<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><p>在百度网站上有很多作弊者，现在百度已经使用某种技术将他们标记起来，比如：<br>cookieA和cookieB的标签都为1，他们是代表同一个用户，而cookieB可能又有一个标签2与cookieC相同，此时cookieB和cookieC]]>
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Spark" scheme="http://yyl8781697.github.io/tags/Spark/"/>
    
      <category term="Spark" scheme="http://yyl8781697.github.io/categories/Spark/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Effective Java》第8章：通用程序设计]]></title>
    <link href="http://yyl8781697.github.io/2015/06/15/Effective%20Java/Common-Program-Desgin/"/>
    <id>http://yyl8781697.github.io/2015/06/15/Effective Java/Common-Program-Desgin/</id>
    <published>2015-06-15T14:56:25.000Z</published>
    <updated>2015-06-21T05:33:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="第45条：将局部变量的作用域最小化">第45条：将局部变量的作用域最小化</h2><blockquote>
<p>将局部变量的作用域最小化，可以增强代码的可读性和可维护性，并降低出错的可能性。</p>
</blockquote>
<p>这一条看字面意思应该已经非常明了了，就是教我们在申明局部变量的时候注意其作用域，将其作用域最小化：</p>
<ul>
<li>比如有些判断的变量在<code>if</code>语句里面完成就好</li>
<li>还有循环里面<code>for</code>优于<code>while</code>，因为<code>for</code>往往不需要其他的额外局部变量</li>
<li>另一种就是使方法小而集中</li>
</ul>
<h2 id="第46条：for-each循环优先于传统的for循环">第46条：for-each循环优先于传统的for循环</h2><p>利用<code>for-each</code>循环不会有性能损失，甚至用于数组也是一样的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Integer&gt; c=Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//普通的for循环</span></span><br><span class="line"><span class="keyword">for</span>(Iterator iter=c.iterator();iter.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">	doSomething(iter.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用for-each的版本</span></span><br><span class="line"><span class="keyword">for</span>(Integer v:c)</span><br><span class="line">&#123;</span><br><span class="line">	doSomething(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有一点是如果你使用普通的<code>for</code>，那么它的<code>next</code>会走光所有的元素，也就无法再利用。</p>
<h2 id="第47条：了解和使用类库">第47条：了解和使用类库</h2><blockquote>
<p>程序猿的类库就是武器弹药，没有弹药如何去写出一首好程序</p>
</blockquote>
<p>通过使用标准类库：</p>
<ol>
<li>可以充分利用这些数据编写标准类库和专家知识，以及在你之前的其他人得使用经验</li>
<li>就是相当于不必浪费时间去重复造轮子</li>
<li>它的性能往往回伴随着时间推移而不断提高</li>
<li>还可以使自己的代码融入主流。</li>
</ol>
<h2 id="第48条：如果需要精确地答案，请避免使用float和double">第48条：如果需要精确地答案，请避免使用float和double</h2><blockquote>
<p><code>float</code>和<code>double</code>为了再广泛地数值范围上提供较为精确地快读近似计算，它们并没有提供完全精确地经过，所以不应该用于需要精确结果的场合。</p>
</blockquote>
<p>比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">1.03</span>-<span class="number">.42</span>);</span><br></pre></td></tr></table></figure></p>
<p>你会惊奇的发现它输出的结果为：</p>
<pre><code>0.6100000000000001
</code></pre><p>关于这点可以使用<code>BigDecimal</code>这个类来代替它们<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal f=<span class="keyword">new</span> BigDecimal(<span class="string">"1.03"</span>);</span><br><span class="line">System.out.println(f.subtract(<span class="keyword">new</span> BigDecimal(<span class="string">"0.42"</span>)));</span><br></pre></td></tr></table></figure></p>
<p>这样就能支持得到精确地结果了。</p>
<blockquote>
<p>总而言之，对于任何需要精确答案的计算任务，请不要使用<code>float</code>或者<code>double</code>。如果你想让系统记录十进制的小数点，并且不介意因为不使用基本类型而带来的不便，那么就请使用<code>BigDecimal</code></p>
</blockquote>
<h2 id="第49条：基本类型优于装箱的基本类型">第49条：基本类型优于装箱的基本类型</h2><p><code>Java</code>的类型系统由两部分组成：</p>
<ul>
<li>基本类型：<code>int</code>,<code>double</code>,<code>boolean</code>还有引用类型<code>String</code>，<code>List</code>等。</li>
<li>装箱基本类型：对应上面的分别为<code>Integer</code>,<code>Double</code>和<code>Boolean</code></li>
</ul>
<p>基本类型和基本装箱类型有三个主要区别：</p>
<ol>
<li>基本类型只有值，而装箱基本类型则具有与它们的值不同的同一性。</li>
<li>基本类型只有功能完备的值，而每个装箱类型还具有肺功能值：<code>null</code>。</li>
<li>基本类型通常比装箱基本类型更加省空间和时间。（我觉得这点才是本条的关键点吧^_^）</li>
</ol>
<p>现在先来看一个比较器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; naturalOrder=<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer first,Integer second)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> first&lt;second?-<span class="number">1</span> :(first==second?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们如果使用这个比较器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(naturalOrder.compare(<span class="keyword">new</span> Integer(<span class="number">42</span>), <span class="keyword">new</span> Integer(<span class="number">42</span>)));</span><br></pre></td></tr></table></figure></p>
<p>你会发现输出的结果竟然是1（我估计是装箱基本类型同一性的问题）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接调用Integer比较的API</span></span><br><span class="line"><span class="keyword">return</span> first.compareTo(second);</span><br><span class="line"><span class="comment">//或者自己进行拆箱</span></span><br><span class="line"><span class="keyword">int</span> f=first;</span><br><span class="line"><span class="keyword">int</span> s=second;</span><br><span class="line"><span class="keyword">return</span> f&lt;s?-<span class="number">1</span> :(f==s?<span class="number">0</span>:<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>还有再来看这个程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Integer i;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">42</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">"unbelievable"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你会收到一个<code>NPE</code>的异常,因为<code>Integer</code>的默认初始值为<code>null</code>，当然是无法进行拆箱啦。</p>
<p>再来看一个性能问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> curTime=System.currentTimeMillis();</span><br><span class="line">	Long s1=<span class="number">0L</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>;i&lt;Integer.MAX_VALUE;i++)</span><br><span class="line">		s1+=i;</span><br><span class="line">	System.out.println(<span class="string">"s1="</span>+s1+<span class="string">",and spend="</span>+(System.currentTimeMillis()-curTime));</span><br><span class="line">	</span><br><span class="line">	curTime=System.currentTimeMillis();</span><br><span class="line">	<span class="keyword">long</span> s2=<span class="number">0L</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>;i&lt;Integer.MAX_VALUE;i++)</span><br><span class="line">		s2+=i;</span><br><span class="line">	System.out.println(<span class="string">"s2="</span>+s1+<span class="string">",and spend="</span>+(System.currentTimeMillis()-curTime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你会惊奇的发现</p>
<pre><code><span class="variable">s1=</span><span class="number">2305843005992468481</span>,<span class="constant">and</span> <span class="variable">spend=</span><span class="number">6286</span>
<span class="variable">s2=</span><span class="number">2305843005992468481</span>,<span class="constant">and</span> <span class="variable">spend=</span><span class="number">720</span>
</code></pre><p>使用<code>Long</code>运算的效率要比基本类型慢了很多，这是因为要都要拆箱装箱的缘故。</p>
<p>所以：基本类型优于装箱的基本类型</p>
<blockquote>
<p>但是，比如类型<code>HashMap</code>的定义的类型还真必须是<code>Integer</code>之类的引用</p>
</blockquote>
<h2 id="第50条：如果其他类型更合适，则尽量避免使用字符串">第50条：如果其他类型更合适，则尽量避免使用字符串</h2><blockquote>
<p>字符串，我们都知道，这个很好用。。。</p>
</blockquote>
<p>但是其实很多情况下，有比用字符串更加好的解决方案：</p>
<ul>
<li>字符串不适合代替其他的值类型</li>
<li>字符串不适合代替聚集类型</li>
<li>字符串不适合代替枚举类型</li>
<li>字符串也不适合代替能力表</li>
</ul>
<p>总之，如果可以使用更加合适的数据类型，或者可以编写更加适当的数据类型，就应该避免用字符串来表示对象。</p>
<h2 id="第51条：当心字符串连接的性能">第51条：当心字符串连接的性能</h2><p>这条是面试常问的问题，众所周知，字符串的连接性能很差，因为字符串是不可变，也就是说没连接一下次就会重新生成一个新的更大的字符串，所以推荐使用<code>StringBuilder</code></p>
<h2 id="第52条：通过接口引用对象">第52条：通过接口引用对象</h2><blockquote>
<p>对应第40条建议：<a href="http://kubicode.me/2015/06/09/Effective%20Java/Method/#第40条：谨慎设计方法签名" target="_blank" rel="external">应该使用接口而不是类作为参数的类型</a>，这条的建议是应该优先使用接口而不是类做做引用对象。</p>
</blockquote>
<p>现在来看这个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Subscriber&gt; subscribers=<span class="keyword">new</span> Vector&lt;Subscriber&gt;();<span class="comment">//好的写法</span></span><br><span class="line">Vector&lt;Subscriber&gt; subscribers=<span class="keyword">new</span> Vector&lt;Subscriber&gt;();<span class="comment">//这个写法不好，太不灵活了</span></span><br><span class="line">List&lt;Subscriber&gt; subscribers=<span class="keyword">new</span> ArrayList&lt;Subscriber&gt;();<span class="comment">//这个写法也好，可以直接与第一种替代</span></span><br></pre></td></tr></table></figure></p>
<p>如果没有合适的接口存在，可以考虑是否有基类可以用来定义类型，否则完全可以使用实现类来引用对象。</p>
<h2 id="第53条：接口优于反射机制">第53条：接口优于反射机制</h2><p>核心反射机制提供了“通过程序了访问已装载的类的信息”（反射大家应该都懂的）</p>
<p>虽然反射使用起来很方法，并且也很灵活，但是使用它的代价很大：</p>
<ul>
<li>丧失了编译时类型检查的好处</li>
<li>执行反射访问所需要的代码非常笨拙和冗余</li>
<li>性能损失很大</li>
</ul>
<p>来看一下  下面的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将该接口进行实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello~~~~~~~~~~~"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始调用sayHello</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line"></span>&#123;</span><br><span class="line">	System.out.println(System.currentTimeMillis());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">		say(<span class="keyword">new</span> Hello());</span><br><span class="line">	System.out.println(System.currentTimeMillis());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">		say(<span class="string">"yyl.java.study.Hello"</span>);</span><br><span class="line">	System.out.println(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 使用接口方法来调用</span><br><span class="line"> *<span class="javadoctag"> @param</span> hello</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Base hello)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	hello.sayHello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 使用反射的方法来调用</span><br><span class="line"> *<span class="javadoctag"> @param</span> className</span><br><span class="line"> *<span class="javadoctag"> @throws</span> Exception</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String className)</span> <span class="keyword">throws</span> Exception</span><br><span class="line"></span>&#123;</span><br><span class="line">	Class cl=Class.forName(className);</span><br><span class="line">	Object obj=cl.newInstance();</span><br><span class="line">	Method m=cl.getMethod(<span class="string">"sayHello"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(m!=<span class="keyword">null</span>)</span><br><span class="line">		m.invoke(obj);<span class="comment">//方法的调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终的输出结果为：</p>
<pre><code><span class="number">1434817643669</span>
<span class="comment">//....</span>
<span class="number">1434817643672</span>
<span class="comment">//....</span>
<span class="number">1434817643681</span>
</code></pre><p>从上面的小实验中可以发现，使用接口比使用反射速度要快3倍左右，但是这其实并不意味着将反射抛弃，然而反射的特点很灵活，比如className可以是当初编译时不存在类，并且反射主要用于组件的开发，一般情况下都是记录缓存，并不是会多次调用反射来取到可执行方法。</p>
<h2 id="第54条：谨慎的使用本地方法">第54条：谨慎的使用本地方法</h2><p><code>JNI</code>准许<code>Java</code>应用程序可以调用本地方法（比如c/c++）编写的，主要是因为本地方法可以</p>
<ul>
<li>访问注册表、文件锁</li>
<li>访问遗留代码库</li>
<li>最重要的还是提升性能啊</li>
</ul>
<p>但是随着<code>JVM</code>的发展，这些功能应该add到最近的<code>JVM</code>中了，并且其本地代码的性能优势也应该没有之前那么明显了，比如<code>BigInteger</code>已经完全用<code>Java</code>重写了。</p>
<p>然而，使用本地方法有一些重要的缺点：</p>
<ul>
<li>本地方法的语言不是安全的</li>
<li>本地方法语言与平台有关，可移植性不高</li>
<li>本地方法更难调试，如果写得不好，性能也许反而会降低</li>
</ul>
<p>所以，慎用本地方法</p>
<blockquote>
<p>当然，我觉得在某些地方还是得用，<code>Java</code>中的<code>system.arraycopy</code>不就是一个本地方法嘛。</p>
</blockquote>
<h2 id="第55条：谨慎的进行优化">第55条：谨慎的进行优化</h2><blockquote>
<p>优化利大于弊，特别是不成熟的优化   赞同^_^</p>
</blockquote>
<p> 那难道就不优化嘛？不！这条是建议我们不要费力去编写快速的程序，而应该努力去编写好的程序，速度自然会随之而来（这并不是先思考，再下手嘛）<br> 如果是实在不行，这个优化得专家来做，并且要经常进行性能测试，直到满意。-_-</p>
<h2 id="第56条：遵守普遍接受的命名惯例">第56条：遵守普遍接受的命名惯例</h2><p> <code>Java</code>平台建立了一套很好的命名规范，这些规范可以大大让你的团队更好地开展活动</p>
<p> 字面上的命名</p>
<ul>
<li>包<ul>
<li>包得名称应该是层次状的，用句号分割每个部分</li>
<li>包名称的其余部分应该包括一个或者多个描述的组成部分</li>
</ul>
</li>
<li>类和接口名称，包括枚举和注解，都应该包括一个或者多个单词，每个单词的首字母大写</li>
<li>方法和域的名称一般使用小驼峰法，整个名称的第一个字母小写，以后每个单词的首字母大写</li>
<li>域常量一般全部字母都大写，每个单词使用下划线作为分割</li>
<li>局部变量允许缩写</li>
<li>类型参数名一般由单个大写字母表示，比如<code>T</code>,<code>E</code>,<code>K</code>,<code>V</code>.</li>
</ul>
<p> 语法上的命名</p>
<ul>
<li>接口建议以<code>able</code>结尾，比如<code>Runnable</code></li>
<li>执行某个东西的方法根据动作命名，比如返回布尔值的方法一般以<code>is</code>开头</li>
<li>如果被调用方法返回一个非布尔值，一般以<code>get</code>开头</li>
<li>类型转换的方法一般以<code>to</code>开头</li>
</ul>
<blockquote>
<p>这些命名规则一般都是约定俗成了，看着也习惯。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="第45条：将局部变量的作用域最小化">第45条：将局部变量的作用域最小化</h2><blockquote>
<p>将局部变量的作用域最小化，可以增强代码的可读性和可维护性，并降低出错的可能性。</p>
</blockquote>
<p>这一条看字面意思应该已经非常]]>
    </summary>
    
      <category term="Java" scheme="http://yyl8781697.github.io/tags/Java/"/>
    
      <category term="Effective Java" scheme="http://yyl8781697.github.io/categories/Effective-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Effective Java》第七章：方法]]></title>
    <link href="http://yyl8781697.github.io/2015/06/09/Effective%20Java/Method/"/>
    <id>http://yyl8781697.github.io/2015/06/09/Effective Java/Method/</id>
    <published>2015-06-09T15:44:24.000Z</published>
    <updated>2015-06-12T15:24:18.000Z</updated>
    <content type="html"><![CDATA[<p>本章主要讨论方法设计的几个方面：</p>
<ul>
<li>如何处理参数和返回值</li>
<li>如何设计方法签名</li>
<li>如何为方法编写文档</li>
</ul>
<h2 id="第38条：检查参数的有效性">第38条：检查参数的有效性</h2><p>这条就是教我们对于公有方法，最好在方法体上的开头处加上参数检查，并且在文档中清楚地指出这些限制，比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 求模</span><br><span class="line"> *<span class="javadoctag"> @param</span> m</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> *<span class="javadoctag"> @throws</span> ArithmeticException 如何m小于等于0时抛出异常</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">mod</span><span class="params">(BigInteger m)</span> <span class="keyword">throws</span> ArithmeticException</span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m.signum()&lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">"Moduls &lt;= 0:"</span>+m);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">	<span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假如是对于私有方法，通常使用断言来检查他们的参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">long</span> a[],<span class="keyword">int</span> offset,<span class="keyword">int</span> length)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">assert</span> a!=<span class="keyword">null</span>:<span class="string">"排序数组不能为空"</span>;</span><br><span class="line">	<span class="keyword">assert</span> offset &gt;= <span class="number">0</span>&amp;&amp; offset&lt;=a.length;</span><br><span class="line">	<span class="keyword">assert</span> length&gt;=<span class="number">0</span> &amp;&amp; length&lt;=a.length-offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>assert</code>默认是关闭的，需要使用<code>-enableassertions</code>或者<code>-ea</code>的<code>Java</code>参数来显示开启。</p>
</blockquote>
<p>其实并不是对任何参数都加限制是件好事，因为参数的有效性检查会带来开销，我们应该在设计方法时，应该使他们尽可能的通用，并符合实际的需要。</p>
<h2 id="第39条：必要时进行保护性拷贝">第39条：必要时进行保护性拷贝</h2><p>假设类的客户端会尽其所能的破坏这个类的约束条件，因此你必须保护性的设计程序。<br>下面希望设计的是一个不可能修改对象内部状态的类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Perion</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Date start;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Date end;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Period</span><span class="params">(Date start,Date end)</span> <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(start.compareTo(end)&gt;<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span>  IllegalArgumentException(<span class="string">"开始时间大于结束时间"</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">this</span>.start=start;</span><br><span class="line">			<span class="keyword">this</span>.end=end;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Date <span class="title">start</span><span class="params">()</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.start;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Date <span class="title">end</span><span class="params">()</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.end;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的类<code>Perion</code>似乎是不可变的，并且还加强了约束条件，<br>但是<code>Date</code>这个类是引用类型，如果是这么使用这个类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date start=<span class="keyword">new</span> Date();</span><br><span class="line">Date end=<span class="keyword">new</span> Date();</span><br><span class="line">Perion p=<span class="keyword">new</span> Perion(start,end);</span><br><span class="line">start.setYear(<span class="number">78</span>);<span class="comment">//在这里进行了外部对Perion类内部对象的修改</span></span><br></pre></td></tr></table></figure></p>
<p>你可以发现实例化之后的<code>Date</code>会被修改掉，所以你需要保护性拷贝<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Perion</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Date start;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Date end;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Period</span><span class="params">(Date start,Date end)</span> <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="comment">//一定要先赋值 在进行类型检查</span></span><br><span class="line">		<span class="keyword">this</span>.start=<span class="keyword">new</span> Date(start.getTime());</span><br><span class="line">		<span class="keyword">this</span>.end=<span class="keyword">new</span> Date(end.getTime());</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.start.compareTo(<span class="keyword">this</span>.end)&gt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span>  IllegalArgumentException(<span class="string">"开始时间大于结束时间"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">start</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="comment">//防止他们使用get方法来获取引用对象</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Date(<span class="keyword">this</span>.start.getTime());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">end</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Date(<span class="keyword">this</span>.end.getTime());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是可以发现这种方法虽然是安全了，但是代价较大，另一种更好地方法是不要用<code>Date</code>引用对象存储再数据库，而是使用时间戳更加合适<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> start;<span class="comment">//其他就不多说了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> end;</span><br></pre></td></tr></table></figure></p>
<p>简而言之，如果类具有从客户端得到或者返回到客户端的可变组件，类就必须保护性的拷贝这些组件。</p>
<h2 id="第40条：谨慎设计方法签名">第40条：谨慎设计方法签名</h2><p>设计方法的时候有下面三个设计原则：</p>
<ul>
<li>谨慎地选择方法名称<blockquote>
<p>方法的名称应该始终遵循标准的命名习惯</p>
</blockquote>
</li>
<li>不要过于追求便利的方法<blockquote>
<p>每个方法应该尽其所能，方法定义也不要太多，最好文档化，有测试和维护，还有接口优于类</p>
</blockquote>
</li>
<li>避免过长的参数列表<ol>
<li>把方法分解成多个方法，每个方法只需要这些参数的一个子集</li>
<li>创建辅助类，其实就是实体类，相信大家都懂的</li>
<li>采用Builder模式</li>
</ol>
</li>
</ul>
<h2 id="第41条：慎用重载">第41条：慎用重载</h2><blockquote>
<p>对于重载方法的选择是静态的，而对于被覆盖方法的选择是动态的。</p>
</blockquote>
<p>使用重载方法可能会让你在调用的时候产生混淆，普通用户根本不知道“对于一组给定的参数，其中哪个重载方法会被调用”。</p>
<p>例如：<code>ArrayList</code>有一个构造器带一个<code>int</code>参数，另一个构造器带<code>Collection</code>参数，难以想象的情况下会不清楚调用哪个参数。</p>
<p>在Java1.5之前，所有的基本类型都是根本不同于所有的引用类型，但是当自动装箱出现之后，就不再如此了，他会带来真正的麻烦。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Set&lt;Integer&gt; set=<span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">	List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=-<span class="number">3</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		set.add(i);</span><br><span class="line">		list.add(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		set.remove(i);</span><br><span class="line">		list.remove(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	System.out.println(set+<span class="string">" "</span>+list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当初写这段代码的本意可能使希望添加[-3~3]之后再移除[0~2]，但是看结果你会发现</p>
<pre><code>[-<span class="number">3</span>, -<span class="number">2</span>, -<span class="number">1</span>] [-<span class="number">3</span>, -<span class="number">2</span>, -<span class="number">1</span>]
</code></pre><p>关于上面的输出：</p>
<ul>
<li><code>set.remove(i)</code>调用的是重写方法<code>remove(E)</code>，这里的<code>E</code>集合是<code>Integer</code>的元素类型，将<code>i</code>自动装箱到<code>Integer</code>中</li>
<li>但是<code>list.remove(i)</code>重载的却是<code>remove(int index)</code>，它是按索引去移除元素，也因此得到了意料之外的结果。</li>
</ul>
<p>简而言之：“能够重载的方法”并不意味着就”应该重载方法”，一般情况下，对于读个具有相同参数目的的方法来说，应该重载方法。</p>
<blockquote>
<p>我想，其实重载还是很好使的，但是在重载的时候一般要避免可拆装箱类型或者有继承类型的出现，比如上例中的<code>remove(Object o)</code>以及<code>remove(int index)</code>就是非常会让人混淆，你可以写成<code>removeByIndex(int index)</code>  ^_^</p>
</blockquote>
<h2 id="第42条：慎用可变参数">第42条：慎用可变参数</h2><p>在Java中，可以使用下面的语法来传递可变参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ... args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i:args)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是该方法可以不传参数调用，但是有时候需要编译1个或者多个参数的传入，而不是0到或者多个，得加上<code>args.length</code>的检查，但是更好地方法是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> firstArgs,<span class="keyword">int</span> ... args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum=firstArgs;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i:args)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在重视参数性能的情况下，使用可变参数机制要特别小心，可变参数的方法每次调用都会进行一次数组的分配和初始化，所以建议先重载5个参数一下的方法（上一条还建议慎用重载呢-_-）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> arg1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> arg1,<span class="keyword">int</span> arg2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> arg1,<span class="keyword">int</span> arg2,<span class="keyword">int</span> arg3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> arg1,<span class="keyword">int</span> arg2,<span class="keyword">int</span> arg3,<span class="keyword">int</span> arg4)</span></span></span><br></pre></td></tr></table></figure></p>
<p>简而言之，在定义参数数目不定的方法时，可变参数方法是一种很方便的方式，但是它们不应该被过度滥用</p>
<h2 id="第43条：返回长度的数组或者集合，而不是null">第43条：返回长度的数组或者集合，而不是null</h2><p>当函数的返回类型集合类但是却没有集合元素返回时不要返回<code>null</code>，因为开发人员可能会使用返回值来做下一个操作，所以最好你应该返回一个空得集合。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Integer&gt; EMPTY_DATA=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(...)</span><br><span class="line">		<span class="keyword">return</span> EMPTY_DATA;<span class="comment">//而不是null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>对，这个注意好，妈妈再也不用担心我这类方法出来之后有没有检查<code>null</code>了</p>
</blockquote>
<h2 id="第44条：为所有导出的API元素编写文档注释">第44条：为所有导出的API元素编写文档注释</h2><p>这还用说嘛，最讨厌使用那么没有提供注释的<code>API</code>了，你叫臣妾怎么顺心的用你的<code>API</code>啊。<br>一般较为友好的注释是这么写的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 这里写你这个方法是干嘛的，有什么特征，或者使用样例、</span><br><span class="line"> *<span class="javadoctag"> @param</span> index  这里写参数的接口</span><br><span class="line"> *<span class="javadoctag"> @return</span> 返回值，一般是一个短语</span><br><span class="line"> *<span class="javadoctag"> @exception</span> 这里就是写方法可能抛出的异常以及原因</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>这里的注释支持简单的<code>html</code>标签：</p>
<ul>
<li>比如你想换行或者分段可以使用&lt;p&gt;d&lt;/p&gt;</li>
<li>你想斜体就用&lt;i&gt;d&lt;/i&gt;</li>
<li>你想保持注释中文本的格式就是用&lt;pre&gt;</li>
</ul>
<p>还有：</p>
<ul>
<li>使用&lt;pre&gt;{@code,…}&lt;/pre&gt;来在注释中添加代码</li>
<li>使用&lt;pre&gt;{@link,…}&lt;/pre&gt;跳转到指定类额注释</li>
<li>还有几个其他的，自己看<code>Eclipse</code>中的提示</li>
</ul>
<p>简而言之，要为<code>API</code>编写文档，注释是最好的，最有效的途径</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本章主要讨论方法设计的几个方面：</p>
<ul>
<li>如何处理参数和返回值</li>
<li>如何设计方法签名</li>
<li>如何为方法编写文档</li>
</ul>
<h2 id="第38条：检查参数的有效性">第38条：检查参数的有效性</h2><p>这条就是]]>
    </summary>
    
      <category term="Java" scheme="http://yyl8781697.github.io/tags/Java/"/>
    
      <category term="Effective Java" scheme="http://yyl8781697.github.io/categories/Effective-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自己煮：麻辣鱼]]></title>
    <link href="http://yyl8781697.github.io/2015/06/06/Food/Spicy-fish/"/>
    <id>http://yyl8781697.github.io/2015/06/06/Food/Spicy-fish/</id>
    <published>2015-06-06T12:46:54.000Z</published>
    <updated>2015-06-06T13:13:50.000Z</updated>
    <content type="html"><![CDATA[<p>麻辣鱼简直就是大餐啊，油而不腻，并且鱼的腥味直接被重口味的油辣给冲掉了-_-，可惜我做的还不到火候。<br>又是一个周五，所以要给自己一个大餐，哈哈！</p>
<h2 id="食材">食材</h2><ul>
<li>鱼：最好是黑鱼，并且要切片（自己切麻烦，可以在买菜的时候直接叫师傅给切了）</li>
<li>油、料酒~~~~</li>
<li>生姜、大蒜：适量，再来一点点葱</li>
<li>大量大量的辣椒</li>
</ul>
<p><img src="/img/Spicy-fish/1.jpg" alt=""></p>
<h2 id="预煮鱼片">预煮鱼片</h2><p>将已经洗干净的鱼片直接放入水中煮3~5分钟，主要最好加一些料酒，去腥味<br><img src="/img/Spicy-fish/2.jpg" alt=""><br>拍得有点迟，水都已经煮浑浊了，然后将煮熟了的鱼片捞起来<br><img src="/img/Spicy-fish/3.jpg" alt=""></p>
<h2 id="炒油辣椒">炒油辣椒</h2><p>将葱、姜、大蒜和大量大量的辣椒爆炒<br><img src="/img/Spicy-fish/4.jpg" alt=""><br>记得炒得时候直接要放盐进去，还要多放一点，重口味嘛^_^</p>
<p>辣椒炒黑了之后可以直接关火，将炒好的油辣椒直接倒到你刚刚捞起来的鱼上就好了</p>
<h2 id="开吃">开吃</h2><p>倒完之后样纸是这样的<br><img src="/img/Spicy-fish/5.jpg" alt=""></p>
<p>开吃得时候记得搅拌一下，并且要蘸着油吃才有味道^_^<br><img src="/img/Spicy-fish/6.jpg" alt=""></p>
<blockquote>
<p>我直到吃完之后才想起来，应该要放点芹菜之类的辅料的，这样无论从色泽还是味道上，无疑都会更加好。-_-</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>麻辣鱼简直就是大餐啊，油而不腻，并且鱼的腥味直接被重口味的油辣给冲掉了-_-，可惜我做的还不到火候。<br>又是一个周五，所以要给自己一个大餐，哈哈！</p>
<h2 id="食材">食材</h2><ul>
<li>鱼：最好是黑鱼，并且要切片（自己切麻烦，可以在买菜的时候直]]>
    </summary>
    
      <category term="Food" scheme="http://yyl8781697.github.io/tags/Food/"/>
    
      <category term="Food" scheme="http://yyl8781697.github.io/categories/Food/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[谈谈Scala中的枚举]]></title>
    <link href="http://yyl8781697.github.io/2015/06/06/Scala/Enum-in-Scala/"/>
    <id>http://yyl8781697.github.io/2015/06/06/Scala/Enum-in-Scala/</id>
    <published>2015-06-06T01:56:03.000Z</published>
    <updated>2015-06-07T00:49:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="先谈Java中的枚举">先谈Java中的枚举</h2><p>将<code>Scala</code>的枚举之前，我们先来讲讲关于<code>Java</code>里面的枚举（相信对于广大程序猿来说都是很熟悉）：</p>
<ul>
<li><p>使用<code>enum</code>关键词定义</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> WeekDay&#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无法再继承其他类或者枚举（但是可以实现接口），因为它默认继承了<code>java.lang.Enum</code></p>
</li>
<li>无法在外部调用枚举的构造函数（因为枚举的构造函数都是私有的，只有内部才能调用）</li>
<li>枚举其实是一组<code>int</code>常量（当初它就是因为使用<code>int</code>常量的需求很大才又了枚举），它还可以在<code>swtich</code>中很方便的使用</li>
<li><p>每个枚举变量还可以重写枚举类或者实现接口中的方法（这个蛮好用）</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> WeekDay&#123;</span><br><span class="line">Mon&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"monday"</span>;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">Tue&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"tuesday"</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">""</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>…（我也不知道了-_-）</p>
</li>
</ul>
<h2 id="再看Scala中的枚举">再看Scala中的枚举</h2><blockquote>
<p>你会发现，上面说的一切在<code>Scala</code>中其实并没有甚么卵用-_-，因为在<code>Scala</code>中压根就么有<code>enum</code>这个关键词，但是当初发明<code>Scala</code>大神兼<code>Java</code>的创始人并没有落下枚举。</p>
</blockquote>
<p><code>Scala</code>不用关注枚举的特别语法，取而代之的是标准库中的类:<code>scala.Enumeration</code><br><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">App</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">WeekDay</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Enumeration</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">WeekDay</span> =</span> <span class="type">Value</span><span class="comment">//这里仅仅是为了将Enumration.Value的类型暴露出来给外界使用而已</span></span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">Mon</span>, <span class="title">Tue</span>, <span class="title">Wed</span>, <span class="title">Thu</span>, <span class="title">Fri</span>, <span class="title">Sat</span>, <span class="title">Sun</span> =</span> <span class="type">Value</span><span class="comment">//在这里定义具体的枚举实例</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">WeekDay</span>._</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isWorkingDay</span>(</span>d: <span class="type">WeekDay</span>) = ! (d == <span class="type">Sat</span> || d == <span class="type">Sun</span>)</span><br><span class="line"></span><br><span class="line">  <span class="type">WeekDay</span>.values filter isWorkingDay foreach println<span class="comment">//使用语法糖进行输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述是源码中给的一个枚举Example，可以发现：</p>
<ul>
<li>它是一个伴随对象</li>
<li>需要显式得继承<code>Enumeration</code></li>
<li>具体的枚举实例都是需要赋值成<code>Value</code>这个对象（它是在超类中定义）</li>
</ul>
<h2 id="Enumeration源码分析">Enumeration源码分析</h2><h3 id="构造函数以有变量">构造函数以有变量</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Defines a finite set of values specific to the enumeration. Typically</span><br><span class="line"> *  these values enumerate all possible forms something can take and provide</span><br><span class="line"> *  a lightweight alternative to case classes.</span><br><span class="line"> *</span><br><span class="line"> *  Each call to a `Value` method adds a new unique value to the enumeration.</span><br><span class="line"> *  To be accessible, these values are usually defined as `val` members of</span><br><span class="line"> *  the evaluation.</span><br><span class="line"> *</span><br><span class="line"> *  All values in an enumeration share a common, unique type defined as the</span><br><span class="line"> *  `Value` type member of the enumeration (`Value` selected on the stable</span><br><span class="line"> *  identifier path of the enumeration instance).</span><br><span class="line"> *</span><br><span class="line"> *  @param initial The initial value from which to count the integers that</span><br><span class="line"> *                 identifies values at run-time.</span><br><span class="line"> *  @author  Matthias Zenger</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@SerialVersionUID</span>(<span class="number">8476000850333817230</span>L)</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enumeration</span> (</span>initial: <span class="type">Int</span>) <span class="keyword">extends</span> <span class="type">Serializable</span> &#123;</span><br><span class="line">  thisenum =&gt;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span>(</span>) = <span class="keyword">this</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The mapping from the integer used to identify values to the actual</span><br><span class="line">    * values. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">vmap</span>:</span> mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Value</span>] = <span class="keyword">new</span> mutable.<span class="type">HashMap</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The cache listing all values of this enumeration. */</span></span><br><span class="line">  <span class="annotation">@transient</span> <span class="keyword">private</span> <span class="keyword">var</span> vset: <span class="type">ValueSet</span> = <span class="literal">null</span></span><br><span class="line">  <span class="annotation">@transient</span> <span class="annotation">@volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> vsetDefined = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The mapping from the integer used to identify values to their</span><br><span class="line">    * names. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">nmap</span>:</span> mutable.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] = <span class="keyword">new</span> mutable.<span class="type">HashMap</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The values of this enumeration as a set.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">values</span>:</span> <span class="type">ValueSet</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vsetDefined) &#123;</span><br><span class="line">      vset = (<span class="type">ValueSet</span>.newBuilder ++= vmap.values).result()</span><br><span class="line">      vsetDefined = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    vset</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The integer to use to identify the next created value. */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">var</span> nextId: <span class="type">Int</span> = initial</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The string to use to name the next created value. */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">var</span> nextName: <span class="type">Iterator</span>[<span class="type">String</span>] = _</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">nextNameOrNull</span> =</span></span><br><span class="line">    <span class="keyword">if</span> (nextName != <span class="literal">null</span> &amp;&amp; nextName.hasNext) nextName.next <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The highest integer amongst those used to identify values in this</span><br><span class="line">    * enumeration. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> topId = initial</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The lowest integer amongst those used to identify values in this</span><br><span class="line">    * enumeration, but no higher than 0. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> bottomId = <span class="keyword">if</span>(initial &lt; <span class="number">0</span>) initial <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The one higher than the highest integer amongst those used to identify</span><br><span class="line">    *  values in this enumeration. */</span></span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">maxId</span> =</span> topId</span><br></pre></td></tr></table></figure>
<p>上面是洋洋洒洒贴了<code>Enumeration</code>类在<code>Scala</code>中的部分源码，从中大致可以看到这么几个关键点：</p>
<ul>
<li>它提供了一个轻量级的枚举类</li>
<li><code>initial</code>初始化变量为整个枚举实例的容量，但是它在运行时可以变化</li>
<li><code>vmap</code>：非常重要的一个变量，它是存储了枚举id和枚举值之间的映射容器。</li>
<li><code>nmap</code>：也是蛮重要的一个变量，存储了枚举id和枚举名称的容器</li>
<li><code>**Id</code>：所有带Id后缀的变量都是为了维护整个枚举的序号</li>
<li>其他就是提供了各种迭代器，用于取值的东西</li>
</ul>
<h3 id="Value类的相关定义">Value类的相关定义</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The type of the enumerated values. */</span></span><br><span class="line"><span class="annotation">@SerialVersionUID</span>(<span class="number">7091335633555234129</span>L)</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Value</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Ordered</span>[</span><span class="type">Value</span>] <span class="keyword">with</span> <span class="type">Serializable</span> &#123;</span><br><span class="line"><span class="comment">/** the id and bit location of this enumeration value */</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">id</span>:</span> <span class="type">Int</span></span><br><span class="line"><span class="comment">/** a marker so we can tell whose values belong to whom come reflective-naming time */</span></span><br><span class="line"><span class="keyword">private</span>[<span class="type">Enumeration</span>] <span class="function"><span class="keyword">val</span> <span class="title">outerEnum</span> =</span> thisenum</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compare</span>(</span>that: <span class="type">Value</span>): <span class="type">Int</span> =</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.id &lt; that.id) -<span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.id == that.id) <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">equals</span>(</span>other: <span class="type">Any</span>) = other <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> that: <span class="type">Enumeration</span>#<span class="type">Value</span>  =&gt; (outerEnum eq that.outerEnum) &amp;&amp; (id == that.id)</span><br><span class="line">  <span class="keyword">case</span> _                        =&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">hashCode</span>:</span> <span class="type">Int</span> = id.##</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Create a ValueSet which contains this value and another one */</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">+</span> (</span>v: <span class="type">Value</span>) = <span class="type">ValueSet</span>(<span class="keyword">this</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在源码的Example中可以看到所有的枚举都是被赋值为<code>Value</code>类型，从上面的源码中可以看到<code>Value</code>类是一个抽象类，看它的内容只是提供了枚举值比较以及id的获取，在<code>Enumeration</code>源码中提供了一个叫<code>Val</code>的类对<code>Value</code>实现，重要是重写了整数命名和id的识别。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** A class implementing the [[scala.Enumeration.Value]] type. This class</span><br><span class="line">*  can be overridden to change the enumeration's naming and integer</span><br><span class="line">*  identification behaviour.</span><br><span class="line">*/</span></span><br><span class="line"><span class="annotation">@SerialVersionUID</span>(<span class="number">0</span> - <span class="number">3501153230598116017</span>L)</span><br><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Val</span>(</span>i: <span class="type">Int</span>, name: <span class="type">String</span>) <span class="keyword">extends</span> <span class="type">Value</span> <span class="keyword">with</span> <span class="type">Serializable</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span>(</span>i: <span class="type">Int</span>)       = <span class="keyword">this</span>(i, nextNameOrNull)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span>(</span>name: <span class="type">String</span>) = <span class="keyword">this</span>(nextId, name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span>(</span>)             = <span class="keyword">this</span>(nextId)</span><br><span class="line"><span class="comment">//to do many things.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Value方法的定义">Value方法的定义</h3><blockquote>
<p>请注意，请注意，Example中的第4行、第5行的<code>Value</code>，前者是类，后者是方法(括号省略了而已)</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Creates a fresh value, part of this enumeration. */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">Value</span>:</span> <span class="type">Value</span> = <span class="type">Value</span>(nextId)</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Creates a fresh value, part of this enumeration, identified by the</span><br><span class="line">*  integer `i`.</span><br><span class="line">*</span><br><span class="line">*  @param i An integer that identifies this value at run-time. It must be</span><br><span class="line">*           unique amongst all values of the enumeration.</span><br><span class="line">*  @return  Fresh value identified by `i`.</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">Value</span>(</span>i: <span class="type">Int</span>): <span class="type">Value</span> = <span class="type">Value</span>(i, nextNameOrNull)</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Creates a fresh value, part of this enumeration, called `name`.</span><br><span class="line">*</span><br><span class="line">*  @param name A human-readable name for that value.</span><br><span class="line">*  @return  Fresh value called `name`.</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">Value</span>(</span>name: <span class="type">String</span>): <span class="type">Value</span> = <span class="type">Value</span>(nextId, name)</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Creates a fresh value, part of this enumeration, called `name`</span><br><span class="line">*  and identified by the integer `i`.</span><br><span class="line">*</span><br><span class="line">* @param i    An integer that identifies this value at run-time. It must be</span><br><span class="line">*             unique amongst all values of the enumeration.</span><br><span class="line">* @param name A human-readable name for that value.</span><br><span class="line">* @return     Fresh value with the provided identifier `i` and name `name`.</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">Value</span>(</span>i: <span class="type">Int</span>, name: <span class="type">String</span>): <span class="type">Value</span> = <span class="keyword">new</span> <span class="type">Val</span>(i, name)</span><br></pre></td></tr></table></figure>
<p>上面提供了各种<code>Value</code>的重载方法均是返回了<code>Val</code>类，所以说嘛，你有需要完全可以自己再实现一个<code>Value</code>类。</p>
<h2 id="Scala中枚举的简单使用">Scala中枚举的简单使用</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">WeekDay</span>.<span class="type">Wed</span>)<span class="comment">//直接取枚举值</span></span><br><span class="line">println(<span class="type">WeekDay</span>.<span class="type">Wed</span>.id)<span class="comment">//取枚举值所在序号</span></span><br><span class="line">println(<span class="type">WeekDay</span>.maxId)<span class="comment">//枚举值的个数</span></span><br><span class="line">println(<span class="type">WeekDay</span>.withName(<span class="string">"Wed"</span>))<span class="comment">//通过字符串获取枚举（这里是不需要反射的）</span></span><br></pre></td></tr></table></figure>
<p>获取枚举的具体信息还是非常方便的</p>
<pre><code><span class="title">Wed</span>
<span class="number">2</span>
<span class="number">7</span>
Wed
</code></pre><p>获取全部的枚举值进行输出<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WeekDay</span>.values.foreach(println(_))</span><br></pre></td></tr></table></figure></p>
<pre><code><span class="title">Mon</span>
Tue
Wed
Thu
Fri
Sat
Sun
</code></pre><p>枚举也可以用在匹配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">matchTest(WeekDay.Wed)</span><br><span class="line">matchTest(WeekDay.Sat)</span><br><span class="line"></span><br><span class="line">def matchTest=(week:WeekDay.Value) =&gt;week match&#123;<span class="comment">//注意，这里枚举的类型都是Value</span></span><br><span class="line"><span class="keyword">case</span> w <span class="keyword">if</span> w.compare(WeekDay.Fri)&lt;=<span class="number">0</span> =&gt;println(<span class="string">"sorry,please working"</span>)</span><br><span class="line"><span class="keyword">case</span> WeekDay.Sat=&gt;println((<span class="string">"go shopping"</span>))</span><br><span class="line"><span class="keyword">case</span> WeekDay.Sun=&gt;println((<span class="string">"sleeping"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到输出</p>
<pre><code>sorry,please working
<span class="keyword">go</span> shopping
</code></pre><blockquote>
<p>这里的枚举值的比较其实就是对比他们的Id是否相等。</p>
</blockquote>
<h2 id="总结">总结</h2><ul>
<li><code>Java</code>中的那套枚举并不能直接使用到<code>Scala</code>中</li>
<li><code>Scala</code>中的枚举使用轻量级<code>Enumeration</code>进行实现</li>
<li><code>Scala</code>中的枚举其实是一个伴随对象</li>
<li><code>Scala</code>中的枚举没有方法重写功能</li>
<li><code>Scala</code>中的枚举其实都是<code>Enumeration.Value</code>这个对象</li>
</ul>
<h2 id="参考">参考</h2><ul>
<li><a href="http://www.cnblogs.com/gnivor/p/4191017.html" target="_blank" rel="external">http://www.cnblogs.com/gnivor/p/4191017.html</a></li>
<li><code>Enumeration.scala</code></li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="先谈Java中的枚举">先谈Java中的枚举</h2><p>将<code>Scala</code>的枚举之前，我们先来讲讲关于<code>Java</code>里面的枚举（相信对于广大程序猿来说都是很熟悉）：</p>
<ul>
<li><p>使用<code>enu]]>
    </summary>
    
      <category term="Scala" scheme="http://yyl8781697.github.io/tags/Scala/"/>
    
      <category term="Scala" scheme="http://yyl8781697.github.io/categories/Scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初识Akka]]></title>
    <link href="http://yyl8781697.github.io/2015/06/04/Akka/Study-Akka-First/"/>
    <id>http://yyl8781697.github.io/2015/06/04/Akka/Study-Akka-First/</id>
    <published>2015-06-04T15:45:36.000Z</published>
    <updated>2015-06-07T05:14:13.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这两天<a href="http://www.csdn.net/article/2015-06-03/2824843" target="_blank" rel="external">微软的分布式系统开发框架rDSN开源</a>出来了，必须要<a href="http://akka.io/" target="_blank" rel="external">Akka</a>压压惊，当然在<code>Spark</code>中大量的使用了<code>AKKA</code>是主要原因^_^</p>
</blockquote>
<h2 id="AKKA介绍">AKKA介绍</h2><p><a href="http://akka.io/" target="_blank" rel="external">Akka</a>是一个基于<code>JVM</code>的用于构建高并发、分布式、弹性的消息驱动系统，它有以下5个特点：</p>
<ol>
<li>并发和分布式</li>
<li>弹性设计</li>
<li>高性能</li>
<li>去中心化</li>
<li>高扩展性</li>
</ol>
<p>可以基于<code>AKKA</code>构建高并发的web框架，也可以构建分布式系统（<code>Spark</code>）</p>
<h2 id="AKKA的引用">AKKA的引用</h2><p>如果你是<code>Maven</code>用户，你可以这么添加依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.typesafe.akka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>akka-actor_2.10<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.3.11<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果你是<code>SBT</code>用户，你的<code>build.sbt</code>可以这么写<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name := &#34;My Project&#34;&#10;version := &#34;1.0&#34;&#10;scalaVersion := &#34;2.10.4&#34;&#10;libraryDependencies +=&#10;  &#34;com.typesafe.akka&#34; %% &#34;akka-actor&#34; % &#34;2.3.11&#34;</span><br></pre></td></tr></table></figure></p>
<p>它还提供了好多其他的其他用法，但是由于天朝连国外网速也是在是太慢了，我直接去<a href="http://akka.io/downloads/" target="_blank" rel="external">http://akka.io/downloads/</a>将压缩包给download下来，然后将已编译的<code>jar</code>添加到IDEA中，简单、粗暴、高效。</p>
<h2 id="AKAA的使用">AKAA的使用</h2><p><code>AKKA</code>是基于<code>Scala</code>的<code>Actor</code>来实现的，了解<code>Scala</code>的<code>Actor</code>可以参考我之前的一篇文章<a href="http://kubicode.me/2015/04/26/Scala/Scala-In-My-Eyes/#Actor" target="_blank" rel="external">我眼中的Scala-简洁不简单</a>。<br><br>在<code>AKKA</code>中最重要的是<code>ActorSystem</code>，关于<code>ActorSystem</code>在Doc中有这么一句话：</p>
<blockquote>
<p>Note: An ActorSystem is a heavyweight structure that will allocate 1…N Threads, so create one per logical application.</p>
</blockquote>
<h3 id="普通模式的调用">普通模式的调用</h3><p>首先创建一个类<code>GreetingActor</code>添加以下代码<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor._</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Greeting</span>(</span>who:<span class="type">String</span>)</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by yanyl on 6/3/15.</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingActor</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Actor</span> <span class="keyword"><span class="keyword">with</span></span> <span class="title">ActorLogging</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive=</span>&#123;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Greeting</span>(who)=&gt;log.info(<span class="string">"hello"</span>+who);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就建立了一个标准的<code>Actor</code>，用过<code>receive</code>方法不断地监听，<br><br>然后建立一个<code>Test</code>类向这个<code>Actor</code>发送消息<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor._;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by yanyl on 6/2/15.</span><br><span class="line"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span>(</span>args:<span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> =&#123;</span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">system=ActorSystem</span>(</span><span class="string">"mySystem"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">greeter=system</span>.<span class="title">actorOf</span>(</span><span class="type">Props</span>[<span class="type">GreetingActor</span>],name=<span class="string">"greeter"</span>);</span><br><span class="line">    greeter!<span class="type">Greeting</span>(<span class="string">"tom"</span>)</span><br><span class="line">    println(<span class="string">"i am not tom"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>叹号<code>!</code>表示发送非阻塞消息，执行之后你可以在控制台看到</p>
<pre><code><span class="tag">i</span> am not tom
[INFO] [<span class="number">06</span>/<span class="number">05</span>/<span class="number">2015</span> <span class="number">00</span>:<span class="number">56</span>:<span class="number">27.188</span>] [mySystem-akka<span class="class">.actor</span><span class="class">.default-dispatcher-5</span>] [akka:<span class="comment">//mySystem/user/greeter] hellotom</span>
</code></pre><p>并可以发现这个程序并没有停止，这是因为<code>Actor</code>一直在监听。</p>
<h2 id="未完待续。。。">未完待续。。。</h2><h2 id="参考">参考</h2><ul>
<li><a href="http://akka.io/" target="_blank" rel="external">http://akka.io/</a></li>
<li><a href="http://doc.akka.io/docs/akka/2.3.11/AkkaScala.pdf?_ga=1.249061252.2036148369.1433248459" target="_blank" rel="external">Akka doc for scala</a></li>
<li><a href="http://www.gtan.com/akka_doc/index.html" target="_blank" rel="external">http://www.gtan.com/akka_doc/index.html</a>  难得的中文文档</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这两天<a href="http://www.csdn.net/article/2015-06-03/2824843" target="_blank" rel="external">微软的分布式系统开发框架rDSN开源</a>出来了，必须要<a h]]>
    </summary>
    
      <category term="Akka" scheme="http://yyl8781697.github.io/tags/Akka/"/>
    
      <category term="Akka" scheme="http://yyl8781697.github.io/categories/Akka/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spark源码中所使用的经典数据结构或者设计模式]]></title>
    <link href="http://yyl8781697.github.io/2015/06/02/Spark/The-Struct-or-Pattern-In-Spark-Source/"/>
    <id>http://yyl8781697.github.io/2015/06/02/Spark/The-Struct-or-Pattern-In-Spark-Source/</id>
    <published>2015-06-02T13:32:28.000Z</published>
    <updated>2015-06-02T13:46:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="位域法">位域法</h2><blockquote>
<p>如果一个枚举类型的元素主要用于在集合中，一般就使用<code>int</code>枚举类型，将2的不同倍数赋予每个常量。<br>这种表示方法让你用OR位运算将几个常量合并到一个集合中，称作位域。</p>
</blockquote>
<p>在<code>Spark</code>源码中进入<code>SparkSubmit</code>类中就可以看到<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cluster managers</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">YARN</span> =</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">STANDALONE</span> =</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">MESOS</span> =</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">LOCAL</span> =</span> <span class="number">8</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">ALL_CLUSTER_MGRS</span> =</span> <span class="type">YARN</span> | <span class="type">STANDALONE</span> | <span class="type">MESOS</span> | <span class="type">LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Deploy modes</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">CLIENT</span> =</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">CLUSTER</span> =</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">val</span> <span class="title">ALL_DEPLOY_MODES</span> =</span> <span class="type">CLIENT</span> | <span class="type">CLUSTER</span></span><br></pre></td></tr></table></figure></p>
<p>将集群类型和部署模式使用位域法来存储。</p>
<blockquote>
<p>在《Effective Java》第32条中提到，但是都不推荐。。<code>Spark</code>都使用了，难道这种结构不好嘛？？^_^</p>
</blockquote>
<h1 id="持续更新中。。。。">持续更新中。。。。</h1>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="位域法">位域法</h2><blockquote>
<p>如果一个枚举类型的元素主要用于在集合中，一般就使用<code>int</code>枚举类型，将2的不同倍数赋予每个常量。<br>这种表示方法让你用OR位运算将几个常量合并到一个集合中，称作位域。</p>
<]]>
    </summary>
    
      <category term="Spark" scheme="http://yyl8781697.github.io/tags/Spark/"/>
    
      <category term="Spark" scheme="http://yyl8781697.github.io/categories/Spark/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自己煮：红烧鸡爪]]></title>
    <link href="http://yyl8781697.github.io/2015/05/31/Food/Braised-chicken-claw/"/>
    <id>http://yyl8781697.github.io/2015/05/31/Food/Braised-chicken-claw/</id>
    <published>2015-05-31T12:46:20.000Z</published>
    <updated>2015-06-06T12:58:19.000Z</updated>
    <content type="html"><![CDATA[<p>具体煮的步骤和<a href="http://kubicode.me/2015/04/19/Food/Coke-Chicken-feet/" target="_blank" rel="external">自己煮：可口又美味的可乐鸡翅</a>一样，无法是增加了酱油的分量以及在最后煮的时候放得时水，可以看到这样煮出来的颜色会比较浓一下，直接看成品图吧：^_^<br><img src="/img/jizhua/8.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>具体煮的步骤和<a href="http://kubicode.me/2015/04/19/Food/Coke-Chicken-feet/" target="_blank" rel="external">自己煮：可口又美味的可乐鸡翅</a>一样，无法是增加了酱油的分量以及在]]>
    </summary>
    
      <category term="Food" scheme="http://yyl8781697.github.io/tags/Food/"/>
    
      <category term="Food" scheme="http://yyl8781697.github.io/categories/Food/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我在Mac中使用的各种实用工具]]></title>
    <link href="http://yyl8781697.github.io/2015/05/31/Mac/My-Tools-Used-In-Mac/"/>
    <id>http://yyl8781697.github.io/2015/05/31/Mac/My-Tools-Used-In-Mac/</id>
    <published>2015-05-31T06:30:53.000Z</published>
    <updated>2015-05-31T07:04:48.000Z</updated>
    <content type="html"><![CDATA[<p>用Mac一个多月来，已经慢慢习惯，Mac下的软件都比较精致，虽然其数量远不及Windows，但是日常使用的都已经有了。</p>
<h2 id="office2011_for_mac破解版">office2011 for mac破解版</h2><p>下载地址<a href="http://www.macx.cn/thread-2082485-1-1.html" target="_blank" rel="external">http://www.macx.cn/thread-2082485-1-1.html</a><br>穷人Mac使用者首选，可以和Windows上的office无缝对接，如果你安装完之后发现word很模糊的话 请将office升级到最新版。<br>里面还有一个很强的功能就是Micosoft Connection，用这个软件可以直接在mac端远程到windows端，方便的很。</p>
<h2 id="chmox">chmox</h2><p>下载地址<a href="http://chmox.sourceforge.net/" target="_blank" rel="external">http://chmox.sourceforge.net/</a><br>chmox可以在mac下查看chm帮助文档,毕竟chm格式的文档很多啊^_^，chmox真实良心产品</p>
<h2 id="Snip-截屏软件">Snip-截屏软件</h2><p>下载地址<a href="http://www.snip.qq.com/" target="_blank" rel="external">http://www.snip.qq.com/</a><br>它软件属于企鹅出品，质量也还不错，不过安装的时候建议不要绑定QQ邮箱-_-</p>
<h2 id="iTerm_2">iTerm 2</h2><p>下载地址<a href="http://iterm2.com/" target="_blank" rel="external">http://iterm2.com/</a><br>iTerm 2 的分屏功能让人用着很爽，它们都说和<a href="http://ohmyz.sh/" target="_blank" rel="external">ohmyz</a>配合简直优雅到爆，但是我还是比较习惯原生的.bash -_-</p>
<h2 id="Sublime_Text2">Sublime Text2</h2><p>下载地址<a href="http://www.sublimetext.com/2" target="_blank" rel="external">http://www.sublimetext.com/2</a><br>和Windows端一样好用，哈哈，因为习惯了这个编辑器。</p>
<blockquote>
<p>遗憾的是Notepad++没有Mac版-_-</p>
</blockquote>
<h2 id="FileZilla-Ftp_工具">FileZilla-Ftp 工具</h2><p>下载地址<a href="https://filezilla-project.org/" target="_blank" rel="external">https://filezilla-project.org/</a><br>用这个连接ftp很方便，不过由于系统语言是英文的，FileZilla老是对中文乱码，还不知道哪里设置。。。</p>
<h2 id="VirtualBox虚拟机">VirtualBox虚拟机</h2><p>下载地址<a href="https://www.virtualbox.org/" target="_blank" rel="external">https://www.virtualbox.org/</a><br>小巧，便捷，免费,用着还挺顺手。</p>
<h2 id="TeamViewer">TeamViewer</h2><p>下载地址<a href="https://www.teamviewer.com/en/index.aspx" target="_blank" rel="external">https://www.teamviewer.com/en/index.aspx</a><br>远程协作工具，该工具在Mac下一样好用</p>
<h2 id="MPlayer-视频播放器">MPlayer-视频播放器</h2><p>下载地址<a href="http://itunes.apple.com/us/app/mplayerx/id421131143?mt=12" target="_blank" rel="external">http://itunes.apple.com/us/app/mplayerx/id421131143?mt=12</a><br>非常好使的一个视频播放软件，支持较多的格式，比自带的QuickTime好用多了-_-</p>
<h2 id="Chrome">Chrome</h2><p>下载地址<a href="http://www.google.cn/chrome/" target="_blank" rel="external">http://www.google.cn/chrome/</a><br>还是习惯使用Chrome来上网啊。。。</p>
<h2 id="Eclipse">Eclipse</h2><p>下载地址<a href="http://www.eclipse.org/downloads/" target="_blank" rel="external">http://www.eclipse.org/downloads/</a><br>跨平台的IDE用起来就是舒服</p>
<h2 id="IDEA">IDEA</h2><p>下载地址<a href="http://www.jetbrains.com/idea/download/" target="_blank" rel="external">http://www.jetbrains.com/idea/download/</a><br>号称开发神奇，下载来玩玩。。^_^</p>
<blockquote>
<p>我喜欢将IDEA的KeyMap设置为Eclipse风格-_-</p>
</blockquote>
<h2 id="MacDown">MacDown</h2><p>下载地址<a href="http://macdown.uranusjr.com/" target="_blank" rel="external">http://macdown.uranusjr.com/</a><br>Mac下写Markdown文章的必备工具，免费漂亮。。</p>
<h2 id="必备常用软件">必备常用软件</h2><p>QQ、迅雷、搜狗输入法等不贴地址了，去各自的官网上都能下载到。蛮好用的。</p>
<p>持续更新中。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>用Mac一个多月来，已经慢慢习惯，Mac下的软件都比较精致，虽然其数量远不及Windows，但是日常使用的都已经有了。</p>
<h2 id="office2011_for_mac破解版">office2011 for mac破解版</h2><p>下载地址<a href="]]>
    </summary>
    
      <category term="Mac" scheme="http://yyl8781697.github.io/tags/Mac/"/>
    
      <category term="Mac" scheme="http://yyl8781697.github.io/categories/Mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用IDEA搭建Spark源码环境及编译Spark源码]]></title>
    <link href="http://yyl8781697.github.io/2015/05/31/Spark/Build-Spark-Source-And-Compile/"/>
    <id>http://yyl8781697.github.io/2015/05/31/Spark/Build-Spark-Source-And-Compile/</id>
    <published>2015-05-31T05:57:05.000Z</published>
    <updated>2015-06-17T15:47:34.000Z</updated>
    <content type="html"><![CDATA[<p>之前在看网上使用Eclipse搭建<code>Spark</code>的源码环境各种复杂，所以我只会spark source code下载下来，然后Import到Eclipse中，各种报错，各种包没有，还好我只是看看源码而已，不运行它报错也无所谓啦，人懒没办法..<br><br>但是现在想深入得学习一下<code>Spark</code>的源码环,就不得不搭建完整地环境，所以使用号称开发神器的IDEA来搭建<code>Spark</code>的源码环境，果然很方便^_^</p>
<h2 id="准备工作">准备工作</h2><ul>
<li><code>JDK1.7+</code></li>
<li><code>Scala2.10.4</code>(最好用这个版本，不然用最新版可能导致Spark出各种错误，点<a href="http://www.scala-lang.org/download/2.10.4.html" target="_blank" rel="external">这里</a>下载)</li>
<li><code>IntelliJ IDEA 14 Community Edition</code>(记得下载时选择<a href="http://www.jetbrains.com/idea/download/" target="_blank" rel="external">社区版</a>,它是免费的)</li>
<li><code>Mac OS X 10.10.2</code> (用其他环境也可以，但是别用windows啊)</li>
</ul>
<h2 id="从Github上clone源码">从Github上clone源码</h2><p>打开Idea,在欢迎界面别动！！！<br><br>点击<strong>Check out from version Control-&gt;Git</strong><br><br>在弹出的界面上输入github上spark的托管地址<a href="http://www.jetbrains.com/idea/download/" target="_blank" rel="external">http://www.jetbrains.com/idea/download/</a><br><img src="/img/Build-Spark-Source-And-Compile/clone.png" height="200px" width="400px"></p>
<p>好了，你可以慢慢等了，我这里clone了半小时-_-网速不好啊。</p>
<h2 id="pom-xml的依赖包下载"><code>pom.xml</code>的依赖包下载</h2><p>好不容易将<code>Spark</code>源码clone到本地了，这个时候idea会提醒你发现<code>pom.xml</code>，询问你是否下载其中的依赖，这个时候你要点“是”（Idea的强大之处就是会把这里的依赖全部给你下载了）。<br>好了，你又可以慢慢等待了，这个时候进度条在Idea右下角，想看进度的自己去点出来，我这里下载依赖貌似下载了一个多小时-_-</p>
<p>依赖包下载完成之后你就可以看<code>Spark</code>源码了<br><img src="/img/Build-Spark-Source-And-Compile/codeui.png" alt=""></p>
<h2 id="编译Spark源码">编译Spark源码</h2><p>编译之前先打开<code>pom.xml</code>看java的版本确保和你本机的版本一样。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">java.version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="title">java.version</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后打开终端iterm，进入sarpk的源码根目录，然后执行<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yans-MacBook-Pro:spark yanyl$build/mvn -DskipTests clean package</span><br></pre></td></tr></table></figure></p>
<p>进行最终的编译，这里编译也是要花很多时间啊-_-，慢慢等吧，天朝的网络就是没办法。</p>
<blockquote>
<p>如果想有其他的编译需求，比如Spark on Yarn：<br> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/mvn -Pyarn -Phadoop-2.4 -Dhadoop.version=2.4.0 -DskipTests clean package</span><br></pre></td></tr></table></figure></p>
<p>具体看官网<code><a href="http://spark.apache.org/docs/latest/building-spark.html#building-with-sbt" target="_blank" rel="external">http://spark.apache.org/docs/latest/building-spark.html#building-with-sbt</a></code>,也还可以使用<code>Sbt</code>来进行编译，不过推荐使用<code>Maven</code>，因为他会下载<code>Zinc</code>来加速编译，还可以显示依赖的下载进度^_^。</p>
</blockquote>
<p>编译完了之后控制台会输出：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Reactor Summary:</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] Spark Project Parent POM ........................... SUCCESS [  5.915 s]</span><br><span class="line">[INFO] Spark Launcher Project ............................. SUCCESS [ 11.219 s]</span><br><span class="line">[INFO] Spark Project Networking ........................... SUCCESS [  9.197 s]</span><br><span class="line">[INFO] Spark Project Shuffle Streaming Service ............ SUCCESS [  4.701 s]</span><br><span class="line">[INFO] Spark Project Unsafe ............................... SUCCESS [  4.131 s]</span><br><span class="line">[INFO] Spark Project Core ................................. SUCCESS [03:29 min]</span><br><span class="line">[INFO] Spark Project Bagel ................................ SUCCESS [  7.715 s]</span><br><span class="line">[INFO] Spark Project GraphX ............................... SUCCESS [ 21.757 s]</span><br><span class="line">[INFO] Spark Project Streaming ............................ SUCCESS [ 40.511 s]</span><br><span class="line">[INFO] Spark Project Catalyst ............................. SUCCESS [ 45.336 s]</span><br><span class="line">[INFO] Spark Project SQL .................................. SUCCESS [ 52.931 s]</span><br><span class="line">[INFO] Spark Project ML Library ........................... SUCCESS [01:10 min]</span><br><span class="line">[INFO] Spark Project Tools ................................ SUCCESS [  3.714 s]</span><br><span class="line">[INFO] Spark Project Hive ................................. SUCCESS [01:02 min]</span><br><span class="line">[INFO] Spark Project REPL ................................. SUCCESS [ 10.813 s]</span><br><span class="line">[INFO] Spark Project YARN ................................. SUCCESS [01:41 min]</span><br><span class="line">[INFO] Spark Project Assembly ............................. SUCCESS [01:25 min]</span><br><span class="line">[INFO] Spark Project External Twitter ..................... SUCCESS [  7.853 s]</span><br><span class="line">[INFO] Spark Project External Flume Sink .................. SUCCESS [  6.082 s]</span><br><span class="line">[INFO] Spark Project External Flume ....................... SUCCESS [  8.545 s]</span><br><span class="line">[INFO] Spark Project External MQTT ........................ SUCCESS [  6.492 s]</span><br><span class="line">[INFO] Spark Project External ZeroMQ ...................... SUCCESS [  6.426 s]</span><br><span class="line">[INFO] Spark Project External Kafka ....................... SUCCESS [  9.914 s]</span><br><span class="line">[INFO] Spark Project Examples ............................. SUCCESS [01:34 min]</span><br><span class="line">[INFO] Spark Project External Kafka Assembly .............. SUCCESS [ 31.930 s]</span><br><span class="line">[INFO] Spark Project YARN Shuffle Service ................. SUCCESS [  7.461 s]</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 15:27 min</span><br><span class="line">[INFO] Finished at: 2015-05-31T22:56:11+08:00</span><br><span class="line">[INFO] Final Memory: 83M/653M</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></p>
<p>现在你就可以在<code>$SPARK_HOME/assembly/target/scala-2.10/</code>下发现这个<code>spark-assembly-1.4.0-SNAPSHOT-hadoop2.6.0.jar</code>文件了，他可以在IDE中引用来开发<code>Spark</code>程序。</p>
<h2 id="验证">验证</h2><p>为了验证编译结果，你可以到<code>$SPARK_HOME/bin/</code>目录下取执行<code>spark-shell</code>这个脚本:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&#62; val rdd=sc.parallelize(List(1,2,3,5))&#10;rdd: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at &#60;console&#62;:21&#10;&#10;scala&#62; rdd.count&#10;//...&#27492;&#22788;&#30465;&#30053;log&#10;res0: Long = 4&#10;scala&#62;</span><br></pre></td></tr></table></figure></p>
<p>这里就可以运行<code>local</code>模式的<code>Spark</code>了，赶紧去体验吧~^_^</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前在看网上使用Eclipse搭建<code>Spark</code>的源码环境各种复杂，所以我只会spark source code下载下来，然后Import到Eclipse中，各种报错，各种包没有，还好我只是看看源码而已，不运行它报错也无所谓啦，人懒没办法..<br><]]>
    </summary>
    
      <category term="Spark" scheme="http://yyl8781697.github.io/tags/Spark/"/>
    
      <category term="Spark" scheme="http://yyl8781697.github.io/categories/Spark/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Effective Java》第六章：枚举和注解]]></title>
    <link href="http://yyl8781697.github.io/2015/05/30/Effective%20Java/Enum-And-Annotation/"/>
    <id>http://yyl8781697.github.io/2015/05/30/Effective Java/Enum-And-Annotation/</id>
    <published>2015-05-30T15:57:33.000Z</published>
    <updated>2015-06-03T15:36:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="第30条：用枚举代替int常量">第30条：用枚举代替int常量</h2><p>在编程语言中还没有引入枚举类型之前，表示枚举类型的常用模式就是声明一组具名的<code>int</code>常量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APPLE_FUJI			=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APPLE_PIPPIN		=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APPLE_GRANNY_SMITH	=<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p>但是它又诸多的缺点：</p>
<ul>
<li>在类型安全性和使用方便性方面没有任何帮助。</li>
<li>如果关联的<code>int</code>放生了变化，客户端必须得重新编译。</li>
<li>打印调试的时候只能打印数字</li>
</ul>
<p>上述<code>int</code>常量如何使用枚举类实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> APPLE&#123;FUJI,PIPPIN,GRANNY_SMITH&#125;;</span><br></pre></td></tr></table></figure></p>
<p>除了编码简单之外，枚举的特点还有：</p>
<ul>
<li>枚举是类型安全的（所有可以作为单例的泛型化来使用）。</li>
<li>可以增加或者重新排列枚举类型中的常量，而无需重新编译它的客户端代码。</li>
<li>可以通过<code>toString</code>方法来打印可视的字符串。</li>
</ul>
<p>枚举类型还可以添加任意的方法和域，并实现任意的接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calc</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 具体继承了接口 并重新实现了</span><br><span class="line"> *<span class="javadoctag"> @author</span> yanyl</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation implements Calc&#123;</span><br><span class="line">	PLUS(<span class="string">"+"</span>)&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	MINUS(<span class="string">"-"</span>)&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x-y;&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	TIMES(<span class="string">"*"</span>)&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x*y;&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	DIVIDE(<span class="string">"/"</span>)&#123;</span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x/y;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line">	Operation(String symbol)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>.symbol=symbol;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.symbol;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述枚举可以这么使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Calc calc=Operation.PLUS;</span><br><span class="line">System.out.println(calc.apply(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure></p>
<p>是不是超级方便~</p>
<blockquote>
<p>总之而言，与<code>int</code>常量对比，枚举类型的优势是不言而喻的，（当然，当初枚举的出现就是为了解决<code>int</code>常量问题的^_^，所以大家还是多使用枚举吧）</p>
</blockquote>
<h2 id="第31条：用实例域代替序数">第31条：用实例域代替序数</h2><p>什么是枚举的序数，你知道吗？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Ensemble&#123;</span><br><span class="line">	SOLO,DUET,TRIO,QUARTET,QUITTET,</span><br><span class="line">	SEXTET,SEPTET,OCTET,NONET,DECTET;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMusicians</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ordinal()+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个枚举都有一个<code>ordinal()</code>方法，用于返回当前枚举值的序数，这个见都没见过的方法用起来看似很方便，但是如果你要修改常量的顺序，那么维护起来就是一场噩梦。<br>第30条说过了，枚举里面可以有字段，所以这条就是推荐使用实例域代替序数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Ensemble&#123;</span><br><span class="line">	SOLO(<span class="number">1</span>),DUET(<span class="number">2</span>),TRIO(<span class="number">3</span>),QUARTET(<span class="number">4</span>),QUITTET(<span class="number">5</span>),</span><br><span class="line">	SEXTET(<span class="number">6</span>),SEPTET(<span class="number">7</span>),OCTET(<span class="number">8</span>),NONET(<span class="number">9</span>),DECTET(<span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 使用自定义的一个实例域</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> numberOfMusicians;</span><br><span class="line">	Ensemble(<span class="keyword">int</span> numberOfMusicians)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>.numberOfMusicians=numberOfMusicians;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMusicians</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> numberOfMusicians+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法实现的修过虽好，然是感觉写起来好麻烦。。。维护起来会很简单吗？？？</p>
<h2 id="第32条：用EnumSet代替位域">第32条：用EnumSet代替位域</h2><blockquote>
<p>这个小节讲的其实就是和位图法相关。</p>
</blockquote>
<p>如果一个枚举类型的元素主要用于在集合中，一般就使用<code>int</code>枚举类型，将2的不同倍数赋予每个常量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_BOLD			=<span class="number">1</span>&lt;&lt;<span class="number">0</span>;<span class="comment">//1</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_ITALIC		=<span class="number">1</span>&lt;&lt;<span class="number">1</span>;<span class="comment">//2</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_UNDERLINE		=<span class="number">1</span>&lt;&lt;<span class="number">2</span>;<span class="comment">//4</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STYLE_STRIKETHROUGH	=<span class="number">1</span>&lt;&lt;<span class="number">3</span>;<span class="comment">//8</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> styles=-<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyStyles</span><span class="params">(<span class="keyword">int</span> styles)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.styles=styles;<span class="comment">//这里其实就是用位图法来保存，取值要用位移来取  int这里只能存32个值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种表示方法让你用OR位运算将几个常量合并到一个集合中，称作位域。<br>然后你可能会使用这或操作种方法来保持状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Text().applyStyles(Text.STYLE_BOLD|Text.STYLE_ITALIC);</span><br></pre></td></tr></table></figure></p>
<p>这种做法一个是打印是来比较难看懂，还有编译表示所有元素时也没好好的办法。</p>
<p>还好有<code>EnumSet</code>的出现，它实现了<code>Set</code>接口，如果底层枚举类型少于64个，那么这个<code>EnumSet</code>就是用一个<code>long</code>类型来表示，所以性能上也是很高的，上面这个例子用<code>EnumSet</code>来实现就是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">enum</span> Style&#123;BOLD,ITALIC,UNDERLINE,STRIKETHROUGH&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> EnumSet&lt;Style&gt; styles=<span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyStyles</span><span class="params">(EnumSet&lt;Style&gt; styles)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.styles=styles;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用方法就用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Text().applyStyles(EnumSet.of(Text.Style.BOLD, Text.Style.ITALIC));</span><br></pre></td></tr></table></figure></p>
<p>这是调用之后你打印<code>styles</code>这个变量可以看到</p>
<pre><code>[BOLD, ITALIC]
</code></pre><p>这种打印显示的总比单纯的数字要美好的多。</p>
<blockquote>
<p>总而言之，正式因为枚举类型要用集合，所以没有理由用位域来表示它。<br>其实我觉得用<code>EnumSet</code>应该没有位域快啊，估计高手还是会去用位域的把</p>
</blockquote>
<h2 id="第33条：用EnumMap代替序数索引">第33条：用EnumMap代替序数索引</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Herb</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">enum</span> Type &#123;ANNUL,PERENNIAL,BIENNIAL&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你需要将上面类的实例根据<code>Type</code>枚举类型来存储起来是，它推荐这么做：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Herb.Type,Set&lt;Herb&gt;&gt; enumMap=<span class="keyword">new</span> EnumMap&lt;Herb.Type,Set&lt;Herb&gt;&gt;(Herb.Type.class);</span><br></pre></td></tr></table></figure></p>
<p>但是我觉得何必这么麻烦,用下面的写得表示也很方便嘛，也还不需要记那么多东西<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer,Set&lt;Herb&gt;&gt; map=<span class="keyword">new</span> HashMap&lt;Integer,Set&lt;Herb&gt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>每次使用<code>Type.ordinal()</code>的索引即可。</p>
<h2 id="第34条：用接口模拟可伸缩的枚举">第34条：用接口模拟可伸缩的枚举</h2><p>前面几条讲了使用<code>Enum</code>的便利性，安全性，但是它的可伸缩性比较弱，因为枚举无法再继承类或者枚举，比较幸运地时枚举支持接口的实现。<br>例如第30条中的四则运算我需要扩展其他的运算：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExtendOperation implements Calc&#123;</span><br><span class="line">	EXP(<span class="string">"^"</span>)&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> Math.pow(x,y);&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	REMAINDER(<span class="string">"%"</span>)&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x%y;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line">	ExtendOperation(String symbol)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>.symbol=symbol;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.symbol;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后你就可以这么使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	System.out.println(test(Operation.PLUS,<span class="number">2</span>,<span class="number">3</span>));<span class="comment">//调用加法</span></span><br><span class="line">	System.out.println(test(ExtendOperation.EXP,<span class="number">2</span>,<span class="number">3</span>));<span class="comment">//调用求幂</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt; &amp; Calc&gt; <span class="function"><span class="keyword">double</span> <span class="title">test</span><span class="params">(T opt,<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> opt.apply(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终会输出</p>
<pre><code>5.0
8.0
</code></pre><p>总而言之，虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型，对它进行模拟。</p>
<h2 id="第35条：注解优于命名模式">第35条：注解优于命名模式</h2><p>以<code>JUnit</code>为例，命名模式的3大缺陷：</p>
<ol>
<li>文字拼写错误会导致失败，并且没有任何提示</li>
<li>无法确保他们只用于相应的程序元素上</li>
<li>它们都没有提供将参数值与程序元素关联起来的好方法</li>
</ol>
<p>你这通过这种方式简单的来创建一个自己的注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="annotation">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> MyTest &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>MyTest</code>注解类型的声明就是它自身的<code>Retention</code>和<code>Targer</code>注解进行了注解，这些注解类型称为元注解，其中：</p>
<ul>
<li><code>@Retention(RetentionPolicy.RUNTIME)</code>表示<code>MyTest</code>注解应该在运行时保留</li>
<li><code>@Target(ElementType.METHOD)</code>表示该注解仅用于方法上</li>
</ul>
<p>我们有了这个注解之后可以这么使用它<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@MyTest</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@MyTest</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@MyTest</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"i am error test4"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那我们如何调用这个注解呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunTests</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tests=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> passed=<span class="number">0</span>;</span><br><span class="line">		Class testClass=Class.forName(<span class="string">"yyl.java.study.test.HelloWorld"</span>);</span><br><span class="line">		Object testClassInstance=testClass.newInstance();</span><br><span class="line">		<span class="keyword">for</span>(Method m:testClass.getDeclaredMethods())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(m.isAnnotationPresent(MyTest.class))</span><br><span class="line">			&#123;</span><br><span class="line">				tests++;</span><br><span class="line">				<span class="keyword">try</span></span><br><span class="line">				&#123;</span><br><span class="line">					m.invoke(testClassInstance,<span class="keyword">null</span>);<span class="comment">//对实例的方法进行调用</span></span><br><span class="line">					passed++;</span><br><span class="line">					System.out.println(<span class="string">"PASSED:"</span>+m.getName());</span><br><span class="line">				&#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">				&#123;</span><br><span class="line">					System.out.println(<span class="string">"FAILD:"</span>+m.getName());</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(String.format(<span class="string">"PASSED:%s,FAILED:%s"</span>,passed,tests-passed));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>启动这个<code>RunTests</code>会得到</p>
<pre><code><span class="string">PASSED:</span>test3
<span class="string">FAILD:</span>test4
<span class="string">PASSED:</span>test1
<span class="string">PASSED:</span><span class="number">2</span>,<span class="string">FAILED:</span><span class="number">1</span>
</code></pre><p>一个简易版的测试框架就完成了，该书中的其他内容是讲你如何完善这个自制的测试框架，比如添加异常的注解，最终判断失败的机制等，我个人觉得只要把上述的简易框架看懂其他都不是问题。^_^</p>
<blockquote>
<p>既然有了注解，那么完全没有理由再使用命名模式了。</p>
</blockquote>
<h2 id="第36条：坚持使用Override注解">第36条：坚持使用Override注解</h2><p>估计<code>Override</code>注解是在<code>Java</code>中最常见也是常用的一种注解了吧，它标志方法被重写，但是在<code>java</code>中你重写方法时不加<code>Override</code>也是可以正常运行的，所以我相信很多人会懒掉这个注解，关于这个注解书中有下面几个推荐理由：</p>
<ul>
<li>你再重写得定义上出错时如果有<code>Override</code>，编译器就会帮你检查错误</li>
<li>IDE具有自动检查功能，当你没有用<code>Override</code>但是却覆盖了超类的方法时，IDE就是产生一条警告，提醒确认。</li>
<li>还可以让程序员清晰地看到这条方式是否是重写方法，在看代码的找起来比较方便啊（我自己觉得的）</li>
</ul>
<p>总而言之，如果在你想要的每个方法声明中使用<code>Override</code>注解来覆盖超类声明，编译器就可以替你防止大量的错误（在继承抽象类时可以不加。。但是我觉得还是加的好）</p>
<h2 id="第37条：用标记接口定义类型">第37条：用标记接口定义类型</h2><p>标记接口是没有包含方法声明的接口，而只是指明一个类实现了具有某种属性的接口，比如<code>Serializable</code></p>
<p>关于标记接口与标记注解的争论：</p>
<p>标记接口的优势：</p>
<ul>
<li>标记接口定义的类型是由被标记类的实例实现的；标记注解则没有定义这样的类型</li>
<li>标记接口可以更加精确地进行锁定</li>
</ul>
<p>标记注解的优势：</p>
<ul>
<li>它可以通过默认的方式添加一个或者多个注解类型的元素</li>
<li>标记注解作为变成元素之一的框架中同样具有一致性。</li>
</ul>
<p>总而言之，标记接口和标记注解都各有用处，如果想要定义一个任何新的方法都不会与之关联的类型，标记接口是最好的选择。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="第30条：用枚举代替int常量">第30条：用枚举代替int常量</h2><p>在编程语言中还没有引入枚举类型之前，表示枚举类型的常用模式就是声明一组具名的<code>int</code>常量<br><figure class="highlight java"><]]>
    </summary>
    
      <category term="Java" scheme="http://yyl8781697.github.io/tags/Java/"/>
    
      <category term="Effective Java" scheme="http://yyl8781697.github.io/categories/Effective-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[学习和使用Scala的Json解析类库-JSON4S]]></title>
    <link href="http://yyl8781697.github.io/2015/05/24/Scala/Study-And-User-JSON4S/"/>
    <id>http://yyl8781697.github.io/2015/05/24/Scala/Study-And-User-JSON4S/</id>
    <published>2015-05-24T02:12:14.000Z</published>
    <updated>2015-05-24T13:06:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>在<code>Scala</code>环境下已经至少有6种Json解析的类库很用了很相似的抽象语法树(<em>AST</em>),而<code>JSON4S</code>这个项目的目标就是提供一个单一的<em>AST</em>树供其他<code>Scala</code>类库来使用。</p>
<p><img src="https://camo.githubusercontent.com/67e5a0a48c91139ac30d2ecbfd6d6b020e8688a2/68747470733a2f2f7261772e6769746875622e636f6d2f6a736f6e34732f6a736f6e34732f332e332f636f72652f6a736f6e2e706e67" alt="JSON4S工作原理"></p>
<p><code>JSON4S</code>的features：</p>
<ul>
<li>快速的<code>JSON</code>解析</li>
<li><code>LINQ</code> 风格的查询</li>
<li>可以紧密结合样例类</li>
<li>差别比较和合并</li>
<li>使用<code>DSL</code>来生成有效格式的<code>JSON</code></li>
<li>支持<code>XPATH</code></li>
<li>优雅的打印</li>
<li>支持<code>XML</code>的转换</li>
<li>序列化</li>
</ul>
<h2 id="下载JSON4S">下载JSON4S</h2><blockquote>
<p>作者使用的是<code>json4s-native_*.jar</code>（与<code>lift-json</code>相同的实现）。下载的时候注意将版本号进行替换。</p>
</blockquote>
<ul>
<li><p><code>SBT</code>用户</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val json4sNative = <span class="string">"org.json4s"</span> %% <span class="string">"json4s-native"</span> % <span class="string">"3.2.11"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>MAVEN</code>用户</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.json4s<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>json4s-native_$&#123;scala.version&#125;<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>3.2.11<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其他：</p>
<ul>
<li><a href="http://repo1.maven.org/maven2/org/json4s/json4s-core_2.11/3.2.11/json4s-core_2.11-3.2.11.jar" target="_blank" rel="external">http://repo1.maven.org/maven2/org/json4s/json4s-core_2.11/3.2.11/json4s-core_2.11-3.2.11.jar</a></li>
<li><a href="http://repo1.maven.org/maven2/org/json4s/json4s-native_2.11/3.2.11/json4s-native_2.11-3.2.11.jar" target="_blank" rel="external">http://repo1.maven.org/maven2/org/json4s/json4s-native_2.11/3.2.11/json4s-native_2.11-3.2.11.jar</a></li>
<li><a href="http://mirrors.ibiblio.org/pub/mirrors/maven2/com/thoughtworks/paranamer/paranamer/2.5.6/paranamer-2.5.6.jar" target="_blank" rel="external">http://mirrors.ibiblio.org/pub/mirrors/maven2/com/thoughtworks/paranamer/paranamer/2.5.6/paranamer-2.5.6.jar</a></li>
</ul>
</li>
<li>IEAD(我使用的)<br>  File-&gt;Project Structure-&gt;Modules-&gt;Dependencies-&gt;+-&gt;From Maven，然后输入json4s即可搜索，选择最新的json4s-natvie进行下载。</li>
</ul>
<h2 id="需导入的核心包介绍">需导入的核心包介绍</h2><ul>
<li><code>import org.json4s._</code><br>  不用多说，解析都是通过它来完成的。</li>
<li><p><code>import org.json4s.native.JsonMethods._</code><br>  <code>Scala</code>对象与外部<code>JSON</code>资源(字符串，流，文件等)相互转换的开放接口，代码不多，这里可以贴一下：</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">JsonMethods</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">org</span>.<span class="title">json4s</span>.<span class="title">JsonMethods</span>[</span><span class="type">Document</span>] &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//外部JSON资源转Scala对象</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(</span>in: <span class="type">JsonInput</span>, useBigDecimalForDouble: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">JValue</span> = in <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">StringInput</span>(s) =&gt; <span class="type">JsonParser</span>.parse(s, useBigDecimalForDouble)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ReaderInput</span>(rdr) =&gt; <span class="type">JsonParser</span>.parse(rdr, useBigDecimalForDouble)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">StreamInput</span>(stream) =&gt; <span class="type">JsonParser</span>.parse(<span class="type">Source</span>.fromInputStream(stream).bufferedReader(), useBigDecimalForDouble)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">FileInput</span>(file) =&gt; <span class="type">JsonParser</span>.parse(<span class="type">Source</span>.fromFile(file).bufferedReader(), useBigDecimalForDouble)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//外部JSON资源转Scala对象(返回值可选)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parseOpt</span>(</span>in: <span class="type">JsonInput</span>, useBigDecimalForDouble: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">Option</span>[<span class="type">JValue</span>] = in <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">StringInput</span>(s) =&gt; <span class="type">JsonParser</span>.parseOpt(s, useBigDecimalForDouble)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ReaderInput</span>(rdr) =&gt; <span class="type">JsonParser</span>.parseOpt(rdr, useBigDecimalForDouble)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">StreamInput</span>(stream) =&gt; <span class="type">JsonParser</span>.parseOpt(<span class="type">Source</span>.fromInputStream(stream).bufferedReader(), useBigDecimalForDouble)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">FileInput</span>(file) =&gt; <span class="type">JsonParser</span>.parseOpt(<span class="type">Source</span>.fromFile(file).bufferedReader(), useBigDecimalForDouble)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Renders JSON.</span><br><span class="line">   * Scala对象转外部JSON&lt;资源</span><br><span class="line">   * @see Printer#compact</span><br><span class="line">   * @see Printer#pretty</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">render</span>(</span>value: <span class="type">JValue</span>): <span class="type">Document</span> = value <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">null</span>          =&gt; text(<span class="string">"null"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JBool</span>(<span class="literal">true</span>)   =&gt; text(<span class="string">"true"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JBool</span>(<span class="literal">false</span>)  =&gt; text(<span class="string">"false"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JDouble</span>(n)    =&gt; text(n.toString)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JDecimal</span>(n)   =&gt; text(n.toString)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JInt</span>(n)       =&gt; text(n.toString)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JNull</span>         =&gt; text(<span class="string">"null"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JNothing</span>      =&gt; sys.error(<span class="string">"can't render 'nothing'"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JString</span>(<span class="literal">null</span>) =&gt; text(<span class="string">"null"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JString</span>(s)    =&gt; text(<span class="string">"\""</span>+<span class="type">JsonAST</span>.quote(s)+<span class="string">"\""</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JArray</span>(arr)   =&gt; text(<span class="string">"["</span>) :: series(trimArr(arr).map(render)) :: text(<span class="string">"]"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JObject</span>(obj)  =&gt;</span><br><span class="line">      <span class="function"><span class="keyword">val</span> <span class="title">nested</span> =</span> <span class="keyword">break</span> :: fields(trimObj(obj).map(&#123;<span class="keyword">case</span> (n,v) =&gt; text(<span class="string">"\""</span>+<span class="type">JsonAST</span>.quote(n)+<span class="string">"\":"</span>) :: render(v)&#125;))</span><br><span class="line">      text(<span class="string">"&#123;"</span>) :: nest(<span class="number">2</span>, nested) :: <span class="keyword">break</span> :: text(<span class="string">"&#125;"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">trimArr</span>(</span>xs: <span class="type">List</span>[<span class="type">JValue</span>]) = xs.filter(_ != <span class="type">JNothing</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">trimObj</span>(</span>xs: <span class="type">List</span>[<span class="type">JField</span>]) = xs.filter(_._2 != <span class="type">JNothing</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">series</span>(</span>docs: <span class="type">List</span>[<span class="type">Document</span>]) = punctuate(text(<span class="string">","</span>), docs)</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">fields</span>(</span>docs: <span class="type">List</span>[<span class="type">Document</span>]) = punctuate(text(<span class="string">","</span>) :: <span class="keyword">break</span>, docs)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">punctuate</span>(</span>p: <span class="type">Document</span>, docs: <span class="type">List</span>[<span class="type">Document</span>]): <span class="type">Document</span> =</span><br><span class="line">    <span class="keyword">if</span> (docs.length == <span class="number">0</span>) empty</span><br><span class="line">    <span class="keyword">else</span> docs.reduceLeft((d1, d2) =&gt; d1 :: p :: d2)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//紧凑和漂亮的打印</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">compact</span>(</span>d: <span class="type">Document</span>): <span class="type">String</span> = <span class="type">Printer</span>.compact(d)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pretty</span>(</span>d: <span class="type">Document</span>): <span class="type">String</span> = <span class="type">Printer</span>.pretty(d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">JsonMethods</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">native</span>.<span class="title">JsonMethods</span></span></span><br></pre></td></tr></table></figure>
<p>  可以发现<code>json4s</code>提供了<code>parse</code>和<code>render</code>两大方法来进行<code>JSON</code>的转换。</p>
</li>
<li><code>import org.json4s.JsonDSL._</code><br>  <code>render</code>方法需要传入的是<code>JValue</code>类型的值，它并不是<code>Scala</code>的原生对象，所以需要通过转换而为之。<code>JsonDSL</code>这个特质就是提供了这些隐式转换：  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">JsonDSL</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span> <span class="keyword"><span class="keyword">with</span></span> <span class="title">org</span>.<span class="title">json4s</span>.<span class="title">Implicits</span> &#123;</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">seq2jvalue</span>[</span><span class="type">A</span>](s : scala.<span class="type">Traversable</span>[<span class="type">A</span>])(<span class="keyword">implicit</span> evidence$<span class="number">1</span> : scala.<span class="type">Function1</span>[<span class="type">A</span>, org.json4s.<span class="type">JsonAST</span>.<span class="type">JValue</span>]) : org.json4s.<span class="type">JsonAST</span>.<span class="type">JArray</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">map2jvalue</span>[</span><span class="type">A</span>](m : scala.<span class="type">Predef</span>.<span class="type">Map</span>[scala.<span class="type">Predef</span>.<span class="type">String</span>, <span class="type">A</span>])(<span class="keyword">implicit</span> evidence$<span class="number">2</span> : scala.<span class="type">Function1</span>[<span class="type">A</span>, org.json4s.<span class="type">JsonAST</span>.<span class="type">JValue</span>]) : org.json4s.<span class="type">JsonAST</span>.<span class="type">JObject</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">option2jvalue</span>[</span><span class="type">A</span>](opt : scala.<span class="type">Option</span>[<span class="type">A</span>])(<span class="keyword">implicit</span> evidence$<span class="number">3</span> : scala.<span class="type">Function1</span>[<span class="type">A</span>, org.json4s.<span class="type">JsonAST</span>.<span class="type">JValue</span>]) : org.json4s.<span class="type">JsonAST</span>.<span class="type">JValue</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">symbol2jvalue</span>(</span>x : scala.<span class="type">Symbol</span>) : org.json4s.<span class="type">JsonAST</span>.<span class="type">JString</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">pair2jvalue</span>[</span><span class="type">A</span>](t : scala.<span class="type">Tuple2</span>[scala.<span class="type">Predef</span>.<span class="type">String</span>, <span class="type">A</span>])(<span class="keyword">implicit</span> evidence$<span class="number">4</span> : scala.<span class="type">Function1</span>[<span class="type">A</span>, org.json4s.<span class="type">JsonAST</span>.<span class="type">JValue</span>]) : org.json4s.<span class="type">JsonAST</span>.<span class="type">JObject</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">list2jvalue</span>(</span>l : scala.<span class="type">List</span>[org.json4s.<span class="type">JsonAST</span>.<span class="type">JField</span>]) : org.json4s.<span class="type">JsonAST</span>.<span class="type">JObject</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">jobject2assoc</span>(</span>o : org.json4s.<span class="type">JsonAST</span>.<span class="type">JObject</span>) : <span class="type">JsonDSL</span>.<span class="keyword">this</span>.<span class="type">JsonListAssoc</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">JsonListAssoc</span>(</span>left : scala.<span class="type">List</span>[org.json4s.<span class="type">JsonAST</span>.<span class="type">JField</span>]) <span class="keyword">extends</span> java.lang.<span class="type">Object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">~</span>(</span>right : scala.<span class="type">Tuple2</span>[scala.<span class="type">Predef</span>.<span class="type">String</span>, org.json4s.<span class="type">JsonAST</span>.<span class="type">JValue</span>]) : org.json4s.<span class="type">JsonAST</span>.<span class="type">JObject</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">~</span>(</span>right : org.json4s.<span class="type">JsonAST</span>.<span class="type">JObject</span>) : org.json4s.<span class="type">JsonAST</span>.<span class="type">JObject</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">pair2Assoc</span>[</span><span class="type">A</span>](t : scala.<span class="type">Tuple2</span>[scala.<span class="type">Predef</span>.<span class="type">String</span>, <span class="type">A</span>])(<span class="keyword">implicit</span> evidence$<span class="number">5</span> : scala.<span class="type">Function1</span>[<span class="type">A</span>, org.json4s.<span class="type">JsonAST</span>.<span class="type">JValue</span>]) : <span class="type">JsonDSL</span>.<span class="keyword">this</span>.<span class="type">JsonAssoc</span>[<span class="type">A</span>] = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">JsonAssoc</span>[</span><span class="type">A</span>](left : scala.<span class="type">Tuple2</span>[scala.<span class="type">Predef</span>.<span class="type">String</span>, <span class="type">A</span>])(<span class="keyword">implicit</span> evidence$<span class="number">6</span> : scala.<span class="type">Function1</span>[<span class="type">A</span>, org.json4s.<span class="type">JsonAST</span>.<span class="type">JValue</span>]) <span class="keyword">extends</span> java.lang.<span class="type">Object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">~</span>[</span><span class="type">B</span>](right : scala.<span class="type">Tuple2</span>[scala.<span class="type">Predef</span>.<span class="type">String</span>, <span class="type">B</span>])(<span class="keyword">implicit</span> evidence$<span class="number">7</span> : scala.<span class="type">Function1</span>[<span class="type">B</span>, org.json4s.<span class="type">JsonAST</span>.<span class="type">JValue</span>]) : org.json4s.<span class="type">JsonAST</span>.<span class="type">JObject</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">~</span>(</span>right : org.json4s.<span class="type">JsonAST</span>.<span class="type">JObject</span>) : org.json4s.<span class="type">JsonAST</span>.<span class="type">JObject</span> = &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="JSON字符串转对象">JSON字符串转对象</h2><p>可以使用<code>parse</code>方法将<code>JSON</code>字符串进行转换<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">t=parse</span>(</span><span class="string">""" &#123; "name" : "tom","age":23,"number":[1,2,3,4] &#125; """</span>)</span><br><span class="line">println(t)</span><br></pre></td></tr></table></figure></p>
<p>最终打印的结果为：</p>
<pre><code>JObject<span class="list">(<span class="keyword">List</span><span class="list">(<span class="list">(<span class="keyword">name</span>,JString<span class="list">(<span class="keyword">tom</span>)</span>)</span>, <span class="list">(<span class="keyword">age</span>,JInt<span class="list">(<span class="number">23</span>)</span>)</span>, <span class="list">(<span class="keyword">number</span>,JArray<span class="list">(<span class="keyword">List</span><span class="list">(<span class="keyword">JInt</span><span class="list">(<span class="number">1</span>)</span>, JInt<span class="list">(<span class="number">2</span>)</span>, JInt<span class="list">(<span class="number">3</span>)</span>, JInt<span class="list">(<span class="number">4</span>)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><p>根据打印结果可以发现转换之后的并不是<code>Scala</code>的原生对象，那么如何取得它的原生对象呢？它其实是一个<code>Map[String,_]</code>类型的转换<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>((k,v)&lt;-t.values.asInstanceOf[<span class="type">Map</span>[<span class="type">String</span>,_]])</span><br><span class="line">&#123;</span><br><span class="line">println(k,<span class="string">"-&gt;"</span>,v,v.getClass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将<code>Map</code>遍历输出之后</p>
<pre><code>(name,-&gt;,tom,class java<span class="class">.lang</span><span class="class">.String</span>)
(age,-&gt;,<span class="number">23</span>,class scala<span class="class">.math</span><span class="class">.BigInt</span>)
(number,-&gt;,<span class="function"><span class="title">List</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span></span>,class scala<span class="class">.collection</span><span class="class">.immutable</span>.<span class="variable">$colon</span><span class="variable">$colon</span>)
</code></pre><p>可以发现<code>parse</code>之后仍旧保留着语言来字符串中可识别的类型，那么还有其他方式取值吗？其实它还支持使用反斜杠(\)的方式进行在顶级目录下取值：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"name"</span>,(t \ <span class="string">"name"</span>).values)</span><br><span class="line">println(<span class="string">"age"</span>,(t \ <span class="string">"age"</span>).values)</span><br><span class="line">println(<span class="string">"number"</span>,(t \ <span class="string">"number"</span>).values)</span><br></pre></td></tr></table></figure></p>
<p>取到得结果为</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">name</span></span>,tom)</span>
<span class="list">(<span class="keyword">age</span>,<span class="number">23</span>)</span>
<span class="list">(<span class="keyword">number</span>,List<span class="list">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span>)</span>
</code></pre><p>这个功能是不是略显惊讶，特别方法，恩，的确很方便。<br><br>同时该对象还可以直接转换为样例类：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>(</span>name:<span class="type">String</span>,age:<span class="type">Int</span>)<span class="comment">//注意这个样例类不要放方法里面，放在外部可访问的地方即可</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">val</span> <span class="title">formats</span> =</span> <span class="type">DefaultFormats</span><span class="comment">//这个日期转换的隐式导入不要忘了，如果有特殊格式还需要自己写</span></span><br><span class="line">println(t.extract[<span class="type">Student</span>])<span class="comment">//这里即可取的对应的样例类数据</span></span><br></pre></td></tr></table></figure></p>
<p>输出为：</p>
<pre><code><span class="function"><span class="title">Student</span><span class="params">(tom,<span class="number">23</span>)</span></span>
</code></pre><p>这个转换功能特别方法，果然,<code>Scala</code>下得<code>JSON</code>转换类库还是有很多自己的特色的^_^。</p>
<h2 id="对象转JSON字符串">对象转JSON字符串</h2><blockquote>
<p>注意在打印的时候一定要添加<code>compact()</code>方法，这样才能将字符串紧凑的表示，不然都是<code>Doc</code>对象。</p>
</blockquote>
<ul>
<li><p>集合类的序列化</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(compact(render(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))))</span><br><span class="line"><span class="comment">//结果：[1,2,3,4]</span></span><br><span class="line">println(compact(render(<span class="type">Map</span>(<span class="string">"name"</span>-&gt;<span class="string">"tom"</span>,<span class="string">"age"</span>-&gt;<span class="string">"23"</span>))))</span><br><span class="line"><span class="comment">//结果：&#123;"name":"tom","age":"23"&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>只支持<code>Seq</code>和<code>List</code></p>
</blockquote>
</li>
<li><p>元组的序列化</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">tuple=</span>(</span><span class="string">"name"</span>,<span class="string">"tom"</span>)</span><br><span class="line">   println(compact(render(tuple)))</span><br><span class="line">   <span class="comment">//结果：&#123;"name":"tom"&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里只支持<code>Tuple2[String,A]</code>这种格式的元组，将会序列化成键值对</p>
</blockquote>
</li>
<li><p>可以使用<code>~</code>将两个字段进行连接操作</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">tuple=</span>(</span><span class="string">"name"</span>,<span class="string">"tom"</span>)~(<span class="string">"age"</span>,<span class="number">23</span>)</span><br><span class="line">println(tuple)</span><br><span class="line">println(compact(render(tuple)))</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//JObject(List((name,JString(tom)), (age,JInt(23))))</span></span><br><span class="line"><span class="comment">//&#123;"name":"tom","age":23&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>任何键的值可以为可选的，为<code>None</code>时将不会被序列化</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">tuple=</span>(</span><span class="string">"name"</span>,<span class="string">"tom"</span>)~(<span class="string">"age"</span>,<span class="type">None</span>:<span class="type">Option</span>[<span class="type">Int</span>])</span><br><span class="line">println(tuple)                                   </span><br><span class="line">println(compact(render(tuple)))</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//JObject(List((name,JString(tom)), (age,JNothing)))</span></span><br><span class="line"><span class="comment">//&#123;"name":"tom"&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一个复杂一点的列子</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Winner</span>(</span>id: <span class="type">Long</span>, numbers: <span class="type">List</span>[<span class="type">Int</span>])</span><br><span class="line">   <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Lotto</span>(</span>id: <span class="type">Long</span>, winningNumbers: <span class="type">List</span>[<span class="type">Int</span>], winners: <span class="type">List</span>[<span class="type">Winner</span>], drawDate: <span class="type">Option</span>[java.util.<span class="type">Date</span>])</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">val</span> <span class="title">winners</span> =</span> <span class="type">List</span>(<span class="type">Winner</span>(<span class="number">23</span>, <span class="type">List</span>(<span class="number">2</span>, <span class="number">45</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">3</span>, <span class="number">5</span>)), <span class="type">Winner</span>(<span class="number">54</span>, <span class="type">List</span>(<span class="number">52</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">18</span>, <span class="number">22</span>)))</span><br><span class="line">   <span class="function"><span class="keyword">val</span> <span class="title">lotto</span> =</span> <span class="type">Lotto</span>(<span class="number">5</span>, <span class="type">List</span>(<span class="number">2</span>, <span class="number">45</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>), winners, <span class="type">Option</span>(<span class="keyword">new</span> java.util.<span class="type">Date</span>()))</span><br><span class="line">   <span class="function"><span class="keyword">val</span> <span class="title">json</span> =</span></span><br><span class="line">     (<span class="string">"lotto"</span> -&gt;</span><br><span class="line">       (<span class="string">"lotto-id"</span> -&gt; lotto.id) ~</span><br><span class="line">         (<span class="string">"winning-numbers"</span> -&gt; lotto.winningNumbers) ~</span><br><span class="line">         (<span class="string">"draw-date"</span> -&gt; lotto.drawDate.map(_.toString)) ~</span><br><span class="line">         (<span class="string">"winners"</span> -&gt;</span><br><span class="line">           lotto.winners.map &#123; w =&gt;</span><br><span class="line">             ((<span class="string">"winner-id"</span> -&gt; w.id) ~</span><br><span class="line">               (<span class="string">"numbers"</span> -&gt; w.numbers))</span><br><span class="line">           &#125;))</span><br><span class="line"></span><br><span class="line">   println(compact(render(json)))</span><br></pre></td></tr></table></figure>
<p>  打印的结果为:</p>
<pre><code>{"<span class="attribute">lotto</span>":<span class="value">{"<span class="attribute">lotto-id</span>":<span class="value"><span class="number">5</span></span>,"<span class="attribute">winning-numbers</span>":<span class="value">[<span class="number">2</span>,<span class="number">45</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>]</span>,"<span class="attribute">draw-date</span>":<span class="value"><span class="string">"Sun May 24 15:41:29 CST 2015"</span></span>,"<span class="attribute">winners</span>":<span class="value">[{"<span class="attribute">winner-id</span>":<span class="value"><span class="number">23</span></span>,"<span class="attribute">numbers</span>":<span class="value">[<span class="number">2</span>,<span class="number">45</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">3</span>,<span class="number">5</span>]</span>},{"<span class="attribute">winner-id</span>":<span class="value"><span class="number">54</span></span>,"<span class="attribute">numbers</span>":<span class="value">[<span class="number">52</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">18</span>,<span class="number">22</span>]</span>}]</span>}</span>}
</code></pre><p>  如果你使用<code>pretty()</code>方法来组织<code>JSON</code>:</p>
  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(pretty(render(json)))</span><br></pre></td></tr></table></figure>
<p>  就可以得到：</p>
<pre><code>{
  "<span class="attribute">lotto</span>":<span class="value">{
    "<span class="attribute">lotto-id</span>":<span class="value"><span class="number">5</span></span>,
    "<span class="attribute">winning-numbers</span>":<span class="value">[<span class="number">2</span>,<span class="number">45</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>]</span>,
    "<span class="attribute">draw-date</span>":<span class="value"><span class="string">"Sun May 24 15:43:01 CST 2015"</span></span>,
    "<span class="attribute">winners</span>":<span class="value">[{
      "<span class="attribute">winner-id</span>":<span class="value"><span class="number">23</span></span>,
      "<span class="attribute">numbers</span>":<span class="value">[<span class="number">2</span>,<span class="number">45</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">3</span>,<span class="number">5</span>]
    </span>},{
      "<span class="attribute">winner-id</span>":<span class="value"><span class="number">54</span></span>,
      "<span class="attribute">numbers</span>":<span class="value">[<span class="number">52</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">18</span>,<span class="number">22</span>]
    </span>}]
  </span>}
</span>}
</code></pre><p>  这样可读性明显提高多了。</p>
</li>
</ul>
<h2 id="合并和差异化对比">合并和差异化对比</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">t1=parse</span>(</span></span><br><span class="line">  <span class="string">"""</span><br><span class="line">    &#123;"name":"tom",</span><br><span class="line">       "age":23,</span><br><span class="line">       "class":["xiaoerban"]</span><br><span class="line">    &#125;</span><br><span class="line">  """</span>)</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">t2=parse</span>(</span></span><br><span class="line">  <span class="string">"""</span><br><span class="line">    &#123;"name":"tom",</span><br><span class="line">       "age":23,</span><br><span class="line">       "class":["xiaosanban"]</span><br><span class="line">    &#125;</span><br><span class="line">  """</span>)</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">t3=t1</span> <span class="title">merge</span> <span class="title">t2</span></span><br><span class="line"></span>println(pretty(render(t3)))</span><br></pre></td></tr></table></figure>
<p>合并之后的结果为</p>
<pre><code>{
  "<span class="attribute">name</span>":<span class="value"><span class="string">"tom"</span></span>,
  "<span class="attribute">age</span>":<span class="value"><span class="number">23</span></span>,
  "<span class="attribute">class</span>":<span class="value">[<span class="string">"xiaoerban"</span>,<span class="string">"xiaosanban"</span>]
</span>}
</code></pre><p>接下来咱们对比一下合并之后的差异化：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">Diff</span>(</span>changed,added,deleted)=t3 diff t1</span><br><span class="line">println(<span class="string">"changed"</span>,changed)</span><br><span class="line">println(<span class="string">"added"</span>,added)</span><br><span class="line">println(<span class="string">"deleted"</span>,deleted)</span><br></pre></td></tr></table></figure></p>
<p>输出的差异化为：</p>
<pre><code><span class="list">(<span class="keyword">changed</span>,JNothing)</span>
<span class="list">(<span class="keyword">added</span>,JNothing)</span>
<span class="list">(<span class="keyword">deleted</span>,JObject<span class="list">(<span class="keyword">List</span><span class="list">(<span class="list">(<span class="keyword"><span class="built_in">class</span></span>,JArray<span class="list">(<span class="keyword">List</span><span class="list">(<span class="keyword">JString</span><span class="list">(<span class="keyword">xiaosanban</span>)</span>)</span>)</span>)</span>)</span>)</span>)</span>
</code></pre><h2 id="XML的支持">XML的支持</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.json4s.<span class="type">Xml</span>.&#123;toJson, toXml&#125;</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">xml</span> =</span></span><br><span class="line">  &lt;users&gt;</span><br><span class="line">    &lt;user&gt;</span><br><span class="line">      &lt;id&gt;<span class="number">1</span>&lt;/id&gt;</span><br><span class="line">      &lt;name&gt;<span class="type">Harry</span>&lt;/name&gt;</span><br><span class="line">    &lt;/user&gt;</span><br><span class="line">    &lt;user&gt;</span><br><span class="line">      &lt;id&gt;<span class="number">2</span>&lt;/id&gt;</span><br><span class="line">      &lt;name&gt;<span class="type">David</span>&lt;/name&gt;</span><br><span class="line">    &lt;/user&gt;</span><br><span class="line">  &lt;/users&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">json</span> =</span> toJson(xml)</span><br><span class="line">println(pretty(render(json)))</span><br></pre></td></tr></table></figure>
<p>输出的结果为：</p>
<pre><code>{
  "<span class="attribute">users</span>":<span class="value">{
    "<span class="attribute">user</span>":<span class="value">[{
      "<span class="attribute">id</span>":<span class="value"><span class="string">"1"</span></span>,
      "<span class="attribute">name</span>":<span class="value"><span class="string">"Harry"</span>
    </span>},{
      "<span class="attribute">id</span>":<span class="value"><span class="string">"2"</span></span>,
      "<span class="attribute">name</span>":<span class="value"><span class="string">"David"</span>
    </span>}]
  </span>}
</span>}
</code></pre><h2 id="总结">总结</h2><p><code>JSON4S</code>很好很强大，其他功能请参考1。</p>
<p>虽然<code>Scala</code>可以无缝的直接访问<code>java</code>版本的<code>JSON</code>解析类库，但是由于<code>Scala</code>有它自己的语法简洁性，所以在<code>Scala</code>环境下强烈推荐使用<code>JSON4S</code>.^_^</p>
<h2 id="参考">参考</h2><ol>
<li><a href="https://github.com/json4s/json4s" target="_blank" rel="external">https://github.com/json4s/json4s</a></li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="介绍">介绍</h2><p>在<code>Scala</code>环境下已经至少有6种Json解析的类库很用了很相似的抽象语法树(<em>AST</em>),而<code>JSON4S</code>这个项目的目标就是提供一个单一的<em>AST</em>树供其他<]]>
    </summary>
    
      <category term="Json4s" scheme="http://yyl8781697.github.io/tags/Json4s/"/>
    
      <category term="Scala" scheme="http://yyl8781697.github.io/tags/Scala/"/>
    
      <category term="Scala" scheme="http://yyl8781697.github.io/categories/Scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Effective Java》第五章：泛型]]></title>
    <link href="http://yyl8781697.github.io/2015/05/23/Effective%20Java/Generic/"/>
    <id>http://yyl8781697.github.io/2015/05/23/Effective Java/Generic/</id>
    <published>2015-05-23T15:05:33.000Z</published>
    <updated>2015-05-31T15:32:49.000Z</updated>
    <content type="html"><![CDATA[<p>泛型，可以告诉编译器每个集合中接受哪些对象类型，编译器会自动地为你的插入进行转化，并在编译时告知是否插入了类型错误的对象。(貌似<code>Java</code>里面的泛型都是<strong>伪泛型</strong>吧-_-|)</p>
<h2 id="第23条：请不要再新代码中使用原生态类型">第23条：请不要再新代码中使用原生态类型</h2><blockquote>
<p>什么是原生态类型？</p>
</blockquote>
<p>类似<code>List&lt;E&gt;</code>,<code>Collection&lt;E&gt;</code>泛型的定义都有一个原生态类型，那就是<code>List</code>,<code>Collection</code>，用他们定义类型也不会出错.</p>
<blockquote>
<p>为什么不要使用原生态类型</p>
</blockquote>
<p>使用原生态类型的集合类可以插入各种不同的类型，他们在编译时不会进行类型检查，但是运行时遇到错误就会抛出，这样是很不安全的。</p>
<blockquote>
<p>我在不确定或者不在乎集合类型的情况下，是不是用原生态类型最好？</p>
</blockquote>
<p>还是不要用，可以使用无限制的通配符来替代，比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numElementsInCommon</span><span class="params">(Set&lt;?&gt; s1,Set&lt;?&gt; s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(Object o:s1)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(s2.contains(o))</span><br><span class="line">			count++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它是类型安全的，但是无法猜测放入了哪些对象，此时可以使用<strong>泛型</strong>或者<strong>有限制的通配符类型</strong>（下文会描述）。</p>
<h2 id="第24条：消除非首检警告">第24条：消除非首检警告</h2><blockquote>
<p>非受检警告很重要，每个警告都表示可能在运行时抛出<code>ClassCastException</code>异常，我们应该在编码时尽量消除编辑器给出的每一条受检警告。如果无法消除非首检警告，同时可证明引起警告的代码是类型安全的，就可以在尽量小得范围中，用<code>@SuppressWarnings(“uncheck”)</code>注解来禁止该警告，并且要把禁止该警告的原因记录下来。</p>
</blockquote>
<h2 id="第25条：列表优先于数组">第25条：列表优先于数组</h2><p>数组与泛型相比，有两个重要的不同点:</p>
<ol>
<li><p>数组是协变的，泛型则是不可变的<br> 如果<code>Sub</code>为<code>Super</code>的子类，那么数组类型<code>Sub[]</code>就是<code>Super[]</code>的子类，但是<code>List&lt;Sub&gt;</code>与<code>List&lt;Super&gt;</code>并没有什么卵关系。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object[] objectArray=<span class="keyword">new</span> Long[<span class="number">10</span>];</span><br><span class="line">objectArray[<span class="number">0</span>]=<span class="string">"Hello"</span>;<span class="comment">//运行时会再这里抛ArrayStoreException异常</span></span><br><span class="line"></span><br><span class="line">List&lt;Object&gt; list=<span class="keyword">new</span> List&lt;Long&gt;();<span class="comment">//在编译时就在这里出错了</span></span><br><span class="line">list.add(<span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure>
<p> 从上面看出来，它们都不能将<code>String</code>放入<code>Long</code>容器中，但是明显泛型的报错更加合理。</p>
</li>
</ol>
<p>2.数组是具体化的，因此在运行时才会知道并检查它们元素类型的约束，而泛型是通过擦除来实现的，因此泛型时只在编译时强化它们的类信息，并在运行时丢弃。</p>
<blockquote>
<p>泛型是数组不能很好的混合使用，使用泛型数组定义式非法的。</p>
</blockquote>
<h2 id="第26条：优先考虑泛型">第26条：优先考虑泛型</h2><p>使用泛型简单，但是自己编写泛型还是有一点麻烦的，下面是第6条中的两种泛型版本。<br>1.使用泛型<code>E[]</code>来存储数据，但是用<code>Object[]</code>的数组转换来处理泛型数组的创建错误<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 简单的栈结构的实现 泛型版本-泛型数组转换</span><br><span class="line"> *<span class="javadoctag"> @author</span> yyl  form Effective Java</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> E[] elements;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPCAITY=<span class="number">16</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 这个elements元素只会使用E类型来添加</span><br><span class="line">	 * 所以他是足够安全的</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		elements=(E[])<span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPCAITY];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		ensureCapacity();<span class="comment">//确保容量足够</span></span><br><span class="line">		elements[size++]=e;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">		<span class="keyword">return</span> elements[--size];<span class="comment">//</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(elements.length==size)</span><br><span class="line">			elements=Arrays.copyOf(elements, <span class="number">2</span>*size+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>使用<code>Object[]</code>来存储，但是返回类型使用<code>Object</code>向泛型类型<code>E</code>去转换<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 简单的栈结构的实现 泛型版本-泛型转换</span><br><span class="line"> *<span class="javadoctag"> @author</span> yyl  form Effective Java</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object[] elements;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPCAITY=<span class="number">16</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		elements=<span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPCAITY];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		ensureCapacity();<span class="comment">//确保容量足够</span></span><br><span class="line">		elements[size++]=e;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 这里都是需要返回E</span><br><span class="line">	 * 所以这里的转换是安全的</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">		<span class="keyword">return</span> (E)elements[--size];<span class="comment">//</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(elements.length==size)</span><br><span class="line">			elements=Arrays.copyOf(elements, <span class="number">2</span>*size+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>上述优先选择的是第二种方案，第一种禁止数组类型的非受检转换比禁止标量类型更加危险，并且它需要多次转换<code>E[]</code>，而第二是是多次转换<code>E</code></p>
</blockquote>
<h2 id="第27条：优先考虑泛型方法">第27条：优先考虑泛型方法</h2><p>关于泛型方法和非泛型方法可以见下面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 原生类型的书写，类型不安全，并且还会产生警告</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set <span class="title">union2</span><span class="params">(Set s1,Set s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Set result=<span class="keyword">new</span> HashSet(s1);</span><br><span class="line">	result.addAll(s2);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 泛型方法，类型安全</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;E&gt; s1,Set&lt;E&gt; s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Set&lt;E&gt; result=<span class="keyword">new</span> HashSet&lt;E&gt;(s1);</span><br><span class="line">	result.addAll(s2);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很明显，泛型方法更加安全，并且简单易用。</p>
<blockquote>
<p>使用泛型方法就像类型异性，还应该将现有的方法泛型化，使新用户使用起来更加轻松，且不会平均破坏现有的客户端。</p>
</blockquote>
<h2 id="第28条:利用有限制通配符来提升API的灵活性">第28条:利用有限制通配符来提升API的灵活性</h2><p>针对第26条中泛型<code>Stack</code>的实现方法，如果现在需要添加<code>pushAll</code>和<code>popAll</code>这两个方法，为了让他们用起来更加顺手，那么应该这么写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 所有E的子类的集合都可以添加进来</span><br><span class="line"> *<span class="javadoctag"> @param</span> iter</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterable&lt;? extends E&gt; iter)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(E e:iter)</span><br><span class="line">		<span class="keyword">this</span>.push(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 可以将elements里面的元素全部弹出到E得超类中</span><br><span class="line"> *<span class="javadoctag"> @param</span> dst</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; dst)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!isEmpty())</span><br><span class="line">		dst.add(pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>使用通配符能让API变得更加灵活，在编写广泛使用的类库时，一定适当地利用通配符类型。</p>
</blockquote>
<h2 id="第29条：优先考虑类型安全的异构容器">第29条：优先考虑类型安全的异构容器</h2><blockquote>
<p>泛型往往会被用户参数化了的容器，每个容器有固定数目的类型参数。但是你可能需要更加灵活地容器，比如数据库的表可以有任意多得列，在<code>Java</code>中，解决这个问题的做法就是将建参数化而不是容器参数化。可以使用类类型<code>Class</code>来作为键值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;Class&lt;?&gt;,Object&gt; favorites=<span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;,Object&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 存值 </span><br><span class="line">	 *<span class="javadoctag"> @param</span> type 这个是键，每个键的类型都是不同的</span><br><span class="line">	 *<span class="javadoctag"> @param</span> instance 这个就是值</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type,T instance)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(type==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Type is null"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="javadoc">/**</span><br><span class="line">		 * 这里加上cast可以防止用户恶意改传类型</span><br><span class="line">		 */</span></span><br><span class="line">		favorites.put(type, type.cast(instance));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFavorites</span><span class="params">(Class&lt;T&gt; type)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="javadoc">/**</span><br><span class="line">		 * 这里的cast转换是安全的，因为放入的都是对应T的类型的值</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="keyword">return</span> type.cast(favorites.get(type));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>Favorites</code>类型里面的键都不同类型的，这里将<code>Favorites</code>称为异构容器。</p>
<p>它又两个局限性：</p>
<ol>
<li>用户可以轻松地破坏<code>Favorites</code>的实例安全（可以用<code>put</code>方法中<code>cast</code>来避免）</li>
<li>它只能用于可具体化的类ing中（比如List<string>这个类型你就不能传过去）</string></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>泛型，可以告诉编译器每个集合中接受哪些对象类型，编译器会自动地为你的插入进行转化，并在编译时告知是否插入了类型错误的对象。(貌似<code>Java</code>里面的泛型都是<strong>伪泛型</strong>吧-_-|)</p>
<h2 id="第23条：请不要再新]]>
    </summary>
    
      <category term="Java" scheme="http://yyl8781697.github.io/tags/Java/"/>
    
      <category term="Effective Java" scheme="http://yyl8781697.github.io/categories/Effective-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自己煮：泡椒牛蛙]]></title>
    <link href="http://yyl8781697.github.io/2015/05/16/Food/Sauteed-Bullfrog-with-Pickled-Peppers/"/>
    <id>http://yyl8781697.github.io/2015/05/16/Food/Sauteed-Bullfrog-with-Pickled-Peppers/</id>
    <published>2015-05-16T14:38:59.000Z</published>
    <updated>2015-06-06T13:04:30.000Z</updated>
    <content type="html"><![CDATA[<pre><code>泡椒牛蛙是一道色香味俱全的汉族名菜，属于川菜系。最常见又易烹制，成菜后味咸鲜，肉细嫩，色红亮，泡菜香气浓郁。
</code></pre><h2 id="食材">食材</h2><ul>
<li>牛蛙：2只</li>
<li>油、料酒~~~~</li>
<li>生姜、大蒜：适量</li>
<li>莴笋：适量（炒到牛蛙里面的莴笋特别好吃）</li>
<li>小米椒：一点点就好了（最好还有红灯笼椒，但是没买到-_-）</li>
</ul>
<p><img src="/img/Sauteed-Bullfrog/1cailiao.jpg" alt=""></p>
<h2 id="预煮牛蛙">预煮牛蛙</h2><p>将洗干净切好的牛蛙倒入热水中煮2~3分钟<br><br><img src="/img/Sauteed-Bullfrog/2yuzhu.jpg" alt=""></p>
<p>然后直接捞出<br><br><img src="/img/Sauteed-Bullfrog/3yuzhuchuguo.jpg" alt=""></p>
<h2 id="炒莴笋">炒莴笋</h2><p>先热油锅<br><br><img src="/img/Sauteed-Bullfrog/4reyouguo.jpg" alt=""></p>
<p>放入生姜大蒜炒出香味之后将莴笋放入油锅爆炒<br><br><img src="/img/Sauteed-Bullfrog/5chaowosun.jpg" alt=""></p>
<p>然后放入小米椒（注意这个很辣的，所以要看个人口味适量而为之）<br><img src="/img/Sauteed-Bullfrog/6fangxiaomijiao.jpg" alt=""></p>
<h2 id="炒牛蛙">炒牛蛙</h2><p>莴笋爆炒2分钟之后将之前预煮过的牛蛙倒入油锅一起炒<br><img src="/img/Sauteed-Bullfrog/7yiqichao.jpg" alt=""></p>
<p>还顺再放点啤酒/料酒，炒出香味之后放入水<br><br><img src="/img/Sauteed-Bullfrog/8fangshui.jpg" alt=""></p>
<h2 id="出锅">出锅</h2><p>盖上锅盖等几分钟之后放入盐味精以及其他配料即可出锅<br><img src="/img/Sauteed-Bullfrog/9chuguo.jpg" alt=""></p>
<p>洗锅开吃~~~~哈哈！</p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>泡椒牛蛙是一道色香味俱全的汉族名菜，属于川菜系。最常见又易烹制，成菜后味咸鲜，肉细嫩，色红亮，泡菜香气浓郁。
</code></pre><h2 id="食材">食材</h2><ul>
<li>牛蛙：2只</li>
<li>油、料酒~~~~</li>
<li>]]>
    </summary>
    
      <category term="Food" scheme="http://yyl8781697.github.io/tags/Food/"/>
    
      <category term="Food" scheme="http://yyl8781697.github.io/categories/Food/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac通过ssh连接到Centos时一些问题的解决]]></title>
    <link href="http://yyl8781697.github.io/2015/05/16/Linux/Mac-ssh-Centos-Problem-List/"/>
    <id>http://yyl8781697.github.io/2015/05/16/Linux/Mac-ssh-Centos-Problem-List/</id>
    <published>2015-05-16T02:26:53.000Z</published>
    <updated>2015-05-16T02:53:09.000Z</updated>
    <content type="html"><![CDATA[<p>Linux版本：Centos6.5<br>Mac版本：OS X Yosemite 10.10.2</p>
<h2 id="LC_CTYPE:_cannot_change_locale_(UTF-8)">LC_CTYPE: cannot change locale (UTF-8)</h2><p>通过ssh连接到linux，会出现如下警告：</p>
<pre><code>-<span class="string">bash:</span> <span class="string">warning:</span> <span class="string">setlocale:</span> <span class="string">LC_CTYPE:</span> cannot change locale (UTF-<span class="number">8</span>): No such file or directory
</code></pre><p>这是由于没有找到对应的语言环境导致的：<br>按一下命令步骤操作即可修复：<br>首先</p>
<pre><code>sudo vi <span class="regexp">/etc/</span>ssh_cofig
</code></pre><p>然后将该文件中的SendEnv LANG LC_*这一行用#进行注释</p>
<pre><code><span class="id">#SendEnv</span> LANG LC_*
</code></pre><p>参考:<a href="http://www.cyberciti.biz/faq/os-x-terminal-bash-warning-setlocale-lc_ctype-cannot-change-locale/" target="_blank" rel="external">OS X Terminal: -bash: warning: setlocale: LC_CTYPE: cannot change locale (UTF-8): No such file or directory Fix</a></p>
<h2 id="Write_failed:_Broken_pipe">Write failed: Broken pipe</h2><p>通过ssh连接到linux，有时候会莫名其妙的出现错误：</p>
<pre><code><span class="tag">Write</span> <span class="rule"><span class="attribute">failed</span>:<span class="value"> Broken pipe</span></span>
</code></pre><p>看资料说的是由于长时间未操作造成的，解决方法为在Mac端的~/.ssh/config文件中添加：</p>
<pre><code><span class="title">ServerAliveInterval</span> <span class="number">60</span>
</code></pre><p>参考：<a href="http://www.cnblogs.com/dudu/archive/2013/02/07/ssh-write-failed-broken-pipe.html" target="_blank" rel="external">解决ssh的”Write failed: Broken pipe”问题</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Linux版本：Centos6.5<br>Mac版本：OS X Yosemite 10.10.2</p>
<h2 id="LC_CTYPE:_cannot_change_locale_(UTF-8)">LC_CTYPE: cannot change locale (UTF-]]>
    </summary>
    
      <category term="Linux" scheme="http://yyl8781697.github.io/tags/Linux/"/>
    
      <category term="ssh" scheme="http://yyl8781697.github.io/tags/ssh/"/>
    
      <category term="Linux" scheme="http://yyl8781697.github.io/categories/Linux/"/>
    
  </entry>
  
</feed>