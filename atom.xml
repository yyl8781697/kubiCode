<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Kubi Code'Blog]]></title>
  <subtitle><![CDATA[The palest ink is better than the best memory.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yyl8781697.github.io/"/>
  <updated>2016-02-24T07:24:38.000Z</updated>
  <id>http://yyl8781697.github.io/</id>
  
  <author>
    <name><![CDATA[Kubi Code]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[在信息检索中Term之间的Proximity计算研究]]></title>
    <link href="http://yyl8781697.github.io/2016/02/23/Search%20Engine/Proximity-Measures-In-Information-Retrieval/"/>
    <id>http://yyl8781697.github.io/2016/02/23/Search Engine/Proximity-Measures-In-Information-Retrieval/</id>
    <published>2016-02-23T12:58:43.000Z</published>
    <updated>2016-02-24T07:24:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="为啥要做Proximity计算">为啥要做Proximity计算</h2><p>先来看下信息检索/搜索引擎 的一般架构流程:</p>
<ol>
<li>对<code>Doc</code>进行分词,这些分词也叫做<code>Term</code>，然后离线做各种计算</li>
<li>将这些<code>Term</code>灌入倒排索引中</li>
<li>用户查询</li>
<li>根据倒排召回命中<code>Term</code>的文档</li>
<li>将文档根据各个<code>Term</code>算分排序</li>
</ol>
<p>其实可以发现这里查的<code>Term</code> 都是<code>bag-of-words</code>的形式，并且第五步的算法也一般是在线的，所以基本不会做全文扫描之类的事情，那么这样的话问题就来了：<br><a id="more"></a></p>
<pre><code>如果搜索“红色连衣裙”,则可能会出现下面的文档:
<span class="number">1.</span>xxxx红色连衣裙xxxx
<span class="number">2.</span>红色高跟鞋配连衣裙
很明显文档<span class="number">1</span>的相关性比<span class="number">2</span>要高，但是此时如果仅仅是bag-<span class="keyword">of</span>-<span class="property">words</span>模型就很难保证<span class="number">1</span>的相关性分要比<span class="number">2</span>高
</code></pre><p>所以一般的搜索引擎还有一个叫做<code>Proximity Measures</code>的特征计算，可以理解为计算文档里面出现的<code>query Term</code>的相近程度，为了保证可行性，降低计算的复杂度，一般也只会计算两个<code>Term</code>之间的<code>Proximity</code>分</p>
<h2 id="使用距离度量">使用距离度量</h2><p>这种方式主要是计算<code>Term</code>之间距离作为<code>Proximity</code>得分，主要分两大类:</p>
<ol>
<li><code>Span-based</code>:使用时将全部的<code>query term</code>丢进去一起算距离</li>
<li><code>Distance aggregation</code>:先算两两之间的距离，再聚集起来</li>
</ol>
<p>假设现在有文档<code>D = t1, t2, t1, t3, t5, t4, t2, t3, t4</code>，基于<code>D</code>集合来讲讲各个距离的计算方式<br><strong>Span-based</strong></p>
<ul>
<li><code>Span</code>:在文档中可以覆盖所有term的最小距离称为<code>Span</code>，<strong>需要包含所有重复的term</strong><br>  比如$Q=t1,t2$这个查询的$Span=7$</li>
<li><code>MinCover</code>:在文档中可以覆盖所有term的最小距离称为<code>MinCover</code>,<strong>每个term至少被包含一次</strong><br>  比如这里的$Q=t1,t2$查询的$MinCover=1$</li>
</ul>
<p><strong>Distance aggregation</strong></p>
<blockquote>
<p>这种方式计算的最近单元是计算一个term pair的最小距离，使用$Dis(t_i,t_j;D)$来表示</p>
</blockquote>
<ul>
<li><code>MinDist(Minimum pair distance)</code>:计算所有pair的最小距离的最小值,<br>  <center>$MinDist=min_{q_1,q_2 \in Q \cap D,q_1 \neq q_2} Dis(q_1,q_2;D)$</center><br>比如$Q={t1,t2,t3}$，则$MinDist=min(1,2,3)=1$</li>
<li><code>AveDist(Average pair distance)</code>:计算所有pair的最小距离的平均值，<br>  <center>$AveDist=\frac{2}{n \cdot (n+1)}min_{q_1,q_2 \in Q \cap D,q_1 \neq q_2} Dis(q_1,q_2;D)$</center><br>比如$Q={t1,t2,t3}$，则$AveDist=(1+2+3)/3=2$</li>
<li><code>MaxDist(Maximum pair distance)</code>:与<code>MinDist</code>正好相反，它是求最大值<br>  <center>$MinDist=max_{q_1,q_2 \in Q \cap D,q_1 \neq q_2} Dis(q_1,q_2;D)$</center><br>  比如$Q={t1,t2,t3}$，则$MaxDist=max(1,2,3)=3$</li>
</ul>
<p>文献中实验表明:</p>
<ol>
<li><code>Span-based</code>为考虑到各个文档长度，以各自文档的长度最为归一化因子进行归一化之后效果要好一些</li>
<li><code>Distance aggregation</code>系列一般比<code>Span-based</code>的效果要好</li>
<li><code>Distance aggregation</code>中<code>MinDist</code>的效果最好</li>
</ol>
<p>但是在一般使用过程中不会直接将距离作为<code>Proximity</code>的值，现将$\delta(Q,D)$作为查询词在各个文档的中的距离度量，$\delta(Q,D)$最小表明查询词与文档越相关，而在使用过程中一般以这个相关性越大最好，这将这个相关性记为:$\pi(Q,D)$，则使用下面的公式来转换:</p>
<p><center>$\pi(Q,D)=log(\alpha + exp(- \delta(Q,D)))$</center></p>
<blockquote>
<p>$\alpha$可以作为调节因子</p>
</blockquote>
<p>使用这种方式的度量最大的优点就是方便，但是单独用起来效果可能不怎么理解，并且波动性较大.~</p>
<h1 id="持续研究中~~~">持续研究中~~~</h1><h2 id="参考">参考</h2><ol>
<li>2007-An Exploration of Proximity Measures in Information Retrieval</li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="为啥要做Proximity计算">为啥要做Proximity计算</h2><p>先来看下信息检索/搜索引擎 的一般架构流程:</p>
<ol>
<li>对<code>Doc</code>进行分词,这些分词也叫做<code>Term</code>，然后离线做各种计算</li>
<li>将这些<code>Term</code>灌入倒排索引中</li>
<li>用户查询</li>
<li>根据倒排召回命中<code>Term</code>的文档</li>
<li>将文档根据各个<code>Term</code>算分排序</li>
</ol>
<p>其实可以发现这里查的<code>Term</code> 都是<code>bag-of-words</code>的形式，并且第五步的算法也一般是在线的，所以基本不会做全文扫描之类的事情，那么这样的话问题就来了：<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Search Engine" scheme="http://yyl8781697.github.io/tags/Search-Engine/"/>
    
      <category term="Search Engine" scheme="http://yyl8781697.github.io/categories/Search-Engine/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[针对BM25遇到长文档时失效情况的一种高效解决方案]]></title>
    <link href="http://yyl8781697.github.io/2016/02/16/Search%20Engine/BM25-Fails-When-The-Docments-Are-Very-Long/"/>
    <id>http://yyl8781697.github.io/2016/02/16/Search Engine/BM25-Fails-When-The-Docments-Are-Very-Long/</id>
    <published>2016-02-16T09:17:19.000Z</published>
    <updated>2016-02-23T15:58:45.000Z</updated>
    <content type="html"><![CDATA[<pre><code>B<span class="title">M25</span>在长文档下会失效，文本是记录SIGIR上的一个Paper的解决方案~
</code></pre><h2 id="当BM25遇到长文档">当BM25遇到长文档</h2><p>文档相关性模型-<code>BM25</code>的拟合公式如下:</p>
<center>$\sum_{i\in Q} log \frac {(r_i+0.5)((N-R)-(n_i-r_i)+0.5)}{(n_i-r_i+0.5)(R-r_i+0.5)} \cdot \frac{(k_1+1)f_i}{K+f_i} \cdot \frac{(k_2+1)qf_i}{k_2+qf_i}$</center>

<p>其中第一部分表示<code>BIM</code>的值，第二部分表示在文档中的权重，第三部分表示在查询词中的权重，(具体符号解释参考之前的<a href="http://kubicode.me/2016/01/26/Search%20Engine/Study-BM25-For-Query-Document-Relevance/" target="_blank" rel="external">BM25介绍</a>)现将第二部分单独拿出来:</p>
<p><center>$f(q,D)=\frac{(k_1+1) \times TF}{k_1 \times ((1-b)+b \cdot \frac{dl}{avdl} )+TF}=\frac{(k_1+1) \times c’(q,D)}{k_1+c’(q,D)}$</center><br>其中:<br><a id="more"></a></p>
<p><center>$c’(q,D)=\frac{TF}{1-b+b \cdot \frac{dl}{avdl}}$</center><br>现在先来做一个假设，假设当前有个文档<code>很长很长</code>，也就是$dl$这个值很大，则可以发现$c’(q,D)$就会很小，小到接近于0，因此会导致文档部分的因子$f(q,D)$也会接近于0，几乎和这个词没有出现在这个文档一样..-_-</p>
<p>在这种情况下，针对长文档，<code>BM25</code>的效果会比较差<br>下面的图就是<code>BM25</code>在不同文档长度下的实验</p>
<p><img src="/img/BM25-Fails-When-The-Docments-Are-Very-Long/doc-len-comp.png" width="600px"></p>
<p>可以发现在<code>BM25</code>中，随着文档的变长，相关性在变高，但是其被检索的概率并没有随着相关性的趋势而变高，也就是长文档使用<code>BM25</code>的效果变得比较差。</p>
<h2 id="高效解决方案">高效解决方案</h2><p>为了避免长文档在<code>BM25</code>的相关性中被惩罚，我们需要对文档权重$f(q,D)$做一个规范化约束，但是由于<code>BM25</code>早已被公认为是一种比较有效的文档相关性，所以这个约束不能破坏掉<code>BM25</code>自身的特征.</p>
<p>我们希望规范化约束之后保持以下三点特性:</p>
<ol>
<li>当$c’(q,D)=0$的时候，$f(q,D)$也为0</li>
<li>随着$c’(q,D)$的变大，$f(q,D)$也需要呈现单调递增，但是会趋向于一个最大值</li>
<li>随着$c’(q,D)$的减少，$f(q,D)$会单调递减趋向于一个最小值，但是这个最小值需要足够大</li>
</ol>
<blockquote>
<p>就是因为原生的<code>BM25</code>不满足第3点，所以会出现在长文档下<code>BM25</code>出现失效的情况</p>
</blockquote>
<!-- 
f'(q,D)=\left\{
\begin{aligned}
\frac{(k_1+1) \cdot [c'(q,D)+\delta ]}{k_1 + [c'(q,D)+\delta ]}  & \quad if \quad c'(q,D)>0\\
0 & \quad otherwise\\
\end{aligned}
\right.
-->
<p>而下面的改进$f’(q,D)$正好可以满足上述三个特性:</p>
<p><img src="/img/BM25-Fails-When-The-Docments-Are-Very-Long/gj.gif" alt=""></p>
<p>使用时针对原来的$c’(q,D)$值增加了一个平滑项$\delta$，增加了平滑项之后依然满足<code>第1、2点</code>特性，并且当$c’(q,D)&gt;0$的时候$f’(q,D)$有一个下界:</p>
<p><center>$\frac{(k_1+1) \cdot \delta}{k_1+ \delta}$</center><br>这样也正好可以满足<code>第3点</code>特性</p>
<p>进行该项小改进之后的模型称为<code>BM25L</code>,遇到长文档时并不会失效，并且还保持原有的<code>BM25</code>特性.</p>
<h2 id="实验效果验证">实验效果验证</h2><p>针对多个数据集  ，使用不同的调节参数$b$,$k_1$,$\delta$进行试验:<br><img src="/img/BM25-Fails-When-The-Docments-Are-Very-Long/exp.png"></p>
<p>在第三章图明显可以发现<code>BM25L</code>的效果对<code>BM25</code>有较大的绝对提升，其中较优的参数范围为:</p>
<ol>
<li>$b \in [0,3,0.6] $</li>
<li>$k_1 \in [1.0,2.0]$</li>
<li>$\delta = 0.5$时最优</li>
</ol>
<h2 id="参考">参考</h2><ol>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.600.16&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">When Documents Are Very Long, BM25 Fails!</a></li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>B<span class="title">M25</span>在长文档下会失效，文本是记录SIGIR上的一个Paper的解决方案~
</code></pre><h2 id="当BM25遇到长文档">当BM25遇到长文档</h2><p>文档相关性模型-<code>BM25</code>的拟合公式如下:</p>
<center>$\sum_{i\in Q} log \frac {(r_i+0.5)((N-R)-(n_i-r_i)+0.5)}{(n_i-r_i+0.5)(R-r_i+0.5)} \cdot \frac{(k_1+1)f_i}{K+f_i} \cdot \frac{(k_2+1)qf_i}{k_2+qf_i}$</center>

<p>其中第一部分表示<code>BIM</code>的值，第二部分表示在文档中的权重，第三部分表示在查询词中的权重，(具体符号解释参考之前的<a href="http://kubicode.me/2016/01/26/Search%20Engine/Study-BM25-For-Query-Document-Relevance/">BM25介绍</a>)现将第二部分单独拿出来:</p>
<p><center>$f(q,D)=\frac{(k_1+1) \times TF}{k_1 \times ((1-b)+b \cdot \frac{dl}{avdl} )+TF}=\frac{(k_1+1) \times c’(q,D)}{k_1+c’(q,D)}$</center><br>其中:<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Search Engine" scheme="http://yyl8781697.github.io/tags/Search-Engine/"/>
    
      <category term="Search Engine" scheme="http://yyl8781697.github.io/categories/Search-Engine/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Learning to rank学习基础]]></title>
    <link href="http://yyl8781697.github.io/2016/02/15/Machine%20Learning/Learning-To-Rank-Base-Knowledge/"/>
    <id>http://yyl8781697.github.io/2016/02/15/Machine Learning/Learning-To-Rank-Base-Knowledge/</id>
    <published>2016-02-15T02:31:43.000Z</published>
    <updated>2016-02-24T07:22:24.000Z</updated>
    <content type="html"><![CDATA[<pre><code>Learning to <span class="function"><span class="title">rank</span><span class="params">(简写 LTR、L2R)</span></span> 也叫排序学习，指的是机器学习中任何用于排序的技术。
</code></pre><h2 id="为什么要用LTR">为什么要用LTR</h2><p>传统的检索模型靠人工拟合排序公式，并通过不断的实验确定最佳的参数组合，以此来形成相关性打分。这种方式非常简单高效，应该范围也很广，比如简单的博客排序、论坛的<code>QA</code>排序等.但是也同时存在较大的问题:</p>
<ol>
<li>手动调参工作量太大</li>
<li>可能会过拟合</li>
<li>如果模型参数很多，手动调参的可用性就很低了~</li>
</ol>
<p>LTR与此思路不同，最合理的排序公式由机器学习算法来确定，而人则需要给机器学习提供训练数据,他的优势有:</p>
<ol>
<li>可以自动调节参数</li>
<li>可以融合多方面观点的(evidences)的数据</li>
<li>避免过拟合(通过正则项)</li>
</ol>
<a id="more"></a>
<h2 id="LTR基本框架">LTR基本框架</h2><p><code>LTR</code>的核心还是机器学习，只是目标不仅仅是简单的分类或者回归了，最主要的是产出文档的排序结果，它通常的工作框架如下:<br><img src="/img/Learning-To-Rank-Base-Knowledge/lrt_framework.png" width="400px"></p>
<p>所描述的步骤为:<code>训练数据获取-&gt;特征提取-&gt;模型训练-&gt;测试数据预测-&gt;效果评估</code></p>
<h2 id="训练数据的获取">训练数据的获取</h2><h4 id="人工标注">人工标注</h4><p>人工标注的数据主要有以下几大类型:</p>
<ul>
<li><p>单点标注</p>
<ul>
<li>对于每个查询文档打上绝对标签</li>
<li>二元标注：相关 vs 不相关</li>
<li><p>五级标注：完美(Perfect),出色(Excellent),好(Good),一般(Fair),差(Bad) ，一般后面两档属于不相关</p>
<blockquote>
<p>好处：标注的量少O(n)<br>坏处：难标。。。不好统一</p>
</blockquote>
</li>
</ul>
</li>
<li><p>两两标注</p>
<ul>
<li><p>对于一个查询<code>Query</code>,要标注文档$d1$比文档$d2$是否更加相关 $(q,d1)\succ (q,d2)?$</p>
<blockquote>
<p>好处：标注起来比较方便<br>坏处：标注量大 估计得有O(n^2)</p>
</blockquote>
</li>
</ul>
</li>
<li><p>列表标注</p>
<ul>
<li><p>对于一个查询<code>Query</code>，将人工理想的排序整个儿标好</p>
<blockquote>
<p>好处： 相对于上面两种，标的效果会很好<br>坏处： 这个工作量也太大了…-_-||</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="日志抽取">日志抽取</h4><p>当搜索引擎搭建起来之后用户的点击数据就变得非常好使。</p>
<pre><code>比如，结果ABC分别位于<span class="number">123</span>位，B比<span class="literal">A</span>位置低，但却得到了更多的点击，那么B的相关性可能好于<span class="literal">A</span>.
</code></pre><p>这种点击数据隐含了<code>Query</code>到文档的相关性好坏。所以一般会使用点击倒置的<code>高低位</code>结果作为训练数据.</p>
<p>但是他也是存在问题的：</p>
<ul>
<li>用户总是习惯于从上到下浏览搜索结果</li>
<li>用户点击有比较大的噪声</li>
<li>一般头查询(<code>head query</code>)才存在用户点击</li>
</ul>
<h2 id="特征提取">特征提取</h2><p>检索系统会使用一系列特征来表示一次查询，通过模型之后最终决定文档的排序顺序，这里用$q$来表示查询,$d$表示查询的文档,$occur-term$表示$q$与$d$共现的词，则提取的特征主要有以下三大类:</p>
<ul>
<li>$occur-term$与$q$特征<ul>
<li>共现在查询中的出现次数、比率等</li>
</ul>
</li>
<li>$occur-term$与$d$的特征<ul>
<li>共现在文档中的出现次数、比率等</li>
<li>共现词与文档的相关性特征:<code>BM25系列</code></li>
</ul>
</li>
<li>$d$自身特征<ul>
<li><code>PageRank</code>值</li>
<li><code>Spam</code>信息</li>
<li><code>Quality</code>质量分</li>
<li>行为分,<code>ctr</code>，<code>停留时间</code>，<code>二跳率</code>等..</li>
</ul>
</li>
</ul>
<h2 id="模型训练">模型训练</h2><p><code>LTR</code>的模型主要有单文档方法(<code>Pointwise Approach</code>)、文档对方法(<code>Pairwise Approach</code>)和列表方法(<code>Listwise Approach</code>)三大类,下面是实现他们的各种算法:</p>
<h3 id="Pointwise_Approach">Pointwise Approach</h3><pre><code><span class="variable">Pointwise</span>的处理对象是单独的一篇文档，将文档转换为特征向量之后，机器学习模型根据从训练数据中学习到的分类或者回归函数对文档打分，打分的结果就是搜索的结果.
</code></pre><p>其实就是将文档排序转为了文档的回归、分类和有序分类问题，其函数的框架为:</p>
<center>$L(F(X),y)=\sum_{i=1}^{n}l(f(x_i)-y_i)$</center><br>输入:<br>- 单个文档查询对:$(x_i,y_i)$<br>- 完全忽略上下文的关系<br>- 将标注转为数字，比如<code>Perfect-&gt;5, Excellent-&gt;4, Good-&gt;3, Fair-&gt;2, Bad-&gt;1</code><br><br>输出:<br>- 排序函数,对于给定查询文档对,能够计算出得分(score)<br><br>关于<code>Pointwise</code>下的三个分支，这张图解释的很好:<br><center><img src="/img/Learning-To-Rank-Base-Knowledge/pointwise_flow.png" width="400px"></center>

<p>其主要区别就是<code>loss function</code>不同，也就是最后的结果目标不一样:</p>
<ul>
<li><code>Classification</code>:输入的是5档类别（作为离散），最后通过分类模型输测试数据的各个档位档位的概率，然后进行加权成一个实数值</li>
<li><code>Regression</code>:输入的是5档或者2档（作为连续），最后通过回归模型输出测试数据的一个相关性实数(就是回归)</li>
<li><code>Ordinal Classification</code>:输入有序的档位，一般2档(离散),最后通过分类模型的阈值给到一个档位(应该是二分类把)</li>
</ul>
<p>实现<code>Pointwise</code>方法的主要算法有:</p>
<ul>
<li>Classification<ul>
<li>Discriminative model for IR (SIGIR 2004)</li>
<li><strong>McRank (NIPS 2007)</strong></li>
</ul>
</li>
<li>Regression<ul>
<li>Least Square Retrieval Function (TOIS 1989)</li>
<li>Regression Tree for Ordinal Class Prediction (Fundamenta Informaticae, 2000)</li>
<li><strong>Subset Ranking using Regression (COLT 2006)</strong></li>
</ul>
</li>
<li>Ordinal Classification<ul>
<li><strong>Pranking (NIPS 2002)</strong></li>
<li>OAP-BPM (EMCL 2003)</li>
<li>Ranking with Large Margin Principles (NIPS 2002)</li>
<li>Constraint Ordinal Regression (ICML 2005)</li>
</ul>
</li>
</ul>
<p><strong>优点:</strong></p>
<ul>
<li>速度快，复杂度低.</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>效果一般</li>
<li>没有考虑到文档之间的相对关系</li>
<li>忽略了文档相关度与查询的关联，比如<code>Top Query</code>排在后面的相关性比<code>Tial Query</code>排在前面的都要高，导致训练样本不一致</li>
</ul>
<h3 id="Pairwise_Approach">Pairwise Approach</h3><pre><code>对于搜索任务来说，系统接收到用户查询后，返回相关文档列表，所以问题的关键是确定文档之间的先后相对顺序关系，而<span class="variable">Pairwise</span>则将重点转向对文档关系是否合理的判断.
</code></pre><p><code>Pairwise</code>主要是讲排序问题转为了文档对顺序的判断<br>以下图为例:<br><img src="/img/Learning-To-Rank-Base-Knowledge/pairwise_example.png" width="500px"><br>对于查询<code>Q1</code>进行人工标注之后,<code>Doc2=5</code>的分数最高，其次是<code>Doc3</code>为4分，最差的是<code>Doc1</code>为3分，将此转为相对关系之后有:<code>Doc2&gt;Doc1、Doc2&gt;Doc3、Doc3&gt;Doc1</code>，而根据这个顺序关系逆向也可以得到相关性的排序顺序，所以排序问题可以很自然的转为任意两个文档关系的判断,而任意两个文档顺序的判断就称为了一个很熟悉的分类问题.<br><code>Pairwise</code>的函数框架为:</p>
<!-- $L(F(x),y)=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}(sign(y_i-y_j),f(x_i)-f(x_j))$ -->
<center><img src="/img/Learning-To-Rank-Base-Knowledge/pairwise_func.gif"></center>

<p><strong>输入</strong>:</p>
<ul>
<li>同一查询的一对文档$(x_i,x_j,sign(y_i-y_j))$</li>
<li>标注两个文档的相对关系，如果文档$x_i$比$x_j$更加相关，则$sign(y_i-y_j))=1$</li>
<li>分布保留同一查询下的文档间关系</li>
</ul>
<p><strong>输出</strong>:</p>
<ul>
<li>排序函数给出文档对的计算得分</li>
</ul>
<p>关于<code>Pairwise</code>最终的算分，其实分类和回归都可以实现:</p>
<center><img src="/img/Learning-To-Rank-Base-Knowledge/pairwise_flow.png" width="400px"></center>


<p>实现<code>Pairwise Approach</code>方法的主要算法有:</p>
<ul>
<li>Learning to Retrieve Information (SCC 1995)</li>
<li>Learning to Order Things (NIPS 1998)</li>
<li><strong>Ranking SVM (ICANN 1999)</strong></li>
<li><strong>RankBoost (JMLR 2003)</strong></li>
<li>LDM (SIGIR 2005)</li>
<li><strong>RankNet (ICML 2005)</strong></li>
<li><strong>Frank (SIGIR 2007)</strong></li>
<li>MHR(SIGIR 2007)</li>
<li><strong>GBRank (SIGIR 2007)</strong></li>
<li>QBRank (NIPS 2007)</li>
<li>MPRank (ICML 2007)</li>
<li><strong>IRSVM (SIGIR 2006)</strong></li>
<li>LambdaRank (NIPS 2006)</li>
</ul>
<p>虽然<code>Pairwise</code>方法对<code>Pointwise</code>方法做了改进，但是也明显存在两个问题:</p>
<ol>
<li>只考虑了两个文档的先后顺序，没有考虑文档出现在搜索列表中的位置</li>
<li>不同的查询，其相关文档数量差异很大，转换为文档对之后，有的查询可能有几百对文档，有的可能只有几十个，最终对机器学习的效果评价造成困难</li>
</ol>
<h3 id="Listwise_Approach">Listwise Approach</h3><pre><code>与<span class="variable">Pointwise</span>和<span class="variable">Pairwise</span>不同，<span class="variable">Listwise</span>是将一个查询对应的所有搜索结果列表作为一个训练实例，因此也称为文档列方法.
</code></pre><p>文档列方法根据$K$个训练实例训练得到最优的评分函数$F$，对于一个新的查询，函数$F$对每一个文档进行打分，之后按照得分顺序高低排序，就是对应的搜索结果.<br><code>Listwise</code>主要有两类:</p>
<ul>
<li><code>Measure specific</code>:损失函数与评估指标相关,比如:$L(F(x),y)=exp(-NDCG)$</li>
<li><code>Non-measure specific</code>:损失函数与评估指标不是显示相关,考虑了信息检索中的一些独特性质</li>
</ul>
<p>实现<code>Listwise</code>的算法主要有:</p>
<ul>
<li>Measure-specific<ul>
<li><strong>AdaRank (SIGIR 2007)</strong></li>
<li><strong>SVM-MAP (SIGIR 2007)</strong></li>
<li><strong>SoftRank (LR4IR 2007)</strong></li>
<li>RankGP (LR4IR 2007)</li>
<li>LambdaMART (inf.retr 2010)</li>
</ul>
</li>
<li>Non-measure specific<ul>
<li><strong>ListNet (ICML 2007)</strong></li>
<li><strong>ListMLE (ICML 2008)</strong></li>
<li>BoltzRank (ICML 2009)</li>
</ul>
</li>
</ul>
<blockquote>
<p>实验表明 一般<code>Listwise</code>要好于前两种排序算法，但是其复杂度是在太高了</p>
</blockquote>
<h3 id="方法对比">方法对比</h3><table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">pointwise</th>
<th style="text-align:left">pairwise</th>
<th style="text-align:left">listwise</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">输入信息的完整度</td>
<td style="text-align:left"><strong>不完全</strong></td>
<td style="text-align:left"><strong>部分完全</strong></td>
<td style="text-align:left"><strong>完全</strong></td>
</tr>
<tr>
<td style="text-align:left">输入</td>
<td style="text-align:left">$(x,y)$</td>
<td style="text-align:left">$(x_1,x_2,y)$</td>
<td style="text-align:left">$(x_1,x_2…x_n,\pi)$</td>
</tr>
<tr>
<td style="text-align:left">输出</td>
<td style="text-align:left">$f(x)$</td>
<td style="text-align:left">$f(x)$</td>
<td style="text-align:left">$f(x)$</td>
</tr>
<tr>
<td style="text-align:left">样本复杂度</td>
<td style="text-align:left">$O(n)$</td>
<td style="text-align:left">O(n^2)</td>
<td style="text-align:left">O(n!)</td>
</tr>
<tr>
<td style="text-align:left">表现</td>
<td style="text-align:left"><em>差</em></td>
<td style="text-align:left"><em>中</em></td>
<td style="text-align:left"><em>好</em></td>
</tr>
</tbody>
</table>
<h2 id="评估指标">评估指标</h2><h3 id="MAP">MAP</h3><p><code>MAP</code>(<code>Mean Average Precision</code>)表示文档在排序中的平均精度均值，是用于衡量个query查询见过的平均精度值<code>AP</code>,<br>系统检索出来的相关文档越靠前(rank 越高)，MAP就可能越高。如果系统没有返回相关文档，则准确率默认为0。</p>
<p>所以对于计算<code>AP</code>的值就是关键了,<code>MAP</code>对文档只分为两档:相关与不相关，则<code>AP</code>表示为</p>
<center>$AP=\frac{\sum_{i:relvance}^{n}P_i/R_i}{n}$</center>

<blockquote>
<p>其中$P_i$表示所有召回文档中相关文档的相对次序，$R_i$表示所有被召回的相关文档中在所有文档中的次序</p>
</blockquote>
<p>比如在某个<code>query</code>得到的排序中:<br><img src="/img/Learning-To-Rank-Base-Knowledge/map_demo.png" width="400px"><br>则他的相对顺序的表格为:</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">O</th>
<th style="text-align:left">X</th>
<th style="text-align:left">O</th>
<th style="text-align:left">O</th>
<th style="text-align:left">O</th>
<th style="text-align:left">O</th>
<th style="text-align:left">X</th>
<th style="text-align:left">X</th>
<th style="text-align:left">X</th>
<th style="text-align:left">O</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">相关文档次序</td>
<td style="text-align:left">1</td>
<td style="text-align:left"></td>
<td style="text-align:left">2</td>
<td style="text-align:left">3</td>
<td style="text-align:left">4</td>
<td style="text-align:left">5</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">6</td>
</tr>
<tr>
<td style="text-align:left">所有召回文档次序</td>
<td style="text-align:left">1</td>
<td style="text-align:left">2</td>
<td style="text-align:left">3</td>
<td style="text-align:left">4</td>
<td style="text-align:left">5</td>
<td style="text-align:left">6</td>
<td style="text-align:left">7</td>
<td style="text-align:left">8</td>
<td style="text-align:left">9</td>
<td style="text-align:left">10</td>
</tr>
<tr>
<td style="text-align:left">Precision</td>
<td style="text-align:left">1/1</td>
<td style="text-align:left"></td>
<td style="text-align:left">2/3</td>
<td style="text-align:left">3/4</td>
<td style="text-align:left">4/5</td>
<td style="text-align:left">5/6</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">6/10</td>
</tr>
</tbody>
</table>
<p>最终计算的$AP=(1/1+2/3+3/4+4/5+5/6+6/10)/6=0.78$</p>
<h3 id="NDCG">NDCG</h3><p><code>NDCG</code>表示表示归一化折损累积增益，主要是衡量实际相关性越高的文档排在越前面，它的全称是<code>Normalized Discounted Cumulative Gain</code>,也正好代表了4个部分的含义:</p>
<ul>
<li><p><code>Gain</code>:表示增益，一般相关性越高，增益值也是越大</p>
  <center>$G_i=2^{y_i}-1$</center>

<blockquote>
<p>其中$y_i$表示文档相关性档位，一般档位越高，相关性越大</p>
</blockquote>
</li>
<li><p><code>Discounted</code>:一般认为排序位置 带来的权重不同，所以会有一个折损因子</p>
  <center>$DG_i=\frac{2^{y_i}-1}{log(1+i)}$</center>

<blockquote>
<p>其中$i$为文档的排序位置，从1开始</p>
</blockquote>
</li>
<li><p><code>Cumulative</code>：表示在一次<code>query</code>查询中所有的增益累加</p>
  <center>$DCG=\sum_{i=1}^{n}{\frac{2^{y_i}-1}{log(1+i)}}$</center>
</li>
<li><p><code>Normalized</code>：为归一化，因为在不同的查询中可能<code>DCG</code>的值波动较大，这里计算各个query最理想的排序的<code>DCG</code>值作为归一化因子，也称为<code>IDCG</code></p>
  <center>$NDCG=\frac{1}{IDCG} \cdot \sum_{i=1}^{n}{\frac{2^{y_i}-1}{log(1+i)}}$</center>

</li>
</ul>
<p><code>NDCG</code>的可使用性更加广泛了，但是还是存在以下三点限制:</p>
<ol>
<li><code>NDCG</code>并没有对不相关文档进行惩罚</li>
<li><code>NDCG</code>对一些缺失的完成结果也没有进行惩罚</li>
</ol>
<h2 id="公开数据集">公开数据集</h2><ol>
<li><a href="http://research.microsoft.com/en-us/um/beijing/projects/letor/" target="_blank" rel="external">http://research.microsoft.com/en-us/um/beijing/projects/letor/</a></li>
<li><a href="http://research.microsoft.com/en-us/projects/mslr/" target="_blank" rel="external">http://research.microsoft.com/en-us/projects/mslr/</a></li>
<li><a href="http://webscope.sandbox.yahoo.com/" target="_blank" rel="external">http://webscope.sandbox.yahoo.com/</a></li>
</ol>
<h2 id="总结">总结</h2><p>在玩搜索引擎时敲定特征分的权重是非常疼的一件事儿，而<code>LTR</code>正好帮你定分，<code>LTR</code>的三种实现方法其实各有优劣：</p>
<ol>
<li>难点主要在训练样本的构建(人工或者挖日志)，另外就是训练复杂</li>
<li>虽说<code>Listwise</code>效果最好，但是天下武功唯快不破，看看这篇文章<a href="http://www.cnblogs.com/zjgtan/p/3652689.html" target="_blank" rel="external">http://www.cnblogs.com/zjgtan/p/3652689.html</a>体验下</li>
<li>在工业界用的比较多的应该还是<code>Pairwise</code>，因为他构建训练样本相对方便，并且复杂度也还可以，所以<code>Rank SVM</code>就很火啊^_^</li>
</ol>
<h2 id="参考">参考</h2><ul>
<li>《这就是搜索引擎：核心技术详解》 . 第五章</li>
<li><a href="http://blog.crackcell.com/posts/2011/12/17/a_short_intro_2_ltr.html" target="_blank" rel="external">Learning to Rank小结</a></li>
<li><a href="http://www.icst.pku.edu.cn/lcwm/course/WebDataMining/slides2012/8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8F%8A%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80.pdf" target="_blank" rel="external">机器学习及排序学习基础</a></li>
<li><a href="http://www.contem.org/2010summer/slides/LEARNING%20TO%20RANK%20TUTORIAL%20-%20tyliu.pdf" target="_blank" rel="external">Learning to Rank for Information Retrieval</a></li>
<li><a href="https://en.wikipedia.org/wiki/Discounted_cumulative_gain" target="_blank" rel="external">https://en.wikipedia.org/wiki/Discounted_cumulative_gain</a></li>
<li><a href="https://www.kaggle.com/wiki/MeanAveragePrecision" target="_blank" rel="external">https://www.kaggle.com/wiki/MeanAveragePrecision</a></li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>Learning to <span class="function"><span class="title">rank</span><span class="params">(简写 LTR、L2R)</span></span> 也叫排序学习，指的是机器学习中任何用于排序的技术。
</code></pre><h2 id="为什么要用LTR">为什么要用LTR</h2><p>传统的检索模型靠人工拟合排序公式，并通过不断的实验确定最佳的参数组合，以此来形成相关性打分。这种方式非常简单高效，应该范围也很广，比如简单的博客排序、论坛的<code>QA</code>排序等.但是也同时存在较大的问题:</p>
<ol>
<li>手动调参工作量太大</li>
<li>可能会过拟合</li>
<li>如果模型参数很多，手动调参的可用性就很低了~</li>
</ol>
<p>LTR与此思路不同，最合理的排序公式由机器学习算法来确定，而人则需要给机器学习提供训练数据,他的优势有:</p>
<ol>
<li>可以自动调节参数</li>
<li>可以融合多方面观点的(evidences)的数据</li>
<li>避免过拟合(通过正则项)</li>
</ol>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Search Engine" scheme="http://yyl8781697.github.io/tags/Search-Engine/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Hexo中离线安装数据工具包-Mathjax]]></title>
    <link href="http://yyl8781697.github.io/2016/01/27/Hexo/Offline-Install-Mathjax-In-Hexo-Jacman/"/>
    <id>http://yyl8781697.github.io/2016/01/27/Hexo/Offline-Install-Mathjax-In-Hexo-Jacman/</id>
    <published>2016-01-27T09:30:11.000Z</published>
    <updated>2016-02-03T06:24:54.000Z</updated>
    <content type="html"><![CDATA[<pre><code>这里与其说安装，还是不如直接拷贝相应文件到hexo目录
</code></pre><p>最近尝试在写<code>blog</code>的时候用<code>Latex</code>来写数学公式，写起来还是极其方便灵活滴，但是，但是其速度慢如爬蜗牛，一般修改一下，在刷新一下要<code>4~5s</code>才能将公式渲染出来，其书写效率也太低了，总之我不能忍，所以准备将其<code>MathJax</code>放在本地.</p>
<ol>
<li>一方面是希望加快公式的渲染速度</li>
<li>另一方面也是希望能支持我在断网的情况下也能正常使用<code>Mathjax</code></li>
</ol>
<a id="more"></a>
<p>我用的是<a href="http://wuchong.me/" target="_blank" rel="external">Jark</a>大神的<code>jacman</code>主题，在简单<code>grep</code>查找之后可以发现<code>MathJax</code>的引用在:<br><code>/themes/jacman/layout/_partial/mathjax.ejs</code>这里，可以发现也就远程引用了官网cdn的一个js<br><code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;</code></p>
<p>在<a href="http://docs.mathjax.org/en/latest/installation.html" target="_blank" rel="external">http://docs.mathjax.org/en/latest/installation.html</a>可以下载到<code>Mathjax</code>的离线包（建议乖乖直接下包，别去爬<code>cdn</code>里面的目录，心累）。</p>
<p>离线包解压之后的<code>unpacked</code>目录里面有整理好直接引用的资源文件(尼玛，之类有<code>16m</code>，难怪慢如蜗牛..)</p>
<p>在<code>/themes/jacman/source/js</code>新建一个<code>mathjax/2.5-latest</code>的目录，将<code>unpacked</code>下的文件整个儿拷贝过去,修改<code>mathjax.ejs</code>中的引用<br><code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/mathjax/2.5-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;</code></p>
<p>清空目录，再重新生成文件,启动服务器，跑起来看公式 只能说   <code>如丝般顺滑</code> ^_^</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>这里与其说安装，还是不如直接拷贝相应文件到hexo目录
</code></pre><p>最近尝试在写<code>blog</code>的时候用<code>Latex</code>来写数学公式，写起来还是极其方便灵活滴，但是，但是其速度慢如爬蜗牛，一般修改一下，在刷新一下要<code>4~5s</code>才能将公式渲染出来，其书写效率也太低了，总之我不能忍，所以准备将其<code>MathJax</code>放在本地.</p>
<ol>
<li>一方面是希望加快公式的渲染速度</li>
<li>另一方面也是希望能支持我在断网的情况下也能正常使用<code>Mathjax</code></li>
</ol>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://yyl8781697.github.io/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://yyl8781697.github.io/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[概率检索模型BM25系列-文档相关性检索的利器]]></title>
    <link href="http://yyl8781697.github.io/2016/01/26/Search%20Engine/Study-BM25-For-Query-Document-Relevance/"/>
    <id>http://yyl8781697.github.io/2016/01/26/Search Engine/Study-BM25-For-Query-Document-Relevance/</id>
    <published>2016-01-26T09:06:31.000Z</published>
    <updated>2016-02-04T09:51:48.000Z</updated>
    <content type="html"><![CDATA[<pre><code>给定一个用户需求(<span class="keyword">query</span>),如果搜索系统展示的搜索结果是根据文档和<span class="keyword">query</span>的相关性由高向低排序的，那么这个搜索引擎是最优的。在文档集合的基础上计算其相关性估计是其核心~
</code></pre><h2 id="概率排序原理">概率排序原理</h2><p>以往的<code>向量空间模型</code>是将<code>query</code>和文档使用向量表示然后计算其内容相似性来进行相关性估计的，而<code>概率检索模型</code>是一种直接对用户需求进行相关性的建模方法,一个<code>query</code>进来，将所有的文档分为两类—-<code>相关文档</code>、<code>不相关文档</code>,这样就转为了一个相关性的分类问题,赞!</p>
<p>对于某个文档$D$来说，$P(R|D)$表示该文档数据相关文档的概率，则$P(NR|D)$表示该文档属于不相关文档的概率，如果<code>query</code>属于相关文档的概率大于不相关文档$P(R|D)&gt;P(RN|D)$，则认为这个文档是与用户查询相关相关的.</p>
<a id="more"></a>
<p>现在使用贝叶斯公式将其转一下:</p>
<center>$P(R|D)&gt;P(NR|D) &lt;=&gt;\frac{P(D|R)P(R)}{P(D)}&gt;\frac{P(D|NR)P(NR)}{P(D)} &lt;=&gt; \frac{P(D|R)}{P(D|NR)}&gt;\frac{P(NR)}{P(R)}$</center>

<p>在搜索排序过程中不需要真正的分类，只需要保证相关性由高到底排序即可，所以只需要$\frac{P(D|R)}{P(D|NR)}$降序即可，<br>这样就最终转为计算$P(D|R)$,$P(D|NR)$的值即可.</p>
<h2 id="二元独立模型(BIM)">二元独立模型(BIM)</h2><pre><code><span class="xml">词汇独立性假设:文档里面出现的词没有任何关联，这样一个文档的出现就可以转为各个单词出现概率的乘积（虽然这种假设有违实际，但是算起来简单的啊</span><span class="keyword">^_</span><span class="xml">^）</span>
</code></pre><p>上述提到的文档$D$表示为<code>{1,0,1,0,1}</code>，用$p_i$来表示第$i$个单词在相关文档出现的概率,则在已知<code>相关文档</code>集合的情况下，观察到$D$的概率为:<br>    <center>$P(D|R)=p_1 \times (1-p_2) \times p_3 \times (1-p_4) \times p_5$ </center></p>
<blockquote>
<p>第<code>1,3,5</code>表示这个单词在$D$中出现,所以其贡献概率为$p_i$，而第<code>2,4</code>这两个单词并没有在$D$中出现，所以其贡献的概率为$1-p_i$ </p>
</blockquote>
<p>同理在<code>不相关文档</code>中观察到的概率为:<br>    <center>$P(D|R)=s_1 \times (1-s_2) \times s_3 \times (1-s_4) \times s_5$ </center></p>
<p>最终得到的相关性概率估算为:</p>
<center>$\frac{P(D|R)}{P(D|NR)}=\frac{p_1 \times (1-p_2) \times p_3 \times (1-p_4) \times p_5}{s_1 \times (1-s_2) \times s_3 \times (1-s_4) \times s_5}$</center>

<p>现在将其推广之后可以有通用的式子：<br><!-- 
\frac{P(D|R)}{P(D|NR)}= \prod_{i:d_i=1} \frac{p_i}{s_i} \times \prod_{i:d_i=0} \frac{1-p_i}{1-s_i}
--></p>
<center><img src="/img/Study-BM25-For-Query-Document-Relevance/eq_zs.gif" alt=""></center>

<blockquote>
<p>$d_i=1$表示在文档中出现的单词，$d_i=0$表示没在文档中出现的单词:</p>
</blockquote>
<p>在这里进一步对上述公式进行等价变换之后有:</p>
<!-- 
\\
\frac{P(D|R)}{P(D|NR)}=\prod_{i:d_i=1} \frac{p_i}{s_i} \times \left ( \prod_{i:d_i=1} \frac{1-s_i}{1-p_i} \times \prod_{i:d_i=1} \frac{1-p_i}{1-s_i} \right ) \times \prod_{i:d_i=0} \frac{1-p_i}{1-s_i}\\
= \left ( \prod_{i:d_i=1} \frac{p_i}{s_i} \times \prod_{i:d_i=1} \frac{1-s_i}{1-p_i} \right ) \times  \left ( \prod_{i:d_i=1} \frac{1-p_i}{1-s_i} \times \prod_{i:d_i=0} \frac{1-p_i}{1-s_i} \right )  \\
=\prod_{i:d_i=1} \frac{p_i(1-s_i)}{s_i(1-p_i)} \times \prod_i \frac{1-pi}{1-s_i} \\
=\prod_{i:d_i=1} \frac{p_i(1-s_i)}{s_i(1-p_i)} 
-->
<center><img src="/img/Study-BM25-For-Query-Document-Relevance/eq_2.gif" alt=""></center>

<p>其中上面式子第三步的第二部分$\prod_i \frac{1-pi}{1-s_i} $表示各个单词在所有文档中出现的概率，所以这个式子的值和具体文档并没有什么关系，在排序中不起作用，才可以简化到第4步.</p>
<p>为了方便计算，将上述连乘公式取$log$:</p>
<center>$log(\frac{P(D|R)}{P(D|NR)}) =  \sum_{i:d_i=1} log \frac{p_i(1-s_i)}{s_i(1-p_i)}$</center>

<p>有了上述最终可计算的式子之后，我们就只需要统计文档$D$中的各个单词在<code>相关文档</code>/<code>不相关文档</code>中出现的概率即可:</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">相关文档</th>
<th style="text-align:left">不相关文档</th>
<th style="text-align:left">文档数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$d_i=1$</td>
<td style="text-align:left">$r_i$</td>
<td style="text-align:left">$n_i-r_i$</td>
<td style="text-align:left">$n_i$</td>
</tr>
<tr>
<td style="text-align:left">$d_i=0$</td>
<td style="text-align:left">$R-r_i$</td>
<td style="text-align:left">$(N-R)-(n_i-r_i)$</td>
<td style="text-align:left">$N-n_i$</td>
</tr>
<tr>
<td style="text-align:left">文档数量</td>
<td style="text-align:left">$R$</td>
<td style="text-align:left">$N-R$</td>
<td style="text-align:left">$N$</td>
</tr>
</tbody>
</table>
<p>上面的表格表示各个单词在文档集合中的<code>相关文档</code>/<code>不相关文档</code>出现数量,同时为了避免$log(0)$出现，加上平滑之后可以计算得到:</p>
<center>$p_i=\frac{r_i+0.5}{R+1}$</center><br><center>$s_i=\frac{(n_i-r_i)+0.5}{(N-R)+1}$</center>

<p>则最终可以得到如下公式:</p>
<center>$\sum_{q_i=d_i=1} log \frac {(r_i+0.5)((N-R)-(n_i-r_i)+0.5)}{(n_i-r_i+0.5)(R-r_i+0.5)}$</center>

<p>上面的公式表示对于同时出现查询$q_i$以及文档$d_i$的时候，对$q_i$在$d_i$中出现的单词在<code>相关文档</code>/<code>不相关文档</code>进行统计，即可得到查询与文档的相关性估计值.</p>
<blockquote>
<p>在不确定哪些文档是相关的，哪些文档是不相关的的时候，可以给公式的估算因子直接赋予固定值，则该公式将会蜕化为$IDF$因子.</p>
</blockquote>
<h2 id="BM25_模型">BM25 模型</h2><h3 id="模型概述">模型概述</h3><blockquote>
<p>上一小节中的<code>BIM模型</code>效果并不佳，也没有考虑单词权重，但是他给<code>BM25模型</code>打下了深深的基础</p>
</blockquote>
<pre><code>B<span class="title">M25</span> 模型在BIM模型的基础上考虑了查询词在Query以及Doc中的权重，并通过实验引入了一些经验参数。B<span class="title">M25</span>模型是目前最成功的内容排序模型.
</code></pre><p>改进之后的<code>BM25</code>模型的拟合公式如下:</p>
<center>$\sum_{i\in Q} log \frac {(r_i+0.5)((N-R)-(n_i-r_i)+0.5)}{(n_i-r_i+0.5)(R-r_i+0.5)} \cdot \frac{(k_1+1)f_i}{K+f_i} \cdot \frac{(k_2+1)qf_i}{k_2+qf_i}$</center>

<p>上面的式子中:</p>
<ol>
<li>第1部分即为上一小节的二元独立模型BIM计算得分</li>
<li>第2部分是查询词在$D$中的权重，其中$f_i$代表词在文档中的词频,$K$因子代表了对文档长度的考虑，其计算公式为$K=k_1((1-b)+b \cdot \frac{dl}{avdl})$<ol>
<li>$k_1$为经验参数,这里的$k_1$一般设置为1.2,</li>
<li>$b$为调节因子，将$b$设为0时，文档长度因素将不起作用，经验表明一般$b=0.75$</li>
<li>$dl$代表当前文档的长度</li>
<li>$avdl$代表所有文档的平均长度</li>
</ol>
</li>
<li>第3部分是查询词在自身的权重,$qf_i$表示在查询中的词频,$k_2$也为调节因子，因为在短查询下这部分一般为1，为了放大这部分的差异，$k_2$一般取值为<code>0~1000</code></li>
</ol>
<blockquote>
<p>综合看来,<code>BM25</code>模型结合了<code>BIM</code>因子、<code>文档长度</code>、<code>文档词频</code>和<code>查询词频</code>进行公式融合，并利用$k_1$、$k_2$、$b$对各种因子进行权重的调整.</p>
</blockquote>
<h3 id="栗子">栗子</h3><p>假设当前以<code>乔布斯 IPAD2</code>这个查询词为例，来计算在某文档$D$中<code>BM25相关性</code>的值，由于不知道文档集中相关与不相关的分类，所以这里直接将相关文档个数$r$置为0,则将得到的<code>BIM</code>因子为:<br>    <center>$Rel_{BIM}=log \frac {(0+0.5)((N-0)-(n_i-0)+0.5)}{(n_i-0+0.5)(0-0+0.5)}=log \frac{N-n_i+0.5}{n_i+0.5}$</center></p>
<p>其他数值假定如下:</p>
<ol>
<li>文档的集合总数$N=100000$</li>
<li>包含<code>乔布斯</code>的文档个数为$n_{乔布斯}=1000$</li>
<li>包含<code>IPAD2</code>的文档个数为$n_{IPAD2}=100$</li>
<li>文档$D$中出现<code>乔布斯</code>的词频为$f_{乔布斯}=8$</li>
<li>文档$D$中出现<code>IPAD2</code>的词频为$f_{IPAD2}=8$</li>
<li>查询词频均为$qf_i=1$</li>
<li>调节因子$k_1=1.2$</li>
<li>调节因子$k_2=200$</li>
<li>调节因子$b=0.75$</li>
<li>设文档$D$的长度为平均长度的1.5倍($\frac{dl}{avdl}=1.5$),即$K=1.2 \times (0.25+0.75 \times 1.5)=1.65$</li>
</ol>
<p>则最终可以计算到的<code>BM25</code>结果为:</p>
<p>$Rel_{BM25}=log \frac{100000-1000+0.5}{1000+0.5} \times \frac{(1.2+1) \times 8}{1.65+8} \times \frac{(200+1) \times 1}{200+1}+ log \frac{100000-1000+0.5}{1000+0.5} \times \frac{(1.2+1) \times 5}{1.65+5} \times \frac{(200+1) \times 1}{200+1} = 8.59$</p>
<p>每个文档按上述公式计算得到相关性排序即可.</p>
<h2 id="BM25F_模型">BM25F 模型</h2><blockquote>
<p>在<code>BM25</code>模型中，文档被当做一个整体进行进行词频的统计，而忽视了不同区域的重要性，<code>BM25F</code>模型正是抓住了这点进行了相应的改进。</p>
</blockquote>
<p><code>BM25F</code>模型在计算相关性时候，会对文档分割成不同的域来进行加权统计，非常适用于网页搜索，因为在一个网页有<code>标题信息</code>、<code>meta信息</code>、<code>页面内容信息</code>等，而<code>标题信息</code>无疑是最重要的，其次是<code>meta信息</code>，最后才是<code>网页内容</code>，<code>BM25F</code>在计算相关性的，会将网页分为不用的区域，在各个区域分别统计自己的词频。<br>所以<code>BM25F</code>模型的计算公式为:</p>
<center>$\sum_{i:q_i=d_i=1} log \frac {(r_i+0.5)((N-R)-(n_i-r_i)+0.5)}{(n_i-r_i+0.5)(R-r_i+0.5)} \times \frac{f_i^u}{k_1+f_i^u}$</center>

<blockquote>
<p><code>BM25F</code>的第1部分还是<code>BIM</code>的值</p>
</blockquote>
<p>其中与<code>BM25</code>主要的差别体现在$f_i^u$因子上,它是单词$i$在各个区域不同的得分,计算公式如下:</p>
<!-- f_i^u=\sum_{k=1}^uw_k \times \frac{f_{ui}}{B_u}-->
<center><img src="/img/Study-BM25-For-Query-Document-Relevance/eq_5.gif" alt=""></center><br><center>$B_u=((1-b_u)+b_u \times  \frac{ul_u}{uvul_u})$</center>

<p>上面的公式表示:</p>
<ol>
<li>文档$D$来个不同的$u$个域</li>
<li>各个域对应的权重为$W_k$</li>
<li><code>f<sub>i</sub><sup>u</sup></code>为第<code>i</code>个单词在各个域中的 $\frac{f_{ui}}{B_u}$ 的加权和</li>
<li>$f_{ui}$表示词频</li>
<li>$B_u$表示各个域的长度情况</li>
<li>$ul_u$为实际域的实际长度,$uvul_u$表示域的平均长度</li>
<li>$b_u$则为各个域长度的调节因子</li>
</ol>
<h2 id="总结">总结</h2><p><code>BM25</code>系列的模型主要是考虑查询词到文档里面的各种词频，含有大量自由的调节因子，最终给出查询到文档的相关性，模型都是比较简单的，但是里面提高的相关文档和不相关文档的引入将比较麻烦，有实际场景可以一试。</p>
<h2 id="参考">参考</h2><ol>
<li>《这就是搜索引擎：核心技术详解》 . 第五章</li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>给定一个用户需求(<span class="keyword">query</span>),如果搜索系统展示的搜索结果是根据文档和<span class="keyword">query</span>的相关性由高向低排序的，那么这个搜索引擎是最优的。在文档集合的基础上计算其相关性估计是其核心~
</code></pre><h2 id="概率排序原理">概率排序原理</h2><p>以往的<code>向量空间模型</code>是将<code>query</code>和文档使用向量表示然后计算其内容相似性来进行相关性估计的，而<code>概率检索模型</code>是一种直接对用户需求进行相关性的建模方法,一个<code>query</code>进来，将所有的文档分为两类—-<code>相关文档</code>、<code>不相关文档</code>,这样就转为了一个相关性的分类问题,赞!</p>
<p>对于某个文档$D$来说，$P(R|D)$表示该文档数据相关文档的概率，则$P(NR|D)$表示该文档属于不相关文档的概率，如果<code>query</code>属于相关文档的概率大于不相关文档$P(R|D)&gt;P(RN|D)$，则认为这个文档是与用户查询相关相关的.</p>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Search Engine" scheme="http://yyl8781697.github.io/tags/Search-Engine/"/>
    
      <category term="Search Engine" scheme="http://yyl8781697.github.io/categories/Search-Engine/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用笨方法解决Shell中按行读取文件之后Tab键不见的问题]]></title>
    <link href="http://yyl8781697.github.io/2016/01/03/Linux/shell-line-no-tab/"/>
    <id>http://yyl8781697.github.io/2016/01/03/Linux/shell-line-no-tab/</id>
    <published>2016-01-03T14:24:09.000Z</published>
    <updated>2016-01-03T15:03:02.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><code>Shell</code>强大灵活，但是今天在使用<code>Shell</code>处理按行读取文件时发现  读取到的行设定的<code>tab</code>分割符不见了</p>
</blockquote>
<p>先看一下演示的待<a href="http://kubicode.me/img/awk-study-list/score.log" target="_blank" rel="external">处理文件</a>:<br><img src="/img/shell-line-no-tab/demo_text.png" alt=""></p>
<p>需要做的需求就是将里面的数据使用<code>shell</code>将第一列读取出来做一些其他处理(当然如果仅仅是完成读取首列这个功能，使用<code>awk</code>是最快的，这里只是演示)</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">cat score.log | <span class="keyword">while</span> <span class="built_in">read</span> line  <span class="comment">#按行读取文件</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">    grade=`<span class="built_in">echo</span> <span class="variable">$line</span> | awk -F <span class="string">"\t"</span> <span class="string">'&#123;print $1&#125;'</span>` <span class="comment">#读取首列（年级）</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$grade</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>执行这个文件并且使用管道<code>| vim -</code> 打印只之后可以发现格式不对，按行打印了，并且其原先的分隔符<code>tab</code>也消失了<br><img src="/img/shell-line-no-tab/no_tab.png" alt=""></p>
<p>后来查到据说<code>shell</code>的默认分隔符是空格的原因,所以一种最直接的方式就是去<code>.bashrc</code>里面修改分割符,但是这么做可能会影响其他的<code>shell程序</code><br>所以比较保险的一种方法就是先将行中的<code>tab</code>替换，再对替换后的数据进行操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">cat score.log | awk <span class="string">'gsub("\t","\001",$0)'</span> | <span class="keyword">while</span> <span class="built_in">read</span> line  <span class="comment">#按行读取文件</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    grade=`<span class="built_in">echo</span> <span class="variable">$line</span> | awk -F <span class="string">"\001"</span> <span class="string">'&#123;print $1&#125;'</span>` <span class="comment">#读取首列（年级）</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$grade</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>先做了独立的<code>tab</code>去掉之后就可以很顺利地看到需要的结果了</p>
<p><img src="/img/shell-line-no-tab/ok.png" alt=""></p>
<blockquote>
<p>这个方法虽然比较简单，但是非常实用~</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><code>Shell</code>强大灵活，但是今天在使用<code>Shell</code>处理按行读取文件时发现  读取到的行设定的<code>tab</code>分割符不见了</p>
</blockquote>
<p>先看一下演示的待<a href="http://kubicode.me/img/awk-study-list/score.log">处理文件</a>:<br><img src="/img/shell-line-no-tab/demo_text.png" alt=""></p>
<p>需要做的需求就是将里面的数据使用<code>shell</code>将第一列读取出来做一些其他处理(当然如果仅仅是完成读取首列这个功能，使用<code>awk</code>是最快的，这里只是演示)</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yyl8781697.github.io/tags/Linux/"/>
    
      <category term="Vim" scheme="http://yyl8781697.github.io/tags/Vim/"/>
    
      <category term="Linux" scheme="http://yyl8781697.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[轻量的结构化文本处理工具-awk]]></title>
    <link href="http://yyl8781697.github.io/2015/12/24/Linux/awk-study-list/"/>
    <id>http://yyl8781697.github.io/2015/12/24/Linux/awk-study-list/</id>
    <published>2015-12-23T16:06:41.000Z</published>
    <updated>2016-01-03T02:38:47.000Z</updated>
    <content type="html"><![CDATA[<pre><code>与其说<span class="tag">awk</span>是一个强大的文本处理工具，我更加喜欢称之为轻量级的<span class="tag">C</span>语言版脚本，有了它，你就能非常自由，轻松的操作文本文件了。<span class="rule"><span class="attribute">ps</span>:<span class="value">比Excel更加方便哦,一句话：awk可以带你装b带你飞~</span></span>
</code></pre><h2 id="初体验：九九乘法表">初体验：九九乘法表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"></span><br><span class="line">BEGIN&#123;</span><br><span class="line">    <span class="built_in">print</span> <span class="string">"lets begins"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=NR;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%sx%s=%s\t"</span>,NR,i,NR*i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">END&#123;</span><br><span class="line">    <span class="built_in">print</span> <span class="string">"ends"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在先看<code>awk</code>程序之前，咱先来看一下由他实现的一个九九乘法表</p>
<pre><code>yans-MacBook-Pro:Downloads yanyl$ seq <span class="number">9</span> | awk -f chengfa.awk
lets begins
<span class="number">1</span><span class="variable">x1=</span><span class="number">1</span>
<span class="number">2</span><span class="variable">x1=</span><span class="number">2</span>    <span class="number">2</span><span class="variable">x2=</span><span class="number">4</span>
<span class="number">3</span><span class="variable">x1=</span><span class="number">3</span>    <span class="number">3</span><span class="variable">x2=</span><span class="number">6</span>    <span class="number">3</span><span class="variable">x3=</span><span class="number">9</span>
<span class="number">4</span><span class="variable">x1=</span><span class="number">4</span>    <span class="number">4</span><span class="variable">x2=</span><span class="number">8</span>    <span class="number">4</span><span class="variable">x3=</span><span class="number">12</span>    <span class="number">4</span><span class="variable">x4=</span><span class="number">16</span>
<span class="number">5</span><span class="variable">x1=</span><span class="number">5</span>    <span class="number">5</span><span class="variable">x2=</span><span class="number">10</span>    <span class="number">5</span><span class="variable">x3=</span><span class="number">15</span>    <span class="number">5</span><span class="variable">x4=</span><span class="number">20</span>    <span class="number">5</span><span class="variable">x5=</span><span class="number">25</span>
<span class="number">6</span><span class="variable">x1=</span><span class="number">6</span>    <span class="number">6</span><span class="variable">x2=</span><span class="number">12</span>    <span class="number">6</span><span class="variable">x3=</span><span class="number">18</span>    <span class="number">6</span><span class="variable">x4=</span><span class="number">24</span>    <span class="number">6</span><span class="variable">x5=</span><span class="number">30</span>    <span class="number">6</span><span class="variable">x6=</span><span class="number">36</span>
<span class="number">7</span><span class="variable">x1=</span><span class="number">7</span>    <span class="number">7</span><span class="variable">x2=</span><span class="number">14</span>    <span class="number">7</span><span class="variable">x3=</span><span class="number">21</span>    <span class="number">7</span><span class="variable">x4=</span><span class="number">28</span>    <span class="number">7</span><span class="variable">x5=</span><span class="number">35</span>    <span class="number">7</span><span class="variable">x6=</span><span class="number">42</span>    <span class="number">7</span><span class="variable">x7=</span><span class="number">49</span>
<span class="number">8</span><span class="variable">x1=</span><span class="number">8</span>    <span class="number">8</span><span class="variable">x2=</span><span class="number">16</span>    <span class="number">8</span><span class="variable">x3=</span><span class="number">24</span>    <span class="number">8</span><span class="variable">x4=</span><span class="number">32</span>    <span class="number">8</span><span class="variable">x5=</span><span class="number">40</span>    <span class="number">8</span><span class="variable">x6=</span><span class="number">48</span>    <span class="number">8</span><span class="variable">x7=</span><span class="number">56</span>    <span class="number">8</span><span class="variable">x8=</span><span class="number">64</span>
<span class="number">9</span><span class="variable">x1=</span><span class="number">9</span>    <span class="number">9</span><span class="variable">x2=</span><span class="number">18</span>    <span class="number">9</span><span class="variable">x3=</span><span class="number">27</span>    <span class="number">9</span><span class="variable">x4=</span><span class="number">36</span>    <span class="number">9</span><span class="variable">x5=</span><span class="number">45</span>    <span class="number">9</span><span class="variable">x6=</span><span class="number">54</span>    <span class="number">9</span><span class="variable">x7=</span><span class="number">63</span>    <span class="number">9</span><span class="variable">x8=</span><span class="number">72</span>    <span class="number">9</span><span class="variable">x9=</span><span class="number">81</span>
ends
yans-MacBook-Pro:Downloads yanyl$
</code></pre><a id="more"></a>
<p>是不是着实惊艳了一把，程序暂时不解释，不错，为了更好更加方便得处理<code>Linux</code>下的文本，文本就记录学习<code>awk</code>神器的基本用法^_^</p>
<h2 id="awk基础结构">awk基础结构</h2><p><code>awk</code>基础结构如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123;commands&#125; &#123;commands&#125; END&#123;commands&#125;'</span> filename</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这个命令敲下去之后，<code>awk</code>回去按行读取<code>filename</code>的文本进行操作，里面的程序就是你对应的文本处理逻辑，还有这里的文件输入也可以改为标准的<code>stdin</code>的形式哦~</p>
</blockquote>
<p>很清晰，<code>awk</code>可以分为3块:</p>
<ol>
<li><code>BEGIN</code>:可以理解为程序的初始化，可以自定一些变量，或者定义文件的分隔符等</li>
<li>{}模式块：这里会从文件或者输入里面按行读取，在这里可以使用<code>内建变量</code>或者列的值<code>$i</code> 或者自定义变量等，然后使用控制结果或者内置函数来进行相应的文本处理逻辑</li>
<li><code>END</code>:程序执行结束块，可以做一些<code>Summary</code>类型或者其他的输出</li>
</ol>
<blockquote>
<p>其实模式快可以省略，默认是执行<code>{print}</code> 打印行内容，其实其他两块也可以省略-_-</p>
</blockquote>
<p>所以总结来说<code>awk</code>的结构其实可以直接看做一个循环体<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGINE <span class="comment">#进行初始化</span></span><br><span class="line"><span class="keyword">while</span></span><br><span class="line">	&#123;commands&#125; <span class="comment">#内部循环的处理逻辑</span></span><br><span class="line">END <span class="comment">#结尾</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是：</p>
<ol>
<li><code>awk</code>语法的是包含在引号或者双引号里面的</li>
<li>程序复杂的话可以写成<code>awk</code>结尾的文件，然后使用<code>awk -f xxx.awk filename</code>来进行执行</li>
</ol>
<blockquote>
<p>当然了,刚刚都说了<code>awk</code>的优势在于轻量级，下面更多的<code>demo</code>都是行内的语法，并不会专门去写成<code>*.awk</code>文件再来执行^_^</p>
</blockquote>
<h2 id="列的操作">列的操作</h2><h3 id="列的输出">列的输出</h3><p>演示之前先看使用的实验文本文件<a href="/img/awk-study-list/score.log">成绩表score.log</a></p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ <span class="keyword">cat</span> <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    math    95
301    xiaoming    chinese    58
301    xiaoming    english    68
301    xiaohong    math    77
301    xiaohong    chinese    88
301    xiaohong    english    75
302    peter    math    35
302    peter    chinese    45
302    peter    english    95
</code></pre><blockquote>
<p>这里的列于列之间是使用<code>tab</code>隔开的</p>
</blockquote>
<p>先来看一下最简单的输出,假设我只关心年龄和成绩</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ awk '{<span class="keyword">print</span> <span class="label">$2</span>,<span class="label">$4}</span>' <span class="keyword">score</span>.<span class="literal">log</span>
name <span class="keyword">score</span>
xiaoming 95
xiaoming 58
xiaoming 68
xiaohong 77
xiaohong 88
xiaohong 75
peter 35
peter 45
peter 95
</code></pre><blockquote>
<p>这里的取列是使用<code>$i~n</code>  从1开始计数，比如<code>$1</code>是第一列，<code>$4</code>是第4列，其中<code>$0</code>表示整好</p>
</blockquote>
<p>但是发现没对齐，我想将其对个齐：</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ awk '{printf(<span class="string">"%-8s\t%-8s\n"</span>,<span class="label">$2</span>,<span class="label">$4</span>)}' <span class="keyword">score</span>.<span class="literal">log</span>
name        <span class="keyword">score</span>
xiaoming    95
xiaoming    58
xiaoming    68
xiaohong    77
xiaohong    88
xiaohong    75
peter       35
peter       45
peter       95
</code></pre><blockquote>
<p>就是就是使用了标准了<code>C</code>语言风格的<code>printf</code>函数了</p>
</blockquote>
<h3 id="列的过滤">列的过滤</h3><p>我感觉里面比较强大的就是使用<code>awk</code>进行各种过滤操作了，简直了<br>现在我只是想查看小明的成绩</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ awk 'NR==1 || <span class="label">$2</span>==<span class="string">"xiaoming"</span>' <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    math    95
301    xiaoming    chinese    58
301    xiaoming    english    68
</code></pre><blockquote>
<p>这里支持and(<code>&amp;&amp;</code>)和or(<code>||</code>)的操作，同时<code>NR</code>表示当前的行号，<code>NR==1</code>就是为了保留表头</p>
</blockquote>
<p>同时<code>awk</code>还支持<code>C</code>语言系的各种比较符号<code>!=, &gt;, &lt;, &gt;=, &lt;=</code><br>查看不及格的小兔崽子-_-</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ awk 'NR==1 || <span class="label">$4</span>&lt;60' <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    chinese    58
302    peter    math    35
302    peter    chinese    45
</code></pre><p>这里除了支持直接判断的语法，还支持字符串的匹配，使用<code>~</code>符号（这个有点强大），使用语法为<code>~/pattern/</code><br>现在来看一下姓小的同学</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ awk 'NR==1 || <span class="label">$2</span>~/xiao/' <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    math    95
301    xiaoming    chinese    58
301    xiaoming    english    68
301    xiaohong    math    77
301    xiaohong    chinese    88
301    xiaohong    english    75
</code></pre><p>还可以进行模式非匹配，要<code>!~</code>即可</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ awk 'NR==1 || <span class="label">$2</span>!~/xiao/' <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
302    peter    math    35
302    peter    chinese    45
302    peter    english    95
</code></pre><h2 id="变量">变量</h2><h3 id="变量定义使用">变量定义使用</h3><p><code>awk</code>里面变量的几个点:</p>
<ol>
<li>里面的变量命名和<code>C</code>系一样</li>
<li>变量区分大小写</li>
<li>变量一般都是数字和字符串类型</li>
<li>在初始化时，数字类型初始化为0，字符串类型初始化为空，并且在运行期间可变，同时不需要向<code>C</code>一样显示的初始化变量</li>
</ol>
<p>这里来看一个最简单的变量的创建与读写</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk '{name=<span class="string">"zhangsan"</span>} END{<span class="keyword">print</span> name}' <span class="keyword">score</span>.<span class="literal">log</span>
zhangsan
yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk '{age=23} END{<span class="keyword">print</span> age}' <span class="keyword">score</span>.<span class="literal">log</span>
23
</code></pre><blockquote>
<p>这里想想<code>python</code>的变量就可以了哦~</p>
</blockquote>
<p>另外参数不一定要在<code>awk</code>语句中初始化，还可以在输入文件中进行传递，语法格式为<code>awk &#39;statment&#39; var=value file</code>的方式</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk '<span class="label">$4</span>&gt;ms' ms=60 <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    math    95
301    xiaoming    english    68
301    xiaohong    math    77
301    xiaohong    chinese    88
301    xiaohong    english    75
302    peter    english    95
yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk '<span class="label">$4</span>&gt;ms' ms=90 <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    math    95
302    peter    english    95
</code></pre><p>这里示例是用于展示在输入文件的时候传一个<code>ms</code>变量，来控制过滤最小分数，应该还是蛮方便的</p>
<h3 id="类型转换">类型转换</h3><blockquote>
<p>这里的类型转换只有数字类型和字符串类型的转换啦-_-</p>
</blockquote>
<p>记住一个原则<code>+号表示数字类型的操作，会忽略字符串，而空才是正常字符串的拼接</code></p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk 'BEGIN{<span class="keyword">two</span>=2;three=3;<span class="keyword">print</span> <span class="keyword">two</span>+three}'
5
yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk 'BEGIN{<span class="keyword">two</span>=2;three=3;<span class="keyword">print</span> <span class="keyword">two</span> three}'
23
yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk 'BEGIN{<span class="keyword">two</span>=2;three=3;<span class="keyword">print</span> <span class="keyword">two</span>+<span class="string">"s"</span>+three}'
5
yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk 'BEGIN{<span class="keyword">two</span>=2;three=3;<span class="keyword">print</span> <span class="keyword">two</span> <span class="string">"s"</span> three}'
2s3
</code></pre><blockquote>
<p>还有关于详细的转换参考<a href="http://www.gnu.org/software/gawk/manual/gawk.html#Variables" target="_blank" rel="external">这里</a></p>
</blockquote>
<h3 id="内建变量">内建变量</h3><p>下面贴出的都是一些内置变量，在自己创建变量的时候请勿将变量名创建为下面的内置变量名</p>
<table>
<thead>
<tr>
<th style="text-align:left">变量名</th>
<th style="text-align:left">变量描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>$0</code></td>
<td style="text-align:left">表示当前正行的内容</td>
</tr>
<tr>
<td style="text-align:left"><code>$1~$n</code></td>
<td style="text-align:left">表示第几个列的值，这些列是使用<code>FS</code>变量进行分割的</td>
</tr>
<tr>
<td style="text-align:left"><code>FS</code></td>
<td style="text-align:left">列的分割符，默认是空格或者<code>tab</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NF</code></td>
<td style="text-align:left">表示当前文件中列的个数</td>
</tr>
<tr>
<td style="text-align:left"><code>NR</code></td>
<td style="text-align:left">表示当前读取的行数</td>
</tr>
<tr>
<td style="text-align:left"><code>FNR</code></td>
<td style="text-align:left">这个表示当前文件自己标的行号</td>
</tr>
<tr>
<td style="text-align:left"><code>NR</code></td>
<td style="text-align:left">表示当前读取的行数</td>
</tr>
<tr>
<td style="text-align:left"><code>RS</code></td>
<td style="text-align:left">表示输入记录的换行符，默认为换行符<code>\n</code></td>
</tr>
<tr>
<td style="text-align:left"><code>OFS</code></td>
<td style="text-align:left">表示输出记录的分割符，默认是空格</td>
</tr>
<tr>
<td style="text-align:left"><code>ORS</code></td>
<td style="text-align:left">表示输出记录的分割符，默认是换行符</td>
</tr>
<tr>
<td style="text-align:left"><code>FILENAME</code></td>
<td style="text-align:left">当前输出的文件名</td>
</tr>
<tr>
<td style="text-align:left"><code>ARGC</code></td>
<td style="text-align:left">传入参数的个数</td>
</tr>
<tr>
<td style="text-align:left"><code>ARGV</code></td>
<td style="text-align:left">传入参数的数组</td>
</tr>
</tbody>
</table>
<p>上面是列出了一些常用的内置变量，详细的可以看<a href="http://www.gnu.org/software/gawk/manual/gawk.html#Built_002din-Variables" target="_blank" rel="external">这里</a></p>
<blockquote>
<p>个人感觉最常用的就是<code>$i</code>犀利以及<code>FS</code>、<code>NR</code>之类的了^_^</p>
</blockquote>
<h2 id="控制流程">控制流程</h2><blockquote>
<p><code>awk</code>提供了类<code>C</code>系语言的强大的控制流程语法，可以发现绝大部门语法和<code>C</code>是一样的</p>
</blockquote>
<h3 id="if判断">if判断</h3><p><code>if</code>语法是你超级熟悉的<code>if (condition) then-body [else else-body]</code><br>现在需要给每个人每门成绩打一个标签，85分以上优秀，60及以上良好，否则。。。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (NR==<span class="number">1</span>) <span class="comment">#这里针对第一行  额外操作   追加一个标签列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span> <span class="variable">$0</span> <span class="string">"\tlabel"</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(<span class="variable">$4</span> &gt;= <span class="number">85</span>)</span><br><span class="line">	        label = <span class="string">"excellent"</span></span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$4</span> &gt;= <span class="number">60</span>)</span><br><span class="line">	        label = <span class="string">"well"</span></span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	        label = <span class="string">"shit"</span></span><br><span class="line"></span><br><span class="line">	    <span class="built_in">print</span> <span class="variable">$0</span> <span class="string">"\t"</span> label</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将这个<code>awk</code>文件进行执行之后可以看到</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk -f <span class="keyword">test</span>.awk <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>    <span class="keyword">label</span>
301    xiaoming    math    95    excellent
301    xiaoming    chinese    58    shit
301    xiaoming    english    68    well
301    xiaohong    math    77    well
301    xiaohong    chinese    88    excellent
301    xiaohong    english    75    well
302    peter    math    35    shit
302    peter    chinese    45    shit
302    peter    english    95    excellent
</code></pre><p>这里注意，你如果想把控制语句写到一行，就必须得使用<code>{}</code>显示标注执行主体，<code>;</code>来标注结束，就是像下面这么任性我也是没办法</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk '{<span class="keyword">if</span> (NR==1){<span class="keyword">print</span> <span class="label">$0</span> <span class="string">"\tlabel"</span>;}<span class="keyword">else</span>{<span class="keyword">if</span>(<span class="label">$4</span> &gt;= 85){<span class="keyword">label</span> = <span class="string">"excellent"</span>;}<span class="keyword">else</span> <span class="keyword">if</span> (<span class="label">$4</span> &gt;= 60){<span class="keyword">label</span> = <span class="string">"well"</span>;}<span class="keyword">else</span>{<span class="keyword">label</span> = <span class="string">"shit"</span>;}<span class="keyword">print</span> <span class="label">$0</span> <span class="string">"\t"</span> <span class="keyword">label</span>;}}' <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>    <span class="keyword">label</span>
301    xiaoming    math    95    excellent
301    xiaoming    chinese    58    shit
301    xiaoming    english    68    well
301    xiaohong    math    77    well
301    xiaohong    chinese    88    excellent
301    xiaohong    english    75    well
302    peter    math    35    shit
302    peter    chinese    45    shit
302    peter    english    95    excellent
</code></pre><h3 id="while循环">while循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)</span><br><span class="line">  body</span><br></pre></td></tr></table></figure>
<p><code>while</code>还是很方便使用</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk 'BEGIN{i=1;<span class="keyword">sum</span>=0;<span class="keyword">while</span>(i&lt;10) {<span class="keyword">sum</span>+=i;i++;} <span class="keyword">print</span> <span class="keyword">sum</span> }'
45
</code></pre><p>从1累加到9的实现</p>
<h3 id="do-while循环">do-while循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">  body</span><br><span class="line"><span class="keyword">while</span> (condition)</span><br></pre></td></tr></table></figure>
<h3 id="for循环">for循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; increment)</span><br><span class="line">  body</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个方法在最上面的初体验里面就有了</p>
</blockquote>
<h3 id="switch">switch</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switch (expression) &#123;</span><br><span class="line"><span class="keyword">case</span> value or regular expression:</span><br><span class="line">    <span class="keyword">case</span>-body</span><br><span class="line">default:</span><br><span class="line">    default-body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个在<code>gnu awk</code>的手册中说明支持，但是自己捣鼓了半天也没结果，下次深入了再贴出来</p>
</blockquote>
<h3 id="next控制">next控制</h3><p>既然有了上面那么强大的<code>C</code>系控制，肯定也少不了<code>break</code>和<code>continue</code>，在<code>awk</code>中都是支持的，而且用法都一样，所以这里不再一一描述，有意思的是来说一下这个<code>next</code>关键字</p>
<pre><code><span class="keyword">next</span>:在文章最上面描述的awk的结构的中间部分是一个天然的循环，<span class="keyword">next</span>关键词就是让你在这个天然的循环中跳转到下一行处理,就像<span class="keyword">continue</span>
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$4</span>&lt;<span class="number">60</span>)</span><br><span class="line">        next <span class="comment">#小于60的直接过掉  不做处理</span></span><br><span class="line">    <span class="built_in">print</span> <span class="variable">$0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序是用来过掉不及格的同学的</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk -f <span class="keyword">test</span>.awk <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    math    95
301    xiaoming    english    68
301    xiaohong    math    77
301    xiaohong    chinese    88
301    xiaohong    english    75
302    peter    english    95
</code></pre><h3 id="nextfile控制">nextfile控制</h3><p>另外一个与<code>next</code>类似的就是<code>nextfile</code> ，表示跳到下一个输入文件(因为<code>awk</code>一下子可以有多个输入文件呀)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$0</span>~/score/)</span><br><span class="line">        next <span class="comment">#含有score字符串的直接过掉</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$4</span>&lt;n)</span><br><span class="line">        nextfile</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> n <span class="string">"\t"</span> <span class="variable">$0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到结果</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk -f <span class="keyword">test</span>.awk <span class="keyword">n</span>=58 <span class="keyword">score</span>.<span class="keyword">log</span> <span class="keyword">n</span>=88 <span class="keyword">score</span>.<span class="literal">log</span>
58    301    xiaoming    math    95
58    301    xiaoming    chinese    58
58    301    xiaoming    english    68
58    301    xiaohong    math    77
58    301    xiaohong    chinese    88
58    301    xiaohong    english    75
88    301    xiaoming    math    95
</code></pre><p>都是符合预期的<br>同时还有一个<code>exit</code>关键词不再介绍，结束程序用的</p>
<h2 id="数组">数组</h2><h3 id="创建与使用">创建与使用</h3><p><code>awk</code>为了更好更加强大的处理出具，他也提供了数组这个功能，但是略有特点:</p>
<ol>
<li>数组的索引不一定是要连续数据，而且还可以字符串与汉字混合（据官网doc解释，<code>awk</code>将数字型的索引都转成了字符串）</li>
<li>使用数组签不需要显示声明他的长度</li>
<li>很多产生数组的函数  产生完了之后都是从1开始的（注意这个，不然得坑爹了）</li>
</ol>
<p>来看一个比较全面的使用数组的列子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line">BEGIN&#123;</span><br><span class="line">	<span class="comment">#可以直接给数组赋值了，不需要定义</span></span><br><span class="line">    arr[<span class="string">"color"</span>]=<span class="string">"red"</span>;</span><br><span class="line">    arr[<span class="string">"age"</span>]=<span class="number">23</span></span><br><span class="line">    arr[<span class="number">99</span>]=<span class="number">999</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">#使用for each的方式取值，当然也可以for的三段式取值</span></span><br><span class="line">    <span class="keyword">for</span>(x <span class="keyword">in</span> arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span> x <span class="string">":"</span> arr[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到输出结果中将数组的索引和值都打印出来了</p>
<pre><code>yans-MacBook-Pro-<span class="number">2</span>:awk_test yanyl$ seq <span class="number">1</span> | awk -f test.awk
<span class="label">age:</span><span class="number">23</span>
<span class="label">color:</span>red
<span class="number">99</span>:<span class="number">999</span>
</code></pre><p>但是需要注意的是你不能这么写<br><code>if(arr[&quot;name&quot;] == &quot;xiaoming&quot;)</code>，也许<code>awk</code>不会报错，但是也不会有正确结果出来，所以你可以些么写 <code>if(&quot;name&quot; in arr)</code>先进行一个是否有索引的判断，这样比较安全<br>其他的技巧自己看详情的doc拉</p>
<blockquote>
<p>我感觉<code>awk</code>的里面的数组俨然是一个<code>LinkedHashMap</code>-_-</p>
</blockquote>
<h3 id="删除">删除</h3><p>删除的语法也很简单<code>delete array[index-expression]</code>，<br>比如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line">BEGIN&#123;</span><br><span class="line">    arr[<span class="string">"color"</span>]=<span class="string">"red"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"color"</span> <span class="keyword">in</span> arr)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">"yes"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">"no"</span></span><br><span class="line"></span><br><span class="line">   delete arr[<span class="string">"color"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"color"</span> <span class="keyword">in</span> arr)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">"yes"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">"no"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进行一个打印之后可以发现</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ seq 1 | awk -f <span class="keyword">test</span>.awk
yes
<span class="keyword">no</span>
</code></pre><p>在第二次判断数组是否存在该元素的时 可以发现已经删除掉了<br>如果想删除全部元素就可以直接使用这个语法：<code>delete array</code>,但是要注意的是 删除了之后之后这个变量还是数组类型，此时无法被用于赋值字符串或者数字:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line">BEGIN&#123;</span><br><span class="line">    arr[<span class="string">"color"</span>]=<span class="string">"red"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    delete arr</span><br><span class="line">    arr=<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式在进行第二次赋值的时候会发错</p>
<pre><code>yans-MacBook-Pro-2:awk_test yanyl$ seq 1 | awk -f test.awk
awk: can't assign to arr; it's an<span class="instruction"> array </span>name.
 input record number 1, file
 source line number 9
</code></pre><blockquote>
<p>关于其余的<a href="http://www.gnu.org/software/gawk/manual/gawk.html#Multiscanning" target="_blank" rel="external">多维数组</a>还是去看文档把~</p>
</blockquote>
<h2 id="内置函数">内置函数</h2><p><code>awk</code>的另一个强大之处就是提供了很丰富的内置函数，写起来非常方便!</p>
<h3 id="算术函数">算术函数</h3><table>
<thead>
<tr>
<th style="text-align:left">函数名称</th>
<th style="text-align:left">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>atan2(y,x)</code></td>
<td style="text-align:left">反正切函数</td>
</tr>
<tr>
<td style="text-align:left"><code>cos(x)</code></td>
<td style="text-align:left">余弦函数</td>
</tr>
<tr>
<td style="text-align:left"><code>sin(x)</code></td>
<td style="text-align:left">正弦函数</td>
</tr>
<tr>
<td style="text-align:left"><code>exp(x)</code></td>
<td style="text-align:left"><code>e</code>的幂次方,任意数的幂次方可以使用<code>x**y</code>来算</td>
</tr>
<tr>
<td style="text-align:left"><code>log(x)</code></td>
<td style="text-align:left">自然数的对数</td>
</tr>
<tr>
<td style="text-align:left"><code>sqrt(x)</code></td>
<td style="text-align:left">平方根</td>
</tr>
<tr>
<td style="text-align:left"><code>int(x)</code></td>
<td style="text-align:left">整数的值</td>
</tr>
<tr>
<td style="text-align:left"><code>rand()</code></td>
<td style="text-align:left">任意随机数，大于0小于1，注意得加<code>srand()</code>方法设置种子</td>
</tr>
</tbody>
</table>
<p>这里仅演示<code>rand()</code>随机数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line">BEGIN&#123;</span><br><span class="line">    srand();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print</span> rand();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行得到</p>
<pre><code>yans-MacBook-Pro-<span class="number">2</span>:awk_<span class="built_in">test</span> yanyl$ seq <span class="number">9</span> | awk <span class="operator">-f</span> test.awk
<span class="number">0.107174</span>
<span class="number">0.117314</span>
<span class="number">0.89198</span>
<span class="number">0.700518</span>
<span class="number">0.269547</span>
<span class="number">0.503197</span>
<span class="number">0.402781</span>
<span class="number">0.958053</span>
<span class="number">0.523041</span>
</code></pre><blockquote>
<p>注意，如果不加<code>srand()</code>方法，则多次执行还是原来的随机数…</p>
</blockquote>
<h3 id="字符串函数">字符串函数</h3><table>
<thead>
<tr>
<th style="text-align:left">函数名称</th>
<th style="text-align:left">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>asort(source [, dest [, how ] ])</code></td>
<td style="text-align:left">对数组的值进行排序</td>
</tr>
<tr>
<td style="text-align:left"><code>asorti(source [, dest [, how ] ])</code></td>
<td style="text-align:left">对数组的索引进行排序</td>
</tr>
<tr>
<td style="text-align:left"><code>gensub(regexp, replacement, how [, target])</code></td>
<td style="text-align:left">正则替换，<code>how</code>为替换的个数，为<code>g or G</code>的时候替换全部，还可以将匹配到的部分使用<code>/N</code>的格式来取</td>
</tr>
<tr>
<td style="text-align:left"><code>gsub(regexp, replacement [, target])</code></td>
<td style="text-align:left">正则替换</td>
</tr>
<tr>
<td style="text-align:left"><code>index(in, find)</code></td>
<td style="text-align:left">查找指定字符串的索引位置，不存在时返回0, 还是注意它不支持正则</td>
</tr>
<tr>
<td style="text-align:left"><code>length([string])</code></td>
<td style="text-align:left">查找字符串的长度，如果查找变量未指定的时候，返回0（当做查一个数组）</td>
</tr>
<tr>
<td style="text-align:left"><code>match(string, regexp [, array])</code></td>
<td style="text-align:left">正则查找字符串 返回找到的位置，如果传了<code>array</code>参数，查找的字符串将会丢入这个数组</td>
</tr>
<tr>
<td style="text-align:left"><code>split(string, array [, fieldsep [, seps ] ])</code></td>
<td style="text-align:left">将字符串分割到数组</td>
</tr>
<tr>
<td style="text-align:left"><code>strtonum(str)</code></td>
<td style="text-align:left">将字符串转为数字</td>
</tr>
<tr>
<td style="text-align:left"><code>sub(regexp, replacement [, target])</code></td>
<td style="text-align:left">替换指定字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>substr(string, start [, length ])</code></td>
<td style="text-align:left">截取指定字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>sub(regexp, replacement [, target])</code></td>
<td style="text-align:left">替换指定字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>tolower(string)</code></td>
<td style="text-align:left">转小写</td>
</tr>
<tr>
<td style="text-align:left"><code>toupper(string)</code></td>
<td style="text-align:left">转大写</td>
</tr>
</tbody>
</table>
<p>演示几个常用的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line">BEGIN&#123;</span><br><span class="line">    str=<span class="string">"abc-def"</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> substr(str,<span class="number">3</span>,<span class="number">2</span>) <span class="comment">#截取字符串</span></span><br><span class="line">    sub(/<span class="built_in">cd</span>/,<span class="string">"CD"</span>,str) <span class="comment">#转大写</span></span><br><span class="line">    <span class="built_in">print</span> str</span><br><span class="line">    split(str,arr,<span class="string">"-"</span>) <span class="comment">#分割字符串</span></span><br><span class="line">    <span class="keyword">for</span>(i <span class="keyword">in</span> arr)</span><br><span class="line">        <span class="built_in">print</span> arr[i]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> index(str,<span class="string">"c-d"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到结果</p>
<pre><code>yans-<span class="constant">MacBook-Pro-</span><span class="number">2</span><span class="symbol">:awk_test</span> yanyl<span class="variable">$ </span>seq <span class="number">1</span> | awk -f test.awk
c-
abc-<span class="function"><span class="keyword">def</span>
<span class="title">def</span></span>
abc
<span class="number">3</span>
</code></pre><h3 id="自定义函数">自定义函数</h3><p><code>awk</code>很强大的一点就是支持自定义函数<br>自定义函数的语法如下</p>
<pre><code><span class="function"><span class="keyword">function</span></span> <span class="keyword">name</span>([<span class="type">parameter</span>-list])
{
     body-of-<span class="function"><span class="keyword">function</span></span>
}
</code></pre><p>还是非常简单的熟悉啊</p>
<blockquote>
<p>由于<code>awk</code>是读取整个代码之后再运行的，所以自定义函数也不需要放在调用者之前，可以放任何地方,如有也返回值也直接使用<code>return</code>即可</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BEGIN&#123;</span><br><span class="line">    sayhello(<span class="string">"tom"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> sayhello(name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello,%s\n"</span>,name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用可以有</p>
<pre><code>yans-MacBook-Pro-<span class="number">2</span>:awk_<span class="built_in">test</span> yanyl$ seq <span class="number">1</span> | awk <span class="operator">-f</span> test.awk
hello,tom
</code></pre><blockquote>
<p>函数里面想使用局部变量就必须将其放到传参中</p>
</blockquote>
<h2 id="总结">总结</h2><ol>
<li><code>awk</code>里面只有<code>数值</code>、<code>字符串</code>、<code>数组</code>三种变量</li>
<li><code>awk</code>的数组其实索引从<code>1</code>开始!!!</li>
<li><code>awk</code>的大部分语法和C一样，但是不需要预定义变量</li>
<li><code>awk</code>非常轻量级，处理结构化的文本文件非常的方便</li>
<li><code>awk</code>还有其他很多功能，参见官方文档，因为主要是用其轻量，所以这里不再一一介绍</li>
</ol>
<h2 id="参考">参考</h2><ol>
<li><a href="http://www.ibm.com/developerworks/cn/education/aix/au-gawk/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/education/aix/au-gawk/</a></li>
<li><a href="http://www.gnu.org/software/gawk/manual/gawk.html#Getopt-Function" target="_blank" rel="external">awk guid</a></li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>与其说<span class="tag">awk</span>是一个强大的文本处理工具，我更加喜欢称之为轻量级的<span class="tag">C</span>语言版脚本，有了它，你就能非常自由，轻松的操作文本文件了。<span class="rule"><span class="attribute">ps</span>:<span class="value">比Excel更加方便哦,一句话：awk可以带你装b带你飞~</span></span>
</code></pre><h2 id="初体验：九九乘法表">初体验：九九乘法表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"></span><br><span class="line">BEGIN&#123;</span><br><span class="line">    <span class="built_in">print</span> <span class="string">"lets begins"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=NR;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%sx%s=%s\t"</span>,NR,i,NR*i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">END&#123;</span><br><span class="line">    <span class="built_in">print</span> <span class="string">"ends"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在先看<code>awk</code>程序之前，咱先来看一下由他实现的一个九九乘法表</p>
<pre><code>yans-MacBook-Pro:Downloads yanyl$ seq <span class="number">9</span> | awk -f chengfa.awk
lets begins
<span class="number">1</span><span class="variable">x1=</span><span class="number">1</span>
<span class="number">2</span><span class="variable">x1=</span><span class="number">2</span>    <span class="number">2</span><span class="variable">x2=</span><span class="number">4</span>
<span class="number">3</span><span class="variable">x1=</span><span class="number">3</span>    <span class="number">3</span><span class="variable">x2=</span><span class="number">6</span>    <span class="number">3</span><span class="variable">x3=</span><span class="number">9</span>
<span class="number">4</span><span class="variable">x1=</span><span class="number">4</span>    <span class="number">4</span><span class="variable">x2=</span><span class="number">8</span>    <span class="number">4</span><span class="variable">x3=</span><span class="number">12</span>    <span class="number">4</span><span class="variable">x4=</span><span class="number">16</span>
<span class="number">5</span><span class="variable">x1=</span><span class="number">5</span>    <span class="number">5</span><span class="variable">x2=</span><span class="number">10</span>    <span class="number">5</span><span class="variable">x3=</span><span class="number">15</span>    <span class="number">5</span><span class="variable">x4=</span><span class="number">20</span>    <span class="number">5</span><span class="variable">x5=</span><span class="number">25</span>
<span class="number">6</span><span class="variable">x1=</span><span class="number">6</span>    <span class="number">6</span><span class="variable">x2=</span><span class="number">12</span>    <span class="number">6</span><span class="variable">x3=</span><span class="number">18</span>    <span class="number">6</span><span class="variable">x4=</span><span class="number">24</span>    <span class="number">6</span><span class="variable">x5=</span><span class="number">30</span>    <span class="number">6</span><span class="variable">x6=</span><span class="number">36</span>
<span class="number">7</span><span class="variable">x1=</span><span class="number">7</span>    <span class="number">7</span><span class="variable">x2=</span><span class="number">14</span>    <span class="number">7</span><span class="variable">x3=</span><span class="number">21</span>    <span class="number">7</span><span class="variable">x4=</span><span class="number">28</span>    <span class="number">7</span><span class="variable">x5=</span><span class="number">35</span>    <span class="number">7</span><span class="variable">x6=</span><span class="number">42</span>    <span class="number">7</span><span class="variable">x7=</span><span class="number">49</span>
<span class="number">8</span><span class="variable">x1=</span><span class="number">8</span>    <span class="number">8</span><span class="variable">x2=</span><span class="number">16</span>    <span class="number">8</span><span class="variable">x3=</span><span class="number">24</span>    <span class="number">8</span><span class="variable">x4=</span><span class="number">32</span>    <span class="number">8</span><span class="variable">x5=</span><span class="number">40</span>    <span class="number">8</span><span class="variable">x6=</span><span class="number">48</span>    <span class="number">8</span><span class="variable">x7=</span><span class="number">56</span>    <span class="number">8</span><span class="variable">x8=</span><span class="number">64</span>
<span class="number">9</span><span class="variable">x1=</span><span class="number">9</span>    <span class="number">9</span><span class="variable">x2=</span><span class="number">18</span>    <span class="number">9</span><span class="variable">x3=</span><span class="number">27</span>    <span class="number">9</span><span class="variable">x4=</span><span class="number">36</span>    <span class="number">9</span><span class="variable">x5=</span><span class="number">45</span>    <span class="number">9</span><span class="variable">x6=</span><span class="number">54</span>    <span class="number">9</span><span class="variable">x7=</span><span class="number">63</span>    <span class="number">9</span><span class="variable">x8=</span><span class="number">72</span>    <span class="number">9</span><span class="variable">x9=</span><span class="number">81</span>
ends
yans-MacBook-Pro:Downloads yanyl$
</code></pre>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yyl8781697.github.io/tags/Linux/"/>
    
      <category term="Vim" scheme="http://yyl8781697.github.io/tags/Vim/"/>
    
      <category term="Linux" scheme="http://yyl8781697.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop Streaming 实践以及Debug]]></title>
    <link href="http://yyl8781697.github.io/2015/11/08/Hadoop/Hadoop-Streaming-Primary-Learning-And-Debug/"/>
    <id>http://yyl8781697.github.io/2015/11/08/Hadoop/Hadoop-Streaming-Primary-Learning-And-Debug/</id>
    <published>2015-11-08T01:23:38.000Z</published>
    <updated>2015-11-08T12:23:38.000Z</updated>
    <content type="html"><![CDATA[<pre><code>Hadoop Streaming是一个便于变成<span class="keyword">Map</span> <span class="keyword">Reduce</span>程序的工具包，这个工具包可以支持各种可执行/脚本语言来创建Mapper和Reducer，利用Hadoop的优势进行大数据的处理，这些语言仅仅只需要支持*unix的表示输出输入即可(python,c,c++,perl,akw etc.)
</code></pre><h2 id="Streaming实践">Streaming实践</h2><p>先直接来看一个由<code>python</code>写的<code>Streaming</code>程序，还有那个经典的word count,我们的数据集是一篇<a href="/img/Hadoop-Streaming-Primary-Learning-And-Debug/words.txt">英语作文</a>,<br>看来看他的<code>mapper</code>文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding=utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys,re</span><br><span class="line"></span><br><span class="line">re_english = re.compile(<span class="string">u'[^a-zA-Z0-9\-]+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin: <span class="comment">#这里你可以看做是map类中的line输入</span></span><br><span class="line">    words = re_english.sub(<span class="string">' '</span>,line.strip()) <span class="comment">#这里只提取英文数字</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words.split():</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'%s\t%s'</span> % (word, <span class="number">1</span>)  <span class="comment">#这儿就是标准的输出，用tab隔开  默认第一个值为key</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>其实看上面的<code>mapper</code>文件还是挺带感的，和标准的<code>mapper</code>类很类似，这里就不解释了，相信用<code>java</code>写过标准<code>Map-Reduce</code>都应该很熟悉<br><br>现在再来看<code>reducer</code>文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">!/usr/bin/env python</span><br><span class="line"><span class="comment">#-*- coding=utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">lastk = <span class="keyword">None</span> <span class="comment">#这里标志最后一个k  用于控制同一个key 到一个组中</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">        w,c = line.split(<span class="string">'\t'</span>)</span><br><span class="line">        c = int(c) <span class="comment">#不转成int会比较麻烦  这是是计数</span></span><br><span class="line">        <span class="keyword">if</span> lastk == <span class="keyword">None</span>: <span class="comment">#这里是判断是否过来的是第一个key</span></span><br><span class="line">            lastk=w</span><br><span class="line">            count += c</span><br><span class="line">        <span class="keyword">elif</span> lastk == w:</span><br><span class="line">            count += c</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"%s\t%s"</span>%(lastk,count)</span><br><span class="line">            lastk=w</span><br><span class="line">            count = c <span class="comment">#这里重置计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> lastk <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"%s\t%s"</span>%(lastk,count)</span><br></pre></td></tr></table></figure></p>
<p>陌生感来了把~其实这里是这样的：</p>
<pre><code>都说了是Streaming，他其实是流式进来的，在进来之前还是和标准的mr一样按<span class="built_in">key</span>进行partation划分到各个桶中，然后每个桶会有若干个<span class="built_in">key</span>，这里按<span class="built_in">key</span>分组一次会将记录一条一条的使用*unix的标准输入 读入道sys.stdin中，那么问题了来了，原来mr中的 迭代器的值如何构造？这里主要使用lastk来的变量，每次当输入的<span class="built_in">key</span>与lastk相等的时候，将当前的值加入到字典或者数组中（因为这个demo是wordcount，所以用累加计数来代替了，第<span class="number">16</span>行），直到<span class="built_in">key</span>与lastk不等时（第<span class="number">18</span>行），此时的数组或者字典就是原来 值的迭代器里面的东西，和正常的mr一样操作，该输出的输出，完了之后同时得更新lastk以迎接下一组<span class="built_in">key</span>的到来，同时清空数组或者字典，周而复始，直至全部输入之后，判断我的lastk是否存在值，有的话这个lastk作为最后一组<span class="built_in">key</span>进行输出（第<span class="number">23</span>行），这样的方式就可以构造出原来的(<span class="built_in">key</span>,iter[<span class="built_in">value</span>])模式了
</code></pre><blockquote>
<p>上述的构造看上去些代码可能更加麻烦一点，但是其实这样的方式是应该灵活了</p>
</blockquote>
<p>现在<code>mapper</code>和<code>reducer</code>两个文件写完了，该如何执行呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar <span class="variable">$HADOOP_HOME</span>/share/hadoop/tools/lib/hadoop-streaming-<span class="number">2.7</span>.<span class="number">0</span>.jar \</span><br><span class="line">-input /yyl/data/words.txt \</span><br><span class="line">-output /yyl/<span class="built_in">test</span>/ouput/streaming \</span><br><span class="line">-mapper <span class="variable">$HADOOP_HOME</span>/runjar/pyscript/word_count_mapper.py \</span><br><span class="line">-reducer <span class="variable">$HADOOP_HOME</span>/runjar/pyscript/word_count_reducer.py \</span><br><span class="line">-file <span class="variable">$HADOOP_HOME</span>/runjar/pyscript/*.py \</span><br></pre></td></tr></table></figure>
<p>其实提交的方式很类似原生的<code>jar</code>包提交，只是这里的<code>jar</code>是使用了<code>Hadoop</code>自带的<code>streaming</code>包,敲火车键进行执行</p>
<pre><code><span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">47</span> WARN streaming.<span class="string">StreamJob:</span> -file option is deprecated, please use generic option -files instead.
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">47</span> WARN util.<span class="string">NativeCodeLoader:</span> Unable to load native-hadoop library <span class="keyword">for</span> your platform... using builtin-java classes where applicable
<span class="string">packageJobJar:</span> [<span class="regexp">/root/</span>program<span class="regexp">/hadoop-2.7.0/</span>runjar<span class="regexp">/pyscript/</span>word_count_mapper.py, <span class="regexp">/root/</span>program<span class="regexp">/hadoop-2.7.0/</span>runjar<span class="regexp">/pyscript/</span>word_count_reducer.py, <span class="regexp">/tmp/</span>hadoop-unjar1825196483906999229<span class="regexp">/] [] /</span>tmp/streamjob6480432411236657839.jar tmpDir=<span class="literal">null</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">51</span> INFO client.<span class="string">RMProxy:</span> Connecting to ResourceManager at master/<span class="number">192.168</span>.56.2:<span class="number">8032</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">51</span> INFO client.<span class="string">RMProxy:</span> Connecting to ResourceManager at master/<span class="number">192.168</span>.56.2:<span class="number">8032</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">53</span> INFO mapred.<span class="string">FileInputFormat:</span> Total input paths to <span class="string">process :</span> <span class="number">1</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">54</span> INFO mapreduce.<span class="string">JobSubmitter:</span> number of <span class="string">splits:</span><span class="number">2</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">54</span> INFO mapreduce.<span class="string">JobSubmitter:</span> Submitting tokens <span class="keyword">for</span> <span class="string">job:</span> job_1446946409340_0001
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">55</span> INFO impl.<span class="string">YarnClientImpl:</span> Submitted application application_1446946409340_0001
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">55</span> INFO mapreduce.<span class="string">Job:</span> The url to track the <span class="string">job:</span> <span class="string">http:</span><span class="comment">//master:8088/proxy/application_1446946409340_0001/</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">55</span> INFO mapreduce.<span class="string">Job:</span> Running <span class="string">job:</span> job_1446946409340_0001
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">12</span> INFO mapreduce.<span class="string">Job:</span> Job job_1446946409340_0001 running <span class="keyword">in</span> uber <span class="string">mode :</span> <span class="literal">false</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">12</span> INFO mapreduce.<span class="string">Job:</span>  map <span class="number">0</span>% reduce <span class="number">0</span>%
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">33</span> INFO mapreduce.<span class="string">Job:</span>  map <span class="number">100</span>% reduce <span class="number">0</span>%
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">46</span> INFO mapreduce.<span class="string">Job:</span>  map <span class="number">100</span>% reduce <span class="number">100</span>%
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">47</span> INFO mapreduce.<span class="string">Job:</span> Job job_1446946409340_0001 completed successfully
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">47</span> INFO mapreduce.<span class="string">Job:</span> <span class="string">Counters:</span> <span class="number">49</span>
    File System Counters
----此处和mr一样  省略<span class="number">1</span>w字
    File Input Format Counters
        Bytes Read=<span class="number">2223</span>
    File Output Format Counters
        Bytes Written=<span class="number">1208</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">47</span> INFO streaming.<span class="string">StreamJob:</span> Output <span class="string">directory:</span> <span class="regexp">/yyl/</span>test<span class="regexp">/ouput/</span>streaming
</code></pre><p>然后来查看熟悉的word count结果</p>
<pre><code>[root<span class="annotation">@master</span> pyscript]# hadoop fs -get <span class="regexp">/yyl/</span>test<span class="regexp">/ouput/</span>streaming
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">16</span> WARN util.<span class="string">NativeCodeLoader:</span> Unable to load native-hadoop library <span class="keyword">for</span> your platform... using builtin-java classes where applicable
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">19</span> WARN hdfs.<span class="string">DFSClient:</span> DFSInputStream has been closed already
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">19</span> WARN hdfs.<span class="string">DFSClient:</span> DFSInputStream has been closed already
[root<span class="annotation">@master</span> pyscript]# cd streaming/
[root<span class="annotation">@master</span> streaming]# sort -nr -k <span class="number">2</span> part-<span class="number">00000</span> | head -n <span class="number">10</span>
and    <span class="number">11</span>
to    <span class="number">10</span>
people    <span class="number">10</span>
Micro-blog    <span class="number">8</span>
their    <span class="number">6</span>
a    <span class="number">5</span>
other    <span class="number">4</span>
of    <span class="number">4</span>
more    <span class="number">4</span>
has    <span class="number">4</span>
</code></pre><p>取计数最高的10个，看到了熟悉的字样，好了，这样一次<code>streaming</code>写执行完了，是不是甚是方便</p>
<blockquote>
<p>这里有一个提示，可以再通<code>hadoop版本hadoop-streaming-*.jar</code>的位置不一样，你可以使用<a href="http://kubicode.me/2015/07/26/Linux/Find-Command/" target="_blank" rel="external">find</a>命令进行查找具体的位置</p>
</blockquote>
<p>到了这里已经可以基本执行<code>streaming</code>程序了，但是从上面的跑的命令里可以看到有好多配置的样子，还有另外可以发现，在写的<code>mapper</code>和<code>reducer</code>中只写了数据的处理逻辑，其他的一些配置参数根本无法写入，那么这些东西都是得在执行的命令里面进行配置的，他可以有的配置参数大致有如下几个</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数名称</th>
<th style="text-align:left">可选/必选</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-input</code></td>
<td style="text-align:left"><strong>必选</strong></td>
<td style="text-align:left">输入文件/目录的位置</td>
</tr>
<tr>
<td style="text-align:left"><code>-output</code></td>
<td style="text-align:left"><strong>必选</strong></td>
<td style="text-align:left">输出目录</td>
</tr>
<tr>
<td style="text-align:left"><code>-mapper</code></td>
<td style="text-align:left"><strong>必选</strong></td>
<td style="text-align:left"><code>mapper</code>的执行文件或者<code>JavaClassName</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-reducer</code></td>
<td style="text-align:left"><strong>必选</strong></td>
<td style="text-align:left"><code>reducer</code>的执行或者<code>JavaClassName</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-file</code></td>
<td style="text-align:left"><strong>必选</strong></td>
<td style="text-align:left">执行的mapper或者reducer文件以及其依赖文件，一定要写，多个可以写多行，他会共享到各个节点上，也可以是jar包</td>
</tr>
<tr>
<td style="text-align:left"><code>-inputformat</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">填<code>JavaClassName</code>，为自定义的输入格式，默认是<code>TextInputFormat</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-outputformat</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">填<code>JavaClassName</code>，为自定义的输出格式，默认是<code>TextOutputformat</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-partitioner</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">填<code>JavaClassName</code>，为自定义的分区函数</td>
</tr>
<tr>
<td style="text-align:left"><code>-combiner</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left"><code>mapper</code>输出之后的合并类，是<code>JavaClassName</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-cmdenv</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left"><code>name=value</code>为输入到流命令里面的环境变量</td>
</tr>
<tr>
<td style="text-align:left"><code>-inputreader</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">貌似可以代替<code>-inputformat</code>这个东西</td>
</tr>
<tr>
<td style="text-align:left"><code>-verbose</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">启用<code>java</code>的<code>verbose</code>输出</td>
</tr>
<tr>
<td style="text-align:left"><code>-lazyOutput</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">当输出格式为<code>FileOutputFormat</code>时，可以配置为懒输出-_-</td>
</tr>
<tr>
<td style="text-align:left"><code>-numReduceTasks</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">指定的<code>reducer</code>的数目</td>
</tr>
<tr>
<td style="text-align:left"><code>-mapdebug</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">指定一个脚本当<code>mapper</code>失败的时候进行调用</td>
</tr>
<tr>
<td style="text-align:left"><code>-reducedebug</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">指定一个脚本当<code>reducer</code>失败的时候进行调用</td>
</tr>
<tr>
<td style="text-align:left"><code>-conf</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">指定配置文件</td>
</tr>
<tr>
<td style="text-align:left"><code>-D</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left"><code>property=value</code> 可以配置<code>Hadoop</code>原生的配置项 <strong>实用</strong>^_^</td>
</tr>
</tbody>
</table>
<blockquote>
<p>这么看来，<code>streaming</code>还是很强大以及很灵活的</p>
</blockquote>
<h2 id="Streaming调试">Streaming调试</h2><p>从上述的配置中可以看到 可以配置<code>mapdebug</code>和<code>reducedebug</code>来追踪<code>streaming</code>中的错误信息来进行调试，除了这种方式，<code>streaming</code>调试还有一种更加方便的方式，<br>先来看<code>streaming</code>的执行过程<code>mapper-&gt;shuffle-&gt;reducer</code>，数据以流的方式进行传递的，在<code>Linux</code>中可以配合自带的命令以及官道来完成这一过程，现在可以看模拟刚刚的demo执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master pyscript]<span class="comment"># cat ~/data/words.txt | python word_count_mapper.py | sort | python word_count_reducer.py | sort -nr -k 2 |head -n 10</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到其输出</p>
<pre><code><span class="operator">and</span>    <span class="number">11</span>
<span class="built_in">to</span>    <span class="number">10</span>
people    <span class="number">10</span>
Micro-blog    <span class="number">8</span>
their    <span class="number">6</span>
<span class="operator">a</span>    <span class="number">5</span>
other    <span class="number">4</span>
<span class="operator">of</span>    <span class="number">4</span>
more    <span class="number">4</span>
has    <span class="number">4</span>
</code></pre><p>与上述demo中的结果一模一样，现在大致来分解一下上述命令</p>
<ol>
<li><code>cat ~/data/words.txt </code>:输出文件内容</li>
<li><code>| python word_count_mapper.py</code>:管道命令  将上一步输出的内容输出到要执行的<code>mapper</code>中</li>
<li><code>| sort </code>:管道命令 直接将<code>mapper</code>中输出的内容按第一列进行排序，排序完了之后其实就是达到了分组的效应</li>
<li><code>| python word_count_reducer.py</code>:管道 将排序后的值一次输入到<code>reducer</code>中进行执行，其实到了这一步已经完成了<code>streaming</code>的模拟</li>
<li><code>| sort -nr -k 2 |head -n 10</code> 将最后的结果排个序，再取top</li>
</ol>
<p>使用上述方式来进行调试我感觉有两大优势</p>
<ol>
<li>快，不需要提交到服务器上 慢悠悠的取执行</li>
<li>准，可以直接看到<code>python</code>抛出来的错误</li>
</ol>
<h2 id="Streaming常见错误">Streaming常见错误</h2><ul>
<li>Caused by: java.io.IOException: error=2, No such file or directory<br>  这个往往是由于没有指定<code>mapper,redue=cer</code>的<code>-file</code>引起的，也可以使用通配符<code>*</code></li>
<li>另一未知的错误 估计就是写的脚本执行出了问题，使用上述方式先在本地调试完了再跑</li>
</ul>
<h2 id="总结">总结</h2><p><code>Hadoop streaming</code>写起来很灵活，并且由于跨语言，迁移起来很很快，熟悉不同语言的开发人员也非常容易合作，如果<code>Hadoop streaming</code>程序由多个<code>Map-Reduce</code>构成，那么用<code>Shell</code>来组织整个程序也就会非常的方便快捷</p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://hadoop.apache.org/docs/r2.7.1/hadoop-streaming/HadoopStreaming.html" target="_blank" rel="external">Hadoop Streaming</a></li>
<li><a href="http://shiyanjun.cn/archives/336.html" target="_blank" rel="external">Hadoop Streaming原理及实践</a></li>
<li><a href="http://dongxicheng.org/mapreduce/hadoop-streaming-programming/" target="_blank" rel="external">Hadoop Streaming 编程</a></li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>Hadoop Streaming是一个便于变成<span class="keyword">Map</span> <span class="keyword">Reduce</span>程序的工具包，这个工具包可以支持各种可执行/脚本语言来创建Mapper和Reducer，利用Hadoop的优势进行大数据的处理，这些语言仅仅只需要支持*unix的表示输出输入即可(python,c,c++,perl,akw etc.)
</code></pre><h2 id="Streaming实践">Streaming实践</h2><p>先直接来看一个由<code>python</code>写的<code>Streaming</code>程序，还有那个经典的word count,我们的数据集是一篇<a href="/img/Hadoop-Streaming-Primary-Learning-And-Debug/words.txt">英语作文</a>,<br>看来看他的<code>mapper</code>文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding=utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys,re</span><br><span class="line"></span><br><span class="line">re_english = re.compile(<span class="string">u'[^a-zA-Z0-9\-]+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin: <span class="comment">#这里你可以看做是map类中的line输入</span></span><br><span class="line">    words = re_english.sub(<span class="string">' '</span>,line.strip()) <span class="comment">#这里只提取英文数字</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words.split():</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'%s\t%s'</span> % (word, <span class="number">1</span>)  <span class="comment">#这儿就是标准的输出，用tab隔开  默认第一个值为key</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Hadoop" scheme="http://yyl8781697.github.io/tags/Hadoop/"/>
    
      <category term="Hadoop" scheme="http://yyl8781697.github.io/categories/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Mac的OSX系统中配置VIM]]></title>
    <link href="http://yyl8781697.github.io/2015/11/07/Mac/Mac-OSX-Vim-highlight/"/>
    <id>http://yyl8781697.github.io/2015/11/07/Mac/Mac-OSX-Vim-highlight/</id>
    <published>2015-11-07T12:19:43.000Z</published>
    <updated>2015-11-07T12:39:50.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文主要参考<a href="http://www.yeyaxi.com/2011/06/how-to-enable-syntax-highlighting-for-vim-in-mac-osx/" target="_blank" rel="external">[译]如何在Mac OS X中开启VIM语法高亮</a>,他是真的work啊^_^</p>
</blockquote>
<p>使用<code>vim</code>来敲代码很带感，设置<code>vim</code>是一大要事，但是在<code>Mac</code>的<code>vim</code>默认是黑白的，而且并不能像<code>Linux</code>设置<code>~/.vimrc</code>来进行配置，但是毕竟还有其他的方法，先下面一步一步走就可以了</p>
<p>首先进入终端之后输入如下代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/vim</span><br><span class="line"></span><br><span class="line">sudo vim vimrc</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>然后再打开的文件中插入下面的配置<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> ai                  <span class="string">" auto indenting</span><br><span class="line"></span><span class="keyword">set</span> <span class="keyword">history</span>=<span class="number">100</span>         <span class="string">" keep 100 lines of history</span><br><span class="line"></span><span class="keyword">set</span> ruler               <span class="string">" show the cursor position</span><br><span class="line"></span><span class="keyword">syntax</span> <span class="keyword">on</span>               <span class="string">" syntax highlighting</span><br><span class="line"></span><span class="keyword">set</span> hlsearch            <span class="string">" highlight the last searched term</span><br><span class="line"></span><span class="keyword">filetype</span> plugin <span class="keyword">on</span>      <span class="string">" use the file type plugins</span><br><span class="line"></span><span class="keyword">set</span> <span class="keyword">ts</span>=<span class="number">4</span>                <span class="string">" tab space =4</span><br><span class="line"></span><span class="keyword">set</span> expandtab</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span>				<span class="string">" show line number</span><br><span class="line"></span><span class="keyword">set</span> <span class="built_in">shiftwidth</span>          <span class="string">" 这个貌是可以用于批量缩进的时候设置为4个空格</span><br><span class="line"></span><span class="keyword">highlight</span> Comment ctermfg=green guifg=green  <span class="string">"高亮备注为绿色</span><br><span class="line"></span></span><br><span class="line"><span class="string">" When editing a file, always jump to the last cursor position</span><br><span class="line"></span><span class="keyword">autocmd</span> BufReadPost *</span><br><span class="line">\ <span class="keyword">if</span> ! <span class="built_in">exists</span>(<span class="string">"g:leave_my_cursor_position_alone"</span>) |</span><br><span class="line">\ <span class="keyword">if</span> <span class="built_in">line</span>(<span class="string">"'\""</span>) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">line</span> (<span class="string">"'\""</span>) &lt;= <span class="built_in">line</span>(<span class="string">"$"</span>) |</span><br><span class="line">\ <span class="keyword">exe</span> <span class="string">"normal g'\""</span> |</span><br><span class="line">\ <span class="keyword">endif</span> |</span><br><span class="line">\ <span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p>
<p>接着退出之后随便使用<code>vim</code>打开一个文件之后可以看到颜色亮起来了<br><img src="/img/Mac-OSX-Vim-highlight/vim_highlight.png" alt=""></p>
<p>瞬间就带感了，其他的设置都可以去在刚刚的文件里面进行配置</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文主要参考<a href="http://www.yeyaxi.com/2011/06/how-to-enable-syntax-highlighting-for-vim-in-mac-osx/">[译]如何在Mac OS X中开启VIM语法高亮</a>,他是真的work啊^_^</p>
</blockquote>
<p>使用<code>vim</code>来敲代码很带感，设置<code>vim</code>是一大要事，但是在<code>Mac</code>的<code>vim</code>默认是黑白的，而且并不能像<code>Linux</code>设置<code>~/.vimrc</code>来进行配置，但是毕竟还有其他的方法，先下面一步一步走就可以了</p>
<p>首先进入终端之后输入如下代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/vim</span><br><span class="line"></span><br><span class="line">sudo vim vimrc</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://yyl8781697.github.io/tags/Mac/"/>
    
      <category term="Mac" scheme="http://yyl8781697.github.io/categories/Mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[来来来，学习Shell的命令]]></title>
    <link href="http://yyl8781697.github.io/2015/11/04/Linux/Shell-Command-List/"/>
    <id>http://yyl8781697.github.io/2015/11/04/Linux/Shell-Command-List/</id>
    <published>2015-11-04T14:34:28.000Z</published>
    <updated>2015-11-27T08:29:34.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Shell脚本是非常强的大一个脚本语言，但是不用会手生，所以在此记录Shell脚本的相应关键点，也做查字典用^_^</p>
</blockquote>
<h2 id="变量">变量</h2><h3 id="变量定义">变量定义</h3><p>先来简单的看一下变量定义的规则</p>
<ol>
<li>在<code>Shell</code>中，使用变量之前不需要事先声明，只是通过使用它们来创建它们；</li>
<li>在默认情况下，所有变量都被看做是字符串，并以字符串来存储；</li>
<li><code>Shell</code>变量是区分大小写的；</li>
<li>在赋值变量的时候等号两端不能有空格-_-</li>
</ol>
<a id="more"></a>
<p>定义了变量之后，一定要加上<code>$</code>符号才能使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">VAR1=HELLO</span><br><span class="line">VAR2=MY NAME</span><br><span class="line">VAR3=<span class="string">"MY AGE"</span></span><br><span class="line">VAR4 = IS</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> VAR1 <span class="comment">#error 能输出 但不是输出该变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$VAR1</span> <span class="comment">#ok 正常读取变量并打印</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$VAR2</span> <span class="comment">#error 定义变量的值 用空格隔开了</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$VAR3</span> <span class="comment">#ok 作为一整个字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$VAR4</span> <span class="comment">#error 变量定义的时候等号两端有空格</span></span><br></pre></td></tr></table></figure>
<p>输出的结果为</p>
<pre><code>./test.sh: <span class="built_in">line</span> <span class="number">2</span>: NAME: <span class="command"><span class="keyword">command</span> <span class="title">not</span> <span class="title">found</span></span>
./test.sh: <span class="built_in">line</span> <span class="number">4</span>: VAR4: <span class="command"><span class="keyword">command</span> <span class="title">not</span> <span class="title">found</span></span>
VAR1
HELLO

MY AGE
</code></pre><blockquote>
<p>关于<code>shell</code>脚本的执行：<code>shell</code>基本一般是以<code>.sh</code>为后缀,然后在<code>*unix</code>系统下一般都是直接使用<code>./[当前shell文件名]</code> 的方式来执行，也可以使用<code>全部经/[shell文件名]</code>的方式来执行，并且需要注意的是 被执行的<code>shell</code>文件一定是有含有可执行权限了的，可以使用<code>chmod</code>命令来修改</p>
</blockquote>
<p>还有另一个点就是在调用变量的时候 ，如果在双引号中直接使用<code>$name</code>任然可以识别，但是如果在单引号是就无法适用<code>$name</code>的方式来调用变量</p>
<h3 id="read读取输入值">read读取输入值</h3><p>这个功能就像<code>java</code>中的<code>readline</code>来读取，使用方法为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"whats your name?"</span></span><br><span class="line"><span class="built_in">read</span> NAME  <span class="comment">#在这里读取输入值到NAME变量中 ，这里如果不输入会停留在屏幕上</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"webcome back"</span> <span class="variable">$NAME</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到熟悉的结果为</p>
<pre><code>whats your <span class="property">name</span>?
tom
webcome <span class="keyword">back</span> tom
</code></pre><h3 id="环境变量">环境变量</h3><p><code>Shell</code>脚本还提供能一些实用的环境变量</p>
<ol>
<li><code>$HOME</code>:为当前用户所在的目录</li>
<li><code>$PATH</code>:当前用户所能方法的PATH变量</li>
<li><code>$#</code>:传递参数额个数  类似<code>java</code>中的<code>args.length</code></li>
<li><code>$$</code><code>:Shell</code>脚本的进程号，脚本程序通常会用它来生成一个唯一的临时文件。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前用户所在的目录为"</span> <span class="variable">$HOME</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前的执行目录为"</span> $(<span class="built_in">pwd</span>)  <span class="comment">#这个是访问当前的脚本的目录很实用</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前用户所能访问的PATH为"</span> <span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前参数的参数个数为"</span> <span class="variable">$#</span>  <span class="comment">#这儿参数的格式是使用空格隔开的哦</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前Shell脚本的进程号为"</span> $$</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以到看的结果是</p>
<pre><code>yans-MacBook-<span class="string">Pro:</span>Downloads yanyl$ ./hi.sh  hello world
当前用户所在的目录为 <span class="regexp">/Users/</span>yanyl
当前的执行目录为 <span class="regexp">/Users/</span>yanyl/Downloads
当前用户所能访问的PATH为 <span class="regexp">/usr/</span>local<span class="regexp">/bin:/</span>usr<span class="regexp">/bin:/</span><span class="string">bin:</span><span class="regexp">/usr/</span><span class="string">sbin:</span><span class="regexp">/sbin:/</span>Users<span class="regexp">/yanyl/</span>Program<span class="regexp">/apache-maven-3.2.5/</span><span class="string">bin:</span><span class="regexp">/Users/</span>yanyl<span class="regexp">/Program/</span>scala-<span class="number">2.10</span>.4<span class="comment">//bin</span>
当前参数的参数个数为 <span class="number">2</span>
当前Shell脚本的进程号为 <span class="number">43746</span>
</code></pre><blockquote>
<p>假如需要进入当前目录的父目录，可以使用<code>$(dirname $(pwd))</code></p>
</blockquote>
<h3 id="参数变量">参数变量</h3><p>刚刚看到可以使用<code>read</code>关键字可以来读取输入变量，但是我们可能更加常用的是参数变量，也就是<code>$#</code>的个数，它的规则如下</p>
<ol>
<li><code>$#</code>表示参数变量的个数</li>
<li><code>$0</code>表示当前的脚本名称</li>
<li><code>$1,$2…$n</code>表示依次能读取到的变量 但是如果参数变量不够，<code>$i</code>会被赋值为空</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前输入的参数变量的长度为"</span> <span class="variable">$#</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前执行的Shell脚本为"</span> <span class="variable">$0</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前输入的第一个参数为"</span> <span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前输入的第二个参数为"</span> <span class="variable">$2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前的输入的第三个参数为"</span> <span class="variable">$3</span> <span class="comment">#现在如果只传2个参数 这里将不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以看到的结果为</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ ./hi.<span class="keyword">sh</span>  hello world
当前输入的参数变量的长度为 2
当前执行的<span class="keyword">Shell</span>脚本为 ./hi.<span class="keyword">sh</span>
当前输入的第一个参数为 hello
当前输入的第二个参数为 world
当前的输入的第三个参数为
</code></pre><p>可以看到在<code>Shell</code>脚本中去读取参数变量还是很方便的，这样配合下面的条件判断以及循环就可以做很多事情了</p>
<h3 id="读取返回码">读取返回码</h3><p>一般的程序/命令在执行结束时都会返回一个 返回码，比如</p>
<ul>
<li><code>java</code>的<code>system.exit(-1)</code></li>
<li><code>python</code>的<code>sys.exit(-1)</code></li>
<li>还有上面<code>Shell</code>脚本中的最后一行<code>exit 0</code></li>
</ul>
<blockquote>
<p>如果你不显式指定返回码，一般默认为0，表示正常退出，但是有时候显式的指定返回码是一个好习惯哦<br>这些程序在<code>Shell</code>中执行的,可以使用<code>$?</code>来读取上一个程序执行下来的脚本码</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">du <span class="operator">-s</span> <span class="comment">#执行的返回码一般为0</span></span><br><span class="line"><span class="built_in">echo</span> du <span class="operator">-s</span>的返回码为 $?</span><br><span class="line"></span><br><span class="line">duu <span class="operator">-s</span> <span class="comment">#这个命令故意输错</span></span><br><span class="line"><span class="built_in">echo</span> duu <span class="operator">-s</span>的返回码为 $?</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以看到正确的结果为</p>
<pre><code><span class="number">28494656</span>    .
du <span class="operator">-s</span>的返回码为 <span class="number">0</span>
./hi.sh: line <span class="number">6</span>: duu: <span class="built_in">command</span> not found
duu <span class="operator">-s</span>的返回码为 <span class="number">127</span>
</code></pre><blockquote>
<p>返回码配上<code>if</code>判断，就可以使用<code>shell</code>脚本自由得在各个语言以及命令中穿梭啦^_^</p>
</blockquote>
<h2 id="数学运算">数学运算</h2><p>在上一小节中说道，<code>Shell</code>中变量一般都是当字符串来处理，那我遇到数字运算该咋办呢？？</p>
<p>可以先看<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">a=<span class="number">1</span>+<span class="number">2</span></span><br><span class="line">b=<span class="variable">$a</span>+<span class="number">3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>结果却看到</p>
<pre><code>1+2
1+2+3
</code></pre><p>那在<code>Shell</code>中解决这个问题大概有这么几种方法</p>
<h3 id="let关键字">let关键字</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">let</span> a=<span class="number">1</span>+<span class="number">2</span></span><br><span class="line"><span class="built_in">let</span> b=<span class="variable">$a</span>+<span class="number">3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>输出的结果为</p>
<pre><code>3
6
</code></pre><p>这个关键词大致需要注意以下几个点:</p>
<ul>
<li><code>let</code>只支持整数运算</li>
<li>当<code>let</code>后面的运算部分有<code>bash</code>关键字时，需加双引号</li>
<li>幂次方可以使用**符号</li>
</ul>
<h3 id="使用(())">使用(())</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">((a=<span class="number">1</span>+<span class="number">2</span>))</span><br><span class="line">((b=<span class="variable">$a</span>+<span class="number">3</span>))</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>结果还是正确的</p>
<pre><code>3
6
</code></pre><blockquote>
<p><code>(())</code>的用法与<code>let</code>完全相同</p>
</blockquote>
<h3 id="使用$[]">使用$[]</h3><p>上面的效果需要这么写<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=$[<span class="number">1</span>+<span class="number">2</span>]</span><br><span class="line">b=$[<span class="variable">$a</span>+<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<p>其余与上面两种限制大致相同</p>
<h3 id="使用expr">使用expr</h3><p>关于这个方式是这么写的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=`expr <span class="number">1</span> + <span class="number">2</span>`</span><br><span class="line">b=`expr <span class="variable">$a</span> \* <span class="number">3</span>`  <span class="comment">#需要转义</span></span><br></pre></td></tr></table></figure></p>
<p>需要额外注意的有：</p>
<ul>
<li>运算符两端需要加空格  一定要记住。。。很容易失误</li>
<li>对于<code>|、&amp;、&lt;、&lt;=、&gt;=、&gt;、*</code>运算符号需要加上<code>\</code>进行转义</li>
</ul>
<h3 id="使用bc">使用bc</h3><p>这个终于是可以用于浮点数的运算了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">a=<span class="number">3.1415926</span></span><br><span class="line">b=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span>*2"</span>|bc`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到结果</p>
<pre><code>3.1415926
6.2831852
</code></pre><p>据说这里还有一个<code>scale</code>来设置精度，但是我设置了感觉木有效果-_-</p>
<h2 id="条件判断">条件判断</h2><h3 id="if_语法">if 语法</h3><p>在<code>Shell</code>脚本中有两种书写<code>if</code>判断的语法</p>
<ul>
<li><p>使用<code>test</code> 关键字</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># if test expression1 operation expression2</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="number">5</span> <span class="operator">-gt</span> <span class="number">4</span>;  <span class="comment">#这个最后的结尾可以加上:或者;</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"ok,5&gt;4"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"oh,no"</span></span><br><span class="line"><span class="keyword">fi</span> <span class="comment">#这个结束符号必须得加</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>  输出为</p>
<pre><code><span class="ok">ok</span>,<span class="number">5</span>&gt;<span class="number">4</span>
</code></pre></li>
<li><p>使用<code>[</code>和<code>]</code>关键字</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># if [ expression1 operation expression2 ]</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="number">5</span> <span class="operator">-lt</span> <span class="number">4</span> ];  <span class="comment">#注意[和]两端必须留空格 同时表达式两端都需要有空格</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"ok,5&gt;4"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"oh,no"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>  输出为</p>
<pre><code>oh,<span class="literal">no</span>
</code></pre></li>
</ul>
<blockquote>
<p>如果还更加复杂的判断你可以使用<code>elif</code>继续增加条件表达式，但是别忘了加<code>then</code>哦</p>
</blockquote>
<h3 id="判断表达式">判断表达式</h3><p>在<code>Shell</code>中有三种判断表达式</p>
<h4 id="字符串比较">字符串比较</h4><table>
<thead>
<tr>
<th style="text-align:left">字符串比较</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>string1 = string2</code></td>
<td style="text-align:left">如果两个字符串相同，也可用<code>==</code>结果就为真</td>
</tr>
<tr>
<td style="text-align:left"><code>string1 != string2</code></td>
<td style="text-align:left">如果两个字符串不同，结果就为真</td>
</tr>
<tr>
<td style="text-align:left"><code>-n string</code></td>
<td style="text-align:left">如果字符串不为空，则结果为真</td>
</tr>
<tr>
<td style="text-align:left"><code>-z string</code></td>
<td style="text-align:left">如果字符串为一个空串（<code>null</code>），则结果为真</td>
</tr>
</tbody>
</table>
<blockquote>
<p>这里需要注意下，<code>-n</code> 和 <code>-z string</code>比较时必须用双引号(“”)将变量引起来</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">a=<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$a</span>"</span>  ]  <span class="comment">#注意要空括号来包住哦</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> exists</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> null</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$c</span>"</span>  ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> exists</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> null</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>结果为</p>
<pre><code>exists
<span class="literal">null</span>
</code></pre><h4 id="算术比较">算术比较</h4><table>
<thead>
<tr>
<th style="text-align:left">算术比较</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>expression1 -eq expression2</code></td>
<td style="text-align:left">如果两个表达式相等，则结果为真</td>
</tr>
<tr>
<td style="text-align:left"><code>expression1 -ne expression2</code></td>
<td style="text-align:left">如果两个表达式不等，则结果为真</td>
</tr>
<tr>
<td style="text-align:left"><code>expression1 -gt expression2</code></td>
<td style="text-align:left">如果<code>expression1</code> 大于<code>expression2</code> ，则为真</td>
</tr>
<tr>
<td style="text-align:left"><code>expression1 -ge expression2</code></td>
<td style="text-align:left">如果<code>expression1</code> 大于等于<code>expression2</code> ,则为真</td>
</tr>
<tr>
<td style="text-align:left"><code>expression1 -lt expression2</code></td>
<td style="text-align:left">如果<code>expression1</code> 小于<code>expression2</code> ，则为真</td>
</tr>
<tr>
<td style="text-align:left"><code>expression1 -le expression2</code></td>
<td style="text-align:left">如果<code>expression1</code> 小于等于<code>expression2</code> ，则为真</td>
</tr>
<tr>
<td style="text-align:left"><code>!expression</code></td>
<td style="text-align:left">表达式为假，则结果就为真；反之亦然</td>
</tr>
</tbody>
</table>
<blockquote>
<p>关于上面比较符号的快速记法如下：<code>eq=equal</code>,<code>gt=great than</code>,<code>lt=less than</code>，然后组合拼凑即可，如果觉得这样还是很难记，就可以像我一样，将这些符号记录下来，需要的时候来查表-_-</p>
</blockquote>
<h4 id="文件条件测试">文件条件测试</h4><table>
<thead>
<tr>
<th style="text-align:left">文件条件测试</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-d file</code></td>
<td style="text-align:left">如果文件是一个目录，则为真</td>
</tr>
<tr>
<td style="text-align:left"><code>-f file</code></td>
<td style="text-align:left">如果文件是一个普通文件，则为真；也可以用来测试文件是否存在</td>
</tr>
<tr>
<td style="text-align:left"><code>-r file</code></td>
<td style="text-align:left">如果文件可读，则结果为真</td>
</tr>
<tr>
<td style="text-align:left"><code>-s file</code></td>
<td style="text-align:left">如果文件大小不为0，则结果为真</td>
</tr>
<tr>
<td style="text-align:left"><code>-w file</code></td>
<td style="text-align:left">如果文件可写，则结果为真</td>
</tr>
<tr>
<td style="text-align:left"><code>-x file</code></td>
<td style="text-align:left">如果文件可执行，则结果为真</td>
</tr>
</tbody>
</table>
<blockquote>
<p>这，真的是一个利民的测试</p>
</blockquote>
<h2 id="循环结构">循环结构</h2><h3 id="for_循环">for 循环</h3><p>先来看一种经典<code>C</code>语法版的<code>for</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">for</span> ((i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>看输出，</p>
<pre><code>0
1
2
3
4
</code></pre><p>还支持在外部控制步长<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">for</span> ((i=<span class="number">0</span>;i&lt;<span class="number">5</span>;))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">    i=$[<span class="variable">$i</span>+<span class="number">2</span>]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<pre><code>0
2
4
</code></pre><blockquote>
<p>是不是感觉基本功能都有呀，就是写某些东西写起来奇怪点<br>是不是有一种莫名的熟悉感</p>
</blockquote>
<p>另一种就是类似<code>foreach</code>的情况了，他的格式是这样的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> variable <span class="keyword">in</span> values</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>values</code> 可能有的情况为：</p>
<ol>
<li><p>使用<code>linux</code>命令输出的行作为迭代的输入:<code>ls</code>,<code>seq</code>,<code>cat</code>之类均可,其实就可以完成很强大的文件读取功能</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `head -n <span class="number">5</span> words.dit`;<span class="keyword">do</span>  <span class="comment">#words.dit 这是一个通用词表 每行一个词</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p> 可以看到通用词典中前5个词</p>
<pre><code>阿
阿巴丹
阿巴岛
阿巴鸟
阿巴伊达
</code></pre></li>
<li><p>使用<code>$*</code>可以来表示遍历传入的参数列表</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $*;<span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p> 来看个结果</p>
<pre><code>yans-MacBook-Pro:Downloads yanyl$ ./hi.sh  <span class="keyword">my</span> <span class="property">name</span> <span class="keyword">is</span> tom
<span class="keyword">my</span>
<span class="property">name</span>
<span class="keyword">is</span>
tom
</code></pre></li>
<li><p>还可以使用带空格的字符串 来进行按空格分隔输出</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">a=<span class="string">"yello red green"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$a</span>;<span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p> 这样在一定程度上可以看成一个简易的数组</p>
</li>
</ol>
<p>这里需要注意的是包含条件以及循环逻辑是双重括号，以及开始结果的<code>do</code>和<code>Done</code></p>
<h3 id="while_循环">while 循环</h3><p>另一个常用的就是<code>while</code>循环了<br>他的结构是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>这个也是蛮好理解的，可以来看一个demo<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"please ent your password:"</span></span><br><span class="line"><span class="built_in">read</span> <span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">"<span class="variable">$pwd</span>"</span>x != <span class="string">"root"</span>x  ] <span class="comment">#这里加x是为了防止啥也不输入直接回车产生的报错</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"error,please try again:"</span></span><br><span class="line">    <span class="built_in">read</span> <span class="built_in">pwd</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"welcome here"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>看一下结果</p>
<pre><code>please ent your <span class="string">password:</span>
sha
error,please <span class="keyword">try</span> <span class="string">again:</span>

error,please <span class="keyword">try</span> <span class="string">again:</span>
root
welcome here
</code></pre><p>很有意思的一个哈~</p>
<h3 id="until语句">until语句</h3><p>这个语句与<code>while</code>的结构完全一样，只是使用了<code>until</code>关键字来代替了<code>while</code>，然后在条件为<code>true</code>的时候停止，正好与<code>while</code>相反</p>
<h2 id="函数">函数</h2><p><code>Shell</code>这么叼，能没有函数吗<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">function</span>] <span class="function"><span class="title">functon_name</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是定义函数的结构，大致有以下几个要点</p>
<ol>
<li>前面的<code>function</code>关键字可有可无，不过感觉还是加上去比较好，这样在代码里面比较好辨识</li>
<li>函数名后面的括号中不能带参数 取的参数是用过<code>$1,$2…$n</code>这样的方式来取的 </li>
<li>调用的时候直接写函数名 不需要加括号</li>
<li>如果想传递参数的话 直接在调用后来加上参数列表 用空格隔开 （就是<code>Shell</code>的传参一样）</li>
<li>使用<code>local</code>关键字来定义函数体里面的局部变量</li>
<li>所以在函数调用必须在函数定义之后</li>
</ol>
<p>先看一个小的demo<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sayhi</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> hi <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayhi tom <span class="comment">#前面的sayhi是函数的调用 后面的tom是传参</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到输出</p>
<pre><code><span class="title">hi</span> tom
</code></pre><h3 id="函数的返回值">函数的返回值</h3><p>关于<code>Shell</code>的返回值方式有两种</p>
<ol>
<li><p>输出给主程序，他的结构为：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">function_name</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$something</span>  <span class="comment">#通过输出的方式来返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a=`<span class="keyword">function</span>_name`  这种方式接收返回值</span><br></pre></td></tr></table></figure>
<p> 看到的demo可以是这样的</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Press ENTER or <span class="built_in">type</span> <span class="built_in">command</span> to <span class="built_in">continue</span></span><br><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sum</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> $[<span class="variable">$1</span>+<span class="variable">$2</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a=`sum <span class="number">1</span> <span class="number">2</span>`</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> the sum is <span class="variable">$a</span></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p> 最终输出结果为</p>
<pre><code><span class="operator">the</span> <span class="built_in">sum</span> is <span class="number">3</span>
</code></pre></li>
<li><p>使用<code>return</code>作为返回码来返回值</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">function_name</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> <span class="variable">$ret</span> <span class="comment">#这里进行返回码的返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>_name</span><br><span class="line">$? <span class="comment">#在这里接收返回值</span></span><br></pre></td></tr></table></figure>
<p> 一样再来一个demo</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sum</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> $[<span class="variable">$1</span>+<span class="variable">$2</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="built_in">echo</span> the sum is $?</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p> 可以看到输出为</p>
<pre><code><span class="operator">the</span> <span class="built_in">sum</span> is <span class="number">3</span>
</code></pre></li>
</ol>
<h2 id="case语句">case语句</h2><p>这里的<code>case</code>的与传统的<code>switch</code>有点像，但是又像<code>scala</code>中的<code>match</code>模式匹配的强大，<br>他的结构是这样的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> variable <span class="keyword">in</span></span><br><span class="line">    pattern [ | pattern] ...) statements;;</span><br><span class="line">    pattern [ | pattern] ...) statements;;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></p>
<p>来看这个强大的demo<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">match</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">        root ) <span class="built_in">echo</span> this is password ;;</span><br><span class="line">        h* ) <span class="built_in">echo</span> hi <span class="variable">$1</span> ;; <span class="comment">#使用通配符</span></span><br><span class="line">        yes | YES ) <span class="built_in">echo</span> agree with me ;; <span class="comment">#可以进行或操作</span></span><br><span class="line">        * ) <span class="built_in">echo</span> everything is here;;  <span class="comment">#你可以理解为switch中的default</span></span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">match root</span><br><span class="line">match hello</span><br><span class="line">match YES</span><br><span class="line">match Yes</span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>来看一下结果</p>
<pre><code><span class="keyword">this</span> <span class="keyword">is</span> password
hi hello
agree <span class="keyword">with</span> me
everything <span class="keyword">is</span> here
</code></pre><blockquote>
<p>注意，这里一旦匹配中了一个之后就马上会停止匹配</p>
</blockquote>
<h2 id="外部命令/文件/语言的调用">外部命令/文件/语言的调用</h2><p><code>Shell</code>的另一个强大之处就是可以无缝的和外部的命令，文件，语言结合，去调用组织他们</p>
<ol>
<li>外部命令：一般情况下可以直接写外部命令，如果要赋值的话得使用<code>``</code>括起来</li>
<li>外部文件：比如资源配置文件，profile文件之类的，可以直接使用<code>source</code>关键字的来执行</li>
<li>外部语言：比如<code>java,python</code>可以直接使用他们的<code>java</code>调用<code>jar,java</code>文件，也可以直接使用<code></code>关键字来执行<code>python</code>文件</li>
</ol>
<h2 id="总结">总结</h2><ol>
<li><code>Shell</code>很好很强大，得学习！！！</li>
<li>注意变量的字符串格式以及需要数学运算时的语法</li>
<li>注意变量赋值时等号两端一定不能有空格以及再取值时一定要加<code>$</code></li>
<li>平常的控制结束符号别忘了，比如<code>fi,doen,esac</code>等</li>
<li>忘了的时候来查查这个文件</li>
</ol>
<h2 id="参考">参考</h2><ul>
<li><a href="http://blog.csdn.net/mdx20072419/article/details/9381339" target="_blank" rel="external">shell 函数返回值接收问题</a></li>
<li><a href="http://www.jellythink.com/archives/699" target="_blank" rel="external">Linux Shell简明教程</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_9d074aae01012ytf.html" target="_blank" rel="external">shell中for循环总结</a></li>
<li><a href="http://www.1987.name/181.html" target="_blank" rel="external">Shell函数的定义、执行、传参和递归函数</a></li>
<li><a href="http://www.cnblogs.com/liujiahi/archive/2011/03/30/2196400.html" target="_blank" rel="external">shell 中数学计算总结</a></li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Shell脚本是非常强的大一个脚本语言，但是不用会手生，所以在此记录Shell脚本的相应关键点，也做查字典用^_^</p>
</blockquote>
<h2 id="变量">变量</h2><h3 id="变量定义">变量定义</h3><p>先来简单的看一下变量定义的规则</p>
<ol>
<li>在<code>Shell</code>中，使用变量之前不需要事先声明，只是通过使用它们来创建它们；</li>
<li>在默认情况下，所有变量都被看做是字符串，并以字符串来存储；</li>
<li><code>Shell</code>变量是区分大小写的；</li>
<li>在赋值变量的时候等号两端不能有空格-_-</li>
</ol>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yyl8781697.github.io/tags/Linux/"/>
    
      <category term="Vim" scheme="http://yyl8781697.github.io/tags/Vim/"/>
    
      <category term="Linux" scheme="http://yyl8781697.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[KNN算法中KD树的应用]]></title>
    <link href="http://yyl8781697.github.io/2015/10/12/Machine%20Learning/KDTree-In-KNN/"/>
    <id>http://yyl8781697.github.io/2015/10/12/Machine Learning/KDTree-In-KNN/</id>
    <published>2015-10-12T03:57:39.000Z</published>
    <updated>2015-10-12T08:10:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="KNN算法">KNN算法</h2><pre><code>给一个训练数据集和一个新的实例，在训练数据集中找出与这个新实例最近的k个训练实例，然后统计最近的k个训练实例中所属类别计数最多的那个类，就是新实例的类。
</code></pre><p><a href="http://kubicode.me/2015/08/16/Machine%20Learning/Algorithm-Summary-for-Interview/#KNN算法" target="_blank" rel="external">点我查看详情</a></p>
<blockquote>
<p>但是该算法每次在查询k个最近邻的时候都需要遍历全集  才能计算出来，可想而且如果训练样本很大的话，代价还是很大的，那有没有啥方法可以优化呢？本文就针对<code>KNN</code>算法实现一个简单的<code>KD</code>树</p>
</blockquote>
<h2 id="KD树">KD树</h2><pre><code>KD树是一个二叉树，表示对<span class="keyword">K</span>维空间的一个划分，可以进行快速检索（那KNN计算的时候不需要对全样本进行距离的计算了）
</code></pre><p>比如针对6个二维数据点{（2,3），（5,4），（9,6），（4,7），（8,1），（7,2）}，可以形成以下树形结构以及空间划分<br><img src="/img/KDTree-In-KNN/example.png" alt=""></p>
<a id="more"></a>
<p>该树的功能就是在高维空间下进行一个快速的最近邻查询。先来看定义的树的类结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">double</span>[] data;<span class="comment">//树上节点的数据  是一个多维的向量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">double</span> distance;<span class="comment">//与当前查询点的距离  初始化的时候是没有的</span></span><br><span class="line">	<span class="keyword">public</span> Node left,right,parent;<span class="comment">//左右子节点  以及父节点</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> dim=-<span class="number">1</span>;<span class="comment">//维度  建立树的时候判断的维度</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">double</span>[] data)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data=data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 返回指定索引上的数值</span><br><span class="line">	 *<span class="javadoctag"> @param</span> index</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getData</span><span class="params">(<span class="keyword">int</span> index)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(data==<span class="keyword">null</span> || data.length&lt;=index)</span><br><span class="line">			<span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">		<span class="keyword">return</span> data[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.distance&gt;o.distance)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(<span class="keyword">this</span>.distance==o.distance)</span></span><br><span class="line">			return 0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 计算距离 这里返回欧式距离</span><br><span class="line">	 *<span class="javadoctag"> @param</span> that</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">computeDistance</span><span class="params">(Node that)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.data==<span class="keyword">null</span> || that.data==<span class="keyword">null</span> || <span class="keyword">this</span>.data.length!=that.data.length)</span><br><span class="line">			<span class="keyword">return</span> Double.MAX_VALUE;<span class="comment">//出问题了  距离最远</span></span><br><span class="line">		<span class="keyword">double</span> d=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.data.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			d+=Math.pow(<span class="keyword">this</span>.data[i]-that.data[i], <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> Math.sqrt(d);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(data==<span class="keyword">null</span> || data.length==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.length;i++)</span><br><span class="line">			sb.append(data[i]+<span class="string">" "</span>);</span><br><span class="line">		sb.append(<span class="string">" d:"</span>+<span class="keyword">this</span>.distance);</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="建立KD树">建立KD树</h3><p>在<code>d</code>维的空间上循环找子区域的中位数进行划分的过程。<br>假设现在有<code>d</code>维空间的数据集<code>T={x<sub>1</sub>,x<sub>2</sub>,x<sub>3</sub>,…x<sub>n</sub>},xi={a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>..a<sub>d</sub>}</code></p>
<ol>
<li>首先构造根节点，以坐标<code>a<sub>1</sub></code>的中位数<code>b</code>为切分点，将根结点对应的矩形局域划分为两个区域，区域1中<code>a1&lt;b</code>,区域2中<code>a1&gt;b</code>，中位数所在的节点就是树上的节点</li>
<li>构造叶子节点，分别以上面两个区域中<code>a<sub>2</sub></code>的中位数作为切分点，再次将他们两两划分，作为深度1的叶子节点，（如果<code>a<sub>2</sub></code>=中位数，则<code>a<sub>2</sub></code>的实例落在切分面）</li>
<li>不断重复2的操作，深度为<code>j</code>的叶子节点划分的时候，索取的<code>a<sub>i</sub></code> 的<code>i=j%d+1</code>，直到两个子区域没有实例时停止</li>
</ol>
<p>所以我们首先需要在高维的数据中针对某一维进行一个中位数的查找的，这里最快捷的就是借用快排的方法</p>
<pre><code>假设f为快排的排头，进行一轮对比之后如果f所在的索引大于<span class="built_in">size</span>/<span class="number">2</span>，则此时只需要对左边进行递归排序就可以了，若小于<span class="built_in">size</span>/<span class="number">2</span>，则只需对右边区域进行递归排序，如果等于<span class="built_in">size</span>/<span class="number">2</span>  则说明
f就是中位数  直接返回就好啦
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 使用快排进进行一个中位数的查找  完了之后返回的数组size/2即中位数</span><br><span class="line"> *<span class="javadoctag"> @param</span> nodeList</span><br><span class="line"> *<span class="javadoctag"> @param</span> index</span><br><span class="line"> *<span class="javadoctag"> @param</span> left</span><br><span class="line"> *<span class="javadoctag"> @param</span> right</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSortForMedian</span><span class="params">(List&lt;Node&gt; nodeList,<span class="keyword">int</span> index,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&gt;=right || nodeList.size()&lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	</span><br><span class="line">	Node kn=nodeList.get(left);</span><br><span class="line">	<span class="keyword">double</span> k=kn.getData(index);<span class="comment">//取得向量指定索引的值</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i=left,j=right;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(nodeList.get(j).getData(index)&gt;=k &amp;&amp; i&lt;j)</span><br><span class="line">			j--;</span><br><span class="line">		nodeList.set(i, nodeList.get(j));</span><br><span class="line">		<span class="keyword">while</span>(nodeList.get(i).getData(index)&lt;=k &amp;&amp; i&lt;j)</span><br><span class="line">			i++;</span><br><span class="line">		nodeList.set(j, nodeList.get(i));</span><br><span class="line">	&#125;</span><br><span class="line">	nodeList.set(i, kn);</span><br><span class="line">	<span class="keyword">if</span>(i==nodeList.size()/<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> ;<span class="comment">//完成中位数的排序了</span></span><br><span class="line">	<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(i&lt;nodeList.size()</span>/2)</span><br><span class="line">	</span>&#123;</span><br><span class="line">		quickSortForMedian(nodeList,index,i+<span class="number">1</span>,right);<span class="comment">//只需要排序右边就可以了</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		quickSortForMedian(nodeList,index,left,i-<span class="number">1</span>);<span class="comment">//只需要排序左边就可以了</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了中位数查找，接下来就可以使用递归来进行树的建立了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 构建kd树  返回根节点</span><br><span class="line"> *<span class="javadoctag"> @param</span> nodeList</span><br><span class="line"> *<span class="javadoctag"> @param</span> index</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">buildKDTree</span><span class="params">(List&lt;Node&gt; nodeList,<span class="keyword">int</span> index)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(nodeList==<span class="keyword">null</span> || nodeList.size()==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	quickSortForMedian(nodeList,index,<span class="number">0</span>,nodeList.size()-<span class="number">1</span>);<span class="comment">//中位数排序</span></span><br><span class="line">	Node root=nodeList.get(nodeList.size()/<span class="number">2</span>);<span class="comment">//中位数 当做根节点</span></span><br><span class="line">	root.dim=index;</span><br><span class="line">	List&lt;Node&gt; leftNodeList=<span class="keyword">new</span> ArrayList&lt;Node&gt;();<span class="comment">//放入左侧区域的节点  包括包含与中位数等值的节点-_-</span></span><br><span class="line">	List&lt;Node&gt; rightNodeList=<span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(Node node:nodeList)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(root!=node)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(node.getData(index)&lt;=root.getData(index))</span><br><span class="line">				leftNodeList.add(node);<span class="comment">//左子区域 包含与中位数等值的节点</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				rightNodeList.add(node);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> newIndex=index+<span class="number">1</span>;<span class="comment">//进入下一个维度</span></span><br><span class="line">	<span class="keyword">if</span>(newIndex&gt;=root.data.length)</span><br><span class="line">		newIndex=<span class="number">0</span>;<span class="comment">//从0维度开始再算</span></span><br><span class="line">	root.left=buildKDTree(leftNodeList,newIndex);<span class="comment">//添加左右子区域</span></span><br><span class="line">	root.right=buildKDTree(rightNodeList,newIndex);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">		root.left.parent=root;<span class="comment">//添加父指针  </span></span><br><span class="line">	<span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">		root.right.parent=root;<span class="comment">//添加父指针  </span></span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="KD树搜索">KD树搜索</h3><ol>
<li>首先从根节点开始递归往下找到包含<code>q</code>的叶子节点，每一层都是找对应的<code>x<sub>i</sub></code></li>
<li>将这个叶子节点认为是当前的“近似最近点”</li>
<li>递归向上回退，如果以<code>q</code>圆心，以“近似最近点”为半径的球与根节点的另一半子区域边界相交，则说明另一半子区域中存在与<code>q</code>更近的点，则进入另一个子区域中查找该点并且更新”近似最近点“</li>
<li>重复3的步骤，直到另一子区域与球体不相交或者退回根节点</li>
<li>最后更新的”近似最近点“与<code>q</code>真正的最近点</li>
</ol>
<p>这里注意按上述方式找到的与查询点最近的那个点，但是我们在<code>KNN</code>的时候是查询<code>k</code>个最近点，<code>topK</code>问题嘛，这里我们就使用了一个最大堆的维护来保证最近的<code>k</code>个点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 维护一个k的最大堆</span><br><span class="line"> *<span class="javadoctag"> @param</span> listNode</span><br><span class="line"> *<span class="javadoctag"> @param</span> newNode</span><br><span class="line"> *<span class="javadoctag"> @param</span> k</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maintainMaxHeap</span><span class="params">(List&lt;Node&gt; listNode,Node newNode,<span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(listNode.size()&lt;k)</span><br><span class="line">	&#123;</span><br><span class="line">		maxHeapFixUp(listNode,newNode);<span class="comment">//不足k个堆   直接向上修复</span></span><br><span class="line">	&#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(newNode.distance&lt;listNode.get(<span class="number">0</span>)</span>.distance)</span>&#123;</span><br><span class="line">		<span class="comment">//比堆顶的要小   还需要向下修复 覆盖堆顶</span></span><br><span class="line">		maxHeapFixDown(listNode,newNode);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 从上往下修复  将会覆盖第一个节点</span><br><span class="line"> *<span class="javadoctag"> @param</span> listNode</span><br><span class="line"> *<span class="javadoctag"> @param</span> newNode</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeapFixDown</span><span class="params">(List&lt;Node&gt; listNode,Node newNode)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	listNode.set(<span class="number">0</span>, newNode);</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(j&lt;listNode.size())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(j+<span class="number">1</span>&lt;listNode.size() &amp;&amp; listNode.get(j).distance&lt;listNode.get(j+<span class="number">1</span>).distance)</span><br><span class="line">			j++;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(listNode.get(i).distance&gt;=listNode.get(j).distance)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		Node t=listNode.get(i);</span><br><span class="line">		listNode.set(i, listNode.get(j));</span><br><span class="line">		listNode.set(j, t);</span><br><span class="line">		</span><br><span class="line">		i=j;</span><br><span class="line">		j=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeapFixUp</span><span class="params">(List&lt;Node&gt; listNode,Node newNode)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	listNode.add(newNode);</span><br><span class="line">	<span class="keyword">int</span> j=listNode.size()-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> i=(j+<span class="number">1</span>)/<span class="number">2</span>-<span class="number">1</span>;<span class="comment">//i是parent节点</span></span><br><span class="line">	<span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(listNode.get(i).distance&gt;=listNode.get(j).distance)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		Node t=listNode.get(i);</span><br><span class="line">		listNode.set(i, listNode.get(j));</span><br><span class="line">		listNode.set(j, t);</span><br><span class="line">		</span><br><span class="line">		j=i;</span><br><span class="line">		i=(j+<span class="number">1</span>)/<span class="number">2</span>-<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好，现在就可以按照上述的思路来进行搜索了，搜索过程中维护一个k堆<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 查询最近邻</span><br><span class="line"> *<span class="javadoctag"> @param</span> root kd树</span><br><span class="line"> *<span class="javadoctag"> @param</span> q 查询点</span><br><span class="line"> *<span class="javadoctag"> @param</span> k</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Node&gt; <span class="title">searchKNN</span><span class="params">(Node root,Node q,<span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	List&lt;Node&gt; knnList=<span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">	Node almostNNode=searchLeaf(root,q);<span class="comment">//近似最近点</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(almostNNode!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">double</span> curD=q.computeDistance(almostNNode);<span class="comment">//最近近似点与查询点的距离 也就是球体的半径</span></span><br><span class="line">		almostNNode.distance=curD;</span><br><span class="line">		maintainMaxHeap(knnList,almostNNode,k);</span><br><span class="line">		<span class="keyword">if</span>(almostNNode.parent!=<span class="keyword">null</span> &amp;&amp;</span><br><span class="line">				curD&gt;Math.abs(q.getData(almostNNode.parent.dim)-almostNNode.parent.getData(almostNNode.parent.dim)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//这样可能在另一个子区域中存在更加近似的点</span></span><br><span class="line">			Node brother=getBrother(almostNNode);</span><br><span class="line">			brother.distance=q.computeDistance(brother);</span><br><span class="line">			maintainMaxHeap(knnList,brother,k);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		almostNNode=almostNNode.parent;<span class="comment">//返回上一级</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> knnList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 获取兄弟节点</span><br><span class="line"> *<span class="javadoctag"> @param</span> node</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">getBrother</span><span class="params">(Node node)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node==node.parent.left)</span><br><span class="line">		<span class="keyword">return</span> node.parent.right;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> node.parent.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 查询到叶子节点</span><br><span class="line"> *<span class="javadoctag"> @param</span> root</span><br><span class="line"> *<span class="javadoctag"> @param</span> q</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchLeaf</span><span class="params">(Node root,Node q)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Node leaf=root,next=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(leaf.left!=<span class="keyword">null</span> || leaf.right!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(q.getData(index)&lt;leaf.getData(index))</span><br><span class="line">		&#123;</span><br><span class="line">			next=leaf.left;<span class="comment">//进入左侧</span></span><br><span class="line">		&#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(q.getData(index)</span>&gt;leaf.<span class="title">getData</span><span class="params">(index)</span>)</span><br><span class="line">		</span>&#123;</span><br><span class="line">			next=leaf.right;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//当取到中位数时  判断左右子区域哪个更加近</span></span><br><span class="line">			<span class="keyword">if</span>(q.computeDistance(leaf.left)&lt;q.computeDistance(leaf.right))</span><br><span class="line">				next=leaf.left;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				next=leaf.right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(next==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//下一个节点是空时  结束了</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			leaf=next;</span><br><span class="line">			<span class="keyword">if</span>(++index&gt;=root.data.length)</span><br><span class="line">				index=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> leaf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意这里在判断查询点<code>q</code>与另一个子区域的边界是否相交时是需要判断半径与（<code>q</code>和父节点影响构建维数上的值之差即可）</p>
</blockquote>
<h2 id="栗子">栗子</h2><p>还是以上面的6个数据点进行构建<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Node&gt; nodeList=<span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">nodeList.add(<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>&#125;));</span><br><span class="line">nodeList.add(<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">5</span>,<span class="number">4</span>&#125;));</span><br><span class="line">nodeList.add(<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">9</span>,<span class="number">6</span>&#125;));</span><br><span class="line">nodeList.add(<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">4</span>,<span class="number">7</span>&#125;));</span><br><span class="line">nodeList.add(<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">8</span>,<span class="number">1</span>&#125;));</span><br><span class="line">nodeList.add(<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">7</span>,<span class="number">2</span>&#125;));</span><br><span class="line"></span><br><span class="line">KDTree kdTree=<span class="keyword">new</span> KDTree();</span><br><span class="line">Node root=kdTree.buildKDTree(nodeList,<span class="number">0</span>);</span><br><span class="line">System.out.println(root);</span><br></pre></td></tr></table></figure></p>
<p>对(2.1,3.1)进行查询<br><img src="/img/KDTree-In-KNN/search1.jpg" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(kdTree.searchKNN(root,<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">2.1</span>,<span class="number">3.1</span>&#125;),<span class="number">2</span>));</span><br></pre></td></tr></table></figure></p>
<p>可以发现最近的两个点</p>
<pre><code>[<span class="number">5.0</span> <span class="number">4.0</span>  d:<span class="number">3.0364452901377956</span>, <span class="number">2.0</span> <span class="number">3.0</span>  d:<span class="number">0.14142135623730964</span>]
</code></pre><p>完全符合预期</p>
<p>再来看(2,4.5)这个查询点<br><img src="/img/KDTree-In-KNN/search2.jpg" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(kdTree.searchKNN(root,<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">2</span>,<span class="number">4.5</span>&#125;),<span class="number">1</span>));</span><br><span class="line">System.out.println(kdTree.searchKNN(root,<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">2</span>,<span class="number">4.5</span>&#125;),<span class="number">3</span>));</span><br></pre></td></tr></table></figure></p>
<pre><code>[<span class="number">2.0</span> <span class="number">3.0</span>  d:<span class="number">1.5</span>]
[<span class="number">4.0</span> <span class="number">7.0</span>  d:<span class="number">3.2015621187164243</span>, <span class="number">2.0</span> <span class="number">3.0</span>  d:<span class="number">1.5</span>, <span class="number">5.0</span> <span class="number">4.0</span>  d:<span class="number">3.0413812651491097</span>]
</code></pre><p>首先最近邻的叶子节点是(4,7) 但是其半径会与另一子区域相交，所以继续进行(2,3)进行距离计算</p>
<blockquote>
<p>完整的源代码<a href="http://www.oschina.net/code/snippet_174837_51436" target="_blank" rel="external">在这儿有</a>!</p>
</blockquote>
<h2 id="参考">参考</h2><ol>
<li>《统计学习方法》第三章</li>
<li><a href="http://blog.csdn.net/qll125596718/article/details/8426458" target="_blank" rel="external">http://blog.csdn.net/qll125596718/article/details/8426458</a>这篇文章举例比较详细</li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="KNN算法">KNN算法</h2><pre><code>给一个训练数据集和一个新的实例，在训练数据集中找出与这个新实例最近的k个训练实例，然后统计最近的k个训练实例中所属类别计数最多的那个类，就是新实例的类。
</code></pre><p><a href="http://kubicode.me/2015/08/16/Machine%20Learning/Algorithm-Summary-for-Interview/#KNN算法">点我查看详情</a></p>
<blockquote>
<p>但是该算法每次在查询k个最近邻的时候都需要遍历全集  才能计算出来，可想而且如果训练样本很大的话，代价还是很大的，那有没有啥方法可以优化呢？本文就针对<code>KNN</code>算法实现一个简单的<code>KD</code>树</p>
</blockquote>
<h2 id="KD树">KD树</h2><pre><code>KD树是一个二叉树，表示对<span class="keyword">K</span>维空间的一个划分，可以进行快速检索（那KNN计算的时候不需要对全样本进行距离的计算了）
</code></pre><p>比如针对6个二维数据点{（2,3），（5,4），（9,6），（4,7），（8,1），（7,2）}，可以形成以下树形结构以及空间划分<br><img src="/img/KDTree-In-KNN/example.png" alt=""></p>]]>
    
    </summary>
    
      <category term="Data Struct" scheme="http://yyl8781697.github.io/tags/Data-Struct/"/>
    
      <category term="Java" scheme="http://yyl8781697.github.io/tags/Java/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[numpy工具包常用快速记]]></title>
    <link href="http://yyl8781697.github.io/2015/10/05/Python/Numpy-Fast-Memory/"/>
    <id>http://yyl8781697.github.io/2015/10/05/Python/Numpy-Fast-Memory/</id>
    <published>2015-10-05T14:54:26.000Z</published>
    <updated>2015-10-08T02:33:12.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><code>numpy</code>这个科学计算工具大法好，但是里面的东西不用老是会忘，所以在此记录常用的一些语法，以备之后查询之用（也叫懒人模式）^_^,不过详细的使用方法还是得看<a href="http://docs.scipy.org/doc/" target="_blank" rel="external">scipy api</a></p>
</blockquote>
<p>使用之前首先得引入包<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure></p>
<h2 id="array">array</h2><p><code>np.array</code>实现了真正的数组，在<code>numpy</code>中其实就是矩阵啦，同时提供了丰富的矩阵计算方法<br><a id="more"></a></p>
<h3 id="np-array"><a href="http://docs.scipy.org/doc/numpy/reference/c-api.array.html#index-0" target="_blank" rel="external">np.array</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment">#一维数组</span></span><br><span class="line">np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])  <span class="comment">#二维数组</span></span><br></pre></td></tr></table></figure>
<h3 id="np-arange"><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html#numpy.arange" target="_blank" rel="external">np.arange</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.arange(<span class="number">10</span>) <span class="comment">#使用指定range来创建数组 array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br><span class="line">np.arange(<span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>)  <span class="comment">#开始，终止(不包含)，步长  array([1, 3, 5, 7])</span></span><br></pre></td></tr></table></figure>
<h3 id="np-linspace"><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html#numpy.linspace" target="_blank" rel="external">np.linspace</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>) <span class="comment">#开始，终止，创建元素个数   array([ 0.    0.25  0.5   0.75  1.  ])</span></span><br><span class="line">np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>,endpoint=<span class="keyword">False</span>) <span class="comment">#endpoint这个参数控制最后一个终止值是否被包含，默认Ture，array([ 0.   0.2  0.4  0.6  0.8])</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>arange与linspace都是在指定范围内生成均匀的变量，只是前者是按步长进行生成，后者是按指定的数量进行生成</p>
</blockquote>
<h3 id="np-ones"><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ones.html#numpy.ones" target="_blank" rel="external">np.ones</a></h3><blockquote>
<p>快速生成值为1的矩阵</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">np.ones(<span class="number">5</span>)  <span class="comment">#array([ 1.,  1.,  1.,  1.,  1.])</span></span><br><span class="line">np.ones((<span class="number">2</span>,<span class="number">2</span>)) <span class="comment">#生成一个2x2的值为1的矩阵</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">array([[ 1.,  1.],</span><br><span class="line">       [ 1.,  1.]])</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure>
<h3 id="np-zeros"><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.zeros.html#numpy.zeros" target="_blank" rel="external">np.zeros</a></h3><blockquote>
<p>快速生成值为1的矩阵</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">np.zeros(<span class="number">5</span>) <span class="comment">#array([ 0.,  0.,  0.,  0.,  0.])</span></span><br><span class="line">np.zeros((<span class="number">2</span>,<span class="number">2</span>)) <span class="comment">#生成一个2x2的值为0的矩阵</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">array([[ 0.,  0.],</span><br><span class="line">       [ 0.,  0.]])</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure>
<h3 id="np-eye"><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.eye.html#numpy.eye" target="_blank" rel="external">np.eye</a></h3><blockquote>
<p>快速生成值为1的对角矩阵</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">np.eye(<span class="number">3</span>)</span><br><span class="line"><span class="string">"""</span><br><span class="line">[[ 1.  0.  0.]</span><br><span class="line"> [ 0.  1.  0.]</span><br><span class="line"> [ 0.  0.  1.]]</span><br><span class="line">"""</span></span><br><span class="line"></span><br><span class="line">np.eye(<span class="number">3</span>,k=<span class="number">1</span>)  <span class="comment">#这里的k可以指定对角的索引位置 默认是0，也就是真正的对角</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">[[ 0.  1.  0.]</span><br><span class="line"> [ 0.  0.  1.]</span><br><span class="line"> [ 0.  0.  0.]]</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure>
<h3 id="np-diag"><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.diag.html#numpy.diag" target="_blank" rel="external">np.diag</a></h3><blockquote>
<p>提取普通矩阵的对角</p>
<ul>
<li>若普通矩阵是1维矩阵，则直接将该1维矩阵转为对角矩阵</li>
<li>若普通矩阵是2维矩阵，则提取该对角线(k)的矩阵并返回一个1维矩阵</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">np.diag(np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]))  <span class="comment">#将4x1的矩阵转为只有对角线上有值的方正</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">[[1 0 0 0]</span><br><span class="line"> [0 2 0 0]</span><br><span class="line"> [0 0 3 0]</span><br><span class="line"> [0 0 0 4]]</span><br><span class="line">"""</span></span><br><span class="line"></span><br><span class="line">np.diag(np.ones((<span class="number">3</span>,<span class="number">3</span>))) <span class="comment">#提取对角线上的元素 转为了1维矩阵 [ 1.  1.  1.]</span></span><br><span class="line"><span class="comment">#若继续想要对角方正，则需呀再一次转换</span></span><br><span class="line">np.diag(np.diag(np.ones((<span class="number">3</span>,<span class="number">3</span>))))</span><br><span class="line"><span class="string">"""</span><br><span class="line">[[ 1.  0.  0.]</span><br><span class="line"> [ 0.  1.  0.]</span><br><span class="line"> [ 0.  0.  1.]]</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure>
<h3 id="矩阵的四则运算">矩阵的四则运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a=np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)  <span class="comment">##0~8的3x3矩阵</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">array([[0, 1, 2],</span><br><span class="line">       [3, 4, 5],</span><br><span class="line">       [6, 7, 8]])</span><br><span class="line">"""</span></span><br><span class="line"></span><br><span class="line">b=np.array(range(<span class="number">9</span>)[::-<span class="number">1</span>]).reshape(<span class="number">3</span>,<span class="number">3</span>)  <span class="comment">##8~0的3x3矩阵</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">array([[8, 7, 6],</span><br><span class="line">       [5, 4, 3],</span><br><span class="line">       [2, 1, 0]])</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure>
<p>加减乘除都可以按这个走<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a+<span class="number">1</span> <span class="comment">#在每个元素上+1</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">array([[1, 2, 3],</span><br><span class="line">       [4, 5, 6],</span><br><span class="line">       [7, 8, 9]])</span><br><span class="line">"""</span></span><br><span class="line">a+b <span class="comment">#两个矩阵相加</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">array([[8, 8, 8],</span><br><span class="line">       [8, 8, 8],</span><br><span class="line">       [8, 8, 8]])</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure></p>
<p>还可以做幂次方<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a**<span class="number">2</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">array([[ 0,  1,  4],</span><br><span class="line">       [ 9, 16, 25],</span><br><span class="line">       [36, 49, 64]])</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure></p>
<p>还可以倒着运算<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>**a</span><br><span class="line">array([[  <span class="number">1</span>,   <span class="number">2</span>,   <span class="number">4</span>],</span><br><span class="line">       [  <span class="number">8</span>,  <span class="number">16</span>,  <span class="number">32</span>],</span><br><span class="line">       [ <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>]])</span><br></pre></td></tr></table></figure></p>
<h3 id="summary">summary</h3><ol>
<li>关于取值，还是按[index]的方式即可取</li>
<li>还有很方便的函数：<ul>
<li>求和:sum</li>
<li>转置：T</li>
<li>最大最小：max,min</li>
<li>方差：var,标准差：std</li>
<li>均值：mean</li>
</ul>
</li>
</ol>
<h2 id="random">random</h2><blockquote>
<p>用于产生强大的随机数呀,并且可以指定具体的矩阵形状</p>
</blockquote>
<h3 id="np-random-rand"><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.rand.html#numpy.random.rand" target="_blank" rel="external">np.random.rand</a></h3><blockquote>
<p>产生均匀的0~1之间的随机数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">np.random.rand(<span class="number">4</span>) <span class="comment">#生成1x4的随机矩阵 array([ 0.78374518,  0.64304815,  0.01667375,  0.50154654])</span></span><br><span class="line">np.random.rand(<span class="number">2</span>,<span class="number">3</span>)  <span class="comment">#生成2x3的随机矩阵</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">array([[ 0.20500983,  0.66468726,  0.55619774],</span><br><span class="line">       [ 0.37256962,  0.86550713,  0.05781776]])</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure>
<h3 id="np-random-randn"><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randn.html#numpy.random.randn" target="_blank" rel="external">np.random.randn</a></h3><blockquote>
<p>生成服从高斯分布的随机矩阵</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">np.random.randn(<span class="number">4</span>)  <span class="comment">#生成N(0,1)分布的的1x4的矩阵 array([ 0.72481524, -0.1976192 , -0.48224937, -0.8019294 ])</span></span><br><span class="line"><span class="comment">#如果想执行方差和均值的话，可以这么干sigma * np.random.randn(...) + mu</span></span><br><span class="line"><span class="number">2.5</span> * np.random.randn(<span class="number">2</span>, <span class="number">4</span>) + <span class="number">3</span>  <span class="comment">#比如这个就是服从N~(3,6.25)的高斯分布</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">array([[ 5.2147326 ,  0.90325509,  1.39212656,  5.97713821],</span><br><span class="line">       [-0.26270206,  3.09619677,  2.21054634,  2.94103359]])</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2><ul>
<li><a href="http://docs.scipy.org/doc/numpy/genindex.html" target="_blank" rel="external">numpy api</a></li>
<li><a href="http://www.scipy-lectures.org/" target="_blank" rel="external">http://www.scipy-lectures.org/</a>  其实上面写的这里都有-_-</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><code>numpy</code>这个科学计算工具大法好，但是里面的东西不用老是会忘，所以在此记录常用的一些语法，以备之后查询之用（也叫懒人模式）^_^,不过详细的使用方法还是得看<a href="http://docs.scipy.org/doc/">scipy api</a></p>
</blockquote>
<p>使用之前首先得引入包<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure></p>
<h2 id="array">array</h2><p><code>np.array</code>实现了真正的数组，在<code>numpy</code>中其实就是矩阵啦，同时提供了丰富的矩阵计算方法<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yyl8781697.github.io/tags/Python/"/>
    
      <category term="Python" scheme="http://yyl8781697.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Scala中Iterator中size/length的一个坑]]></title>
    <link href="http://yyl8781697.github.io/2015/09/19/Scala/Scala-Iterator-Size-Length-Keng/"/>
    <id>http://yyl8781697.github.io/2015/09/19/Scala/Scala-Iterator-Size-Length-Keng/</id>
    <published>2015-09-19T02:36:42.000Z</published>
    <updated>2015-09-19T04:18:46.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><code>Scala</code>语言是出了名的语法诡异，功能强大-_-，他的<code>Iterator</code>也是如此，还提供了亲民心的<code>size/length</code>方法，但是，但是，但是慎用!!</p>
</blockquote>
<p>事情是这样的</p>
<pre><code>今天在做这个：进行采样，在mapPartitions中操作，会传来一个Iterator迭代器，里面存着原始数据，我需要做的大概是先统计迭代器中的数量<span class="keyword">N</span>（使用size方法来做），然后计算出一个需要采样的量<span class="keyword">n</span>,然后遍历(直接<span class="keyword">for</span>来做)这个迭代器，按自己的业务采样<span class="keyword">n</span>个记录！
</code></pre><p>清晰明了的一个程序,这尼玛最终采样的变量一直是空，一直是空，一直是空。<br>起初还以为是概率那块算错了，导致采不出来，但是单独把程序剥离出来<code>debuge</code>发现这个<code>for</code>压根没数据，但是明明这个迭代器的里面的<code>size</code>是有值的啊，奇了怪了。。。<br><a id="more"></a></p>
<p>后来发现问题就是处在这个<code>size</code>方法。。</p>
<p><code>Iterator</code>大致是满足如下继承关系的:<br><code>AbstractIterator-&gt;Iterator-&gt;TraversableOnce-&gt;GenTraversableOnce</code></p>
<p>在<code>TraversableOnce</code>这个<code>trait</code>中对<code>size</code>方法进行了实现，<br>现在来看源码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span>:</span> <span class="type">Int</span> = &#123;</span><br><span class="line"><span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (x &lt;- self) result += <span class="number">1</span>   <span class="comment">//额，它的计数是直接遍历得来的..</span></span><br><span class="line">result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Iterator</code>这个<code>trait</code>中对<code>length</code>方法进行了实现，<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Returns the number of elements in this iterator.</span><br><span class="line">*  $willNotTerminateInf</span><br><span class="line">*</span><br><span class="line">*  @note Reuse: $consumesIterator</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">length</span>:</span> <span class="type">Int</span> = <span class="keyword">this</span>.size</span><br></pre></td></tr></table></figure></p>
<p>可以发现<code>size/length</code>是通过遍历迭代器累加来计数的，这样就是导致使用了<code>size/length</code>之后就无法再取迭代器里面的值，然后就出现了上述<code>for</code>根本无法进入。。-_-||</p>
<p>然后就会出现这样的测试结果<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">it=List</span>(</span><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).iterator</span><br><span class="line"><span class="type">System</span>.out.println(it.size);</span><br><span class="line"><span class="type">System</span>.out.println(it.size);</span><br></pre></td></tr></table></figure></p>
<pre><code>4
0
</code></pre><p>这是因为<code>collection.iterator</code>会产生一个新的迭代器实例<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="comment">/*IterableLike*/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iterator</span>:</span> <span class="type">Iterator</span>[<span class="type">A</span>] = <span class="keyword">new</span> <span class="type">AbstractIterator</span>[<span class="type">A</span>] &#123;</span><br><span class="line"><span class="keyword">var</span> these = self</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>:</span> <span class="type">Boolean</span> = !these.isEmpty</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next</span>(</span>): <span class="type">A</span> =</span><br><span class="line">  <span class="keyword">if</span> (hasNext) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">result</span> =</span> these.head; these = these.tail; result</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="type">Iterator</span>.empty.next</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Have to clear `these` so the iterator is exhausted like</span><br><span class="line"> *  it would be without the optimization.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toList</span>:</span> <span class="type">List</span>[<span class="type">A</span>] = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">xs</span> =</span> these.toList</span><br><span class="line">  these = newBuilder.result</span><br><span class="line">  xs</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一次<code>size</code>完了之后就已经将该迭代器遍历掉了-_-</p>
<blockquote>
<p>个人感觉<code>Iterator.size</code>这个方法简直是一个坑，还不如像<code>java</code>一样不提供该方法，所以慎用慎用..</p>
</blockquote>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><code>Scala</code>语言是出了名的语法诡异，功能强大-_-，他的<code>Iterator</code>也是如此，还提供了亲民心的<code>size/length</code>方法，但是，但是，但是慎用!!</p>
</blockquote>
<p>事情是这样的</p>
<pre><code>今天在做这个：进行采样，在mapPartitions中操作，会传来一个Iterator迭代器，里面存着原始数据，我需要做的大概是先统计迭代器中的数量<span class="keyword">N</span>（使用size方法来做），然后计算出一个需要采样的量<span class="keyword">n</span>,然后遍历(直接<span class="keyword">for</span>来做)这个迭代器，按自己的业务采样<span class="keyword">n</span>个记录！
</code></pre><p>清晰明了的一个程序,这尼玛最终采样的变量一直是空，一直是空，一直是空。<br>起初还以为是概率那块算错了，导致采不出来，但是单独把程序剥离出来<code>debuge</code>发现这个<code>for</code>压根没数据，但是明明这个迭代器的里面的<code>size</code>是有值的啊，奇了怪了。。。<br>]]>
    
    </summary>
    
      <category term="Scala" scheme="http://yyl8781697.github.io/tags/Scala/"/>
    
      <category term="Scala" scheme="http://yyl8781697.github.io/categories/Scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python里面的一些小记（方便自己查询）]]></title>
    <link href="http://yyl8781697.github.io/2015/09/12/Python/python-little-memory/"/>
    <id>http://yyl8781697.github.io/2015/09/12/Python/python-little-memory/</id>
    <published>2015-09-12T01:37:18.000Z</published>
    <updated>2015-12-12T01:47:49.000Z</updated>
    <content type="html"><![CDATA[<pre><code><span class="keyword">python</span>相当方便，有问题可以直接查Doc，但是Doc略有繁琐，所以在词记下常用的一些技巧以及bug解决方案^_^
</code></pre><h2 id="判断字符串的一些东西">判断字符串的一些东西</h2><blockquote>
<p>当然下面的判断完全可以自己使用正则表达式来些，但是有一句话是<code>杀鸡焉用牛刀</code>,下面的api使用起来就会非常便捷</p>
</blockquote>
<p><code>s</code>为字符串</p>
<ol>
<li><code>s.isalnum()</code> 所有字符都是数字或者字母</li>
<li><code>s.isalpha()</code> 所有字符都是字母</li>
<li><code>s.isdigit()</code> 所有字符都是数字</li>
<li><code>s.islower()</code> 所有字符都是小写</li>
<li><code>s.isupper()</code> 所有字符都是大写</li>
<li><code>s.istitle()</code> 所有单词都是首字母大写，像标题</li>
<li><code>s.isspace()</code> 所有字符都是空白字符、<code>\t</code>、<code>\n</code>、<code>\r</code></li>
</ol>
<h3 id="下面应该回持续更新">下面应该回持续更新</h3>]]></content>
    <summary type="html">
    <![CDATA[<pre><code><span class="keyword">python</span>相当方便，有问题可以直接查Doc，但是Doc略有繁琐，所以在词记下常用的一些技巧以及bug解决方案^_^
</code></pre><h2 id="判断字符串的一些东西">判断字符串的一些]]>
    </summary>
    
      <category term="Python" scheme="http://yyl8781697.github.io/tags/Python/"/>
    
      <category term="Python" scheme="http://yyl8781697.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《台大机器学习基石》Validation]]></title>
    <link href="http://yyl8781697.github.io/2015/09/07/Machine%20Learning/Validation/"/>
    <id>http://yyl8781697.github.io/2015/09/07/Machine Learning/Validation/</id>
    <published>2015-09-07T15:32:37.000Z</published>
    <updated>2015-09-10T13:21:06.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Model_Select_problem">Model Select problem</h2><p>在机器学习的世界里面有非常多的模型（基石这个课暂时只讲了<a href="http://kubicode.me/2015/08/06/Machine%20Learning/Perceptron-Learning-Algorithm/" target="_blank" rel="external">Perceptron Learning Algorithm</a>，<a href="http://kubicode.me/2015/08/19/Machine%20Learning/Linear-Regression/" target="_blank" rel="external">Linear Regression</a>,<a href="http://kubicode.me/2015/08/21/Machine%20Learning/Logistic-Regression/" target="_blank" rel="external">Logistic Regression</a>），各个模型也会有自己不同的特点，有各自长处，也有各自的短处,并且除模型之外，还有其他的附属选择，比如<a href="http://kubicode.me/2015/09/05/Machine%20Learning/Regularization/" target="_blank" rel="external">Regularization</a>的类型，或者具体参数的值，比如<a href="http://kubicode.me/2015/08/21/Machine%20Learning/Logistic-Regression/#Gradient_Descent" target="_blank" rel="external">Gradient Descent</a>里面的步长等，我们知道，现在机器学习的目的就是得到最小化的<code>E<sub>out</sub></code>（也就是测试误差啦），那么现在给你一批数据，然后会出现上述那么多的选择，如果做才能得到最小的<code>E<sub>out</sub></code>呢？<br><img src="/img/Validation/goal.png" height="200px" width="500px"><br>也就是我们要找到一个最好的模型<code>H<sub>m<sup><em></em></sup></sub></code>，使得<code>E<sub>out</sub>(g<sub>m<sup></sup></sub>)</code>最小。<br><a id="more"></a></p>
<p>看到<code>E<sub>out</sub></code>首先联想到得就是<code>E<sub>in</sub></code>，根据<a href="http://kubicode.me/2015/08/15/Machine%20Learning/VC-Dimension/#VC_Bound" target="_blank" rel="external">VC Bound</a>可以知道,样本空间存在有限的break point，并且采样的资料量N够多的时候，有一个很大的概率<code>E<sub>out</sub></code>与<code>E<sub>in</sub></code>会很相似，但是又根据VC维中的模型复杂图可以看到，到VC维很高时（模型会很复杂），此时的<code>E<sub>in</sub></code>会很小，但是<code>E<sub>out</sub></code>就会很大了，这样就会出现了<code>BAD Regularization</code></p>
<pre><code>这里好比一个<span class="number">1126</span>次的多项式的E<span class="keyword">in</span>总是能低于<span class="number">1</span>次的多项式-_-，但是其E<span class="keyword">out</span>就不一定了
</code></pre><p>所以说只使用<code>E<sub>in</sub></code>最小化来选择模型并不是很靠谱，因为不能保证得到一个最小的<code>E<sub>out</sub></code>-_-||</p>
<p>现在再来思考一下，假如我们能够得到测试数据的误差<code>E<sub>test</sub></code>,那么<code>E<sub>out</sub></code>会不会与之很相似呢？<br>关于这个问题<code>Hoeffding</code>不等式又可以出来证明了<br><img src="/img/Validation/hof.png" height="150px" width="400px"> 1-2<br>这里的<code>M</code>表示可以进行模型选择的数量，<code>N<sub>test</sub></code>表示预测样本的数量，通过上面的不等式可以看到当预测样本足够大，可选模型足够少的时候，<code>E<sub>test</sub></code>和<code>E<sub>out</sub></code>是很就近的。<br>那么问题来了：关于这个测试样本如何得到？？？这是一个比较大的问题<br>先来看<code>E<sub>in</sub></code>和<code>E<sub>test</sub></code>这两者的对比<br><img src="/img/Validation/cbee.png" height="250px" width="500px"><br>可以发现：</p>
<ul>
<li><code>E<sub>in</sub></code>表示数据比较容易获取，但是可以变相得看做在原有数据集上训练完了 又在该数据库测试了一遍</li>
<li><code>E<sub>test</sub></code>测试数据比较难获取，但是一旦得到的测试数据都市无污染的，没有被训练过（也就是没有哎呦）</li>
</ul>
<p>所以这里又想了一种比较折中的方式<br><img src="/img/Validation/sib.png" height="250px" width="450px"><br>这个折中的方式就是使用现有的训练样本来进行测试，但是这个训练样本是没有被训练过， 这里叫做评估/验证的误差<code>E<sub>val</sub></code>,这中方式的具体做法就是将训练样本分为两部分，一本分用于训练，另一个部分用于测试，通过这种方式就可以有效的选择。</p>
<h2 id="Validation_Error">Validation Error</h2><p>现在假设总资料有<code>N</code>，切出<code>K</code>份来作为验证集，这样关于这个式子就可以有<br><img src="/img/Validation/cv.png" height="250px" width="500px"><br>（ps:其中D表示所有的数据集,<code>g<sub>m</sub></code>为我们需要的目标函数）<br>这样的话：</p>
<ol>
<li><code>D<sub>val</sub></code>表示验证数据集，并且是比较容易得到的</li>
<li>在<code>K</code>合适的情况下<code>E<sub>val</sub></code>与<code>E<sub>out</sub></code>是很接近的</li>
<li><code>D<sub>val</sub></code>数据从训练数据中剥离出来，并且是没有训练过</li>
</ol>
<p>那么根据上面的式子1-2 可以有<br><img src="/img/Validation/fhof.png" height="150px" width="400px"><br>(其中式子里面带减号是为了表示当前训练的数据集并不是全集，而是除去了切出去之后剩余的训练集)</p>
<p>按照上面的思路，我们只需要求<code>E<sub>val</sub></code>的最小化即可<br>在通过比较最小化的<code>E<sub>val</sub></code>之后得到的模型其实并不是我们需要的最终的模型，因为该模型是在部分数据集上训练得到的，接下来我们还可以将该模型在全集上再次训练出一个新的模型<br><img src="/img/Validation/Eout.png" height="250px" width="400px"><br>根据<a href="http://kubicode.me/2015/09/01/Machine%20Learning/Overfitting/#The_Role_of_Noise_and_Data_Size" target="_blank" rel="external">数据集的学习曲线</a>可以了解到 全集训练出模型的<code>E<sub>out</sub></code>将会更加小</p>
<p>所以我们最终产生一个最优模型的学习流程应该是这样的<br><img src="/img/Validation/process.png" height="400px" width="400px"> </p>
<ol>
<li>将数据集<code>D</code>分为两份，训练集叫做<code>D<sub>train</sub></code>，验证集叫做<code>D<sub>val</sub></code></li>
<li>将训练集<code>D<sub>train</sub></code>输入到各个模型中<code>H<sub>m</sub></code>得到各自的<code>g<sup>-</sup><sub>m</sub></code>（也就是模型模型训练之后得到的）</li>
<li>将这些训练出来的<code>g<sup>-</sup><sub>m</sub></code>通过验证集<code>D<sub>val</sub></code>来进行一个验证误差计算<code>E<sub>m</sub></code></li>
<li>将得到<code>E<sub>m</sub></code>最小的模型<code>H<sub>m<sup>*</sup></sub></code>再次输入到全部数据集中进行一个训练</li>
<li>最终输出全集上的训练得到<code>g<sub>m<sup>*</sup></sub></code>的结果</li>
</ol>
<p>这样将上面提到的几个概念连起来之后有<br><img src="/img/Validation/tog.png" height="150px" width="500px"> </p>
<p>现在来对比一下刚刚提到几种最优模型的选择方法<br><img src="/img/Validation/compare.png" height="300px" width="300px"> 2-6<br>其中横轴表示验证数据集<code>K</code>的大小，纵轴表示<code>E<sub>out</sub></code>的大小，从图中可以看到</p>
<ul>
<li>黑色的实线表示通过<code>E<code>in</code></code>来选择的模型，因为它是在全集上进行的计算，所以总是和验证集的大小没关系，故为一条直线</li>
<li>黑色的虚线表示直接在测试集上根据其误差选择的模型，测试集都给你了。。。当然能选择较好的模型，但是这种事情一般都是不现实的。。</li>
<li>红色的线表示根据<code>E<sub>val</sub></code>进行模型的选择，但是最终给的模型仍然是在除验证集的训练集上训练得出的</li>
<li>蓝色的线表示根据<code>E<sub>val</sub></code>进行模型的选择，但是最终给的模型会重新在全集上进行一次训练</li>
<li>可以发现蓝色的线总是优于红色的线，这也说明在全集的训练能将<code>E<sub>out</sub></code>降到更低</li>
<li>可以发现蓝色的线也总是低于黑色的实线，这也说明了使用<code>E<sub>val</sub></code>比<code>E<code>in</code></code>选择模型更加靠谱</li>
<li>还可以发现红色的线会在<code>K</code>到于一定程度之后会高于黑色的实线，这是因为<code>K</code>越大，而总得样本集是一定的，也就是说明能训练的样本就变少了，那么最后训练的<code>g<sup>-</sup><sub>m</sub></code>的<code>E<sub>val</sub></code>比较大了，也就会导致<code>E<sub>out</sub></code>变大</li>
</ul>
<blockquote>
<p>上图可以总结出使用<code>E<sub>val</sub></code>来选择模型是靠谱的，并且<code>E<sub>val</sub></code>大小也是相当重要的，当然是越小越好</p>
</blockquote>
<p>其实使用求<code>E<sub>val</sub></code>最小来选择模型，我们是希望<code>E<sub>val</sub></code>较小的同时可以得到一个较为相似的<code>E<sub>out</sub>(g<sup>-</sup>)</code>，那么我们也可以认为<code>E<sub>out</sub>(g<sup>-</sup>)</code>较小，同时在得到<code>E<sub>out</sub>(g<sup>-</sup>)</code>较小的同时又希望得到相似<code>E<sub>out</sub>(g)</code>,这才是模型选择的最终目的，但是这两个相似同时成立遂不如人愿啊-_-<br><img src="/img/Validation/rv.png" height="150px" width="500px"> </p>
<ol>
<li>看右侧：当<code>K</code>比较大的时候，这样才可以让<code>E<sub>val</sub></code>越准越好，也就是会越接近<code>E<sub>out</sub>(g<sup>-</sup>)</code><blockquote>
<p>但是此时的<code>E<sub>out</sub>(g<sup>-</sup>)</code>和<code>E<sub>out</sub>(g)</code>就会有较大的偏离的，从图2-6中<code>K&gt;5</code>之后，两者的偏差就会越来越大</p>
</blockquote>
</li>
<li>看左侧：当<code>K</code>比较小的时候，这样<code>E<sub>out</sub>(g<sup>-</sup>)</code>才是基于较多的训练样本训练出得模型，才能接近<code>E<sub>out</sub>(g)</code>，当<code>K=0</code>时，<code>E<sub>out</sub>(g<sup>-</sup>)=E<sub>out</sub>(g)</code></li>
</ol>
<p>那这个<code>K</code>值的选择可纠结了，该咋选呢？根据林老师的经验建议<code>K=N/5</code>比较合适，其中<code>N</code>为样本总数。</p>
<h2 id="Cross_Validation">Cross Validation</h2><p>现在考虑极端情况，当<code>K=1</code>的时候，我们去计算一个<code>E<sub>val</sub></code><br><img src="/img/Validation/en.png" height="120px" width="300px"><br>那么这个<code>e<sub>n</sub></code>会与<code>E<sub>out</sub></code>接近呢？一般一个<code>e<sub>n</sub></code>不太可能与之接近 -_-|| 想想也是~<br>那假如我们用<code>N</code>个<code>e<sub>n</sub></code>来求平均呢？每个<code>e<sub>n</sub></code>都是用不同的样本进行的校样(假设数据集中的各个样本都把不同)<br><img src="/img/Validation/ioocv.png" height="150px" width="400px"> </p>
<blockquote>
<p>这种方式就是叫做交叉验证（Cross Validation），因为里面同一个样本，有时会作为训练样本，有时会作为测试样本。<br> 在<code>K=1</code>的时候也叫<code>leave one out validation</code></p>
</blockquote>
<p>这张图就可以演示平面上三个点,现有一个一次函数和一个常量来拟合，使用交叉验证来进行选择<br><img src="/img/Validation/show.png" height="400px" width="500px"> </p>
<p> 那现在咱们只需要能证明<code>E<sub>ioocv</sub>(H,A)≈E<sub>out</sub>(g)</code>即可。<br> <img src="/img/Validation/prove.png" height="400px" width="500px"> </p>
<blockquote>
<p>我理解的大致推导的过程是,将整个对<code>Data</code>的期望拆解之后形成<code>D<sub>train</sub></code>和<code>D<sub>val</sub></code>，根据<code>E<sub>val</sub></code>推出<code>E<sup>-</sup><sub>out</sub></code>  再根据对<code>D<sub>train</sub></code>上的期望得到<code>E<sub>out</sub>(N-1)</code>的平均，再之外围的求和的平均可以抵消，结果就成了在  <code>E<sub>out</sub>(N-1)</code>的平均了。ps：当<code>K=1</code>的时候，<code>E<sup>-</sup><sub>out</sub></code> 和<code>E<sub>out</sub>(N-1)</code>很接近,同时<code>E<sub>out</sub>(N-1)</code>又会与<code>E<sub>out</sub></code>很接近，这就证明成立了。^_^</p>
</blockquote>
<h3 id="Example">Example</h3><p>到了这里，来看一个实际的例子<br><img src="/img/Validation/handwrite.png" height="300px" width="400px"><br>现在需要做一个手写体的识别，来识别是否是1，通过不同的选择方法来进行最优模型的选择<br><img src="/img/Validation/example.png" height="300px" width="400px"><br>可以发现，随着特征的增加<code>E<sub>in</sub></code>在不断的减少（这点其实很容易理解，与VC维里面的图相似），但是会发现<code>E<sub>out</sub></code>并不是一直的降低，反而特征增加到一定量之后，<code>E<sub>out</sub></code>就上升了<br>反而来看验证的误差<code>E<sub>cv</sub></code>(cv表示cross validation)，他的曲线几乎与<code>E<sub>out</sub></code>一致，并且在两者最低点的地方也很相似，最终可以分别看到用<code>E<sub>in</sub></code>和<code>E<sub>cv</sub></code>选择出来的模型<br><img src="/img/Validation/result.png" height="300px" width="500px"><br>很明显，通过交叉验证选出来的模型更加平滑，也更加不容易过拟合。^_^</p>
<h3 id="V-Fold_Cross_Validation">V-Fold Cross Validation</h3><p>上面说的使用<code>leave one out validation</code>的交叉验证来选择模型的效果虽然好，然后难免也存在以下两个主要的问题</p>
<ol>
<li>计算问题<br> 可以看到，计算一次<code>E<sub>ioocv</sub></code>,都大概需要<code>N</code>次，并且每次训练时的数据量为<code>N-1</code>,那这样整个训练的复杂度野生生的由<code>Ω(N)</code>提升到了<code>Ω(N)<sub>2</sub></code>，复杂一些的模型在数据量大一点的情况下整个训练速度已经很难控了，这么一来简直就是灾难。-_-||</li>
<li>稳定性问题<br> ps:关于这点现在还是没想通，感觉单个点测试总体平均之后应和<code>v-fold validation</code>一样的-_-，为啥就这个会有这么大的波动。。 来个高手指导下<blockquote>
<p>所以<code>leave one out validation</code>的交叉验证在实际中并不常用</p>
</blockquote>
</li>
</ol>
<p>既然有问题存在，那么如何改善呢？<br>在<code>leave one out validation</code>中，每个验证的样本只有1个，这个也未免太极端了，现在想想假如将整个样本划分为10分，每一份都轮流做一次验证集,每一轮中其余9份作为训练集，最终将求出来的10个验证集误差<code>E<sub>val</sub></code>求平均<br><img src="/img/Validation/vf.png" height="300px" width="500px"><br>这种方式在效果上其实很类似<code>leave one out validation</code>，但是在计算量上却可以大大的减少，该方式并一定是划分10份，叫做<code>v-fold cross-validation</code>，该<code>v</code>一般取5或者10的效果就已经不错了</p>
<blockquote>
<p>虽然这么看来使用<code>E<sub>val</sub></code>已经很错了，但是其实评估一个模型的好坏还是得看<code>E<sub>out</sub></code>，目的不能忘^_^</p>
</blockquote>
<h2 id="参考">参考</h2><ul>
<li>《台湾国立大学-机器学习基石》第十五讲</li>
</ul>
<p>配图均来自《台湾国立大学-机器学习基石》</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Model_Select_problem">Model Select problem</h2><p>在机器学习的世界里面有非常多的模型（基石这个课暂时只讲了<a href="http://kubicode.me/2015/08/06/Machine%20Learning/Perceptron-Learning-Algorithm/">Perceptron Learning Algorithm</a>，<a href="http://kubicode.me/2015/08/19/Machine%20Learning/Linear-Regression/">Linear Regression</a>,<a href="http://kubicode.me/2015/08/21/Machine%20Learning/Logistic-Regression/">Logistic Regression</a>），各个模型也会有自己不同的特点，有各自长处，也有各自的短处,并且除模型之外，还有其他的附属选择，比如<a href="http://kubicode.me/2015/09/05/Machine%20Learning/Regularization/">Regularization</a>的类型，或者具体参数的值，比如<a href="http://kubicode.me/2015/08/21/Machine%20Learning/Logistic-Regression/#Gradient_Descent">Gradient Descent</a>里面的步长等，我们知道，现在机器学习的目的就是得到最小化的<code>E<sub>out</sub></code>（也就是测试误差啦），那么现在给你一批数据，然后会出现上述那么多的选择，如果做才能得到最小的<code>E<sub>out</sub></code>呢？<br><img src="/img/Validation/goal.png" height="200px" width="500px" /><br>也就是我们要找到一个最好的模型<code>H<sub>m<sup><em></sup></sub></code>，使得<code>E<sub>out</sub>(g<sub>m<sup></em></sup></sub>)</code>最小。<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《台大机器学习基石》Regularization]]></title>
    <link href="http://yyl8781697.github.io/2015/09/05/Machine%20Learning/Regularization/"/>
    <id>http://yyl8781697.github.io/2015/09/05/Machine Learning/Regularization/</id>
    <published>2015-09-05T08:36:48.000Z</published>
    <updated>2015-09-08T12:37:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Regularization">Regularization</h2><p>正则化(<code>Regularization</code>)是缓解<code>Overfitting</code>非常有效的一项手段，在了解正则化之前，先来看下正则化做了什么：<br><img src="/img/Regularization/reg_target.png" height="300px" width="500px"></p>
<p>那这种正则化过程又该如何做呢？<br>其实上面图中的右侧可以看作十次多项式拟合出来的线，而左侧是由二次多项式拟合出得线(这里不了解的<a href="http://kubicode.me/2015/09/01/Machine%20Learning/Overfitting/" target="_blank" rel="external">点击我</a>)<br><a id="more"></a><br>并且我们还知道低次多项式的假设空间是包含在高次多项式中的<br><img src="/img/Regularization/contains.png" height="150px" width="250px"><br>那么也就是说我们如果能把高次的多项式慢慢退回到合适的低次多项式中，就可以缓解<code>Overfitting</code>问题</p>
<p>这里来看一下<code>H<sub>2</sub></code>和<code>H<sub>10</sub></code>的多项式关系<br><img src="/img/Regularization/h10h2.png" height="250px" width="500px"><br>可以发现<code>H<sub>2</sub></code>的多项式仅仅是在<code>H<sub>10</sub></code>添加了红色的约束即可形成</p>
<p>那这样给我们的启发是在<code>H<sub>10</sub></code>多项式退回到<code>H<sub>2</sub></code>多项式时可以加约束来操作<br>现在可以将上述的启发套用到求<code>min(E<sub>in</sub>)</code><br><img src="/img/Regularization/h10h2p.png" height="300px" width="700px"></p>
<ol>
<li>上图左侧：求<code>H<sub>10</sub></code>的<code>min(E<sub>in</sub>)</code>可以按具体模型正常求解,这样相对来说可以得到一个更小的<code>E<sub>in</sub></code></li>
<li>上图中间：求<code>H<sub>2</sub></code>的时候可以在红色约束(后面8个权重值均为0)的基础上求<code>H<sub>10</sub></code>的<code>min(E<sub>in</sub>)</code></li>
<li>上图右侧：让约束来的更加宽松一点，只要存在8个权重的值为0，这里可以用<code>H‘<sub>2</sub></code>来表示，产生的<code>hypothesis</code>也叫做<code>sparse hypothesis</code>，因为大部分权重值都为0呀^_^</li>
</ol>
<blockquote>
<p>这里就会有：<code>H<sub>2</sub> ⊂ H‘<sub>2</sub> ⊂ H<sub>10</sub></code></p>
</blockquote>
<p>现在看似求解<code>H‘<sub>2</sub></code>的<code>min(E<sub>in</sub>)</code>即可，但是遗憾的是他是一个NP难题-_-!!<br>只能继续改进了：原来在<code>H‘<sub>2</sub></code>中对不等于0的权重进行计数设定一个阈值，这个过程可以转为将权重平方和小于一个阈值来操作，这样就有了：<br><img src="/img/Regularization/hc.png" height="300px" width="250px"><br>这样就转为了一个类似的最佳化问题，并且可以解决原来<code>H‘<sub>2</sub></code>离散约束，这个<code>hypothesis</code>叫做<code>H(c)</code>,这个<code>H(c)</code>产生的权重要么非常稀疏，要么都是比较小的。<br>这样产生的权重值叫做<code>W<sub>reg</sub></code>，它也是通过<code>H(c)</code>来完成<code>Regularization</code>的优化解决方案。</p>
<p>现在使用<code>H(c)</code>的求解<code>Linear Regression</code>，将其转为矩阵形式求解为：<br><img src="/img/Regularization/lrReg.png" height="300px" width="400px"><br>则根据约束条件我们可以知道在约束下最优的解是在半径为<code>sqrt(C)</code>的球里面找到一个权重<code>w</code>使得原始的<code>E<sub>in</sub></code>最小<br>我们现在需要做的就是在条件下求最佳化问题：<br><img src="/img/Regularization/opt.png" height="300px" width="300px"></p>
<blockquote>
<p>原始问题是沿着梯度反方向滚到谷底即可，也就是椭圆中的<code>W<sub>lin</sub></code>,现在的话该点就会被限制在球内，则我们可以知道最佳点一定是在球的边缘。</p>
</blockquote>
<p>则现在<code>w</code>可以滚动的规则为：</p>
<ol>
<li>球的切面方向量的垂直方向为<code>normal</code>，但是只能往该方向的垂直方向滚动(绿色的向量)，不然就会违背了<code>w</code>在球内的约束条件</li>
<li>要往梯度的反方向滚动(蓝色的方向)，但是为了不违反在球内的条件，所以只能在梯度反方向的分量滚动，并且该方法还必须垂直于<code>normal</code></li>
</ol>
<p>所以<code>w</code>滚动的方向是梯度反方向中能垂直球的切面方向量的垂直方向（有点绕。。简单的说，就是蓝色方向与红色垂直的方向滚动），这样即可以满足在球内的约束条件，又可以进一步的优化<code>E<sub>in</sub></code>,直达梯度的反方向与求的切面方向垂直的方向平行，就达到最优了。</p>
<p>因为最终需要那两个方向是平行的，也样通过拉格朗日乘法可以将其写到一个式子里面去<br><img src="/img/Regularization/lagrange.png" height="250px" width="300px"></p>
<p>现在假设当前的模型是<code>Linear Regression</code><br><img src="/img/Regularization/par.png" height="250px" width="300px"></p>
<p>这样只需要求<code>w<sub>reg</sub></code>即可<br><img src="/img/Regularization/wreg.png" height="100px" width="300px"></p>
<p>现在延生看待这个问题的话<br><img src="/img/Regularization/lrg.png" height="350px" width="500px"><br>其中，在原始基础上添加的<code>w<sup>T</sup>w</code>称作正则项，这里的<code>λ</code>需要取正数大于等于0</p>
<blockquote>
<p>这种方式最大的优势就是将原本的阈值<code>C</code>，现在如果知道<code>λ</code>的话就可以在一个式子里面进行直接求解了</p>
</blockquote>
<p>关于<code>λ</code>产生的影响的结果图<br><img src="/img/Regularization/lamdba.png" height="300px" width="700px"><br>可以发现</p>
<ol>
<li><code>λ</code>如果不加的会产生<code>Overfitting</code></li>
<li><code>λ</code>加一点点就可以缓解<code>Overfitting</code></li>
<li>但是<code>λ</code>加太多的话会产生<code>underfitting</code></li>
</ol>
<p>这种正则化的方式叫做<code>weight-decay</code>，会把权重值变小（因为球面上权重向量的各个值都会比较小^_^）。</p>
<h2 id="Regularization_and_VC_theory">Regularization and VC theory</h2><p>通过求带有约束的<code>E<sub>in</sub></code>可以相继得到<code>augmented Error</code>和<code>VC Bound</code><br><img src="/img/Regularization/vct.jpg" height="400px" width="500px"></p>
<blockquote>
<p>这里在最优化<code>augmented Error</code>的同时其实在间接的求<code>VC Bound</code></p>
</blockquote>
<p>再来看一下他们俩的区别：</p>
<ul>
<li><code>augmented Error</code>它的正则项<code>w<sup>T</sup>w=Ω(W)</code>是表示一个<code>hypothesis</code>的复杂程度</li>
<li><code>VC Bound</code>的<code>Ω(H)</code>是表示整个<code>hypothesis set</code>的复杂程度</li>
</ul>
<p>那么如果<code>λ/N*Ω(W)</code>与<code>Ω(H)</code>之间存在关联的话，就可以说最小化<code>E<sub>aug</sub></code>是比通过<code>E<sub>in</sub></code>来求<code>E<sub>out</sub></code>的更好的一个代理</p>
<p>再来看具体的一个模型复杂度的一个问题<br><img src="/img/Regularization/complex.png" height="200px" width="400px"></p>
<ul>
<li>原始求<code>E<sub>in</sub></code>他需要的VC复杂度为<code>d<sub>vc</sub>(H)=d+1</code>，需要在整个<code>hypothesis set</code>中找</li>
<li>在<code>E<sub>aug</sub></code>中他是被限制在了<code>H(C)</code>中，所以所需的VC复杂度为<code>d<sub>vc</sub>(H(C))=d<sub>EFF</sub>(H,min E<sub>aug</sub>)</code>,他只考虑了<code>w</code>比较小的情况</li>
</ul>
<blockquote>
<p>所以<code>E<sub>aug</sub></code>有效的VC复杂度要比原来的<code>E<sub>in</sub></code>小很多</p>
</blockquote>
<h2 id="L2_VS_L1_Regularization">L2 VS L1 Regularization</h2><p>上面提到的<code>||W||<sup>2</sup></code>的正则化称为<code>L2 Regulariation</code>,这里再来看一个 <code>L1 Regularization</code><br><img src="/img/Regularization/l1l2.png" height="400px" width="700px"><br><code>L1 Regularization</code>主要是在原始<code>E<sub>in</sub></code>上添加了权重向量的绝对值求和<code>||W||<sub>1</sub></code>,它可以产生更为稀疏的权重值，因为<code>||W||<sub>1</sub></code>在多维中可以看做菱形体，根据上面求球体最优的方法，在上面提到的最有约束中我们可以知道w滚动的方向是菱形体法向量垂直的方法（该垂直方向是梯度方向的一个放量），直到滚到菱形体角上的时候，该垂直方向将与梯度方向平行，也就是到了最优，而菱形体角上各个权重的值会是比较稀疏的，也就是说<code>L1 Regularization</code>可以将特征稀疏化（特征稀疏化可以减少存储空间，又可以加快计算速度，只是。。这个稀疏化很不方便优化）。</p>
<p>参考上图对比一下<code>L2 Regulariation</code>和<code>L1 Regulariation</code>：</p>
<ul>
<li><code>L2 Regulariation</code>：凸函数，可以求导，并且很方便优化，最后通过正则化之后得到权重值都会偏小</li>
<li><code>L1 Regulariation</code>：凸函数，但是角上无法求导，也就是说优化比较难，通过正则化之后得到的权重值比较稀疏，对于计算和存储都是很大的优势。</li>
</ul>
<blockquote>
<p>关于<code>E<sub>aug</sub></code>中正则项的<code>λ</code>参数的取值最好是按照噪声大小来定^_^</p>
</blockquote>
<h2 id="参考">参考</h2><ul>
<li>《台湾国立大学-机器学习基石》第十四讲</li>
</ul>
<p>配图均来自《台湾国立大学-机器学习基石》</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Regularization">Regularization</h2><p>正则化(<code>Regularization</code>)是缓解<code>Overfitting</code>非常有效的一项手段，在了解正则化之前，先来看下正则化做了什么：<br><img src="/img/Regularization/reg_target.png" height="300px" width="500px" /></p>
<p>那这种正则化过程又该如何做呢？<br>其实上面图中的右侧可以看作十次多项式拟合出来的线，而左侧是由二次多项式拟合出得线(这里不了解的<a href="http://kubicode.me/2015/09/01/Machine%20Learning/Overfitting/">点击我</a>)<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《台大机器学习基石》Overfitting]]></title>
    <link href="http://yyl8781697.github.io/2015/09/01/Machine%20Learning/Overfitting/"/>
    <id>http://yyl8781697.github.io/2015/09/01/Machine Learning/Overfitting/</id>
    <published>2015-09-01T15:24:58.000Z</published>
    <updated>2015-09-03T16:44:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="What_is_Overfitting">What is Overfitting</h2><p>假设现在我们使用一个二次函数随机产生几个点，并且加入非常少量的噪声，然后使用一个四次函数来进行拟合<br>将得到如下的结果<br><img src="/img/Overfitting/4fit2.png" height="240px" width="240px"><br>可以发现4次函数可以完全拟合含有噪声的2次函数产生的点，也就是拟合出来的<code>E<sub>in</sub>=0</code>，但是此时如果使用新的2次函数的点用这个4次的拟合函数来进行预测的话，可以发现<code>E<sub>out</sub></code>会很高，<br>这种低<code>E<sub>in</sub></code>高<code>E<sub>out</sub></code>就是叫做泛化能力差(<code>BAD generalization</code>)，也是往往我们在做训练预测时不希望看到的。<br><a id="more"></a></p>
<p>此时再来回顾一下VC维中经典的一张图<br><img src="/img/Overfitting/vc.png" height="240px" width="240px"><br>可以看到VC维在<code>d<sup>*</sup><sub>vc</sub></code>的时候可以有最小的<code>E<sub>out</sub></code><br>但是在<code>d<sup>*</sup><sub>vc</sub></code>的右侧，可以发现VC维在不断增大时，<code>E<sub>in</sub></code>不断减小，但是<code>E<sub>out</sub></code>会不断增大，这种就是过拟合了（<code>Overfitting</code>）</p>
<blockquote>
<p>其实在<code>d<sup>*</sup><sub>vc</sub></code>的左侧叫做欠拟合<code>underfitting</code>，这种情况一般通过增加特征或者向高维映射来进行解决，但是<code>Overfitting</code>是由于一般是VC维太大造成的，不容易解决</p>
</blockquote>
<p><code>Overfitting</code>产生的主要原因有</p>
<ol>
<li>使用了太多的VC维，也就是模型太复杂了（类似刚刚用4次方的线）</li>
<li>噪声<code>Nosie</code>太多，这些噪声都被训练函数给拟合学习了</li>
<li>数据量太少</li>
</ol>
<h2 id="The_Role_of_Noise_and_Data_Size">The Role of Noise and Data Size</h2><p>以二维平面上的函数为例，现在平面上有这么一些点：</p>
<ol>
<li>一种是以十次多项式产生的点，但是加上了一些噪声</li>
<li>另一种时以五十次多项式产生的店，但是没有噪声</li>
</ol>
<p><img src="/img/Overfitting/case1.png" height="300px" width="500px"><br>分别使用一个二次多项式(<code>H<sub>2</sub></code>)和一个十次多项式<code>H<sub>10</sub></code>用回归的方式去拟合这两个平面上的点</p>
<p>最终拟合得结果为<br><img src="/img/Overfitting/case2.png" height="350px" width="500px"><br>从两个平面上均可以惊奇的发现：</p>
<ul>
<li><code>H<sub>2</sub></code>的<code>E<sub>in</sub></code>比<code>H<sub>10</sub></code>的大，但是在<code>E<sub>out</sub></code>却比<code>H<sub>10</sub></code>小的多</li>
<li><code>H<sub>10</sub></code>的<code>E<sub>in</sub></code>可以做到很小，但是观察图<code>H<sub>10</sub></code>在图上的高低之处正好与原图相反</li>
</ul>
<blockquote>
<p>也就是说从<code>H<sub>2</sub></code>切换到<code>H<sub>10</sub></code>时，<code>E<sub>in</sub></code>变小了，但是<code>E<sub>out</sub></code>增加了，也就是此时发生了<code>Overfitting</code></p>
</blockquote>
<p>这里比较有意思的是原来是十次项产生的点用十次项的线来拟合，该<code>E<sub>out</sub></code>竟然比二次项的线要高很多-_-，这是为何呢？？</p>
<p>可以看看这两个多项式的学习曲线（这个是针对<code>Liner Regression</code>）<br><img src="/img/Overfitting/curves.png" height="300px" width="500px"><br>其中：</p>
<ol>
<li>当样本量无限多的时候，<code>E<sub>in</sub></code>会接近于<code>E<sub>out</sub></code>，否在在有限样本时，<code>E<sub>in</sub></code>总小于<code>E<sub>out</sub></code>，因为训练出来的线总是往训练样本靠拢，这样在预测样本上的时候这个靠拢的距离就会变大。</li>
<li>随着样本量的增加，<code>E<sub>in</sub></code>会慢慢增加，但是<code>E<sub>out</sub></code>会慢慢减少</li>
<li>当样本量较少的时候(也就是左边的区域)，这里随着<code>E<sub>in</sub></code>的减少，<code>E<sub>out</sub></code>会增加，也就是出现了<code>Overfitting</code>的情况，应该就是出现了<code>Overfitting</code>的情况，只是左侧的图(十次多项式)更加明显而已</li>
</ol>
<blockquote>
<p>所以啊，可以看出使用简单的模型有多重要^_^</p>
</blockquote>
<p>这里再来进一步进行一些<code>Overfitting</code>的实验<br>现在有一个多项次函数和高斯噪声产生的点<br><img src="/img/Overfitting/yf.png" height="200px" width="300px"><br>有三个参数：</p>
<ol>
<li><code>σ<sup>2</sup></code>表示高斯噪声的强度</li>
<li><code>Q<sub>f</sub></code>表示目标多项次函数的复杂度(比如50次多项式 就是<code>Q<sub>f</sub>=50</code>)</li>
<li><code>N</code>表示训练数据量的大小</li>
</ol>
<p>还是用<code>H<sub>2</sub></code>(<code>g<sub>2</sub></code>)和<code>H<sub>10</sub></code>(<code>g<sub>10</sub></code>)进行实验，根据上一个实验的经验，这里肯定成立的是<code>E<sub>in</sub>(g<sub>10</sub>)&lt;E<sub>in</sub>(g<sub>2</sub>)</code>,现在设定<code>Overfitting</code>的度量为<code>E<sub>out</sub>(g<sub>10</sub>)-E<sub>out</sub>(g<sub>2</sub>)</code>，如果这个差值越大，说明<code>Overfitting</code>得越厉害。</p>
<p>那这样直接看实验结果图</p>
<blockquote>
<p>这里横纵坐标是用上面三个参数中选的，还有平面上的颜色表示<code>Overfitting</code>的程度，也就是右侧的那个小纵条，越往上升，<code>Overfitting</code>得越厉害（度量的差值越大）。</p>
</blockquote>
<p>先来看噪声强度<code>σ<sup>2</sup></code>和样本数量<code>N</code>对<code>Overfitting</code>的影响<br><img src="/img/Overfitting/isv.png" height="250px" width="250px"><br>从图中可以看到：</p>
<ul>
<li>样本数量越少，噪声强度越大的时候，<code>Overfitting</code>得越厉害</li>
<li>样本数量越多，噪声强度越小的时候，<code>Overfitting</code>的程度很轻<blockquote>
<p>恩，这想想也是，结果挺合理的^_^</p>
</blockquote>
</li>
</ul>
<p>再来看看一张比较扭曲的图：目标多项次函数的复杂度<code>Q<sub>f</sub></code>和样本数量<code>N</code>对<code>Overfitting</code>的影响<br><img src="/img/Overfitting/iqv.png" height="250px" width="250px"><br>其实这张图大致上和上面的趋势是一直的，只不过在较少样本同时在较小的复杂度情况下也可以得到较小的<code>Overfitting</code>。</p>
<blockquote>
<p>额。。。这个原因我也不是很了解，先去问问其他大神！！</p>
</blockquote>
<p>上面两个图中的纵坐标中：</p>
<ol>
<li>高斯噪声也叫做随机噪声(<code>stochastic noise</code>)</li>
<li>目标的复杂度也叫做确定性噪声(<code>deterministic nosie</code>)<br> 这个怎么说呢，比如一个十次项的目标函数产生的点，用一个二次项来拟合，那么这些点中必定有一些是在二次项之外的，那这不就是噪声了嘛，所以这个噪声是可以计算出来的</li>
</ol>
<p>他们俩都会对<code>Overfitting</code>都会有影响，并且影响都很类似，不过差别就是<code>deterministic nosie</code>和训练的模型是有改关的。</p>
<h2 id="Solution_for_Overfitting">Solution for Overfitting</h2><p>既然了解了<code>Overfitting</code>出现的原因以及导致的后果，那咱们该如何处理呢？大致有以下几种方法</p>
<ol>
<li>使用简单的模型<br> 根据之前VC维的理论，简单的模型VC维较低，可以得到较低的<code>E<sub>int</sub></code></li>
<li>剪枝或者数据清洗<br> 其实是为了降低噪声带来的影响</li>
<li>数据的提示<br> 在原特征上再挖掘有用特征，这样可以弥补训练样本少带来的问题</li>
<li>正则项<br> 额。好东西，不过下个视频才讲-_-</li>
<li>验证<br> 应该可以理解为交叉验证把？</li>
</ol>
<h2 id="参考">参考</h2><ul>
<li>《台湾国立大学-机器学习基石》第十三讲</li>
</ul>
<p>配图均来自《台湾国立大学-机器学习基石》</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="What_is_Overfitting">What is Overfitting</h2><p>假设现在我们使用一个二次函数随机产生几个点，并且加入非常少量的噪声，然后使用一个四次函数来进行拟合<br>将得到如下的结果<br><img src="/img/Overfitting/4fit2.png" height="240px" width="240px" /><br>可以发现4次函数可以完全拟合含有噪声的2次函数产生的点，也就是拟合出来的<code>E<sub>in</sub>=0</code>，但是此时如果使用新的2次函数的点用这个4次的拟合函数来进行预测的话，可以发现<code>E<sub>out</sub></code>会很高，<br>这种低<code>E<sub>in</sub></code>高<code>E<sub>out</sub></code>就是叫做泛化能力差(<code>BAD generalization</code>)，也是往往我们在做训练预测时不希望看到的。<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《台大机器学习基石》Multiclass-Classification]]></title>
    <link href="http://yyl8781697.github.io/2015/08/30/Machine%20Learning/Multiclass-Classification/"/>
    <id>http://yyl8781697.github.io/2015/08/30/Machine Learning/Multiclass-Classification/</id>
    <published>2015-08-30T01:27:19.000Z</published>
    <updated>2015-09-01T15:30:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Multiclass-Classification">Multiclass-Classification</h2><p><a href="http://kubicode.me/2015/08/06/Machine%20Learning/Perceptron-Learning-Algorithm/" target="_blank" rel="external">Perceptron Learning Algorithm</a>,<a href="http://kubicode.me/2015/08/21/Machine%20Learning/Logistic-Regression/" target="_blank" rel="external">Logistic Regression</a>这些算法的最初出现都是基于2分类的(Binary Classification)，但是生活中会出很多多分类的问题出现（比如选择题：四选一，视觉的识别，手写体的识别之类的）</p>
<p><img src="/img/Multiclass-Classification/mc.png" height="300px" width="500px"><br><img src="/img/Multiclass-Classification/mcw.png" height="100px" width="300px"><br>那么我们如何才能使用这些二分类的模型来完成多分类的需求呢？<br><a id="more"></a></p>
<h2 id="One-Vs-All">One-Vs-All</h2><p>这里可以先采用一对多的方法来进行多分类，以上面的4个不同形状的多边形分类为例：<br>这是将方块作为一类，其余作为另一类<br><img src="/img/Multiclass-Classification/oa1.png" height="300px" width="500px"><br>也其实就是一个二分类问题了，通过这个分类器我们可以至少将方块给区分出来<br><img src="/img/Multiclass-Classification/bc.png" height="100px" width="350px"></p>
<p>这是一个菱形作为一类的方案<br><img src="/img/Multiclass-Classification/oa2.png" height="300px" width="500px"></p>
<p>同理就会有4个区分不同形状的分类器<br><img src="/img/Multiclass-Classification/oa3.png" height="300px" width="500px"></p>
<p>那么原图上四个角可以进行很容易得分类的<br><img src="/img/Multiclass-Classification/oa4.png" height="250px" width="250px"></p>
<p>那么问题来了：<br><img src="/img/Multiclass-Classification/oa5.png" height="250px" width="250px"></p>
<ul>
<li>在1，2，3，4四个区域是每个单分类器的交集处，就会出现不知道这个分类应该属于哪个类额</li>
<li>还有在5这个区域，没有一个分类器去涉及它，就会成为了4不管区域了-_-</li>
</ul>
<p>这里可以用一个软性(<code>softly</code>)的方法来解决这个问题<br><img src="/img/Multiclass-Classification/s1.png" height="250px" width="250px"><br>颜色越深的区域属于这个类的概率越大，也就是<br><img src="/img/Multiclass-Classification/sp.png" height="100px" width="350px"><br>那么之后形成的4个形状各自的分类器为<br><img src="/img/Multiclass-Classification/s24.png" height="300px" width="500px"><br>使用这种软性分类器最终的多分类判别方式是<br><img src="/img/Multiclass-Classification/ccpb.png" height="100px" width="350px"><br>也就是它会取分类概率那大的那个类别作为预测出来的分类<br>这种软性多分类的分类能力为<br><img src="/img/Multiclass-Classification/s24s.png" height="250px" width="250px"><br>可以发现图中的4中形状的类别都基本已经分开了</p>
<p>现在以<a href="http://kubicode.me/2015/08/21/Machine%20Learning/Logistic-Regression/" target="_blank" rel="external">Logistic Regression</a>为例来总结一下<code>One-Vs-All</code>的多分类过程<br><img src="/img/Multiclass-Classification/lmc.png" height="300px" width="500px"></p>
<ol>
<li>首先是遍历每个类别，被遍历的类别作为<code>positive</code>，其余的类作为<code>negitive</code>类别，使用<code>Logistic Regression</code>来训练一个分类器</li>
<li>这样遍历完了之后就可以得到<code>k</code>（表示类别的种类数）分类器（这样也可以将每个分类器对应到一个类别）</li>
<li>在预测阶段输入一个样本，计算出概率最高的分类器作为预测的类别</li>
</ol>
<p>这种分类方法：</p>
<ul>
<li>优点：效率很高，有多少个类别就训练多少个分类器就可以完成多分类，并且普适性还比较广，可以应用于能输出值或者概率的分类器</li>
<li>缺点：就是有较大的样本不平衡，比如现在有很多个类别，每个类别都是只占其中一点点的样本，那么每个单模型在训练的时候可能都是偏向于<code>negitive</code>，最终在预测的时候就是相当于在一端偏向<code>negitive</code>的模型中找<code>positive</code>的分类器</li>
</ul>
<h2 id="One-Vs-One">One-Vs-One</h2><p>相当于<code>One-Vs-All</code>的方法，这里的<code>One-Vs-One</code>是从多个类别里面随便选两个出来进行分类,<br>比如还是以上面的四种形状分类为例，先单独拿出菱形和方块这两种类别<br><img src="/img/Multiclass-Classification/oo1.png" height="300px" width="500px"><br>然后单独对这两个类别做一个二分类<br><img src="/img/Multiclass-Classification/oo12.png" height="100px" width="300px"></p>
<p>还可以做<br>方块和三角形<br><img src="/img/Multiclass-Classification/oo2.png" height="200px" width="200px"><br>方块和星星<br><img src="/img/Multiclass-Classification/oo3.png" height="200px" width="200px"><br>等等还有其他的。。它在四种类别中就会有6种不同的方法(N(4,2),用于表示4的2组合)<br><img src="/img/Multiclass-Classification/oo5.png" height="250px" width="600px"></p>
<pre><code>现在将这个问题想做是4支队伍，两两对战，然后取出一组成绩最好的作为预测类别，也就是一种投票分类
</code></pre><p>所以关于上述分类的公式是<br><img src="/img/Multiclass-Classification/eq.png" height="150px" width="600px"></p>
<p>再来撸一下<code>One-Vs-One</code>的流程:</p>
<ol>
<li>遍历<code>k</code>个类别，两两之间进行组合，那么就会有<code>C(k,2)</code>组</li>
<li>对那么多组进行一个单独进行分类训练</li>
<li>训练完了之后最终模型的预测输出使用投票的方法</li>
</ol>
<p><img src="/img/Multiclass-Classification/lc.png" height="300px" width="500px"></p>
<p>这种分类方法有</p>
<ol>
<li>优点：高效，别看它分为了<code>N(k,2)</code>个模型，但是每个训练的时候他的训练样本只有针对训练类做一下，并且还比较稳定</li>
<li>缺点：预测的时间会变久，需要更加多得训练</li>
</ol>
<h2 id="总结">总结</h2><p>假设现在有<code>k</code>个类别，现在需要使用多分类的方法去预测一个样本属于具体哪个类</p>
<ul>
<li><code>One-Vs-All</code>:其中一个类别作为一类，剩余其他类作为一类训练一个二分类模型，按次方法共训练<code>k</code>模型，一般可以认为一个模型对应一个类别，预测时候取概率最大的那个模型即可<br>  优点：训练速度快<br>  缺点：会导致样本不平衡</li>
<li><code>One-Vs-One</code>:两两类别之间取数据进行二分类模型的训练，按此方法共训练<code>N(k,2)</code>个模型,在预测的时候使用投票的方法作为最终结果<br>  优点：高效（因为每个单模型并不是训练全部数据），稳定<br>  缺点：预测时间会变很久</li>
</ul>
<h2 id="参考">参考</h2><ul>
<li>《台湾国立大学-机器学习基石》第十一讲</li>
</ul>
<p>配图均来自《台湾国立大学-机器学习基石》</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Multiclass-Classification">Multiclass-Classification</h2><p><a href="http://kubicode.me/2015/08/06/Machine%20Learning/Perceptron-Learning-Algorithm/">Perceptron Learning Algorithm</a>,<a href="http://kubicode.me/2015/08/21/Machine%20Learning/Logistic-Regression/">Logistic Regression</a>这些算法的最初出现都是基于2分类的(Binary Classification)，但是生活中会出很多多分类的问题出现（比如选择题：四选一，视觉的识别，手写体的识别之类的）</p>
<p><img src="/img/Multiclass-Classification/mc.png" height="300px" width="500px" /><br><img src="/img/Multiclass-Classification/mcw.png" height="100px" width="300px" /><br>那么我们如何才能使用这些二分类的模型来完成多分类的需求呢？<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《台大机器学习基石》Logistic Regression]]></title>
    <link href="http://yyl8781697.github.io/2015/08/21/Machine%20Learning/Logistic-Regression/"/>
    <id>http://yyl8781697.github.io/2015/08/21/Machine Learning/Logistic-Regression/</id>
    <published>2015-08-21T13:07:01.000Z</published>
    <updated>2015-11-25T02:11:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Logistic_Regression">Logistic Regression</h2><p>前两篇文章中的模型<a href="http://kubicode.me/2015/08/06/Machine%20Learning/Perceptron-Learning-Algorithm/" target="_blank" rel="external">Perceptron Learning Algorithm</a>和<a href="http://kubicode.me/2015/08/19/Machine%20Learning/Linear-Regression/" target="_blank" rel="external">Linear Regression</a>可以解决的问题是判断一个患者是否会心脏病，但是实际生活中里面里面可能给出的报告的是患者患心脏病的一个概率：<br><img src="/img/Logistic-Regression/har.png" height="240px" width="240px"><br>这样的话从模型的角度来说更希望的是得到一个发生在患心脏病的概率<code>f(x)=P(+1|x)∈[0,1]</code>,<br>这个概率值越大，患心脏病的概率越大，反之则越小<br><a id="more"></a></p>
<blockquote>
<p>这个也叫<code>Soft Binary Classification</code>，因为这里的概率可以根据一个阈值来判断是否属于哪一类</p>
</blockquote>
<p>刚刚可以看到目标函数<code>f(x)</code>的值是属于一个[0,1]范围的值，理所应当，我们理想的训练数据应该是这样的<br><img src="/img/Logistic-Regression/ind1.png" height="300px" width="300px"><br>想法虽好，然是实际上训练目标的概率值很难得到（比如一个患者你过了两三个月之后也许可以观察到该用户是否会患上心脏病，但是你可能是无法知道他患心脏病的真实概率的）<br>所以我们拿到的真实数据是这样的<br><img src="/img/Logistic-Regression/ind2.png" height="300px" width="300px"><br>这样也可以你可以看成为上上概率训练数据一个有噪声的版本，每个标签值对应的0或者1都是直接在概率阈值上进行了一个分类了</p>
<p>那么现在的目标就是在原来（二分类）的数据上，以[0,1]范围为目标找到一个好的假设(<code>hypothesis</code>)</p>
<p>那么首先可以想到的是按<code>Linear Regression</code>一样在特征值和权重向量上进行一个加权<br><img src="/img/Logistic-Regression/fw.png" height="400px" width="300px"><br>得到加权之后的<code>score</code>之后，我们希望<code>score</code>越高，最终得到的概率值越大（但是不能大于1），<code>score</code>越低，最终的概率值越小（不能小于0），那正好可以通过下面的函数的转换来完成刚刚的需求<br><img src="/img/Logistic-Regression/lf.png" height="300px" width="400px"><br>这个函数也叫做<code>logistic function</code><br><img src="/img/Logistic-Regression/logit.png" height="100px" width="400px"><br>其中里面的<code>s</code>就是相当于<code>score</code></p>
<p>最终我们可以得到的模型函数为<br><img src="/img/Logistic-Regression/lh.png" height="300px" width="400px"><br>这也就是<code>Logistic Regression</code>的表示</p>
<h2 id="Cross-Entropy_Error">Cross-Entropy Error</h2><p>根据<code>Logistic Regression</code>的目标函数<code>f(x)</code>可以很容易得到如下关系<br><img src="/img/Logistic-Regression/fx.png" height="100px" width="500px"></p>
<p>假如现在有如下的数据<br><img src="/img/Logistic-Regression/cd.png" height="100px" width="500px"><br>那么这批数据产生的概率是<br><img src="/img/Logistic-Regression/d1.png" height="300px" width="300px"><br>使用<code>f(x)</code>替换可以得到<br><img src="/img/Logistic-Regression/d2.png" height="300px" width="300px"></p>
<p>现在以<code>hypothesis</code>的角度来看，通过<code>h(x)</code>产生的样本情况为<br><img src="/img/Logistic-Regression/h1.png" height="300px" width="300px"></p>
<p>如果<code>h(x)≈f(x)</code>,那么我们就可以说通过<code>h(x)</code>产生的样本的可能性与真正<code>f(x)</code>产生的数据很接近<br>那么我们现在找<br><img src="/img/Logistic-Regression/lhp.png" height="200px" width="500px"><br>这个是建立在<code>f(x)</code>产生的数据的可能性很大的基础上，所以现在也相应的就是求<code>h(x)</code>产生的样本的可能性也要很大。<br>用式子表达出来就是这个<br><img src="/img/Logistic-Regression/hn.png" height="100px" width="500px"><br>又因为<code>logistic function</code>的写对称性（<code>1-h(x)=h(-x)</code>），上面的式子可以转为<br><img src="/img/Logistic-Regression/hn2.png" height="100px" width="500px"><br>上面带负号的正好可以看做负样本(<code>y<sub>n</sub>=-1</code>)，带正好的也正好可以看做正样本(<code>y<sub>n</sub>=+1</code>)，同时对于每个<code>hypothesis</code>来说上图中灰色部分(产生各个数据的概率,不含目标)都是一样的，所以现在可以将上述式子简写为<br><img src="/img/Logistic-Regression/like.png" height="100px" width="500px"></p>
<blockquote>
<p>它是一个正比函数，<code>y<sub>n</sub></code>正好可以替换为原来的正负1</p>
</blockquote>
<p>现在要做的就是找到合适的<code>h(x)</code>，使的上述的可能性最高<br>把<code>h</code>用气w来替换为<br><img src="/img/Logistic-Regression/hwt.png" height="100px" width="500px"><br>为了求其最优化，我们将上述式子的连乘转为连加，通过添加一个<code>ln</code>函数(单调递增)，同时使用添加负号来由求最大化转为最小化(方便求)<br> <img src="/img/Logistic-Regression/cee.png" height="150px" width="500px">（式子2）<br>这里继续使用<code>logistic function</code>函数进行替换，可以有<br> <img src="/img/Logistic-Regression/ecc2.png" height="250px" width="500px"><br>(替换技巧ln a/b=ln a- ln b和ln 1=0)<br>紫色背景的表示对x<sub>n</sub>，y<sub>n</sub>的Error，通过累加再求平均就是很熟悉的<code>E<sub>in</sub></code>了,这个Error就叫做<code>Cross-Entropy Error</code></p>
<h2 id="Gradient_Descent">Gradient Descent</h2><p>求式子2中的最小值最直观的就是对其求梯度并且其梯度在0的地方就是最小(也是最优)</p>
<blockquote>
<p>这里能用上述的方法来求是因为<code>Logistic Regression</code>的<code>E<sub>in</sub></code>是可导可微的，并且是凸的</p>
</blockquote>
<p>现在将其对<code>w</code>求偏导<br> <img src="/img/Logistic-Regression/pwf.png" height="400px" width="500px"><br>上面求的是梯度里面的一个<code>Component</code>，那么对所有的<code>Component</code>都整理起来可以得到<br><img src="/img/Logistic-Regression/zpwf.png" height="100px" width="500px"><br>目标就变成了求上述梯度为0的情况<br><img src="/img/Logistic-Regression/tdt.png" height="250px" width="250px"><br>但是可以看到上述的梯度并不是一个一次的方程式，也就是无法直接求出具体的值(不能像<code>Linear Regression</code>中那样直接求出)</p>
<p>不过现在根据需要求解的问题看成现在这样<br><img src="/img/Logistic-Regression/gdt.png" height="250px" width="250px"><br>梯度的函数可以看成图种的曲线，而相应的参数<code>w</code>可以看成图种的那个球，每次都朝着错误的方向<code>v</code>滚，将球从上面滚到最低处，也就是得到梯度为0的情况<br><img src="/img/Logistic-Regression/aga.png" height="200px" width="400px"><br>其中<code>v</code>为球滚动的方向（后面可以知道是梯度的反方向），还有<code>η</code>表示步伐的长度(为正数，越大会滚的越快)<br>现在的问题就是转为了如果很快滚下去，并且是走对方向（真实中并不是一个二维空间，往往是一个多维空间）</p>
<p>在曲线上很小很小的一个区间内可以看作是一个线段，那这样就可以在曲线上的一个点出来，然后走出一小段的线段来，那这样可以通过多维度的泰勒展开可以得到<br><img src="/img/Logistic-Regression/aag.png" height="200px" width="500px"></p>
<blockquote>
<p>这里的<code>η</code>很小的时候，这个线段的逼近 还是很不错的</p>
</blockquote>
<p>上面公式中的灰色标志是表示与<code>v</code>没什么关系，在求解最小化的过程中有颜色部分两个向量内积的最小，那这样的话两个向量完全反方向就是最小的，也就是说<code>v</code>走的是梯度反方向，并且需要注意的是他是单位向量，所以这里就会有<br><img src="/img/Logistic-Regression/odo.png" height="200px" width="500px"><br>那么参数更新的方式就会有<br><img src="/img/Logistic-Regression/paraUpdate.png" height="200px" width="500px"></p>
<pre><code>这个就是梯度下降法<span class="comment">(Gradient Descent)</span>，也是一种较为简单的，有效的优化方法
</code></pre><p>好，到了这里<code>v</code>可以求了，那么<code>η</code>这个需要给定的参数取多少合适呢？<br><img src="/img/Logistic-Regression/eta.png" height="300px" width="400px"><br>从上图中可以发现：</p>
<ol>
<li><code>η</code>很小：那么整个参数更新过程就会很慢，不过准确性（与最小值的接近程度）应该还是可以保证的</li>
<li><code>η</code>很大，那么这个参数过程就会很不稳定，那么他的最终的准确性可能就会较低</li>
</ol>
<p>比较推荐的是采用一种自适应的方法来做<br><img src="/img/Logistic-Regression/jr.png" height="300px" width="200px"><br>当梯度较大的时候，<code>η</code>也跨的较大，那么当梯度慢慢减小的时候，<code>η</code>也同时慢慢减少，也就是说<code>η</code>与梯度值会呈正相关的关系，那么这样在保证了准确性的同时，又可以加快速度^_^<br>此时根据<code>η</code>正比于梯度值的特性可以惊奇的发现<br><img src="/img/Logistic-Regression/xjr.png" height="250px" width="500px"><br>（图种<span style="color:red">红色</span>的<code>η</code>为原生值，<span style="color:purple">紫色</span>的<code>η</code>为正比的比率）<br>在整个参数的更新过程中可以将梯度值的计算消除掉，这里的<span style="color:purple">紫色</span>的<code>η</code>也称为学习速率</p>
<p>现在<code>Logistic Regression</code>使用<code>Gradient Descent</code>来计算的过程为<br><img src="/img/Logistic-Regression/lrgd.png" height="400px" width="500px"></p>
<ol>
<li>首先将<code>w</code>初始化为0向量</li>
<li>不断迭代的遍历样本</li>
<li>每遍历一次样本时都计算当前样本的梯度(可以发现每个样本的梯度都需要遍历整个样本之后才能计算得到-_-)</li>
<li>计算完梯度之后往梯度的反方向更新权值<code>w</code></li>
<li>不断进行2~4的步骤，直到<code>E<sub>in</sub></code>足够小或者迭代次数足够多</li>
<li>返回最后一个更新的<code>w</code>就作为我们的最优<code>hypothesis</code></li>
</ol>
<blockquote>
<p>推导了这么久，但是最终发现整个计算过程还是比较简单清晰地，而且还有点像<code>PLA</code>的<code>Pocket Algorithm</code></p>
</blockquote>
<h2 id="Stochastic_Gradient_Descent">Stochastic Gradient Descent</h2><p>现在这里再重新理解一下<code>Gradient Descent</code>算法：每次迭代在计算其中一个样本的梯度的时候，都需要遍历所有的样本对梯度的贡献进行求和，然后取平均值作为最后的梯度，是不是感觉代价偏大(<strong>牵一发而动全身的感觉</strong>-_-，特别是在现在大数据的情况下，这效率应该会很慢)<br>现在我们是希望求得这个梯度的方向，但是不希望通过遍历所有样本求和求平均来得到梯度，有一个巧妙的方法就是将这个过程看过一个随机过程的平均，随便去抽一个样本然后将其作为梯度<br><img src="/img/Logistic-Regression/tor.png" height="200px" width="400px"><br>这种方式我们将随机的一个样本偏微分算出来的梯度称为随机梯度(Stochastic Gradient)，最终真实地梯度与这种随机方式求出来的梯度的期望是一致的<br><img src="/img/Logistic-Regression/tg.png" height="200px" width="400px"></p>
<pre><code>上面的过程就好比：现在有<span class="number">10000</span>个数字，需要求这些数字的平均数，最普通的方法就是<span class="number">10000</span>求和再求平均，但是遍历<span class="number">10000</span>次的复杂度认为太大，另一种解决方法就随机抽一小批数据<span class="comment">(比如100)</span>再求和求平均，其实这两个期望是很类似的，现在另一种trick的方法是直接只抽一个数字，把它认为就是这<span class="number">10000</span>个数字的平均数，现在再想想抽数字抽好多次最后结果喝第一次求和的期望也是类似的
</code></pre><blockquote>
<p>这个方式可以认为：随机得梯度=真实梯度+一些噪声</p>
</blockquote>
<p>这样的话在更新参数这一块的代价较大的梯度计算即可直接替换为轻量级的随机梯度，在足够多次的迭代之后，这个真实梯度的平均也会约等于随机梯度的平均<br>那么最终<code>Stochastic Gradient Descent(SGD)</code>算法的表示为<br><img src="/img/Logistic-Regression/sgd.png" height="200px" width="400px"><br>在整个算法计算过程中除了随机梯度计算的区别，还有其终止条件就是足够多的迭代，但是取的是<code>E<sub>in</sub></code>最小的那组作为最优</p>
<blockquote>
<p>貌似林老师爆出来关于<code>η</code>参数的取值最优是0.1126 经验参数值哦^_^</p>
</blockquote>
<p><code>SGD</code>优势有:</p>
<ol>
<li>轻量级计算</li>
<li>适合于大数据（因为复杂度低，计算梯度是O(1)）</li>
<li>还可以进行<code>online learning</code></li>
<li>。。。其实我想说比较容易实现并行</li>
</ol>
<p>劣势：就是可能不稳定</p>
<h2 id="总结">总结</h2><p><code>Logistic Regression(LR)</code>是一个线性的二分类模型，主要有以下优缺点<br>优点：</p>
<ol>
<li>实现简单；</li>
<li>分类时计算量非常小，速度很快，存储资源低，也很容易并行；(在大量数据情况下这个模型非常适用，这也是好多广告系统首选的原因)</li>
<li>在处理分类问题的同时还可能给出一个概率值(这个值有时候蛮有用的)</li>
<li>优化方法多：除了GD和SGD，应该还有拟牛顿法、BFGS、L-BFGS</li>
</ol>
<p>缺点：</p>
<ol>
<li>容易欠拟合，一般准确度不太高</li>
<li>只能处理两分类问题（在此基础上衍生出来的softmax可以用于多分类），且必须线性可分；</li>
</ol>
<h2 id="参考">参考</h2><ul>
<li>《台湾国立大学-机器学习基石》第十讲</li>
<li>《台湾国立大学-机器学习基石》第十一讲</li>
</ul>
<p>配图均来自《台湾国立大学-机器学习基石》</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Logistic_Regression">Logistic Regression</h2><p>前两篇文章中的模型<a href="http://kubicode.me/2015/08/06/Machine%20Learning/Perceptron-Learning-Algorithm/">Perceptron Learning Algorithm</a>和<a href="http://kubicode.me/2015/08/19/Machine%20Learning/Linear-Regression/">Linear Regression</a>可以解决的问题是判断一个患者是否会心脏病，但是实际生活中里面里面可能给出的报告的是患者患心脏病的一个概率：<br><img src="/img/Logistic-Regression/har.png" height="240px" width="240px" /><br>这样的话从模型的角度来说更希望的是得到一个发生在患心脏病的概率<code>f(x)=P(+1|x)∈[0,1]</code>,<br>这个概率值越大，患心脏病的概率越大，反之则越小<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《台大机器学习基石》Linear Regression]]></title>
    <link href="http://yyl8781697.github.io/2015/08/19/Machine%20Learning/Linear-Regression/"/>
    <id>http://yyl8781697.github.io/2015/08/19/Machine Learning/Linear-Regression/</id>
    <published>2015-08-19T15:15:46.000Z</published>
    <updated>2015-08-23T15:31:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Linear_Regression">Linear Regression</h2><p>现在相对比于之前的<a href="http://kubicode.me/2015/08/06/Machine%20Learning/Perceptron-Learning-Algorithm/" target="_blank" rel="external">Perceptron Learning Algorithm</a>算法，假如我们现在时的问题不是解决是否发行用卡，而是该发<strong>多少额度</strong>的问题<br><img src="/img/Linear-Regression/ed.png" width="300px" height="300px"><br>也就是输出空间属于一个实数，那么就需要一个回归算法来解决该问题！<br><a id="more"></a></p>
<p>那么我们其实可以直接使用特征属性与权重的加权求和来表示需要发的信用额度即可(与<code>PLA</code>类似，但是没有激活函数：二值判断逆函数)<br><img src="/img/Linear-Regression/jq.png" width="500px" height="300px"><br>上图中表示的就是为线性回归(<code>Linear Regression</code>)，其中<code>w<sup>T</sup>x</code>就是表示为全部的假设空间(<code>hypothesis set</code>)</p>
<p>如果当前的特征是一维的，那么这里的<code>hypothesis set</code>就表示一条线，（因为总体的特征向量里面还有一个常数值）<br><img src="/img/Linear-Regression/2d.png" width="300px" height="300px"><br>如果当前的特征是二维的，那么这里的<code>hypothesis set</code>就一个平面<br><img src="/img/Linear-Regression/3d.png" width="300px" height="300px"><br>当然特征更加多得话，最终<code>hypothesis set</code>表示一个超平面<br>其中图上红色的部分叫做误差（视频里面叫做<strong>余数</strong>），那么回归分析的目标就是将所有的误差降到最小越好<br>这里使用平方误差来衡量整体的误差<br><img src="/img/Linear-Regression/se.png" width="300px" height="100px"><br>那么从机器学习的角度来说，这里的误差就可以看做(下面这个表达式就很熟悉了)<br><img src="/img/Linear-Regression/jse.png" width="300px" height="100px"><br>相应的<br><img src="/img/Linear-Regression/jse2.png" width="300px" height="100px"><br>表示这个分类器在未来未训练数据集中产生的误差是多少<br>那么现在的线性回归的问题就是转为将<code>E<sub>in</sub>(w)</code>优化到最小。</p>
<h2 id="Ein(w)最小化">Ein(w)最小化</h2><p>现将上面小节的中的<code>E<sub>in</sub></code>转为矩阵的运算<br><img src="/img/Linear-Regression/mt.png" width="500px" height="400px"></p>
<ol>
<li>向量内积可交换，将<code>w<sup>T</sup>x</code>转为<code>x<sup>T</sup>w</code></li>
<li>将连加转为向量形式的长度（应该是二范数）</li>
<li>将<code>w</code>单独提出来（相当于隔离出了一个特征属性向量的矩阵）</li>
<li>最终使用缩写来进行整理</li>
</ol>
<p>到了这一步我们可以发现<code>E<sub>in</sub>(w)</code>只与<code>w</code>有关，那么他们的关系图是<br><img src="/img/Linear-Regression/wq.png" width="300px" height="300px"><br>可以发现<code>E<sub>in</sub>(w)</code>是连续可导，还有它是凸的<br>那么用<code>E<sub>in</sub>(w)</code>对<code>w</code>求偏导即可求导最优值(梯度为0的位置)<br><img src="/img/Linear-Regression/td.png" width="400px" height="300px"><br>这样现在问题又转为了 求<img src="/img/Linear-Regression/task.png" width="300px" height="100px"></p>
<p>首先将<img src="/img/Linear-Regression/ei.png" width="400px" height="100px"><br>现在对其求偏导<br><img src="/img/Linear-Regression/pd.png" width="300px" height="100px"><br>完了之后再将<code>A,b</code>替换回去<img src="/img/Linear-Regression/qw.png" width="300px" height="100px"></p>
<p>进一步将问题转换为<img src="/img/Linear-Regression/task2.png" width="400px" height="100px"><br>式子中<code>X<sup>T</sup>X</code>和<code>X<sup>T</sup>y</code>都是已知的，唯一不知道的就是<code>w</code>，这样就变为了一个一次的方程式</p>
<ol>
<li>假如有<code>(X<sup>T</sup>X)<sup>-1</sup></code>反矩阵的存在，那么就可以直接得到解了,并且是唯一的<br> <img src="/img/Linear-Regression/s1.png" width="250px" height="250px"></li>
<li>但是如果<code>(X<sup>T</sup>X)<sup>-1</sup></code>反矩阵不存在，那么得到的解可能就不唯一了<br> <img src="/img/Linear-Regression/s2.png" width="250px" height="250px"></li>
</ol>
<p>所以这里的核心就是计算虚假的反矩阵(<code>pseudo-inverse</code>),听林老师说这个的计算很多工具都是由现成的^_^</p>
<blockquote>
<p>刚刚求<code>E<sub>in</sub>(w)</code>最小化的过程中看似直接用公式代替可到，但是其中的<code>pseudo-inverse</code>计算起来麻烦，最终在计算的时候还是需要迭代，然后会触发<code>E<sub>in</sub>(w)</code>和<code>E<sub>out</sub>(w)</code>的变化，是一个深度隐含的学习过程(这种是叫做<code>Analytic Solution</code>)。</p>
</blockquote>
<h2 id="Learning_happened">Learning happened</h2><p>那么该如果保证<code>E<sub>out</sub></code>可以是小的呢？<br>我们先来看一下<code>E<sub>in</sub></code>的平均<br><img src="/img/Linear-Regression/eip.png" width="500px" height="100px"><br>其中<code>nosie level</code>表示样本中噪声的一个情况，<code>d+1</code>表示模型的自由度，<code>N</code>表示样本的容量<br>其中单独表示<code>E<sub>in</sub>(w)</code>的话为<br><img src="/img/Linear-Regression/eipt.png" width="500px" height="200px"><br>这样就形成了两项<code>1-XX<sup>+</sup></code>和<code>y</code>，也就是相当于将输入喝输出进行了一个分离,其中<code>XX<sup>+</sup></code>叫做<code>hat matrix</code><br>关于这个<code>hat matrix</code>,它的意义是这样纸的<br><img src="/img/Linear-Regression/hm.png" width="500px" height="400px"></p>
<ol>
<li>红色区块表示向量<code>X</code>的一个扩散，而<code>y^</code>就是落在这个空间上</li>
<li>目标就是求<code>y-y^</code>的最小化，也就是图种的绿色那条线（<code>y^</code>）向下投影的线</li>
<li><code>H</code>就是表示这个空间上<code>y</code>到<code>y^</code>的一个投影</li>
<li><code>I-H</code>就是表示误差部分<code>y-y^</code></li>
</ol>
<p>相应的会有<code>trace(I-H)=N-(d+1)</code></p>
<p>好，现在再来看<code>E<sub>in</sub></code>的平均到底是什么意思<br><img src="/img/Linear-Regression/eips.png" width="500px" height="400px"></p>
<ol>
<li>其中如果<code>f(x)</code>为目标函数，那么目标值<code>y</code>就相当于在<code>f(x)</code>上添加噪声</li>
<li>然后这个噪声通过<code>I-H</code>就可以转为<code>y-y^</code></li>
</ol>
<p>现在对噪声作评价的话，那么就可以得到<img src="/img/Linear-Regression/eint2.png" width="500px" height="60px"><br>此时<img src="/img/Linear-Regression/eint3.png" width="500px" height="60px"><br>这两个式子哲学上的意思是<code>E<sub>in</sub></code>的平均是可以看到的，所以当存在噪声的时候看到的线会偏向于噪声方向，而在<code>E<sub>out</sub></code>的平均是未知的，比最好的那个线还要向右边偏一点（没听懂-_-）</p>
<p>他们俩会形成如下的关系线<br><img src="/img/Linear-Regression/einout.png" width="300px" height="300px"><br>它描述的是当前的样本量与平均的<code>E<sub>in</sub></code>和<code>E<sub>out</sub></code>的关系,随着样本量<code>N</code>的增长，最终会趋向于<code>nosie level</code></p>
<p>那么就可以得到<br><img src="/img/Linear-Regression/vvv.png" width="300px" height="200px"><br>说明<code>N</code>足够大，然后他的<code>noise level</code>够小时，说明了<code>Learning happened</code></p>
<h2 id="总结">总结</h2><ol>
<li>线性回归最终求出的是一个加权求和的值.</li>
</ol>
<ul>
<li>线性回归的<code>E<sub>in</sub></code>的采用的是最小平方误差.</li>
<li>在计算<code>E<sub>in</sub></code>的最小化时，可以将问题转为矩阵之后就逆矩阵相关即可.</li>
<li>通过<code>E<sub>in</sub></code>平均的计算,说明了<code>Learning happened</code>.</li>
<li>其实线性回归去坐分类问题也是可以的^_^，第9课第4个小视频.</li>
</ul>
<h2 id="参考">参考</h2><ul>
<li>《台湾国立大学-机器学习基石》第九讲</li>
</ul>
<p>配图均来自《台湾国立大学-机器学习基石》</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Linear_Regression">Linear Regression</h2><p>现在相对比于之前的<a href="http://kubicode.me/2015/08/06/Machine%20Learning/Perceptron-Learning-Algorithm/">Perceptron Learning Algorithm</a>算法，假如我们现在时的问题不是解决是否发行用卡，而是该发<strong>多少额度</strong>的问题<br><img src="/img/Linear-Regression/ed.png" width="300px" height="300px" /><br>也就是输出空间属于一个实数，那么就需要一个回归算法来解决该问题！<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
</feed>