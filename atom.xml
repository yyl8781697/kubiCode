<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Kubi Code'Blog]]></title>
  <subtitle><![CDATA[The palest ink is better than the best memory.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yyl8781697.github.io/"/>
  <updated>2015-08-16T00:22:10.000Z</updated>
  <id>http://yyl8781697.github.io/</id>
  
  <author>
    <name><![CDATA[Kubi Code]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[机器学习常见算法个人总结（面试用）]]></title>
    <link href="http://yyl8781697.github.io/2015/08/16/Machine%20Learning/Algorithm-Summary-for-Interview/"/>
    <id>http://yyl8781697.github.io/2015/08/16/Machine Learning/Algorithm-Summary-for-Interview/</id>
    <published>2015-08-15T23:40:29.000Z</published>
    <updated>2015-08-16T00:22:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="朴素贝叶斯">朴素贝叶斯</h2><p>P(A∩B)=P(A)*P(B|A)=P(B)*P(A|B)<br>所以有：P(A|B)=P(B|A)*P(A)/P(B)</p>
<p>对于给出的待分类项，求解在此项出现的条件下各个目标类别出现的概率，哪个最大，就认为此待分类项属于哪个类别</p>
<h3 id="工作原理">工作原理</h3><ol>
<li>假设现在有样本x=(a1,a2,a3,…an)这个待分类项(并认为x里面的特征独立)</li>
<li>再假设现在有分类目标Y={y1,y2,y3,y4..yn}</li>
<li>那么max(P(y1|x),P(y2|x),P(y3|x)..P(yn|x))中的最大者就是最终的分类类别</li>
<li>而P(yi|x)=p(x|yi)*P(yi)/P(x)</li>
<li>因为x对于每个分类目标来说都一样，所以就是求max(P(x|yi)*p(yi))</li>
<li>P(x|yi)*p(yi)=p(yi)*PI(P(ai|yi))  (PI表示连乘)</li>
<li>而具体的p(ai|yi)和p(yi)都是能从训练样本中统计出来<br><br> p(ai|yi)表示该类别下该特征出现的概率<br><br> p(yi)表示全部类别中这个这个类别出现的概率</li>
<li>好的，就是这么工作的^_^</li>
</ol>
<a id="more"></a>
<h3 id="工作流程">工作流程</h3><ol>
<li>准备阶段<br><br> 确定特征属性，并对每个特征属性进行适当划分，然后由人工对一部分待分类项进行分类，形成训练样本。</li>
<li>训练阶段<br><br> 计算每个类别在训练样本中的出现频率及每个特征属性划分对每个类别的条件概率估计</li>
<li>应用阶段<br><br> 使用分类器进行分类，输入是分类器和待分类样本，输出是样本属于的分类类别</li>
</ol>
<h3 id="属性特征">属性特征</h3><ol>
<li>特征为离散值时直接统计即可（表示统计概率）</li>
<li>特征为连续值的时候假定特征符合高斯分布:g(x,n,u)<br> 那么p(ak|yi)=g(xk,ni,ui)</li>
</ol>
<h3 id="Laplace校准(拉普拉斯校验)">Laplace校准(拉普拉斯校验)</h3><p>当某个类别下某个特征划分没有出现时，会有P(a|y)=0，就是导致分类器质量降低，所以此时引入Laplace校验，就是对没类别下所有划分的计数加1。</p>
<h3 id="遇到特征之间不独立问题">遇到特征之间不独立问题</h3><p>参考改进的贝叶斯网络，使用DAG来进行概率图的描述</p>
<h3 id="优缺点">优缺点</h3><p>朴素贝叶斯的优点：</p>
<ol>
<li>对小规模的数据表现很好，适合多分类任务，适合增量式训练。<br>缺点：</li>
<li>对输入数据的表达形式很敏感（离散、连续，值极大极小之类的）。</li>
</ol>
<p><a href="http://www.cnblogs.com/leoo2sk/archive/2010/09/17/naive-bayesian-classifier.html" target="_blank" rel="external">http://www.cnblogs.com/leoo2sk/archive/2010/09/17/naive-bayesian-classifier.html</a></p>
<h2 id="逻辑回归和线性回归">逻辑回归和线性回归</h2><pre><code>LR回归是一个线性的二分类模型，主要是计算在某个样本特征下事件发生的概率，比如根据用户的浏览购买情况作为特征来计算它是否会购买这个商品，抑或是它是否会点击这个商品。然后LR的最终值是根据一个线性和函数再通过一个sigmod函数来求得，这个线性和函数权重与特征值的累加以及加上偏置求出来的，所以在训练LR时也就是在训练线性和函数的各个权重值w。
关于这个权重值w一般使用最大似然法来估计，比如yi=<span class="number">1</span>的概率是pi,则yi=<span class="number">0</span>的概率是<span class="number">1</span>-pi，那么观测概率为<span class="function"><span class="title">p</span><span class="params">(yi)</span></span>=pi^yi*(<span class="number">1</span>-pi)^(<span class="number">1</span>-yi)这个这个最大似然函数为（<span class="function"><span class="title">hw</span><span class="params">(xi)</span></span>^yi*(<span class="number">1</span>-<span class="function"><span class="title">hw</span><span class="params">(xi)</span></span>)^(<span class="number">1</span>-yi)）连乘，对这个似然函数取对数之后就会得到的表达式<span class="function"><span class="title">L</span><span class="params">(w)</span></span>=<span class="function"><span class="title">sigma</span><span class="params">(yi*log(hw(xi)</span></span>)-(<span class="number">1</span>-yi)<span class="function"><span class="title">log</span><span class="params">(<span class="number">1</span>-hw(xi)</span></span>))=<span class="function"><span class="title">sigma</span><span class="params">(yi*(w*xi)</span></span>-<span class="function"><span class="title">log</span><span class="params">(<span class="number">1</span>+exp(w*xi)</span></span>))，估计这个<span class="function"><span class="title">L</span><span class="params">(w)</span></span>的极大值就可以得到w的估计值。
所以求解问题就变成了这个最大似然函数的最优化问题，这里通常会采样随机梯度下降法和拟牛顿迭代法来进行优化
</code></pre><h3 id="梯度下降法">梯度下降法</h3><pre><code>如果hw(x)=1/(1-<span class="keyword">e</span>^(-wx))，
则cost function=-1/<span class="keyword">m</span>* sigma(yi*<span class="literal">log</span>(hw(<span class="keyword">xi</span>)+(1-yi)*<span class="literal">log</span>(1-hw(<span class="keyword">xi</span>)))=<span class="literal">j</span>(w)
这里就成了就<span class="literal">min</span>(<span class="literal">j</span>(w))
所以更新w的过程为
w:=w-lamea*<span class="literal">j</span>(w)'  (求导)
w:=w-lamea* 1/<span class="keyword">m</span>\*sigma[<span class="keyword">m</span>](hw(<span class="keyword">xi</span>)-yi)*<span class="keyword">xi</span>)
直到<span class="literal">j</span>(w)不能再的时候停止

梯度下降法的最大问题就是会陷入局部最优，并且每次在对当前样本计算cost的时候都需要去遍历全部样本才能得到cost值，这样计算速度就会慢很多（虽然在计算的时候可以转为矩阵乘法去更新整个w值）
所以现在好多框架（mahout）中一般使用随机梯度下降法，它在计算cost的时候只计算当前的代价，最终cost是在全部样本迭代一遍之求和得出，还有他在更新当前的参数w的时候并不是依次遍历样本，而是从所有的样本中随机选择一条进行计算，它方法收敛速度快（一般是使用最大迭代次数），并且还可以避免局部最优，并且还很容易并行（使用参数服务器的方式进行并行）
这里SGD可以改进的地方就是使用动态的梯度值<span class="keyword">alpha</span>=0.04*(1.0+<span class="keyword">n</span>+i)+Rate
</code></pre><h3 id="其他优化方法">其他优化方法</h3><ul>
<li>拟牛顿法（记得是需要使用Hessian矩阵和cholesky分解）</li>
<li>BFGS</li>
<li>L-BFGS</li>
</ul>
<blockquote>
<p>优缺点：无需选择学习率α，更快，但是更复杂</p>
</blockquote>
<h3 id="关于LR的过拟合问题：">关于LR的过拟合问题：</h3><blockquote>
<p>如果我们有很多的特性，在训练集上拟合得很好，但是在预测集上却达不到这种效果</p>
</blockquote>
<pre><code>1. 减少feature个数（人工定义留多少个feature、算法选取这些feature）
2. 正则化（留下所有的feature，但对于部分feature定义其parameter非常小）
    在cost上加   lamea(sigma(w^2))
    同时w的更新变为w:=w-rate* 1/<span class="keyword">m</span>\*sigma[<span class="keyword">m</span>](hw(<span class="keyword">xi</span>)-yi)*<span class="keyword">xi</span>+ （lamea/<span class="keyword">m</span>)*<span class="literal">w</span>
    注意：这里的w0不受正则化影响
</code></pre><h3 id="关于LR的多分类：softmax">关于LR的多分类：softmax</h3><pre><code>softmax:假设离散型随机变量Y的取值集合是{<span class="number">1</span>,<span class="number">2</span>,..,k},则多分类的LR为
P<span class="comment">(Y=a|x)</span>=exp<span class="comment">(wa*x)</span>/<span class="comment">(1-1到k求和(wk*x)</span>)    <span class="number">1</span>&amp;<span class="keyword">lt</span>;a&amp;<span class="keyword">lt</span>;k
这里会输出当前样本下属于哪一类的概率，并且满足全部概率加起来=<span class="number">1</span>
</code></pre><h3 id="关于softmax和k个LR的选择">关于softmax和k个LR的选择</h3><p>如果类别之间是否互斥（比如音乐只能属于古典音乐、乡村音乐、摇滚月的一种）就用softmax<br>否则类别之前有联系（比如一首歌曲可能有影视原声，也可能包含人声，或者是舞曲），这个时候使用k个LR更为合适</p>
<p>优缺点：<br>Logistic回归优点：</p>
<ol>
<li>实现简单；</li>
<li>分类时计算量非常小，速度很快，存储资源低；</li>
</ol>
<p>缺点：</p>
<ol>
<li>容易欠拟合，一般准确度不太高</li>
<li>只能处理两分类问题（在此基础上衍生出来的softmax可以用于多分类），且必须线性可分；</li>
</ol>
<p><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/18/2595410.html" target="_blank" rel="external">http://www.cnblogs.com/biyeymyhjob/archive/2012/07/18/2595410.html</a><br><a href="http://blog.csdn.net/abcjennifer/article/details/7716281" target="_blank" rel="external">http://blog.csdn.net/abcjennifer/article/details/7716281</a><br><a href="http://ufldl.stanford.edu/wiki/index.php/Softmax%E5%9B%9E%E5%BD%92" target="_blank" rel="external">http://ufldl.stanford.edu/wiki/index.php/Softmax%E5%9B%9E%E5%BD%92</a></p>
<h2 id="KNN算法">KNN算法</h2><p>给一个训练数据集和一个新的实例，在训练数据集中找出与这个新实例最近的k个训练实例，然后统计最近的k个训练实例中所属类别计数最多的那个类，就是新实例的类</p>
<h3 id="三要素：">三要素：</h3><ol>
<li>k值的选择</li>
<li>距离的度量（常见的距离度量有欧式距离，马氏距离等）</li>
<li>分类决策规则 （多数表决规则）</li>
</ol>
<h3 id="k值的选择">k值的选择</h3><ol>
<li>k值越小表明模型越复杂，更加容易过拟合</li>
<li>但是k值越大，模型越简单，如果k=N的时候就表明无论什么点都是训练集中类别最多的那个类</li>
</ol>
<blockquote>
<p>所以一般k会取一个较小的值，然后用过交叉验证来确定<br>这里所谓的交叉验证就是将样本划分一部分出来为预测样本，比如95%训练，5%预测，然后k分别取1，2，3，4，5之类的，进行预测，计算最后的分类误差，选择误差最小的k</p>
</blockquote>
<h3 id="KNN的回归">KNN的回归</h3><p>在找到最近的k个实例之后，可以计算这k个实例的平均值作为预测值。或者还可以给这k个实例添加一个权重再求平均值，这个权重与度量距离成反比（越近权重越大）。</p>
<h3 id="优缺点：">优缺点：</h3><p>KNN算法的优点：</p>
<ol>
<li>思想简单，理论成熟，既可以用来做分类也可以用来做回归；</li>
<li>可用于非线性分类；</li>
<li>训练时间复杂度为O(n)；</li>
<li>准确度高，对数据没有假设，对outlier不敏感；</li>
</ol>
<p>缺点：</p>
<ol>
<li>计算量大；</li>
<li>样本不平衡问题（即有些类别的样本数量很多，而其它样本的数量很少）；</li>
<li>需要大量的内存；</li>
</ol>
<h3 id="KD树">KD树</h3><p>KD树是一个二叉树，表示对K维空间的一个划分，可以进行快速检索（那KNN计算的时候不需要对全样本进行距离的计算了）</p>
<h4 id="构造KD树">构造KD树</h4><p>在k维的空间上循环找子区域的中位数进行划分的过程。<br>假设现在有K维空间的数据集T={x1,x2,x3,…xn},xi={a1,a2,a3..ak}</p>
<ol>
<li>首先构造根节点，以坐标a1的中位数b为切分点，将根结点对应的矩形局域划分为两个区域，区域1中a1<b,区域2中a1>b</b,区域2中a1></li>
<li>构造叶子节点，分别以上面两个区域中a2的中位数作为切分点，再次将他们两两划分，作为深度1的叶子节点，（如果a2=中位数，则a2的实例落在切分面）</li>
<li>不断重复2的操作，深度为j的叶子节点划分的时候，索取的ai 的i=j%k+1，直到两个子区域没有实例时停止</li>
</ol>
<h4 id="KD树的搜索">KD树的搜索</h4><ol>
<li>首先从根节点开始递归往下找到包含x的叶子节点，每一层都是找对应的xi</li>
<li>将这个叶子节点认为是当前的“近似最近点”</li>
<li>递归向上回退，如果以x圆心，以“近似最近点”为半径的球与根节点的另一半子区域边界相交，则说明另一半子区域中存在与x更近的点，则进入另一个子区域中查找该点并且更新”近似最近点“</li>
<li>重复3的步骤，直到另一子区域与球体不相交或者退回根节点</li>
<li>最后更新的”近似最近点“与x真正的最近点</li>
</ol>
<h4 id="KD树进行KNN查找">KD树进行KNN查找</h4><p>通过KD树的搜索找到与搜索目标最近的点，这样KNN的搜索就可以被限制在空间的局部区域上了，可以大大增加效率。</p>
<h4 id="KD树搜索的复杂度">KD树搜索的复杂度</h4><p>当实例随机分布的时候，搜索的复杂度为log(N)，N为实例的个数，KD树更加适用于实例数量远大于空间维度的KNN搜索，如果实例的空间维度与实例个数差不多时，它的效率基于等于线性扫描。</p>
<h2 id="SVM、SMO">SVM、SMO</h2><p>对于样本点(xi,yi)以及svm的超平面：wix+b=0</p>
<ul>
<li>函数间隔：yi(wxi+b)</li>
<li>几何间隔：yi(wxi+b)/||w||,其中||w||为w的L2范数，几何间隔不会因为参数比例的改变而改变</li>
</ul>
<blockquote>
<p>svm的基本想法就是求解能正确划分训练样本并且其几何间隔最大化的超平面。</p>
</blockquote>
<h3 id="线性SVM问题">线性SVM问题</h3><p>yi(wxi+b)/||w||&gt;=d  （使用几何间隔）<br>求max(d)<br>那么假设d’=d<em>||w||<br>则将问题转为：yi(wxi+b)&gt;=1,max(d’/||w||)<br>由于d’的成比例增减不会影响实际间距，所以这里的取d’=1，又因为max(1/||w||)=min(1/2\</em>||w||^2)<br>所以最终的问题就变为了<br>yi(wxi+b)&gt;=1,min(1/2*||w||^2)<br>这样就变成了一个凸的二次规划化，可以将其转换为拉格朗日函数，然后使用对偶算法来求解</p>
<h4 id="对偶求解">对偶求解</h4><p>L(w,b,a)=1/2*||w||^2-sigma(ai*yi(wxi+b))+sigma(ai) 其中a={a1,a2..an}为拉格朗日向量<br>根据对偶性质  原始问题就是求对偶问题的极大极小max[a]min[w,b]L(w,b,a)<br>先求L对w,b的极小，再求对a的极大<br>求min[w,b]L(w,b,a)：<br>L’(w)=w-sigma(aiyixi)=0<br>L’(b)=sigma(aiyi)=0;<br>代入后可得min[w,b]L(w,b,a)=-1/2*sigma(sigma(aiajyiyj(xi·xj)))+sigma(ai)<br>求min[w,b]L(w,b,a)对a的极大<br>max[a] -1/2*sigma(sigma(aiajyiyj(xi·xj)))+sigma(ai)<br>sigma(aiyi)=0<br>转成等价的对偶形式就是<br>min[a] 1/2*sigma(sigma(aiajyiyj(xi·xj)))-sigma(ai)<br>sigma(aiyi)=0</p>
<p>假如求解出来的a为a^=(a1,a2,…an)<br>则得到最优的w,b分别为<br>w^=sigma(aiyixi)<br>b^=yj-sigma(aiyi(xi·xj))</p>
<p>所以，最终的决策分类面为<br>f=sign(sigma(aiyi(x·xi))+b^<br>也就是说，分类决策函数只依赖于输入x与训练样本的输入的内积</p>
<blockquote>
<p>与分离超平面最近的样本点称为支持向量</p>
</blockquote>
<h3 id="损失函数">损失函数</h3><p>经验损失函数:sigma(1-yi(wxi+b))   (注意，如果该值小于0时直接取0即可)<br>合页损失函数：sigma(1-yi(wi+b)) + leama||w||^2 后面的是L2正则项</p>
<h3 id="为什么要引入对偶算法">为什么要引入对偶算法</h3><ol>
<li>对偶问题往往更加容易求解(结合拉格朗日和kkt条件)</li>
<li>可以很自然的引用核函数（拉格朗日表达式里面有内积，而核函数也是通过内积进行映射的）</li>
</ol>
<h3 id="核函数">核函数</h3><p>将输入特征x（线性不可分）映射到高维特征R空间，可以在R空间上让SVM进行线性可以变，这就是核函数的作用</p>
<ul>
<li>多项式核函数:K(x,z)=(x*z+1)^p</li>
<li>高斯核函数:K(x,z)=exp(-(x-z)^2/a^2)   a为均值</li>
<li>字符串核函数：好像用于文本匹配、检索之类的，不懂</li>
</ul>
<h3 id="SVM优缺点">SVM优缺点</h3><p>优点：</p>
<ol>
<li>使用核函数可以向高维空间进行映射</li>
<li>使用核函数可以解决非线性的分类</li>
<li>分类思想很简单，就是将样本与决策面的间隔最大化</li>
<li>分类效果较好</li>
</ol>
<p>缺点：</p>
<ol>
<li>对大规模数据训练比较困难，因为它是用二次规划来求解的</li>
<li>无法直接支持多分类，但是可以使用间接的方法来做</li>
</ol>
<h3 id="SMO">SMO</h3><p>SMO是用于快速求解SVM的<br>它选择凸二次规划的两个变量，其他的变量保持不变，然后根据这两个变量构建一个二次规划问题，这个二次规划关于这两个变量解会更加的接近原始二次规划的解，通过这样的子问题划分可以大大增加整个算法的计算速度，关于这两个变量：</p>
<ol>
<li>其中一个是严重违反KKT条件的一个变量</li>
<li>另一个变量是根据自由约束确定，好像是求剩余变量的最大化来确定的。</li>
</ol>
<h3 id="SVM多分类问题">SVM多分类问题</h3><ol>
<li>直接法<br> 直接在目标函数上进行修改，将多个分类面的参数求解合并到一个最优化问题中，通过求解该优化就可以实现多分类（计算复杂度很高，实现起来较为困难）</li>
<li>间接法<ol>
<li>一对多<br><br>其中某个类为一类，其余n-1个类为另一个类，比如A,B,C,D四个类，第一次A为一个类，{B,C,D}为一个类训练一个分类器，第二次B为一个类,{A,C,D}为另一个类,按这方式共需要训练4个分类器，最后在测试的时候将测试样本经过这4个分类器f1(x),f2(x),f3(x)和f4(x),取其最大值为分类器(这种方式由于是1对M分类，会存在偏置，很不实用)</li>
<li>一对一(libsvm实现的方式)<br><br>任意两个类都训练一个分类器，那么n个类就需要n*(n-1)/2个svm分类器。<br><br>还是以A,B,C,D为例,那么需要{A,B},{A,C},{A,D},{B,C},{B,D},{C,D}为目标共6个分类器，然后在预测的将测试样本通过这6个分类器之后进行投票选择最终结果。（这种方法虽好，但是需要n*(n-1)/2个分类器代价太大，不过有好像使用循环图来进行改进）</li>
</ol>
</li>
</ol>
<h2 id="决策树">决策树</h2><p>决策树是一颗依托决策而建立起来的树。</p>
<h3 id="ID3">ID3</h3><ol>
<li>首先是针对当前的集合，计算每个特征的信息增益</li>
<li>然后选择信息增益最大的特征作为当前节点的决策决策特征</li>
<li>根据特征不同的类别划分到不同的子节点（比如年龄特征有青年，中年，老年，则划分到3颗子树）</li>
<li>然后继续对子节点进行递归，直到所有特征都被划分</li>
</ol>
<p>S(C,ai)=-sigma(pi<em>log(pi)) 一个属性中某个类别的熵  pi=P(yi|ai) pi表示ai情况下发生yi的概率，也即是统计概率<br>S(C,A)=sigma(P(A=ai)\</em>S(ai))  整个属性的熵，为各个类别的比例与各自熵的加权求和<br>Gain(C,A)=S(C)-S(C,A) 增益表示分类目标的熵减去当前属性的熵，增益越大，分类能力越强<br>(这里前者叫做经验熵，表示数据集分类C的不确定性，后者就是经验条件熵，表示在给定A的条件下对数据集分类C的不确定性，两者相减叫做互信息，决策树的增益等价于互信息)<br>比如说当前属性是是否拥有房产，分类是是否能偿还债务<br>现在：</p>
<ul>
<li>有用房产为7个，4个能偿还债务，3个无法偿还债务</li>
<li>然后无房产为3个，其中1个能偿还债务，2个无法偿还债务</li>
</ul>
<p>然后S(有房产)=-(4/7*log4/7+3/7*log3/7)<br>    S(无房产)=-(1/3*log1/3+2/3*log2/3)<br>    其中S(分类)=-(5/10*log5/10+5/10*log5/10)<br>    最终的增益=S(分类)-(7/10*S(有房产)+3/10*S(无房产))  最大越好</p>
<p>关于损失函数<br>设树的叶子节点个数为T，t为其中一个叶子节点，该叶子节点有Nt个样本，其中k类的样本有Ntk个，H(t)为叶子节点上的经验熵，则损失函数定义为<br>Ct(T)=sigma(Nt*H(t))+ lamdba |T|<br>其中H(t)=sigma(Ntk/Nt*log(Ntk/Nt))<br>代入可以得到Ct(T)=sigma(sigma(Ntk*log(Ntk/Nt)))+lamdba|T|<br>最终有Ct(T)=C(T)+ lamdba|T|<br>lamdba|T|为正则化项，leama是用于调节比率<br>决策树的生成只考虑了信息增益</p>
<h3 id="C4-5">C4.5</h3><p>它是ID3的一个改进算法，使用信息增益率来进行属性的选择<br>splitInformation(S,A)=-sigma(|Si|/|S|*log2(|Si|/|S|))<br>GainRatio(S,A)=Gain(S,A)/splitInformation(S,A)</p>
<p>优缺点：<br>准确率高，但是子构造树的过程中需要进行多次的扫描和排序，所以它的运算效率较低</p>
<h3 id="Cart">Cart</h3><p>分类回归树(Classification And Regression Tree)是一个决策二叉树，在通过递归的方式建立，每个节点在分裂的时候都是希望通过最好的方式将剩余的样本划分成两类，这里的分类指标：</p>
<ol>
<li>分类树：基尼指数最小化(gini_index)</li>
<li>回归树：平方误差最小化</li>
</ol>
<p>分类树：</p>
<ol>
<li>首先是根据当前特征计算他们的基尼增益</li>
<li>选择基尼增益最小的特征作为划分特征</li>
<li>从该特征中查找基尼指数最小的分类类别作为最优划分点</li>
<li>将当前样本划分成两类，一类是划分特征的类别等于最优划分点，另一类就是不等于</li>
<li>针对这两类递归进行上述的划分工作，直达所有叶子指向同一样本目标或者叶子个数小于一定的阈值</li>
</ol>
<p>gini用来度量分布不均匀性（或者说不纯），总体的类别越杂乱，GINI指数就越大（跟熵的概念很相似）<br>gini(ai)=1-sigma(pi^2) pi当前数据集中第i类样本的比例<br>gini越小，表示样本分布越均匀（0的时候就表示只有一类了），越大越不均匀<br>基尼增益gini_gain=sigma(Ni/N*gini(ai)) 表示当前属性的一个混乱  Ni/N表示当前类别占所有类别的概率<br>最终Cart选择GiniGain最小的特征作为划分特征</p>
<p>以ID3中的贷款的那棵树为样例：<br>gini(有房产)=1-((3/7)^2+(4/7)^2)  //基尼指数<br>gini(无房产)=1-((1/3)^2+(2/3)^2)<br>gini_gain=7/10*gini(有房产)+3/10*gini(无房产)  //基尼增益</p>
<p>回归树：</p>
<blockquote>
<p>回归树是以平方误差最小化的准则划分为两块区域</p>
</blockquote>
<ol>
<li>遍历特征计算最优的划分点s，<br> 使其最小化的平方误差是：min{min(R1.sigma((yi-c1)^2))+min(R2.sigma((yi-c2)^2))}<br> 计算根据s划分到左侧和右侧子树的目标值与预测值之差的平方和最小，这里的预测值是两个子树上输入xi样本对应yi的均值</li>
<li>找到最小的划分特征j以及其最优的划分点s,根据特征j以及划分点s将现有的样本划分为两个区域，一个是在特征j上小于等于s，另一个在在特征j上大于s<br> R1(j)={x|x(j)&lt;=s}、R2(j)={x|x(j)&gt;s}</li>
<li>进入两个子区域按上述方法继续划分，直到到达停止条件</li>
</ol>
<blockquote>
<p>这里面的最小化我记得可以使用最小二乘法来求</p>
</blockquote>
<p>关于剪枝：用独立的验证数据集对训练集生长的树进行剪枝（事后剪枝）。</p>
<h3 id="停止条件">停止条件</h3><ol>
<li>直到每个叶子节点都只有一种类型的记录时停止，（这种方式很容易过拟合）</li>
<li>另一种时当叶子节点的记录树小于一定的阈值或者节点的信息增益小于一定的阈值时停止</li>
</ol>
<h3 id="关于特征与目标值">关于特征与目标值</h3><ol>
<li>特征离散 目标值离散：可以使用ID3，cart</li>
<li>特征连续 目标值离散：将连续的特征离散化  可以使用ID3，cart</li>
<li>特征离散 目标值连续</li>
</ol>
<h3 id="决策树的分类与回归">决策树的分类与回归</h3><ul>
<li>分类树<br>  输出叶子节点中所属类别最多的那一类</li>
<li>回归树<br>  输出叶子节点中各个样本值的平均值</li>
</ul>
<h3 id="理想的决策树">理想的决策树</h3><ol>
<li>叶子节点数尽量少</li>
<li>叶子节点的深度尽量小(太深可能会过拟合)</li>
</ol>
<h3 id="解决决策树的过拟合">解决决策树的过拟合</h3><ol>
<li>剪枝<ol>
<li>前置剪枝：在分裂节点的时候设计比较苛刻的条件，如不满足则直接停止分裂（这样干决策树无法到最优，也无法得到比较好的效果）</li>
<li>后置剪枝：在树建立完之后，用单个节点代替子树，节点的分类采用子树中主要的分类（这种方法比较浪费前面的建立过程）</li>
</ol>
</li>
<li>交叉验证</li>
<li>随机森林</li>
</ol>
<h3 id="优缺点-1">优缺点</h3><p>优点：</p>
<ol>
<li>计算量简单，可解释性强，比较适合处理有缺失属性值的样本，能够处理不相关的特征；<br>缺点：</li>
<li>单颗决策树分类能力弱，并且对连续值变量难以处理；</li>
<li>容易过拟合（后续出现了随机森林，减小了过拟合现象）；</li>
</ol>
<h2 id="随机森林RF">随机森林RF</h2><p>随机森林是有很多随机得决策树构成，它们之间没有关联。得到RF以后，在预测时分别对每一个决策树进行判断，最后使用Bagging的思想进行结果的输出（也就是投票的思想）</p>
<h3 id="学习过程">学习过程</h3><ol>
<li>现在有N个训练样本，每个样本的特征为M个，需要建K颗树</li>
<li>从N个训练样本中有放回的取N个样本作为一组训练集（其余未取到的样本作为预测分类，评估其误差）</li>
<li>从M个特征中取m个特征左右子集特征(m&lt;&lt;M)</li>
<li>对采样的数据使用完全分裂的方式来建立决策树，这样的决策树每个节点要么无法分裂，要么所有的样本都指向同一个分类</li>
<li>重复2的过程K次，即可建立森林</li>
</ol>
<h3 id="预测过程">预测过程</h3><ol>
<li>将预测样本输入到K颗树分别进行预测</li>
<li>如果是分类问题，直接使用投票的方式选择分类频次最高的类别</li>
<li>如果是回归问题，使用分类之后的均值作为结果</li>
</ol>
<h3 id="参数问题">参数问题</h3><ol>
<li>这里的一般取m=sqrt(M)</li>
<li>关于树的个数K，一般都需要成百上千，但是也有具体的样本有关（比如特征数量）</li>
<li>树的最大深度，（太深可能可能导致过拟合？？）</li>
<li>节点上的最小样本数、最小信息增益</li>
</ol>
<h3 id="泛化误差估计">泛化误差估计</h3><p>使用oob（out-of-bag）进行泛化误差的估计，将各个树的未采样样本作为预测样本（大约有36.8%），使用已经建立好的森林对各个预测样本进行预测，预测完之后最后统计误分得个数占总预测样本的比率作为RF的oob误分率。</p>
<h3 id="学习算法">学习算法</h3><ol>
<li>ID3算法：处理离散值的量</li>
<li>C45算法：处理连续值的量</li>
<li>Cart算法：离散和连续 两者都合适？</li>
</ol>
<h3 id="关于CART">关于CART</h3><p>Cart可以通过特征的选择迭代建立一颗分类树，使得每次的分类平面能最好的将剩余数据分为两类</p>
<p>gini=1-sigma(pi^2)，表示每个类别出现的概率和与1的差值，<br>分类问题：argmax（Gini-GiniLeft-GiniRight）<br>回归问题argmax(Var-VarLeft-VarRight) </p>
<p>查找最佳特征f已经最佳属性阈值th  小于th的在左边，大于th的在右边子树</p>
<h3 id="优缺点-2">优缺点</h3><ol>
<li>能够处理大量特征的分类，并且还不用做特征选择</li>
<li>在训练完成之后能给出哪些feature的比较重要</li>
<li>训练速度很快</li>
<li>很容易并行</li>
<li>实现相对来说较为简单</li>
</ol>
<h2 id="GBDT">GBDT</h2><blockquote>
<p>GBDT的精髓在于训练的时候都是以上一颗树的残差为目标，这个残差就是上一个树的预测值与真实值的差值。</p>
</blockquote>
<pre><code>比如，当前样本年龄是18岁，那么第一颗会去按18岁来训练，但是训练完之后预测的年龄为12岁，差值为6，所以第二颗树的会以6岁来进行训练，假如训练完之后预测出来的结果为6，那么两棵树累加起来就是真实年龄了，但是假如第二颗树预测出来的结果是5，那么剩余的残差1就会交给第三个树去训练。
</code></pre><p>Boosting的好处就是每一步的参加就是变相了增加了分错instance的权重，而对已经对的instance趋向于0，这样后面的树就可以更加关注错分的instance的训练了</p>
<h3 id="Shrinkage">Shrinkage</h3><p>Shrinkage认为，每次走一小步逐步逼近的结果要比每次迈一大步逼近结果更加容易避免过拟合。<br>y(1 ~ i) = y(1 ~ i-1) + step * yi</p>
<blockquote>
<p>就像我们做互联网，总是先解决60%用户的需求凑合着，再解决35%用户的需求，最后才关注那5%人的需求，这样就能逐渐把产品做好.</p>
</blockquote>
<h3 id="调参">调参</h3><ol>
<li>树的个数  100~10000</li>
<li>叶子的深度 3~8</li>
<li>学习速率    0.01~1</li>
<li>叶子上最大节点树  20</li>
<li>训练采样比例 0.5~1</li>
<li>训练特征采样比例  sqrt(num)</li>
</ol>
<h3 id="优缺点：-1">优缺点：</h3><p>优点：</p>
<ol>
<li>精度高</li>
<li>能处理非线性数据</li>
<li>能处理多特征类型</li>
<li>适合低维稠密数据<br>缺点：</li>
<li>并行麻烦（因为上下两颗树有联系）</li>
<li>多分类的时候 复杂度很大</li>
</ol>
<h2 id="BP">BP</h2><h2 id="最小二乘法">最小二乘法</h2><p>最小二乘法是一种数学的优化技术，通过求最小化平方误差来寻找最佳的函数匹配<br>假设现在有二维的观测数据(x1,y1),(x2,y2)…(xn,yn)，求y=a+bx的拟合。</p>
<p>现设yi=a+bxi+ki 如果有a,b能得到sigma(|ki|)最小，则该线比较理想<br>所以先变为求min(sigma(ki)) ，这个与min(sigma(ki^2))等价<br>而ki=yi-(a+bxi)<br>那么现设f=sigma((yi-(a+bxi))^2)求其最小即可</p>
<blockquote>
<p>上述就是最小二乘原则，估计a,b的方法称为最小二乘法</p>
</blockquote>
<p>先求f对a,b的偏导：<br>f’(a)=-2*sigma(yi-(a+bxi))=0<br>f’(b)=-2*xi*sigma(yi-(a+bxi))=0</p>
<p>现设：X=sigma(xi)/n   Y=sigma(yi)/<br>则代入上述偏导：<br>an+bnX=nY<br>anX+b*sigma(xi^2)=sigma(xi*yi)</p>
<p>求该行列式:<br>|n ,nX         |<br>|nX,sigma(xi^2)|<br>=n*sigma((xi-X))!=0  所以有唯一解</p>
<p>最后记：<br>l(xx)=sigma((xi-X)^2)<br>l(yy)=sigma((yi-Y)^2)<br>l(xy)=sigma((xi-X)(yi-Y))</p>
<p>则b=l(xy)/l(xx)   a=Y-bX</p>
<p><a href="http://wenku.baidu.com/link?url=z-fofhp6T8y39P6tmaLzUiybVEQXpYTz6Uz-MjqxNNvg0GQrjCY0hA95mkqxg1Suk-fT_z-gq2jiMUhH9OWrv2e9kOA4uZ7ZlS6CcM2O0Zq" target="_blank" rel="external">百度文库-最小二乘法</a></p>
<h2 id="EM">EM</h2><p>EM用于隐含变量的概率模型的极大似然估计，它一般分为两步：第一步求期望(E),第二步求极大(M)，<br>如果概率模型的变量都是观测变量，那么给定数据之后就可以直接使用极大似然法或者贝叶斯估计模型参数。<br>但是当模型含有隐含变量的时候就不能简单的用这些方法来估计，EM就是一种含有隐含变量的概率模型参数的极大似然估计法。</p>
<p>应用到的地方：混合高斯模型、混合朴素贝叶斯模型、因子分析模型</p>
<h2 id="Bagging">Bagging</h2><ol>
<li>从N样本中有放回的采样N个样本</li>
<li>对这N个样本在全属性上建立分类器(CART,SVM)</li>
<li>重复上面的步骤，建立m个分类器</li>
<li>预测的时候使用投票的方法得到结果</li>
</ol>
<h2 id="Boosting">Boosting</h2><p>boosting在训练的时候会给样本加一个权重，然后使loss function尽量去考虑那些分错类的样本（比如给分错类的样本的权重值加大）</p>
<h2 id="凸优化">凸优化</h2><p>在机器学习中往往是最终要求解某个函数的最优值，但是一般情况下，任意一个函数的最优值求解比较困难，但是对于凸函数来说就可以有效的求解出全局最优值。</p>
<h3 id="凸集">凸集</h3><p>一个集合C是，当前仅当任意x,y属于C且0&lt;=theta&lt;=1，都有theta*x+(1-theta)*y属于C<br>用通俗的话来说C集合线段上的任意两点也在C集合中</p>
<h3 id="凸函数">凸函数</h3><p>一个函数f其定义域(D(f))是凸集，并且对任意x,y属于D(f)和0&lt;=theta&lt;=1都有<br><br>f(theta*x+(1-theta)*y)&lt;=theta*f(x)+(1-theta)*f(y)   —这个貌似叫做jensen不等式<br><br>用通俗的话来说就是曲线上任意两点的割线都在曲线的上方</p>
<p>常见的凸函数有：</p>
<ul>
<li>指数函数f(x)=a^x   a&gt;1</li>
<li>负对数函数-logax  a&gt;1,x&gt;0</li>
<li>开口向上的二次函数等</li>
</ul>
<p>凸函数的判定：</p>
<ol>
<li>如果f是一阶可导，对于任意数据域内的x,y满足f(y)&gt;=f(x)+f’(x)(y-x)</li>
<li>如果f是二阶可导，</li>
</ol>
<h3 id="凸优化应用举例">凸优化应用举例</h3><ul>
<li>SVM：其中由max|w|  转向min(1/2*|w|^2)</li>
<li>最小二乘法？</li>
<li>LR的损失函数sigma(yi*log(hw(x))+(1-yi)*(log(1-hw(x))))</li>
</ul>
<h2 id="备注">备注</h2><p>资料主要来源于网络或者《统计学习方法》，还有自己一小部分的总结，如果错误之处敬请指出</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="朴素贝叶斯">朴素贝叶斯</h2><p>P(A∩B)=P(A)*P(B|A)=P(B)*P(A|B)<br>所以有：P(A|B)=P(B|A)*P(A)/P(B)</p>
<p>对于给出的待分类项，求解在此项出现的条件下各个目标类别出现的概率，哪个最大，就认为此待分类项属于哪个类别</p>
<h3 id="工作原理">工作原理</h3><ol>
<li>假设现在有样本x=(a1,a2,a3,…an)这个待分类项(并认为x里面的特征独立)</li>
<li>再假设现在有分类目标Y={y1,y2,y3,y4..yn}</li>
<li>那么max(P(y1|x),P(y2|x),P(y3|x)..P(yn|x))中的最大者就是最终的分类类别</li>
<li>而P(yi|x)=p(x|yi)*P(yi)/P(x)</li>
<li>因为x对于每个分类目标来说都一样，所以就是求max(P(x|yi)*p(yi))</li>
<li>P(x|yi)*p(yi)=p(yi)*PI(P(ai|yi))  (PI表示连乘)</li>
<li>而具体的p(ai|yi)和p(yi)都是能从训练样本中统计出来<br /><br> p(ai|yi)表示该类别下该特征出现的概率<br /><br> p(yi)表示全部类别中这个这个类别出现的概率</li>
<li>好的，就是这么工作的^_^</li>
</ol>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习常见面试题整理]]></title>
    <link href="http://yyl8781697.github.io/2015/08/16/Machine%20Learning/Common-Interview/"/>
    <id>http://yyl8781697.github.io/2015/08/16/Machine Learning/Common-Interview/</id>
    <published>2015-08-15T23:39:47.000Z</published>
    <updated>2015-08-15T23:47:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="有监督学习和无监督学习的区别">有监督学习和无监督学习的区别</h2><ul>
<li>有监督学习：对具有标记的训练样本进行学习，以尽可能对训练样本集外的数据进行分类预测。（LR,SVM,BP,RF,GBRT）</li>
<li>无监督学习：对未标记的样本进行训练学习，比发现这些样本中的结构知识。(KMeans,DL)</li>
</ul>
<h2 id="正则化">正则化</h2><p>正则化是针对过拟合而提出的，以为在求解模型最优的是一般优化最小的经验风险，现在在该经验风险上加入模型复杂度这一项（正则化项是模型参数向量的范数），并使用一个rate比率来权衡模型复杂度与以往经验风险的权重，如果模型复杂度越高，结构化的经验风险会越大，现在的目标就变为了结构经验风险的最优化，可以防止模型训练过度复杂，有效的降低过拟合的风险。</p>
<blockquote>
<p>奥卡姆剃刀原理，能够很好的解释已知数据并且十分简单才是最好的模型。</p>
</blockquote>
<a id="more"></a>
<h2 id="过拟合">过拟合</h2><p>如果一味的去提高训练数据的预测能力，所选模型的复杂度往往会很高，这种现象称为过拟合。所表现的就是模型训练时候的误差很小，但在测试的时候误差很大。</p>
<h3 id="产生的原因">产生的原因</h3><ol>
<li>因为参数太多，会导致我们的模型复杂度上升，容易过拟合</li>
<li>权值学习迭代次数足够多(Overtraining),拟合了训练数据中的噪声和训练样例中没有代表性的特征.</li>
</ol>
<h3 id="解决方法">解决方法</h3><ol>
<li>交叉验证法</li>
<li>减少特征</li>
<li>正则化</li>
<li>权值衰减</li>
<li>验证数据</li>
</ol>
<h2 id="泛化能力">泛化能力</h2><p>泛化能力是指模型对未知数据的预测能力</p>
<h2 id="生成模型和判别模型">生成模型和判别模型</h2><ol>
<li>生成模型：由数据学习联合概率分布P(X,Y)，然后求出条件概率分布P(Y|X)作为预测的模型，即生成模型：P(Y|X)= P(X,Y)/ P(X)。（朴素贝叶斯）<br> 生成模型可以还原联合概率分布p(X,Y)，并且有较快的学习收敛速度，还可以用于隐变量的学习</li>
<li>判别模型：由数据直接学习决策函数Y=f(X)或者条件概率分布P(Y|X)作为预测的模型，即判别模型。（k近邻、决策树）<br> 直接面对预测，往往准确率较高，直接对数据在各种程度上的抽象，所以可以简化模型</li>
</ol>
<h2 id="线性分类器与非线性分类器的区别以及优劣">线性分类器与非线性分类器的区别以及优劣</h2><p>如果模型是参数的线性函数，并且存在线性分类面，那么就是线性分类器，否则不是。<br>常见的线性分类器有：LR,贝叶斯分类，单层感知机、线性回归<br>常见的非线性分类器：决策树、RF、GBDT、多层感知机</p>
<blockquote>
<p>SVM两种都有(看线性核还是高斯核)</p>
</blockquote>
<ul>
<li>线性分类器速度快、编程方便，但是可能拟合效果不会很好</li>
<li>非线性分类器编程复杂，但是效果拟合能力强</li>
</ul>
<h3 id="特征比数据量还大时，选择什么样的分类器？">特征比数据量还大时，选择什么样的分类器？</h3><p>线性分类器，因为维度高的时候，数据一般在维度空间里面会比较稀疏，很有可能线性可分</p>
<h3 id="对于维度很高的特征，你是选择线性还是非线性分类器？">对于维度很高的特征，你是选择线性还是非线性分类器？</h3><p>理由同上</p>
<h3 id="对于维度极低的特征，你是选择线性还是非线性分类器？">对于维度极低的特征，你是选择线性还是非线性分类器？</h3><p>非线性分类器，因为低维空间可能很多特征都跑到一起了，导致线性不可分</p>
<h2 id="ill-condition病态问题">ill-condition病态问题</h2><p>训练完的模型测试样本稍作修改就会得到差别很大的结果，就是病态问题（这简直是不能用啊）</p>
<h2 id="L1和L2正则的区别，如何选择L1和L2正则">L1和L2正则的区别，如何选择L1和L2正则</h2><blockquote>
<p>他们都是可以防止过拟合，降低模型复杂度</p>
</blockquote>
<ul>
<li>L1是在loss function后面加上 模型参数的1范数（也就是|xi|）</li>
<li><p>L2是在loss function后面加上 模型参数的2范数（也就是sigma(xi^2)），注意L2范数的定义是sqrt(sigma(xi^2))，在正则项上没有添加sqrt根号是为了更加容易优化</p>
</li>
<li><p>L1 会产生稀疏的特征</p>
</li>
<li>L2 会产生更多地特征但是都会接近于0 </li>
</ul>
<p>L1会趋向于产生少量的特征，而其他的特征都是0，而L2会选择更多的特征，这些特征都会接近于0。L1在特征选择时候非常有用，而L2就只是一种规则化而已。</p>
<h2 id="特征向量的归一化方法">特征向量的归一化方法</h2><ol>
<li>线性函数转换，表达式如下：y=(x-MinValue)/(MaxValue-MinValue)</li>
<li>对数函数转换，表达式如下：y=log10 (x)</li>
<li>反余切函数转换 ，表达式如下：y=arctan(x)*2/PI</li>
<li>减去均值，乘以方差：y=(x-means)/ variance</li>
</ol>
<h2 id="特征向量的异常值处理">特征向量的异常值处理</h2><ol>
<li>用均值或者其他统计量代替</li>
</ol>
<h2 id="越小的参数说明模型越简单">越小的参数说明模型越简单</h2><p>过拟合的，拟合会经过曲面的每个点，也就是说在较小的区间里面可能会有较大的曲率，这里的导数就是很大，线性模型里面的权值就是导数，所以越小的参数说明模型越简单。</p>
<blockquote>
<p>这个其实可以看VC维相关的东西感觉更加合适</p>
</blockquote>
<h2 id="svm中rbf核函数与高斯和函数的比较">svm中rbf核函数与高斯和函数的比较</h2><p>高斯核函数好像是RBF核的一种</p>
<h2 id="ROC、AUC">ROC、AUC</h2><p>ROC和AUC通常是用来评价一个二值分类器的好坏</p>
<h3 id="ROC曲线">ROC曲线</h3><p>曲线坐标上：</p>
<ul>
<li>X轴是FPR（表示假阳率-预测结果为positive，但是实际结果为negitive，FP/(N)）</li>
<li>Y轴式TPR（表示真阳率-预测结果为positive，而且的确真实结果也为positive的,TP/P）</li>
</ul>
<p>那么平面的上点(X,Y)：</p>
<ul>
<li>(0,1)表示所有的positive的样本都预测出来了，分类效果最好</li>
<li>(0,0)表示预测的结果全部为negitive</li>
<li>(1,0)表示预测的错过全部分错了，分类效果最差</li>
<li>(1,1)表示预测的结果全部为positive<blockquote>
<p>针对落在x=y上点，表示是采用随机猜测出来的结果</p>
</blockquote>
</li>
</ul>
<p>ROC曲线建立<br>一般默认预测完成之后会有一个概率输出p，这个概率越高，表示它对positive的概率越大。<br>现在假设我们有一个threshold，如果p&gt;threshold，那么该预测结果为positive，否则为negitive，按照这个思路，我们多设置几个threshold,那么我们就可以得到多组positive和negitive的结果了，也就是我们可以得到多组FPR和TPR值了<br>将这些(FPR,TPR)点投射到坐标上再用线连接起来就是ROC曲线了</p>
<blockquote>
<p>当threshold取1和0时，分别得到的就是(0,0)和(1,1)这两个点。（threshold=1，预测的样本全部为负样本，threshold=0，预测的样本全部为正样本）</p>
</blockquote>
<h3 id="AUC">AUC</h3><p>AUC(Area Under Curve)被定义为ROC曲线下的面积，显然这个面积不会大于1（一般情况下ROC会在x=y的上方，所以0.5&lt;AUC&lt;1）.</p>
<blockquote>
<p>AUC越大说明分类效果越好</p>
</blockquote>
<h3 id="为什么要使用ROC和AUC">为什么要使用ROC和AUC</h3><p>因为当测试集中的正负样本发生变化时，ROC曲线能基本保持不变，但是precision和recall可能就会有较大的波动。<br><a href="http://www.douban.com/note/284051363/?type=like" target="_blank" rel="external">http://www.douban.com/note/284051363/?type=like</a></p>
<h2 id="测试集和训练集的区别">测试集和训练集的区别</h2><p>训练集用于建立模型,测试集评估模型的预测等能力</p>
<h2 id="优化Kmeans">优化Kmeans</h2><p>使用kd树或者ball tree(这个树不懂)<br>将所有的观测实例构建成一颗kd树，之前每个聚类中心都是需要和每个观测点做依次距离计算，现在这些聚类中心根据kd树只需要计算附近的一个局部区域即可</p>
<h2 id="数据挖掘和机器学习的区别">数据挖掘和机器学习的区别</h2><p>机器学习是数据挖掘的一个重要工具，但是数据挖掘不仅仅只有机器学习这一类方法，还有其他很多非机器学习的方法，比如图挖掘，频繁项挖掘等。感觉数据挖掘是从目的而言的，但是机器学习是从方法而言的。</p>
<h2 id="备注">备注</h2><p>题目主要来源于网络，答案主要来源于网络或者《统计学习方法》，还有自己一小部分的总结，如果错误之处敬请指出</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="有监督学习和无监督学习的区别">有监督学习和无监督学习的区别</h2><ul>
<li>有监督学习：对具有标记的训练样本进行学习，以尽可能对训练样本集外的数据进行分类预测。（LR,SVM,BP,RF,GBRT）</li>
<li>无监督学习：对未标记的样本进行训练学习，比发现这些样本中的结构知识。(KMeans,DL)</li>
</ul>
<h2 id="正则化">正则化</h2><p>正则化是针对过拟合而提出的，以为在求解模型最优的是一般优化最小的经验风险，现在在该经验风险上加入模型复杂度这一项（正则化项是模型参数向量的范数），并使用一个rate比率来权衡模型复杂度与以往经验风险的权重，如果模型复杂度越高，结构化的经验风险会越大，现在的目标就变为了结构经验风险的最优化，可以防止模型训练过度复杂，有效的降低过拟合的风险。</p>
<blockquote>
<p>奥卡姆剃刀原理，能够很好的解释已知数据并且十分简单才是最好的模型。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一些面试常见的智力题啦]]></title>
    <link href="http://yyl8781697.github.io/2015/08/11/Algorithm/Intelligence-Problems/"/>
    <id>http://yyl8781697.github.io/2015/08/11/Algorithm/Intelligence-Problems/</id>
    <published>2015-08-11T15:10:06.000Z</published>
    <updated>2015-08-16T00:15:08.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>考智力，脑子不好使咋办？？只有记下来^_^</p>
</blockquote>
<h2 id="烧香/绳子计时1小时15分钟">烧香/绳子计时1小时15分钟</h2><pre><code>烧一根不均匀的绳,从头烧到尾总共需要 1 个小时。现在有若干条材质相同的绳子,问 如何用烧绳的方法来计时一个小时十五分钟呢?
</code></pre><p>假设现在有三根绳子A和B和C，现在将A的两端都点着，B的一端都点着<br>半小时过去后，A就烧没了，此时B应该还有半小时的时长可以烧，但是现在把B的另一端也点着<br>又过了十五分钟，B也烧没了，这个时候把C的两端也都点着<br>又过了半小时，C也烧没了<br>好了，一小时十五分钟就这么烧到了^_^<br>其实主要思路还是两端  一端 烧得搭配</p>
<a id="more"></a>
<h2 id="取两个同一颜色的果冻">取两个同一颜色的果冻</h2><pre><code>你有一桶果冻,其中有黄色、绿色、红色三种,闭上眼睛抓取同种颜色的两个。抓取多少 个就可以确定你肯定有两个同一颜色的果冻?
</code></pre><p>用鸽巢原理，很容易得出是4啊</p>
<h2 id="打水问题">打水问题</h2><pre><code>如果你有无穷多的水,一个 3 公升的􏰁捅,一个 5 公升的􏰁捅,两只􏰁捅形状上下都不 均匀,问你如何才能准确称出 4 公升的水
</code></pre><p>假设3、5公升的桶分别为A=0，B=0</p>
<ol>
<li>将B的桶装满，此时A=0,B=5</li>
<li>将B中的水倒入A，直到A满掉，此时A=3，B=2</li>
<li>A中的水倒掉，将B中剩余的水全部倒入A，此时A=2，B=0</li>
<li>将B中的水装满，此时，A=2，B=5</li>
<li>将B中的水倒入A直到A满了（也就是倒入了1升水），此时A=3，B=4</li>
</ol>
<h2 id="诚实国和说谎国">诚实国和说谎国</h2><pre><code>来了两个人,已知一个是诚实国的,另一个是说谎国的。 诚实国永远说实话,说谎国永远说谎话。现在你要去说谎国, 但不知道应该走哪条路,需要问这两个人。请问应该怎么问?
</code></pre><p>假设这两个人分别简称甲和乙.</p>
<ol>
<li><p>情况一</p>
<ul>
<li>问题1问甲：乙是来自说谎国的对吧?<br>如甲是说谎国的他只会说谎,甲不能回答正确答案乙是来自诚实国他必然回答“乙是来自诚实国”.</li>
<li>问题2问甲：乙是来自诚实国对吧?<br>如甲是说谎国的他只会说谎,那他在明知乙是诚实国人的情况下也回答“乙是来自说谎国”.<blockquote>
<p>经过前两个问题分析甲的回答前后矛盾,可知道甲在说谎,甲来自说谎国.</p>
</blockquote>
</li>
<li>问题3问甲：哪边的岔道口通向说谎国?<br>因为已经推论出甲必说谎话所以向他答案的反其道而行就好.</li>
</ul>
</li>
<li><p>情况二</p>
<ul>
<li>问题1问甲：乙是来自说谎国的对吧?<br>如甲是诚实的,他必然回答“乙是来自说谎国”.</li>
<li>问题2问甲：乙是来自诚实国对吧?<br>如甲是诚实的,他必然回答“不,乙来自说谎国”.<blockquote>
<p>经过前两个问题分析甲的回答前后一致,可知道甲是诚实的,甲来自诚实国.</p>
</blockquote>
</li>
<li>问题3问甲：哪边的岔道口通向说谎国?<br>按甲指出的方向走就好.</li>
</ul>
</li>
</ol>
<h2 id="称球问题">称球问题</h2><pre><code><span class="number">12</span> 个球一个天平,现知道只有一个和其它的重量不同,问怎样称才能用三次就找到那个 球。<span class="number">13</span> 个呢?<span class="comment">(注意此题并未说明那个球的重量是轻是重,所以需要仔细考虑)</span>
</code></pre><p><strong>先看12个球</strong><br>分三组:每组四个,第一组编号1-4，第二组5-8，第三组9-12.<br>第一次称：天平左边放第一组，右边放第二组。 </p>
<ul>
<li><p>A 第一种可能：<code>平衡</code>。则不同的在第三组。<br>  接下来可以在左边放第9、10、11号，右边放1、2、3号三个正常的。 </p>
<ul>
<li>a.如果<code>平衡</code>，则12号是不同的; </li>
<li>b.如果<code>左重右轻</code>，则不同的在9、10、11号中，而且比正常球重。再称一次：9放左边，10放右边，如果平衡，则11号是不同的；如果左重右轻，则9号是不同的，如果右重左轻，则10号是不同的。 </li>
<li>c.如果左轻右重，道理同b </li>
</ul>
</li>
<li><p>B 第二种可能：<code>左重右轻</code>，则不同的在1-8号中，但不知比正常的轻还是重。<br>  第二次称：左边放1、2、5号，右边放6、9、3号。 </p>
<ul>
<li>a.如果<code>平衡</code>。则不同的在4、7、8中。可以称第三次：左边放4、7，右边放9、10。如果平衡，则8是不同;如果左重右轻，则4是不同；如果左轻右重，则7是不同。 </li>
<li>b.仍然<code>左重右轻</code>。则不同的在位置没有改变的1、2、6中。可以称第三次：左边放1、6，右边放9、10。如果平衡，则2是不同; 如果左重右轻，则1是不同;如果左轻右重，则6是不同。 </li>
<li>c：<code>左轻右重</code>。则不同的在5、3、中，因为只有它们改变了原来的位置。可以称第三次：左放5，3，右放9，10。如果左轻右重，则5是不同，如果左重右轻，则3是不同。 </li>
</ul>
</li>
<li><p>C 第三种可能：<code>左轻右重</code>，道理同B </p>
<p>  至此，不论发生任何情况，称三次都可以找出不同，而且知道比正常的轻了还是重了。</p>
</li>
</ul>
<p><strong>现在来看13个球</strong><br>同样分三组，第一组编号1-4，第二组5-8，第三组9-13</p>
<ul>
<li>如果出现了上述A的情况，则说明不同的再第三组<br>  接下来可以左边放1、2、3  右边放9、19、11<ul>
<li>a 如果平衡，则说明不同的在12、13里面，那么拿一个正常的与12对比，即可得到结果</li>
<li>b 如果左重右轻，说明不同的球再11、12、13里面，则不同的在9、10、11号中，而且比正常球重。再称一次：9放左边，10放右边，如果平衡，则11号是不同的；如果左重右轻，则9号是不同的，如果右重左轻，则10号是不同的。 </li>
<li>c.如果左轻右重，道理同b </li>
</ul>
</li>
<li>如果出现了上述B或C的情况 按B或者C走就好了</li>
</ul>
<h2 id="每条直线上至少有三个点">每条直线上至少有三个点</h2><pre><code>在 9 个点上画 10 条直线,要求每条直线上至少有三个点
</code></pre><p>先画一个五角星，然后去掉一个点就可以了(bingo)</p>
<h2 id="抛硬币问题">抛硬币问题</h2><pre><code>101个硬币中有一个假币，有一个无砝码的天平，称两次，判断假币比真币重还是轻。
</code></pre><p>方案是分33，33，35三堆，先33与33称，</p>
<ul>
<li>如果相同，那么假币在35那堆里，然后去35枚真币与有假币那堆的称，就知道结果了。</li>
<li>如果33与33重量不相等，记录哪一堆更重，然后可以知道35枚硬币都只真的，从中取33枚，与其中33个中的一堆对比，<ul>
<li>如果相等，另一堆就是假，</li>
<li>不相等，那么这一堆就是假，根据之前记录的轻重比，就知道结果了。</li>
</ul>
</li>
</ul>
<h2 id="备注">备注</h2><p>理论上还会再更新-_-</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>考智力，脑子不好使咋办？？只有记下来^_^</p>
</blockquote>
<h2 id="烧香/绳子计时1小时15分钟">烧香/绳子计时1小时15分钟</h2><pre><code>烧一根不均匀的绳,从头烧到尾总共需要 1 个小时。现在有若干条材质相同的绳子,问 如何用烧绳的方法来计时一个小时十五分钟呢?
</code></pre><p>假设现在有三根绳子A和B和C，现在将A的两端都点着，B的一端都点着<br>半小时过去后，A就烧没了，此时B应该还有半小时的时长可以烧，但是现在把B的另一端也点着<br>又过了十五分钟，B也烧没了，这个时候把C的两端也都点着<br>又过了半小时，C也烧没了<br>好了，一小时十五分钟就这么烧到了^_^<br>其实主要思路还是两端  一端 烧得搭配</p>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[判断当前序列是否是二叉查找树的后续遍历结果]]></title>
    <link href="http://yyl8781697.github.io/2015/08/04/Algorithm/IsBSTPostOrder/"/>
    <id>http://yyl8781697.github.io/2015/08/04/Algorithm/IsBSTPostOrder/</id>
    <published>2015-08-04T13:54:53.000Z</published>
    <updated>2015-08-04T14:16:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>输入一个整数数组,判断该数组是不是某二元查找树的后序遍历的结果。 如果是返回 <span class="literal">true</span>,否则返回 <span class="literal">false</span>。
例如输入 <span class="number">5</span>、<span class="number">7</span>、<span class="number">6</span>、<span class="number">9</span>、<span class="number">11</span>、<span class="number">10</span>、<span class="number">8</span>,由于这一整数序列是如下树的后序遍历结果:
      <span class="number">8</span> 
     / <span class="string">\</span>
    <span class="number">6</span>  <span class="number">10</span> 
   /<span class="string">\</span>   /<span class="string">\</span> 
  <span class="number">5</span>  <span class="number">7</span> <span class="number">9</span>  <span class="number">11</span>
因此返回 <span class="literal">true</span>。
如果输入 <span class="number">7</span>、<span class="number">4</span>、<span class="number">6</span>、<span class="number">5</span>,没有哪棵树的后序遍历的结果是这个序列,因此返回 <span class="literal">false</span>
</code></pre><h2 id="解析">解析</h2><p>做该题之前还必须得了解什么是<a href="http://kubicode.me/2015/06/29/Data%20Struct/Binary-Search-Tree/" target="_blank" rel="external">二叉查找树</a><br>最主要的性质就是左子树的任何节点都小于根节点，右子树的任何节点都大于根节点。<br>然后后序遍历的最后一位肯定是根节点，所以，可以得到巧妙的方法为：<br>则该序列的最后一位a[n-1]必定是根节点，然后前面的序列中连续一部分是左子树的遍历，另一部份是右子树的遍历<br>此时需要在前面的序列中查找第一个大于root的节点a[i]<br><a id="more"></a></p>
<pre><code>来个例子：后序遍历5、7，6，9，11，10，8
第一次迭代：根节点为8 然后从左遍历过来可以发现9为首个大于8的地方，那么如果再9后面的都大于8的话就可以判断9以及后面的为8的右子树
此时成立，8的左子树为5,7,6 右子树为9,11,10
第二次迭代：
左子树  6为根节点  同理7为6的右子树，5为6的左子树
右子树  10为根节点  同理11为10的右子树 9为11的左子树
剩余各个左右子树的各个孩子节点都为空，迭代停止，该序列为后序遍历

再来看7、4，6，5
其中5为根节点，7为第一个大于5的节点，但是7之后的4小于5，所以7以及后面的数字不可能为5的右子树，同时又不可能为左子树，所以不成立
</code></pre><h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 通过左右子树的递归序列判断他们是否也能构成二叉查找树即可</span><br><span class="line"> *<span class="javadoctag"> @param</span> a</span><br><span class="line"> *<span class="javadoctag"> @param</span> left</span><br><span class="line"> *<span class="javadoctag"> @param</span> right</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBSTPostOrder</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//这两个小于0的判断都是因为仅存在左子树 或者 仅存在右子树的时候 存在left必定会大于right</span></span><br><span class="line">	<span class="keyword">if</span>(left&gt;=right)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> root=a[right];</span><br><span class="line">	<span class="keyword">int</span> mid=-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;right;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(mid!=-<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&lt;root)</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//第一个大于root后面的节点存在小于root的节点  直接返回false</span></span><br><span class="line">		&#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(a[i]&gt;root)</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			mid=i;<span class="comment">//查找第一个大于root的值</span></span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(mid==-<span class="number">1</span>)</span><br><span class="line">		mid=right;<span class="comment">//表示只有左子树</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//分别递归左右子树</span></span><br><span class="line">	<span class="keyword">return</span> isBSTPostOrder(a,left,mid-<span class="number">1</span>) &amp;&amp; isBSTPostOrder(a,mid,right-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a=&#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">8</span>&#125;;<span class="comment">//ok</span></span><br><span class="line"><span class="keyword">int</span>[] b=&#123;<span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;<span class="comment">//not ok</span></span><br><span class="line">System.out.println(isBSTPostOrder(a,<span class="number">0</span>,a.length-<span class="number">1</span>));</span><br><span class="line">System.out.println(isBSTPostOrder(b,<span class="number">0</span>,b.length-<span class="number">1</span>));</span><br></pre></td></tr></table></figure></p>
<pre><code><span class="literal">true</span>
<span class="literal">false</span>
</code></pre><h2 id="参考">参考</h2><p>July 微软面试100题 第9题</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>输入一个整数数组,判断该数组是不是某二元查找树的后序遍历的结果。 如果是返回 <span class="literal">true</span>,否则返回 <span class="literal">false</span>。
例如输入 <span class="number">5</span>、<span class="number">7</span>、<span class="number">6</span>、<span class="number">9</span>、<span class="number">11</span>、<span class="number">10</span>、<span class="number">8</span>,由于这一整数序列是如下树的后序遍历结果:
      <span class="number">8</span> 
     / <span class="string">\</span>
    <span class="number">6</span>  <span class="number">10</span> 
   /<span class="string">\</span>   /<span class="string">\</span> 
  <span class="number">5</span>  <span class="number">7</span> <span class="number">9</span>  <span class="number">11</span>
因此返回 <span class="literal">true</span>。
如果输入 <span class="number">7</span>、<span class="number">4</span>、<span class="number">6</span>、<span class="number">5</span>,没有哪棵树的后序遍历的结果是这个序列,因此返回 <span class="literal">false</span>
</code></pre><h2 id="解析">解析</h2><p>做该题之前还必须得了解什么是<a href="http://kubicode.me/2015/06/29/Data%20Struct/Binary-Search-Tree/">二叉查找树</a><br>最主要的性质就是左子树的任何节点都小于根节点，右子树的任何节点都大于根节点。<br>然后后序遍历的最后一位肯定是根节点，所以，可以得到巧妙的方法为：<br>则该序列的最后一位a[n-1]必定是根节点，然后前面的序列中连续一部分是左子树的遍历，另一部份是右子树的遍历<br>此时需要在前面的序列中查找第一个大于root的节点a[i]<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[删除指定的字符串]]></title>
    <link href="http://yyl8781697.github.io/2015/08/04/Algorithm/Delete-Specify-String/"/>
    <id>http://yyl8781697.github.io/2015/08/04/Algorithm/Delete-Specify-String/</id>
    <published>2015-08-04T13:26:01.000Z</published>
    <updated>2015-08-04T13:37:16.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>删除指定的字符串
比如They are students 和 aeiou 则删除之后剩下Thy r stdnts
</code></pre><h2 id="解析">解析</h2><p>关于此类查找之类的如果能往位图上靠就是最快速的，本题也可以，一个字符是8位，也就是会出现256中情况，所以现在只需要用一个256长度的位图就可以来判断当前字符是否存在待删除的字符字典中。<br><a id="more"></a></p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 使用类似位图法的方式来做  复杂度是O(n+m)</span><br><span class="line"> * 因为一个int有32位，如果再要压缩的话 只需要使用8个int数组即可，本代码偷懒使用256个长度</span><br><span class="line"> *<span class="javadoctag"> @param</span> sStr</span><br><span class="line"> *<span class="javadoctag"> @param</span> dStr</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">deleteSpecifyString</span><span class="params">(String sStr,String dStr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] dict=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];<span class="comment">//每个字符8位  则会有256种情况</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dStr.length();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dict[dStr.charAt(i)]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span>[] cs=<span class="keyword">new</span> <span class="keyword">char</span>[sStr.length()];</span><br><span class="line">	<span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sStr.length();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dict[sStr.charAt(i)]==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//表示这个字符串不需要删除</span></span><br><span class="line">			cs[t++]=sStr.charAt(i);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> String.valueOf(cs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String sStr=<span class="string">"They are students"</span>;</span><br><span class="line">	String dStr=<span class="string">"aeiou"</span>;</span><br><span class="line">	</span><br><span class="line">	System.out.println(deleteSpecifyString(sStr,dStr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code><span class="title">Thy</span> r stdnts
</code></pre><hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>删除指定的字符串
比如They are students 和 aeiou 则删除之后剩下Thy r stdnts
</code></pre><h2 id="解析">解析</h2><p>关于此类查找之类的如果能往位图上靠就是最快速的，本题也可以，一个字符是8位，也就是会出现256中情况，所以现在只需要用一个256长度的位图就可以来判断当前字符是否存在待删除的字符字典中。<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[股票买卖，获得最大的收益]]></title>
    <link href="http://yyl8781697.github.io/2015/08/04/Algorithm/Stock/"/>
    <id>http://yyl8781697.github.io/2015/08/04/Algorithm/Stock/</id>
    <published>2015-08-03T22:34:24.000Z</published>
    <updated>2015-08-03T22:44:12.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题">问题</h2><pre><code>一个人知道未来<span class="keyword">n</span>天的每天股票的价格，请你给出一个算法，使得这个人从哪天买入，哪天卖出能获得最大的收益。
</code></pre><h2 id="解析">解析</h2><p>问题实际上就是求一个数组后面元素减前面元素的最大值<br>看了大神们提出了一个O(n)的方法，就是遍历过去，同时记录当前最小的那个元素，然后每次都是当前遍历元素减去最小的元素   取其差值最大<br><a id="more"></a></p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 通过维护一个最小的minLeft  来计算最大的差值  聪明</span><br><span class="line"> *<span class="javadoctag"> @param</span> a</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stock</span><span class="params">(<span class="keyword">int</span>[] a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.length&lt;<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//都来不及买和卖  肯定不做了</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> max=a[<span class="number">1</span>]-a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> minLeft=a[<span class="number">0</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;a.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		minLeft=Math.min(minLeft, a[i-<span class="number">1</span>]);<span class="comment">//通过最小的价格买下</span></span><br><span class="line">		max=Math.max(max, a[i]-minLeft);<span class="comment">//计算买了能赚最大的钱</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> Math.max(<span class="number">0</span>, max);<span class="comment">//再怎么也不能亏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] a=&#123;<span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">15</span>&#125;;</span><br><span class="line">	System.out.println(stock(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>14
</code></pre><p>其他两个股票升级问题看</p>
<ul>
<li><a href="http://kubicode.me/2014/07/04/LeetCode/LeetCode-Best-Time-to-Buy-and-Sell-Stock-II/" target="_blank" rel="external">LeetCode-Best Time to Buy and Sell Stock II</a></li>
<li><a href="http://kubicode.me/2014/07/05/LeetCode/LeetCode-Best-Time-to-Buy-and-Sell-Stock-III/" target="_blank" rel="external">LeetCode-Best Time to Buy and Sell Stock III</a></li>
</ul>
<h2 id="参考">参考</h2><p><a href="http://www.cnblogs.com/iamccme/archive/2013/05/21/3091706.html" target="_blank" rel="external">http://www.cnblogs.com/iamccme/archive/2013/05/21/3091706.html</a></p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="问题">问题</h2><pre><code>一个人知道未来<span class="keyword">n</span>天的每天股票的价格，请你给出一个算法，使得这个人从哪天买入，哪天卖出能获得最大的收益。
</code></pre><h2 id="解析">解析</h2><p>问题实际上就是求一个数组后面元素减前面元素的最大值<br>看了大神们提出了一个O(n)的方法，就是遍历过去，同时记录当前最小的那个元素，然后每次都是当前遍历元素减去最小的元素   取其差值最大<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最短摘要生成]]></title>
    <link href="http://yyl8781697.github.io/2015/08/03/Algorithm/Short-Abstract/"/>
    <id>http://yyl8781697.github.io/2015/08/03/Algorithm/Short-Abstract/</id>
    <published>2015-08-03T15:21:15.000Z</published>
    <updated>2015-08-03T15:28:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>最短摘要生成
给定一个字符串，以及一系列查询词，在这个字符串中找到一个子串，该子串包含全部的查询词，求这个最短子串
</code></pre><h2 id="解析">解析</h2><p>两个指针，begin和end<br>首先使用end往右边移动一直移动到全部包含查询字符集q的位置<br>然后将begin也向右边移动，直达再移动一次begin-end区间里面的数据将不再包含q<br>此时记录begin和end以及其最小的间距<br>然后begin右移一位，end继续右边移动直至全部包含，周而复始<br><a id="more"></a></p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minBegin=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minEnd=-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> curBegin=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> curEnd=-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 最短摘要生成的匹配</span><br><span class="line"> * 两个指针，begin和end</span><br><span class="line"> * 首先使用end往右边移动一直移动到全部包含查询字符集q的位置</span><br><span class="line"> * 然后将begin也向右边移动，直达再移动一次begin-end区间里面的数据将不再包含q</span><br><span class="line"> * 此时记录begin和end以及其最小的间距</span><br><span class="line"> * 然后begin右移一位，end继续右边移动直至全部包含，周而复始</span><br><span class="line"> * 代码中查询是否全部包含使用了位操作，这样更加快^_^</span><br><span class="line"> *<span class="javadoctag"> @param</span> data</span><br><span class="line"> *<span class="javadoctag"> @param</span> q</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">match</span><span class="params">(String data,<span class="keyword">char</span>[] q)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> matchs=<span class="number">0</span>;<span class="comment">//存储匹配的情况</span></span><br><span class="line">	<span class="keyword">int</span> matchIndex=-<span class="number">1</span>;</span><br><span class="line">	curBegin=-<span class="number">1</span>;</span><br><span class="line">	curEnd=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(curEnd&lt;data.length())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((matchIndex=indexOf(q,data.charAt(curEnd)))&gt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(curBegin==-<span class="number">1</span>)</span><br><span class="line">				curBegin=curEnd;<span class="comment">//初始化第一次开始匹配项</span></span><br><span class="line">			</span><br><span class="line">			matchs|=<span class="number">1</span>&lt;&lt;matchIndex;<span class="comment">//存储到匹配库</span></span><br><span class="line">			<span class="keyword">if</span>(matchs==(<span class="number">1</span>&lt;&lt;q.length)-<span class="number">1</span>)<span class="comment">//全部匹配</span></span><br><span class="line">			&#123;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(minBegin==-<span class="number">1</span> || (minEnd-minBegin)&gt;(curEnd-curBegin))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//更新最短摘要</span></span><br><span class="line">					minBegin=curBegin;</span><br><span class="line">					minEnd=curEnd;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				matchs^=indexOf(q,data.charAt(curBegin));<span class="comment">//去掉首位匹配</span></span><br><span class="line">				<span class="keyword">while</span>(data.charAt(++curBegin)&lt;<span class="number">0</span>);<span class="comment">//将首位匹配移至第二位</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		curEnd++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(minBegin!=-<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span>[] rc=<span class="keyword">new</span> <span class="keyword">char</span>[minEnd-minBegin+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(minBegin&lt;=minEnd)</span><br><span class="line">		&#123;</span><br><span class="line">			rc[i++]=data.charAt(minBegin++);<span class="comment">//取值</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		minBegin=-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> String.valueOf(rc);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 查找当前字符在数组中的位置</span><br><span class="line"> *<span class="javadoctag"> @param</span> q</span><br><span class="line"> *<span class="javadoctag"> @param</span> d</span><br><span class="line"> *<span class="javadoctag"> @return</span> 没有找到则返回-1</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] q,<span class="keyword">char</span> d)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> index=-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(q[i]==d)</span><br><span class="line">		&#123;</span><br><span class="line">			index=i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试的代码为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span>[] q=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'s'</span>,<span class="string">'d'</span>&#125;;</span><br><span class="line">	String data=<span class="string">"hello are you bottom of ado the is bot doke astringadb"</span>;</span><br><span class="line">	<span class="comment">//String data="abd";</span></span><br><span class="line">	</span><br><span class="line">	System.out.println(<span class="keyword">new</span> ShortAbstract().match(data, q));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出的结果为</p>
<pre><code>are you bottom <span class="keyword">of</span> ado <span class="keyword">the</span> <span class="keyword">is</span>
</code></pre><hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>最短摘要生成
给定一个字符串，以及一系列查询词，在这个字符串中找到一个子串，该子串包含全部的查询词，求这个最短子串
</code></pre><h2 id="解析">解析</h2><p>两个指针，begin和end<br>首先使用end往右边移动一直移动到全部包含查询字符集q的位置<br>然后将begin也向右边移动，直达再移动一次begin-end区间里面的数据将不再包含q<br>此时记录begin和end以及其最小的间距<br>然后begin右移一位，end继续右边移动直至全部包含，周而复始<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[找一个数组中绝对值和最小的三个元素]]></title>
    <link href="http://yyl8781697.github.io/2015/08/03/Algorithm/Min-Abs-ThreeNumber/"/>
    <id>http://yyl8781697.github.io/2015/08/03/Algorithm/Min-Abs-ThreeNumber/</id>
    <published>2015-08-03T15:11:04.000Z</published>
    <updated>2015-08-03T15:16:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>找一个数组中绝对值和最小的三个元素
</code></pre><h2 id="解析">解析</h2><p>暴力的方法是O(n^3)，肯定还存在其他更加优的方法</p>
<ol>
<li>将数组升序排序</li>
<li>固定一个数字，然后从两端开始找，如果sum&lt;0 则left++ 否则right—  同时记录最小的minSum<blockquote>
<p>注意，两端向中间找的时候如果遇到当前固定的数字需要跳过</p>
</blockquote>
</li>
</ol>
<a id="more"></a>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minAbsThreeNumber</span><span class="params">(<span class="keyword">int</span>[] a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> left=<span class="number">0</span>,mid=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> mas=Integer.MAX_VALUE;<span class="comment">//min abs sum</span></span><br><span class="line">	</span><br><span class="line">	Arrays.sort(a);<span class="comment">//这里使用了快速排序  会破坏原有数组 不过由于本题重点不在这里 所以也就不需要考虑了</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//mas==0 的时候已经是最小的sum了，如果出现这种情况可以直接停止</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;a.length&amp;&amp;mas!=<span class="number">0</span>;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//固定的那个数字为k</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=k-<span class="number">1</span>;i&lt;j &amp;&amp; mas!=<span class="number">0</span>;)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//两个continue操作是避免重复使用了k</span></span><br><span class="line">			<span class="keyword">if</span>(i==k)</span><br><span class="line">			&#123;</span><br><span class="line">				i++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(j==k)</span><br><span class="line">			&#123;</span><br><span class="line">				j--;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//更新最小的abs(sum)</span></span><br><span class="line">			<span class="keyword">int</span> sum=a[i]+a[k]+a[j];</span><br><span class="line">			<span class="keyword">if</span>(Math.abs(sum)&lt;mas)</span><br><span class="line">			&#123;</span><br><span class="line">				mas=Math.abs(sum);</span><br><span class="line">				left=i;</span><br><span class="line">				mid=k;</span><br><span class="line">				right=j;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(sum&lt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				i++;<span class="comment">//增加sum</span></span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				j--;<span class="comment">//减少sum</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	System.out.println(String.format(<span class="string">"min abs sum:%s=(%s)+(%s)+(%s)"</span>,mas,a[left],a[mid],a[right]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[]=&#123;-<span class="number">9</span>,<span class="number">9</span>,<span class="number">0</span>,-<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> b[]=&#123;-<span class="number">99</span>,<span class="number">66</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	minAbsThreeNumber(b);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果为</p>
<pre><code><span class="built_in">min</span> <span class="built_in">abs</span> <span class="built_in">sum</span>:<span class="number">5</span>=(<span class="number">0</span>)+(<span class="number">3</span>)+(<span class="number">2</span>)
</code></pre><p>它的最终复杂度是O(n^2)，还是有所提升的</p>
<h2 id="参考">参考</h2><p><a href="http://blog.csdn.net/deutschester/article/details/5981503" target="_blank" rel="external">http://blog.csdn.net/deutschester/article/details/5981503</a></p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>找一个数组中绝对值和最小的三个元素
</code></pre><h2 id="解析">解析</h2><p>暴力的方法是O(n^3)，肯定还存在其他更加优的方法</p>
<ol>
<li>将数组升序排序</li>
<li>固定一个数字，然后从两端开始找，如果sum&lt;0 则left++ 否则right—  同时记录最小的minSum<blockquote>
<p>注意，两端向中间找的时候如果遇到当前固定的数字需要跳过</p>
</blockquote>
</li>
</ol>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对于一个由N个整数组成的数组，需要比较多少次才能把最大和最小的数找出来呢？]]></title>
    <link href="http://yyl8781697.github.io/2015/08/03/Algorithm/Max-Min-in-Array/"/>
    <id>http://yyl8781697.github.io/2015/08/03/Algorithm/Max-Min-in-Array/</id>
    <published>2015-08-03T14:59:25.000Z</published>
    <updated>2015-08-03T15:16:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>对于一个由<span class="keyword">N</span>个整数组成的数组，需要比较多少次才能把最大和最小的数找出来呢？
</code></pre><h2 id="解析">解析</h2><p>普通的遍历是需要O(2n)时间，那有没有其他更好的办法呢？<br>其实可以使用分而治之的思想，将N分为两段  分别取到每一段中的最大和最小值  ，然后最大与最大比即可 最小与最小比即可，这样就可以避免最小与最大的比较</p>
<pre><code>比如：
<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>
正常对比的话得到<span class="built_in">min</span>=<span class="number">1</span>,<span class="built_in">max</span>=<span class="number">4</span>需要<span class="number">6</span>次
那如果先求的<span class="built_in">min1</span>=<span class="number">1</span>,<span class="built_in">max1</span>=<span class="number">2</span>,min2=<span class="number">3</span>,max2=<span class="number">4</span>（需要<span class="number">2</span>次比较）
然后<span class="built_in">min1</span>&lt;min2 得到<span class="built_in">min</span>=<span class="number">1</span>,<span class="built_in">max1</span>&lt;max2可得<span class="built_in">max</span>=<span class="number">4</span> （又是需要<span class="number">2</span>次）
所以这种方法只需要<span class="number">4</span>次
</code></pre><a id="more"></a>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> compareCount=<span class="number">0</span>;</span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 分而治之的思想，将N分为两段  分别取到每一段中的最大和最小值  ，然后最大与最大比即可 最小与最小比即可，这样就可以避免最小与最大的比较</span><br><span class="line"> *<span class="javadoctag"> @param</span> a</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxMinInArray</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> left,<span class="keyword">int</span> right,Data data)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//当只有两个以及两个以内时才进行比较</span></span><br><span class="line">	<span class="keyword">if</span>(right-left&lt;=<span class="number">1</span>)<span class="comment">//难道这个索引位置的比较不算？？？</span></span><br><span class="line">	&#123;</span><br><span class="line">		compareCount++;</span><br><span class="line">		<span class="keyword">if</span>(a[right]&gt;a[left])</span><br><span class="line">		&#123;</span><br><span class="line">			data.min=a[left];</span><br><span class="line">			data.max=a[right];</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			data.min=a[right];</span><br><span class="line">			data.max=a[left];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Data dLeft=<span class="keyword">new</span> Data();</span><br><span class="line">	Data dRight=<span class="keyword">new</span> Data();</span><br><span class="line">	<span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">	maxMinInArray(a,left,mid,dLeft);<span class="comment">//递归左边</span></span><br><span class="line">	maxMinInArray(a,mid+<span class="number">1</span>,right,dRight);<span class="comment">//递归右边</span></span><br><span class="line">	</span><br><span class="line">	compareCount++;</span><br><span class="line">	data.min=Math.min(dLeft.min, dRight.min);</span><br><span class="line"></span><br><span class="line">	compareCount++;</span><br><span class="line">	data.max=Math.min(dRight.max, dLeft.max);		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> min;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式最终的复杂度是O(1.5n)<br>测试代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] a = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">56</span>, <span class="number">109</span>, <span class="number">10</span>, <span class="number">95</span>, <span class="number">1</span>, <span class="number">230</span>, -<span class="number">1000</span>&#125;; </span><br><span class="line">	Data data=<span class="keyword">new</span> Data();</span><br><span class="line">	maxMinInArray(a,<span class="number">0</span>,a.length-<span class="number">1</span>,data);</span><br><span class="line">	System.out.println(String.format(<span class="string">"min:%s,max:%s"</span>,data.min,data.max));</span><br><span class="line">	System.out.println(String.format(<span class="string">"length:%s,compare count:%s"</span>,a.length,compareCount));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code><span class="string">min:</span>-<span class="number">1000</span>,<span class="string">max:</span><span class="number">3</span>
<span class="string">length:</span><span class="number">9</span>,compare <span class="string">count:</span><span class="number">13</span>
</code></pre><h2 id="参考">参考</h2><p>July微软面试100题</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>对于一个由<span class="keyword">N</span>个整数组成的数组，需要比较多少次才能把最大和最小的数找出来呢？
</code></pre><h2 id="解析">解析</h2><p>普通的遍历是需要O(2n)时间，那有没有其他更好的办法呢？<br>其实可以使用分而治之的思想，将N分为两段  分别取到每一段中的最大和最小值  ，然后最大与最大比即可 最小与最小比即可，这样就可以避免最小与最大的比较</p>
<pre><code>比如：
<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>
正常对比的话得到<span class="built_in">min</span>=<span class="number">1</span>,<span class="built_in">max</span>=<span class="number">4</span>需要<span class="number">6</span>次
那如果先求的<span class="built_in">min1</span>=<span class="number">1</span>,<span class="built_in">max1</span>=<span class="number">2</span>,min2=<span class="number">3</span>,max2=<span class="number">4</span>（需要<span class="number">2</span>次比较）
然后<span class="built_in">min1</span>&lt;min2 得到<span class="built_in">min</span>=<span class="number">1</span>,<span class="built_in">max1</span>&lt;max2可得<span class="built_in">max</span>=<span class="number">4</span> （又是需要<span class="number">2</span>次）
所以这种方法只需要<span class="number">4</span>次
</code></pre>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[全排列以及全组合]]></title>
    <link href="http://yyl8781697.github.io/2015/08/02/Algorithm/Permutation-and-Combination/"/>
    <id>http://yyl8781697.github.io/2015/08/02/Algorithm/Permutation-and-Combination/</id>
    <published>2015-08-02T14:44:33.000Z</published>
    <updated>2015-08-02T15:08:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="全排列">全排列</h2><blockquote>
<p>这里主要使用递归来实现，也就是考察递归的熟练使用与否</p>
</blockquote>
<p>全排列的递归生成规则为：</p>
<ol>
<li>n个数的全排列=(其中一个数的前缀)+n-1个树的全排列</li>
<li>当前只剩下一个待选前缀的时候，停止迭代</li>
<li>关于前缀的设立，是逐个迭代剩余的候选元素通过两两交换完成的，在进行输出之后还需要还得将两个数字重新交换回去</li>
</ol>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 全排列算法</span><br><span class="line"> * 依次将剩余的元素交换到begin处  直到end的地方进行输出</span><br><span class="line"> *<span class="javadoctag"> @param</span> a</span><br><span class="line"> *<span class="javadoctag"> @param</span> begin</span><br><span class="line"> *<span class="javadoctag"> @param</span> end</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(begin==end)<span class="comment">//当前已经排列完成 进行输出</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">			System.out.print(a[i]);</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=begin;j&lt;=end;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			swap(a,begin,j);<span class="comment">//依次遍历剩余元素放置在begin 位置处</span></span><br><span class="line">			permutation(a,begin+<span class="number">1</span>,end);</span><br><span class="line">			swap(a,begin,j);<span class="comment">//将之前交换的数据还原</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp=a[i];</span><br><span class="line">	a[i]=a[j];</span><br><span class="line">	a[j]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行测试输出为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">permutation(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>最终的结果是</p>
<pre><code>123
132
213
231
321
312
</code></pre><blockquote>
<p>这里，这里只考虑的无重复的情况，一旦有重复的，需要考虑去重，因为两个相同的数字交换没什么意思啊。这里的去重主要是在for循环中添加一个isSwap来判断是否要交换即可。</p>
</blockquote>
<h2 id="全组合">全组合</h2><blockquote>
<p>全组合貌似就是一个元素的<a href="http://kubicode.me/2015/07/19/Algorithm/SubCollection/" target="_blank" rel="external">全子集算法</a>，之前做过的-_-</p>
</blockquote>
<h2 id="参考">参考</h2><ul>
<li><a href="http://blog.csdn.net/hackbuteer1/article/details/7462447" target="_blank" rel="external">http://blog.csdn.net/hackbuteer1/article/details/7462447</a></li>
<li><a href="http://blog.csdn.net/hackbuteer1/article/details/6823329" target="_blank" rel="external">http://blog.csdn.net/hackbuteer1/article/details/6823329</a></li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="全排列">全排列</h2><blockquote>
<p>这里主要使用递归来实现，也就是考察递归的熟练使用与否</p>
</blockquote>
<p>全排列的递归生成规则为：</p>
<ol>
<li>n个数的全排列=(其中一个数的前缀)+n-1个树的全排列</li>
<li>当前只剩下一个待选前缀的时候，停止迭代</li>
<li>关于前缀的设立，是逐个迭代剩余的候选元素通过两两交换完成的，在进行输出之后还需要还得将两个数字重新交换回去</li>
</ol>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[学习Java AOP的实现]]></title>
    <link href="http://yyl8781697.github.io/2015/07/30/Java%20Base/Java-AOP-Study/"/>
    <id>http://yyl8781697.github.io/2015/07/30/Java Base/Java-AOP-Study/</id>
    <published>2015-07-30T15:49:09.000Z</published>
    <updated>2015-07-31T16:36:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="AOP介绍">AOP介绍</h2><pre><code>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。
<span class="comment">--摘自百度百科</span>
</code></pre><p>通过这个介绍还不是很理解怎么办？什么是切面呀？</p>
<blockquote>
<p>我的理解哈：你现在有一系列普通的执行方法，但是想在方法执行的前后加点东西，比如记录日志，那你不可能去再每个方法上都去加记录日志的语句，那这个时候AOP就来了，将这个记录日志作为切面切入到这些方法中，在平常自然调用这些方法时候同时执行这些切面。</p>
</blockquote>
<p>那该怎么切入呢？<br><a id="more"></a></p>
<h2 id="AOP原理">AOP原理</h2><p>切入的方法主要有在编译器修改源代码，在运行期字节码加载前修改字节码或字节码加载后动态创建代理类的字节码，下面借用别人总结的一个表：<br><img src="/img/Java-AOP-Study/list.png" alt=""><br>本文主要是学习“动态AOP”以及“动态字节码生成” 这两种比较常用的实现方法</p>
<h2 id="动态AOP-动态代理">动态AOP-动态代理</h2><p>这种实现方法最主要的就是<code>Proxy.newProxyInstance</code>生成代理方法，其核心需要的是：<br><img src="/img/Java-AOP-Study/dynamicProxy.jpg" alt=""><br>也就是一定需要接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;<span class="comment">//这个就是我们平常所执行的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时将该接口进行一个实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentImpl</span> <span class="keyword">implements</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello ,i am tom"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们添加传说中的切面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 定义日志切面的接口</span><br><span class="line"> *<span class="javadoctag"> @author</span> yanyl</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>;<span class="comment">//方法调用前执行</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>;<span class="comment">//方法调用后执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>随便实现一个切面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintLogAspect</span> <span class="keyword">implements</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Log:before invoke"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"after invoke"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好，我们的目标就是将切面<code>LogAspect</code>切入到<code>Student</code>这个接口中。</p>
<p>现在我们现在创建代理之前先创建一个<code>InvocationHandler</code>的子类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 这就是调用打印日志的切面</span><br><span class="line"> *<span class="javadoctag"> @author</span> yanyl</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object target;<span class="comment">//这个就是调用的目标类</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;LogAspect&gt; aspectList=<span class="keyword">new</span> ArrayList&lt;LogAspect&gt;();<span class="comment">//所指定的切面方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LogInvocationHandler</span><span class="params">(Object instance)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target=instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAspect</span><span class="params">(LogAspect logAspect)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.aspectList.add(logAspect);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 在这个切面调用原方法执行</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">			<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;aspectList.size();i++)</span><br><span class="line">			aspectList.get(i).before();<span class="comment">//调用方法执行前到方法</span></span><br><span class="line">		</span><br><span class="line">		Object ret=method.invoke(target, args);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=aspectList.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">			aspectList.get(i).before();<span class="comment">//这里是方法执行后的方法</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好了我们再实现一个比较简单的日志功能个：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 则是一个非常简单的代理工厂，主要就是创建新的实例</span><br><span class="line"> *<span class="javadoctag"> @author</span> yanyl</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleProxyFactory</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SimpleProxyFactory</span><span class="params">()</span></span>&#123;&#125;;<span class="comment">//不公开构造方法</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Object instance,LogAspect logAspect)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		LogInvocationHandler h=<span class="keyword">new</span> LogInvocationHandler(instance);</span><br><span class="line">		h.addAspect(logAspect);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//这里是直接返回创建的代理类</span></span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(instance.getClass().getClassLoader(), </span><br><span class="line">							instance.getClass().getInterfaces(), h);</span><br><span class="line">				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后再来看main方法怎么启动：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里创建一个打印的切面</span></span><br><span class="line">	LogAspect logAspect=<span class="keyword">new</span> PrintLogAspect();</span><br><span class="line">	<span class="comment">//使用简单的代理工厂生产具体的接口</span></span><br><span class="line">	Student s=(Student)SimpleProxyFactory.newInstance(<span class="keyword">new</span> StudentImpl(), logAspect);</span><br><span class="line">	<span class="comment">//接口调用方法 可以发现已经带上了需要切入的面</span></span><br><span class="line">	s.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终的输结果：</p>
<pre><code>Log:before<span class="instruction"> invoke
</span>hello ,i am tom
Log:before invoke
</code></pre><p>可以发现打印日志已经成功切入。^_^<br>还是蛮神奇的，竟然直接使用原来接口的方法就能自动切入额外打印功能，那么这个代理类是如何工作的呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟一下代理类公的工作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyMock</span> <span class="keyword">implements</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> LogInvocationHandler h;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyMock</span><span class="params">(LogInvocationHandler h)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.h=h;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			Method m=h.getTarget().getClass().getMethod(<span class="string">"sayHello"</span>, <span class="keyword">null</span>);</span><br><span class="line">			h.invoke(<span class="keyword">this</span>, m,<span class="keyword">null</span>);<span class="comment">//最终调用handler.invoke 来执行</span></span><br><span class="line">		&#125;<span class="keyword">catch</span>(Throwable e)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		LogInvocationHandler lh=<span class="keyword">new</span> LogInvocationHandler(<span class="keyword">new</span> StudentImpl());</span><br><span class="line">		lh.addAspect(<span class="keyword">new</span> PrintLogAspect());</span><br><span class="line">		</span><br><span class="line">		Student student=<span class="keyword">new</span> ProxyMock(lh);<span class="comment">//模拟的代理类</span></span><br><span class="line">		student.sayHello();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是模拟的代理类，在<code>sayHello</code>方法里面使用反射最终还是调用了<code>h.invoke</code>方法，那这样思路就比较清晰了</p>
<blockquote>
<ol>
<li>使用上面代理类的时候别忘了在<code>LogInvocationHandler</code>类上添加<code>getTarget</code>的方法</li>
<li>如果需要知道如何用代码来实现上述过程  请看JDK中的<code>Proxy</code>源码或者下面参考的文章也有介绍</li>
</ol>
</blockquote>
<p>使用动态代理实现<code>AOP</code>问题比较方便，也相当灵活，但是有以下几个缺点：</p>
<ol>
<li>一定需要定义接口</li>
<li>实现是使用反射的，所以带来性能影响</li>
<li>反射生成的文件可能会照成频繁的Major GC</li>
</ol>
<h2 id="动态字节码生成-cglib技术">动态字节码生成-cglib技术</h2><p><code>cglib</code>是一个强大的高效的字节码生成类库，可以在运行期间扩展Java类或者实现java接口，那么按照上述的动态代理技术，使用<code>cglib</code>就不必在去反射，而是直接基于需要代理的类直接取生成一个扩展的字节码即可，这样的话这种方式的切入逻辑为：<br><img src="/img/Java-AOP-Study/cglibAOP.jpg" alt=""><br>现在还是来用<code>LogAspect</code>来进行切入 但是这次切入是切入到具体的类<code>StudentImpl</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 使用cglib来实现AOP</span><br><span class="line"> *<span class="javadoctag"> @author</span> yanyl</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CgLibTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		Enhancer enhancer=<span class="keyword">new</span> Enhancer();</span><br><span class="line">		enhancer.setSuperclass(StudentImpl.class);<span class="comment">//设置需要继承的父类  也就是需要切入的类</span></span><br><span class="line">		enhancer.setCallback(<span class="keyword">new</span> LogMethodInterceptor(<span class="keyword">new</span> PrintLogAspect()));<span class="comment">//设置拦截器 这里顺带设置切面</span></span><br><span class="line">		enhancer.setUseCache(<span class="keyword">true</span>);</span><br><span class="line">		StudentImpl studentImpl=(StudentImpl)enhancer.create();<span class="comment">//创建切入的子类</span></span><br><span class="line">		studentImpl.sayHello();<span class="comment">//这里直接对类进行了切入  使用原来的类就可以了</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 日志方法拦截器</span><br><span class="line">	 * 这里的MethodInterceptor是继承net.sf.cglib.proxy.Callback的</span><br><span class="line">	 *<span class="javadoctag"> @author</span> yanyl</span><br><span class="line">	 *</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LogMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> LogAspect logAspect;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">LogMethodInterceptor</span><span class="params">(LogAspect logAspect)</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.logAspect=logAspect;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object instance, Method method, Object[] args,</span><br><span class="line">				MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">			Object ret=<span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">if</span>(instance!=<span class="keyword">null</span> &amp;&amp; methodProxy!=<span class="keyword">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				logAspect.before();<span class="comment">//进行切入</span></span><br><span class="line">				ret=methodProxy.invokeSuper(instance, args);<span class="comment">//注意，这里一定是要执行这个proxy的method 并且是invokeSuper</span></span><br><span class="line">				logAspect.after();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终的输出为：</p>
<pre><code>Log:before<span class="instruction"> invoke
</span>hello ,i am tom
after invoke
</code></pre><p>上面的代码演示了如何使用cglib来进行<code>AOP</code>的实现，可以发现使用cglib不需要提前创建接口，更加灵活，并且它是会动态生成相应的字节码，比原来的动态代理更加高效。</p>
<blockquote>
<p>注意：这个实例需要引用<code>asm.jar</code>以及同时引用的cglib最好使用<code>cglib-nodep.jar</code>防止冲突</p>
</blockquote>
<h2 id="AOP的作用">AOP的作用</h2><p><code>AOP</code>可以做好多事情了，比如：</p>
<ul>
<li>性能监控，在方法调用前后记录调用时间，方法执行太长或超时报警。 赞</li>
<li>缓存代理，缓存某方法的返回值，下次执行该方法时，直接从缓存里获取。 赞，妙</li>
<li>软件破解，使用AOP修改软件的验证类的判断逻辑。 </li>
<li>记录日志，在方法执行前后记录系统日志。 本文的介绍就是用于日志的记录</li>
<li>工作流系统，工作流系统需要将业务代码和流程引擎代码混合在一起执行，那么我们可以使用AOP将其分离，并动态挂接业务。</li>
<li>权限验证，方法执行前验证是否有权限执行当前方法，没有则抛出没有权限执行异常，由业务代码捕捉。 </li>
</ul>
<h2 id="参考">参考</h2><blockquote>
<p>关于<code>Spring</code>的<code>AOP</code>看参考把，不再多说，本来本文绝大部分就是来自参考，自己组织了一下并且实际操练而已-_-</p>
</blockquote>
<ul>
<li><a href="http://www.iteye.com/topic/1116696" target="_blank" rel="external">http://www.iteye.com/topic/1116696</a> 非常推荐，写的非常好</li>
<li><a href="http://rainsilence.iteye.com/blog/684265" target="_blank" rel="external">http://rainsilence.iteye.com/blog/684265</a></li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="AOP介绍">AOP介绍</h2><pre><code>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。
<span class="comment">--摘自百度百科</span>
</code></pre><p>通过这个介绍还不是很理解怎么办？什么是切面呀？</p>
<blockquote>
<p>我的理解哈：你现在有一系列普通的执行方法，但是想在方法执行的前后加点东西，比如记录日志，那你不可能去再每个方法上都去加记录日志的语句，那这个时候AOP就来了，将这个记录日志作为切面切入到这些方法中，在平常自然调用这些方法时候同时执行这些切面。</p>
</blockquote>
<p>那该怎么切入呢？<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://yyl8781697.github.io/tags/Java/"/>
    
      <category term="Java Base" scheme="http://yyl8781697.github.io/categories/Java-Base/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用两个队列实现栈、两个栈实现队列]]></title>
    <link href="http://yyl8781697.github.io/2015/07/30/Algorithm/Queue-Stack/"/>
    <id>http://yyl8781697.github.io/2015/07/30/Algorithm/Queue-Stack/</id>
    <published>2015-07-29T23:43:30.000Z</published>
    <updated>2015-07-30T15:59:37.000Z</updated>
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>队列和栈是编程中非常经典并且使用的两个数据结构：</p>
<ul>
<li>队列：先入先出</li>
<li>栈：先入后出</li>
</ul>
<p>队列和栈的互操作主要考察对两个数据结构的认识</p>
<h2 id="使用两个队列实现栈">使用两个队列实现栈</h2><p>假设现有队列q1和q2，要通过q1,q2来构建数据的先入后出<br>栈每次pop的都是最后一次push的值，所以可以在pop的时候将原有值都压入另一个队列，<br>直到最后一个元素时直接弹出<br>所以这样的话在push的时候就必须将元素进队到有值的那个队列，大致的逻辑图就是这样：<br><a id="more"></a><br><img src="/img/Queue-Stack/q2s.png" alt=""></p>
<pre><code>假如当前<span class="tag">q1</span>有值<span class="attr_selector">[4,3,2,1]</span>，那么压入5的时候就会压入到<span class="tag">q1</span>
然后在<span class="tag">pop</span>的时候从<span class="tag">q1</span>里面依次将<span class="attr_selector">[4,3,2,1]</span>压入到<span class="tag">q2</span>，直至最后一个元素5的时候直接返回即可
</code></pre><p>所以：</p>
<ul>
<li>push的时候将输入压入已有值的队列</li>
<li>pop的时候将已有值的队列出队到另一个队列中，直达最后一个元素进行返回</li>
</ul>
<p>看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Queue&lt;Integer&gt; queue1,queue2;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Queue2Stack</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">this</span>.queue1=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">	<span class="keyword">this</span>.queue2=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 压入栈的时候   只需要向有数据的队列进行压入即可</span><br><span class="line"> * 这样可以保证一个队列有值，另一个队列为空</span><br><span class="line"> *<span class="javadoctag"> @param</span> a</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.queue1.size()==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">this</span>.queue2.add(a);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">this</span>.queue1.add(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 取数据的时候，有值对队列一直向空队列进行值的压入</span><br><span class="line"> * 直到最后一个值 进行弹出即可</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.queue1.size()==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> pop(<span class="keyword">this</span>.queue2,<span class="keyword">this</span>.queue1);</span><br><span class="line">	<span class="function"><span class="keyword">else</span></span><br><span class="line">		return <span class="title">pop</span><span class="params">(<span class="keyword">this</span>.queue1,<span class="keyword">this</span>.queue2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">(Queue&lt;Integer&gt; normQueue,Queue&lt;Integer&gt; emptyQueue)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(normQueue.size()==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(normQueue.size()!=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		emptyQueue.add(normQueue.poll());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> normQueue.poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看下测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Queue2Stack queue2Stack=<span class="keyword">new</span> Queue2Stack();</span><br><span class="line">	</span><br><span class="line">	queue2Stack.push(<span class="number">1</span>);</span><br><span class="line">	queue2Stack.push(<span class="number">4</span>);</span><br><span class="line">	queue2Stack.push(<span class="number">5</span>);</span><br><span class="line">	</span><br><span class="line">	System.out.println(queue2Stack.pop());</span><br><span class="line">	System.out.println(queue2Stack.pop());</span><br><span class="line">	System.out.println(queue2Stack.pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出为：</p>
<pre><code>5
4
1
</code></pre><h2 id="两个栈实现队列">两个栈实现队列</h2><p>根据栈实现队里相对来说更加简单一点<br>现有栈s1,s2，如果现将输入压入s1,然后s1出栈再压入s2，此时可以发现s2如果再出栈的话就是队列的顺序了，看图<br><img src="/img/Queue-Stack/s2q.png" alt=""></p>
<pre><code>假如见当前数据入队到<span class="tag">s1</span> <span class="attr_selector">[4,3,2,1]</span>，此时入队5的时候继续入<span class="tag">s1</span> <span class="attr_selector">[5,4,3,2,1]</span>
再出队的时候判断<span class="tag">s2</span>中是否有值，如果有直接<span class="tag">pop</span>得值就是出队的值，否则遍历<span class="tag">s1</span>出栈 然后入栈到<span class="tag">s2</span> <span class="attr_selector">[1,2,3,4,5]</span>
再从<span class="tag">s2</span>进行<span class="tag">pop</span>即可
</code></pre><p>所以：</p>
<ul>
<li>enQueue:总是见数据入队到s1</li>
<li>deQueue:先判断s2是否有值，如果有直接pop，否则将s1的数据全部压入到s2  再从s2进行pop</li>
</ul>
<p>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; stack1,stack2;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Stack2Queue</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.stack1=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">	<span class="keyword">this</span>.stack2=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 入队  直接压入s1即可</span><br><span class="line"> *<span class="javadoctag"> @param</span> a</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.stack1.push(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 出队 先判断s2是否有值，如果没有，现将s1的值压入s2，再返回</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(stack2.isEmpty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(!stack1.isEmpty())</span><br><span class="line">		&#123;</span><br><span class="line">			stack2.push(stack1.pop());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> stack2.pop();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看下测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Stack2Queue test=<span class="keyword">new</span> Stack2Queue();</span><br><span class="line">	test.enQueue(<span class="number">1</span>);</span><br><span class="line">	test.enQueue(<span class="number">4</span>);</span><br><span class="line">	test.enQueue(<span class="number">5</span>);</span><br><span class="line">	</span><br><span class="line">	System.out.println(test.deQueue());</span><br><span class="line">	System.out.println(test.deQueue());</span><br><span class="line">	System.out.println(test.deQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：</p>
<pre><code>1
4
5
</code></pre><hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="介绍">介绍</h2><p>队列和栈是编程中非常经典并且使用的两个数据结构：</p>
<ul>
<li>队列：先入先出</li>
<li>栈：先入后出</li>
</ul>
<p>队列和栈的互操作主要考察对两个数据结构的认识</p>
<h2 id="使用两个队列实现栈">使用两个队列实现栈</h2><p>假设现有队列q1和q2，要通过q1,q2来构建数据的先入后出<br>栈每次pop的都是最后一次push的值，所以可以在pop的时候将原有值都压入另一个队列，<br>直到最后一个元素时直接弹出<br>所以这样的话在push的时候就必须将元素进队到有值的那个队列，大致的逻辑图就是这样：<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[函数将字符串中的字符'*'移到串的前部分]]></title>
    <link href="http://yyl8781697.github.io/2015/07/30/Algorithm/Put-x-To-Head/"/>
    <id>http://yyl8781697.github.io/2015/07/30/Algorithm/Put-x-To-Head/</id>
    <published>2015-07-29T16:51:08.000Z</published>
    <updated>2015-07-30T14:42:12.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>函数将字符串中的字符'<span class="keyword">*</span>'移到串的前部分,前面的非'<span class="keyword">*</span>'字符后移,但不能改变非'<span class="keyword">*</span>'字符的先 后顺序,函数返回串中字符'<span class="keyword">*</span>'的数量。如原始串为:ab<span class="keyword">*</span><span class="keyword">*</span>cd<span class="keyword">*</span><span class="keyword">*</span>e<span class="keyword">*</span>12,处理后为<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>abcde12, 函数并返回值为 5。(要求使用尽量少的时间和辅助空间)
</code></pre><h2 id="解析1">解析1</h2><p>之前做过<a href="http://kubicode.me/2015/07/19/Algorithm/OddEvenSplit/" target="_blank" rel="external">奇数偶数分离</a>可能很快就想到使用快排分区的思想来解此题了：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 使用快排分区 </span><br><span class="line"> * 首位的左侧是* 右侧是非*</span><br><span class="line"> *<span class="javadoctag"> @param</span> cs</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">putxToHead</span><span class="params">(<span class="keyword">char</span>[] cs)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> k=cs[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=cs.length-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=<span class="string">'*'</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(cs[j]!=c &amp;&amp; i&lt;j)</span><br><span class="line">			j--;</span><br><span class="line">		cs[i]=cs[j];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(cs[i]==c &amp;&amp; i&lt;j)</span><br><span class="line">			i++;</span><br><span class="line">		cs[j]=cs[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cs[i]=k;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (k==c)?i+<span class="number">1</span>:i;<span class="comment">//如果首位是* 则需要多加一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>马上进行测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String str=<span class="string">"ab**cd**e*12"</span>;</span><br><span class="line">	<span class="keyword">char</span>[] cs=<span class="keyword">new</span> <span class="keyword">char</span>[str.length()];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cs.length;i++)</span><br><span class="line">		cs[i]=str.charAt(i);</span><br><span class="line">	</span><br><span class="line">	System.out.println(putxToHead(cs));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cs.length;i++)</span><br><span class="line">		System.out.print(cs[i]);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到的结果为</p>
<pre><code>5
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>adceb12
</code></pre><p>咦，*的个数是计算出来的，但是字母的顺序却乱掉了，这是由于分区过程中快排是不考虑同一区里面两两的顺序</p>
<h2 id="解析2">解析2</h2><p>好吧，现在这种做法可以满足，使用两个指针，从后开始遍历，依次将当前非*的字符串给交换进来，这样就可以保证原来数据的顺序了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">putxToHead2</span><span class="params">(<span class="keyword">char</span>[] cs)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=cs.length-<span class="number">1</span>,j=cs.length-<span class="number">1</span>,count=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c=<span class="string">'*'</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(cs[i]!=c)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">char</span> t=cs[i];<span class="comment">//进行交换  将非*按顺序往后排</span></span><br><span class="line">			cs[i]=cs[j];</span><br><span class="line">			cs[j]=t;</span><br><span class="line">			j--;</span><br><span class="line">			count++;<span class="comment">//这里交换的次数就是代表非*的个数</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> cs.length-count;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用上面的测试程序的结果为：</p>
<pre><code>5
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>abcde12
</code></pre><p>恩，这样就对了，上述两种方法的复杂度同样都是O(n)</p>
<h2 id="参考">参考</h2><ul>
<li>July 微软面试100题 第88题</li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>函数将字符串中的字符'<span class="keyword">*</span>'移到串的前部分,前面的非'<span class="keyword">*</span>'字符后移,但不能改变非'<span class="keyword">*</span>'字符的先 后顺序,函数返回串中字符'<span class="keyword">*</span>'的数量。如原始串为:ab<span class="keyword">*</span><span class="keyword">*</span>cd<span class="keyword">*</span><span class="keyword">*</span>e<span class="keyword">*</span>12,处理后为<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>abcde12, 函数并返回值为 5。(要求使用尽量少的时间和辅助空间)
</code></pre><h2 id="解析1">解析1</h2><p>之前做过<a href="http://kubicode.me/2015/07/19/Algorithm/OddEvenSplit/">奇数偶数分离</a>可能很快就想到使用快排分区的思想来解此题了：<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[怎样编写一个程序,把一个有序整数数组放到二叉树中]]></title>
    <link href="http://yyl8781697.github.io/2015/07/30/Algorithm/Put-Array-To-Tree/"/>
    <id>http://yyl8781697.github.io/2015/07/30/Algorithm/Put-Array-To-Tree/</id>
    <published>2015-07-29T16:12:36.000Z</published>
    <updated>2015-07-29T16:21:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>怎样编写一个程序,把一个有序整数数组放到二叉树中?
</code></pre><h2 id="解析">解析</h2><p>这里都说这个数组是有序了，想想二叉树中对应有序相关的，就是二叉搜索树了。<br>二叉搜索树的根节点大于左侧的值，同时又小于右侧的值，那这样正好取数组的中间值作为根节点<br>然后将两侧分别递归作为左右子节点即可。<br>这种方式建树的另一个好处就是将树还原成数组很方便：直接使用中序遍历或者<a href="http://kubicode.me/2015/07/01/Algorithm/Binary-Search-Tree-2-Double-LinkedList/" target="_blank" rel="external">用不开辟空间的方法</a><br><a id="more"></a></p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 使用递归构建二叉树即可 </span><br><span class="line"> * 这样左侧节点小于根节点，右侧节点大于根节点</span><br><span class="line"> * 对应数组正好是中间的值以及两侧的值</span><br><span class="line"> *<span class="javadoctag"> @param</span> a</span><br><span class="line"> *<span class="javadoctag"> @param</span> left</span><br><span class="line"> *<span class="javadoctag"> @param</span> right</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">putArrayToTree</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&gt;right)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> m=left+(right-left)/<span class="number">2</span>;<span class="comment">//取中间位置</span></span><br><span class="line">	TreeNode root=<span class="keyword">new</span> TreeNode(a[m]);<span class="comment">//就是根节点</span></span><br><span class="line">	root.left=putArrayToTree(a,left,m-<span class="number">1</span>);</span><br><span class="line">	root.right=putArrayToTree(a,m+<span class="number">1</span>,right);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 树的结构</span><br><span class="line"> *<span class="javadoctag"> @author</span> yanyl</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">public</span> TreeNode left,right;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> data)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data=data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2><ul>
<li>July 微软面试100题 第86题</li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>怎样编写一个程序,把一个有序整数数组放到二叉树中?
</code></pre><h2 id="解析">解析</h2><p>这里都说这个数组是有序了，想想二叉树中对应有序相关的，就是二叉搜索树了。<br>二叉搜索树的根节点大于左侧的值，同时又小于右侧的值，那这样正好取数组的中间值作为根节点<br>然后将两侧分别递归作为左右子节点即可。<br>这种方式建树的另一个好处就是将树还原成数组很方便：直接使用中序遍历或者<a href="http://kubicode.me/2015/07/01/Algorithm/Binary-Search-Tree-2-Double-LinkedList/">用不开辟空间的方法</a><br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[a~z 包括大小写与 0~9 组成的 N 个数, 用最快的方式把其中重复的元素挑出来]]></title>
    <link href="http://yyl8781697.github.io/2015/07/27/Algorithm/Find-Same-Char/"/>
    <id>http://yyl8781697.github.io/2015/07/27/Algorithm/Find-Same-Char/</id>
    <published>2015-07-27T15:39:41.000Z</published>
    <updated>2015-07-27T15:54:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code><span class="literal">a</span>~z 包括大小写与 <span class="number">0</span>~<span class="number">9</span> 组成的 N 个数, 用最快的方式把其中重复的元素挑出来。
</code></pre><h2 id="解析">解析</h2><p>本题中已经限制了可能出现字符,他们对应的ascii为</p>
<ul>
<li>a-z:97~122,</li>
<li>A-Z:65-90</li>
<li>0-9:48~57</li>
</ul>
<p>所以这里只需要用位图法来存储，并且之用128位即可，就是4个长度的int数组，<br>在操作过程中，如果数组中已经设置了值，则说明当前遍历的为重复，打印出来即可<br>否则，将这个值设置到数组中，整体思路与位排序大致一致，复杂度为O(n)<br><a id="more"></a></p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findSameChar</span><span class="params">(String str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] store=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];<span class="comment">//4*32 =128  已经可以存下a~z大小写以及0~9</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(get(store,(<span class="keyword">int</span>)str.charAt(i))&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;<span class="comment">//表示这里已经设置过值了，直接打印出来即可</span></span><br><span class="line">			System.out.print(str.charAt(i));</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;<span class="comment">//未出现过，需要先设置标志一下</span></span><br><span class="line">			set(store,(<span class="keyword">int</span>)str.charAt(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//11111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHIFT=<span class="number">5</span>;<span class="comment">//除以32</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK=<span class="number">0x1F</span>;<span class="comment">//向32取余</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> v)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a[v&gt;&gt;SHIFT]&amp;(<span class="number">1</span>&lt;&lt;(v&amp;MASK));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> v)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	a[v&gt;&gt;SHIFT]|=(<span class="number">1</span>&lt;&lt;(v&amp;MASK));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看下实验结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	String str=<span class="string">"helloworld1232"</span>;</span><br><span class="line">	findSameChar(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>lol2
</code></pre><h2 id="参考">参考</h2><ul>
<li>July 微软面试100题  第84.1题</li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code><span class="literal">a</span>~z 包括大小写与 <span class="number">0</span>~<span class="number">9</span> 组成的 N 个数, 用最快的方式把其中重复的元素挑出来。
</code></pre><h2 id="解析">解析</h2><p>本题中已经限制了可能出现字符,他们对应的ascii为</p>
<ul>
<li>a-z:97~122,</li>
<li>A-Z:65-90</li>
<li>0-9:48~57</li>
</ul>
<p>所以这里只需要用位图法来存储，并且之用128位即可，就是4个长度的int数组，<br>在操作过程中，如果数组中已经设置了值，则说明当前遍历的为重复，打印出来即可<br>否则，将这个值设置到数组中，整体思路与位排序大致一致，复杂度为O(n)<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux下的Find命令学习]]></title>
    <link href="http://yyl8781697.github.io/2015/07/26/Linux/Find-Command/"/>
    <id>http://yyl8781697.github.io/2015/07/26/Linux/Find-Command/</id>
    <published>2015-07-26T06:46:14.000Z</published>
    <updated>2015-07-27T15:22:07.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><code>find</code>命令极为好使，在面试中也常常会被问到，所以在这里再好好学习一下^_^<br>注：本文使用的环境是CentOS6.5</p>
</blockquote>
<h2 id="Find介绍">Find介绍</h2><pre><code>功能：在目录结构中搜索文件，并执行指定的操作。此命令提供了相当多的查找条件，功能很强大。 
语法：<span class="built_in">find</span> 起始目录 寻找条件 操作 
说明：<span class="built_in">find</span>命令从指定的起始目录开始，递归地搜索其各个子目录，查找满足寻找条件的文件并对之采取相关的操作。 
</code></pre><p>其实关于<code>Linux</code>下的命令一般通过<code>—help</code>就可以大致入门使用，实在不行再用<code>man</code>来看更为完整版的手册。<br>下面先长长得列一下：<br><a id="more"></a></p>
<pre><code>[root@master spark-1.3.1-bin-hadoop2.6]# find --<span class="keyword">help</span>
Usage: find [-<span class="keyword">H</span>] [-<span class="keyword">L</span>] [-P] [-Olevel] [-<span class="keyword">D</span> <span class="keyword">help</span>|tree|<span class="keyword">search</span>|stat|rates|opt|exec] [path...] [expression]

default path is the current directory; default expression is -<span class="keyword">print</span>
expression may consist of: operators, options, tests, and actions:

operators (decreasing precedence; -and is implicit where <span class="keyword">no</span> others are given):
      ( EXPR )   ! EXPR   -not EXPR   EXPR1 -a EXPR2   EXPR1 -and EXPR2
      EXPR1 -o EXPR2   EXPR1 -or EXPR2   EXPR1 , EXPR2

positional options (always true): -daystart -follow -regextype

normal options (always true, specified before other expressions):
      -depth --<span class="keyword">help</span> -maxdepth <span class="keyword">LEVELS</span> -mindepth <span class="keyword">LEVELS</span> -mount -noleaf
      --<span class="keyword">version</span> -xdev -ignore_readdir_race -noignore_readdir_race

tests (<span class="keyword">N</span> can be +<span class="keyword">N</span> or -<span class="keyword">N</span> or <span class="keyword">N</span>): -amin <span class="keyword">N</span> -anewer <span class="keyword">FILE</span> -atime <span class="keyword">N</span> -cmin <span class="keyword">N</span>
      -cnewer <span class="keyword">FILE</span> -ctime <span class="keyword">N</span> -empty -false -fstype <span class="keyword">TYPE</span> -gid <span class="keyword">N</span> -group NAME
      -ilname PATTERN -iname PATTERN -inum <span class="keyword">N</span> -iwholename PATTERN -iregex PATTERN
      -links <span class="keyword">N</span> -lname PATTERN -mmin <span class="keyword">N</span> -mtime <span class="keyword">N</span> -name PATTERN -newer <span class="keyword">FILE</span>
      -nouser -nogroup -path PATTERN -perm [+-]MODE -regex PATTERN
      -readable -writable -executable
      -wholename PATTERN -size <span class="keyword">N</span>[bcwkMG] -true -<span class="keyword">type</span> [bcdpflsD] -uid <span class="keyword">N</span>
      -used <span class="keyword">N</span> -user NAME -xtype [bcdpfls]
      -context CONTEXT


actions: -delete -print0 -printf <span class="keyword">FORMAT</span> -fprintf <span class="keyword">FILE</span> <span class="keyword">FORMAT</span> -<span class="keyword">print</span>
      -fprint0 <span class="keyword">FILE</span> -fprint <span class="keyword">FILE</span> -<span class="keyword">ls</span> -fls <span class="keyword">FILE</span> -prune -quit
      -exec COMMAND ; -exec COMMAND {} + -ok COMMAND ;
      -execdir COMMAND ; -execdir COMMAND {} + -okdir COMMAND ;

<span class="keyword">Report</span> (and track progress <span class="keyword">on</span> fixing) bugs via the findutils bug-reporting
page at http:<span class="comment">//savannah.gnu.org/ or, if you have no web access, by sending</span>
email to &lt;bug-findutils@gnu.org&gt;.
</code></pre><p>从<code>—help</code>中我们大致可以发现<code>find</code>有以下四大表达式：</p>
<ol>
<li>operators(逻辑运算)：就是<code>and</code>,<code>or</code>,<code>not</code>这些东西</li>
<li>options(可选项？)：感觉是一些额外可选的功能</li>
<li>tests(条件属性)：各种属性啦，文件名，文件大小之类的</li>
<li>acionts(行为)：find之后想干嘛呢？打印出来  or 去执行</li>
</ol>
<p>先来看一下当前的实验目录(使用了spark已编译的一个根目录)：</p>
<pre><code><span class="attr_selector">[root@master spark-1.3.1-bin-hadoop2.6]</span># <span class="tag">ll</span>
<span class="tag">total</span> 408
<span class="tag">drwxrwxr-x</span>. 2 1000 1000   4096 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">bin</span>
<span class="tag">-rw-rw-r--</span>. 1 1000 1000 278851 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">CHANGES</span><span class="class">.txt</span>
<span class="tag">drwxrwxr-x</span>. 2 1000 1000   4096 <span class="tag">May</span> 17 09<span class="pseudo">:00</span> <span class="tag">conf</span>
<span class="tag">drwxrwxr-x</span>. 3 1000 1000   4096 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">data</span>
<span class="tag">drwxrwxr-x</span>. 3 1000 1000   4096 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">ec2</span>
<span class="tag">drwxrwxr-x</span>. 3 1000 1000   4096 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">examples</span>
<span class="tag">drwxrwxr-x</span>. 2 1000 1000   4096 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">lib</span>
<span class="tag">-rw-rw-r--</span>. 1 1000 1000  46083 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">LICENSE</span>
<span class="tag">drwxr-xr-x</span>. 2 <span class="tag">root</span> <span class="tag">root</span>   4096 <span class="tag">Jul</span> 22 11<span class="pseudo">:28</span> <span class="tag">logs</span>
<span class="tag">-rw-rw-r--</span>. 1 1000 1000  22559 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">NOTICE</span>
<span class="tag">drwxrwxr-x</span>. 7 1000 1000   4096 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">python</span>
<span class="tag">-rw-rw-r--</span>. 1 1000 1000   3629 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">README</span><span class="class">.md</span>
<span class="tag">-rw-rw-r--</span>. 1 1000 1000    157 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">RELEASE</span>
<span class="tag">drwxr-xr-x</span>. 2 <span class="tag">root</span> <span class="tag">root</span>   4096 <span class="tag">Jul</span> 20 09<span class="pseudo">:33</span> <span class="tag">runjar</span>
<span class="tag">drwxrwxr-x</span>. 2 1000 1000   4096 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">sbin</span>
<span class="tag">drwx------</span>. 2 <span class="tag">root</span> <span class="tag">root</span>   4096 <span class="tag">May</span> 22 23<span class="pseudo">:24</span> <span class="tag">spark-99afc66e-6bb1-41ee-8497-e2abdbb3013f</span>
<span class="tag">drwx------</span>. 2 <span class="tag">root</span> <span class="tag">root</span>   4096 <span class="tag">May</span> 22 23<span class="pseudo">:24</span> <span class="tag">spark-e0919038-82ee-4d5d-b421-1f50f6a110ed</span>
<span class="tag">drwx------</span>. 2 <span class="tag">root</span> <span class="tag">root</span>   4096 <span class="tag">May</span> 22 23<span class="pseudo">:24</span> <span class="tag">spark-f37f1978-ad83-4208-86d8-2bdf8c3e5696</span>
</code></pre><p>在该目录下最简单的使用一个<code>find</code>操作</p>
<pre><code>[root<span class="annotation">@master</span> spark-<span class="number">1.3</span>.1-bin-hadoop2.6]# find -name <span class="string">"NOTICE"</span>
./NOTICE
</code></pre><p>可以看到<code>NOTEICE</code>这个文件就查询出来了。</p>
<h2 id="逻辑运算">逻辑运算</h2><p><code>find</code>命令通过逻辑运算可以完成强大的组合查询，先抛开这个，看看我们码农平常写的条件判断：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(f1 &amp;&amp; (f2 || f3) &amp;&amp; !f4)</span><br></pre></td></tr></table></figure></p>
<p>而<code>find</code>的逻辑运算与之对应的就是：</p>
<ul>
<li><p><code>&amp;&amp;</code>对应<code>-and</code>，简写为：<code>-a</code></p>
<pre><code>[root<span class="variable">@master</span> spark-<span class="number">1.3</span>.1-bin-hadoop2.6]# find -name <span class="string">"NOTICE"</span> -a -<span class="keyword">size</span> -<span class="number">20</span>
[root<span class="variable">@master</span> spark-<span class="number">1.3</span>.1-bin-hadoop2.6]# find -name <span class="string">"NOTICE"</span> -a -<span class="keyword">size</span> +<span class="number">20</span>
./NOTICE
[root<span class="variable">@master</span> spark-<span class="number">1.3</span>.1-bin-hadoop2.6]# find -name <span class="string">"NOTICE"</span> -<span class="keyword">size</span> +<span class="number">20</span>
./NOTICE
</code></pre><p>  可以发现”NOTICE”文件并且小于20是找不到的，但是大于20b的时候可以找到</p>
<blockquote>
<p>注意，缺省操作符的情况就是使用<code>-a</code>，所以第三条命令和第二条命令的效果是一样的。</p>
</blockquote>
</li>
<li><p><code>||</code>对应<code>-or</code>，简写为：<code>-o</code></p>
<pre><code>[root@master spark-<span class="number">1.3</span>.1-bin-hadoop2.6]<span class="preprocessor"># find -name <span class="title">"NOTICE"</span> -o -name <span class="title">"LICENSE"</span></span>
./LICE<span class="built_in">NSE</span>
./NOTICE
</code></pre><p>  在或操作下两个文件都能查询出来</p>
</li>
<li><p><code>!</code>还是对应<code>!</code></p>
<pre><code>[root<span class="variable">@master</span> spark-<span class="number">1.3</span>.1-bin-hadoop2.6]# find -maxdepth <span class="number">1</span> ! -name <span class="string">"NOTICE"</span> -<span class="keyword">size</span> +<span class="number">20</span>
./LICENSE
./CHANGES.txt
</code></pre><p>  这样就可以查找在当前目录下名字不叫“NOTICE”以及大于20b的文件/文件夹了</p>
</li>
</ul>
<blockquote>
<p>注意，关于操作符还可以使用括号将各个操作表达式括起来，用起来还是非常灵活的^_^</p>
</blockquote>
<h2 id="可选项">可选项</h2><p>这个还是蛮有用的，看<code>—help</code>命令其实就是，还有:</p>
<ul>
<li><code>-depth</code>:使用它之后貌似先会从里向外打印，比如先找到最深的文件夹，然后一层一层向外显示</li>
<li><code>-maxdepth</code>:限制递归的最大深度，如果只在当前目录下找，那么设置<code>-maxdepth 1</code>即可</li>
<li><code>-mindepth</code>:限制最小深度，比如<code>-mindepth 2</code> 只查找深度大于2的文件</li>
<li><code>-daystart</code>:限制查找的文件是今天起24小时的文件</li>
<li><code>-follow</code>:遵循通配符链接方式查找</li>
<li>还有其他等等</li>
</ul>
<h2 id="条件属性">条件属性</h2><p>在使用<code>find</code>的时候条件属性是我们的核心,这里有两个技巧</p>
<ol>
<li><p>如果属性后面跟着的条件是数字N，那么一般支持+,-操作，比如</p>
<pre><code>[root<span class="annotation">@master</span> spark-<span class="number">1.3</span>.1-bin-hadoop2.6]# find -maxdepth <span class="number">1</span> -<span class="class"><span class="keyword">type</span> <span class="title">f</span> <span class="title">-size</span> <span class="title">+22559c</span>
</span>./<span class="type">LICENSE</span>
./<span class="type">CHANGES</span>.txt
[root<span class="annotation">@master</span> spark-<span class="number">1.3</span>.1-bin-hadoop2.6]# find -maxdepth <span class="number">1</span> -<span class="class"><span class="keyword">type</span> <span class="title">f</span> <span class="title">-size</span> 22559<span class="title">c</span>
</span>./<span class="type">NOTICE</span>
[root<span class="annotation">@master</span> spark-<span class="number">1.3</span>.1-bin-hadoop2.6]# find -maxdepth <span class="number">1</span> -<span class="class"><span class="keyword">type</span> <span class="title">f</span> <span class="title">-size</span> <span class="title">-22559c</span>
</span>./<span class="type">README</span>.md
./<span class="type">RELEASE</span>
</code></pre><p> 上面3条命令分别就是查大于22559字节的文件，等于22559字节以及小于22559字节的文件</p>
</li>
<li><p>如果属性后面跟着的条件是字串，那么一般都支持通配符<code>*</code>、<code>?</code>、<code>［ ］</code></p>
<pre><code>[root@master spark-<span class="number">1</span>.<span class="number">3</span>.<span class="number">1</span>-bin-hadoop2.<span class="number">6</span>]# <span class="built_in">find</span> -maxdepth <span class="number">1</span> -<span class="built_in">type</span> f -name "RE*"
./README.<span class="built_in">md</span>
./RELEASE
</code></pre><p> 取”RE”开头的文件名</p>
</li>
</ol>
<p>接下来看一些常用的筛选属性(要知道全部的话看<code>—help</code>里面的信息即可)</p>
<ul>
<li><code>-name PATTERN</code>:根据文件名进行匹配<blockquote>
<p>估计是最为常用的一个属性之一了，上面的演示都是用它来作为示例，所以这里不加其他说明了</p>
</blockquote>
</li>
<li><code>-type [bcdpflsD]</code>:筛选查找的类型：<ul>
<li>b 块设备文件 </li>
<li>c 字符设备文件 </li>
<li>d 目录文件 </li>
<li>p 命名管道（FIFO） </li>
<li>f 普通文件 </li>
<li>l 符号链接文件（symbolic links） </li>
<li>s socket文件 </li>
</ul>
</li>
</ul>
<pre><code>[root@master spark-<span class="number">1.3</span>.1-bin-hadoop2.6]# find -maxdepth <span class="number">1</span> -<span class="typedef"><span class="keyword">type</span> f</span>
./<span class="type">LICENSE</span>
./<span class="type">CHANGES</span>.txt
./<span class="type">README</span>.md
./<span class="type">NOTICE</span>
./<span class="type">RELEASE</span>
[root@master spark-<span class="number">1.3</span>.1-bin-hadoop2.6]# find -maxdepth <span class="number">1</span> -<span class="typedef"><span class="keyword">type</span> d</span>
.
./sbin
./spark-f37f1978-ad83-<span class="number">4208</span>-<span class="number">86</span>d8-<span class="number">2</span>bdf8c3e5696
./ec2
./bin
./spark-<span class="number">99</span>afc66e-<span class="number">6</span>bb1-<span class="number">41</span>ee-<span class="number">8497</span>-e2abdbb3013f
./<span class="typedef"><span class="keyword">data</span></span>
./lib
./conf
./python
./examples
./runjar
./spark-e0919038-<span class="number">82</span>ee-<span class="number">4</span>d5d-b421-<span class="number">1</span>f50f6a110ed
./logs


上述命名分别是查找当前目录下的文件和文件夹
</code></pre><ul>
<li><code>- size</code>:根据文件大小来进行匹配，这里大小的单位默认是字节<code>b</code>，还可以显式的其他单位<code>bcwkMG</code></li>
<li><p><code>-perm</code>: 查找具有指定权限的文件和目录</p>
<pre><code>[root@master spark-<span class="number">1.3</span>.<span class="number">1</span>-bin-hadoop2.<span class="number">6</span>]<span class="comment"># find -maxdepth 1 -perm 700</span>
./spark<span class="operator">-f</span>37f1978-ad83-<span class="number">4208</span>-<span class="number">86</span>d8-<span class="number">2</span>bdf8c3e5696
./spark-<span class="number">99</span>afc66e-<span class="number">6</span>bb1-<span class="number">41</span>ee-<span class="number">8497</span><span class="operator">-e</span>2abdbb3013f
./spark<span class="operator">-e</span>0919038-<span class="number">82</span>ee-<span class="number">4</span>d5d-b421-<span class="number">1</span>f50f6a110ed
</code></pre><p>  查找自有创建者才能用全完控制权限的目录和文件</p>
</li>
<li><code>-empty</code>:查找大小为0的目录或者空文件 </li>
<li><code>-user NAME</code>:查找所属用户名的文件</li>
<li><code>-amin n</code>:查找n分钟以前被访问过的所有文件</li>
<li><code>-atime n</code>:查找n天以前被访问过的所有文件</li>
<li><code>-cmin n</code>:查找n分钟以前文件状态被修改过的所有文件</li>
<li><code>-ctime n</code>:查找n天以前文件状态被修改过的所有文件</li>
<li><code>-mmin n</code>:查找n分钟以前文件内容被修改过的所有文件</li>
<li><code>-mtime n</code>:查找n天以前文件内容被修改过的所有文件</li>
<li>等等等自己看<code>—help</code></li>
</ul>
<h2 id="行为">行为</h2><blockquote>
<p>这里的行为是指找到文件之后再做的行为操作</p>
</blockquote>
<ul>
<li><code>-print</code>:将找到的文件/文件夹的名称给打印出来</li>
<li><code>-ls</code>:将找到的文件/文件夹的的具体信息列出来</li>
<li><code>-delete</code>:将找到的文件/文件夹的删除掉</li>
<li><p><code>-exec command {} \;</code>:异常强大，在command 里面可以写linux的命令</p>
<p>  [root@master spark-1.3.1-bin-hadoop2.6]# find -maxdepth 1 -size +20 -exec ls -l {} \;<br>  -rw-rw-r—. 1 1000 1000 46083 Apr 11 01:32 ./LICENSE<br>  -rw-rw-r—. 1 1000 1000 278851 Apr 11 01:32 ./CHANGES.txt<br>  -rw-rw-r—. 1 1000 1000 22559 Apr 11 01:32 ./NOTICE</p>
<p>  比如来实现<code>-ls</code>的功能</p>
</li>
<li><p><code>-xargs</code>:也是异常强大，它会批次/依次的取得参数，进行相应的命令操作</p>
<pre><code><span class="keyword">find</span> -maxdepth <span class="number">1</span> -<span class="keyword">size</span> +<span class="number">20</span> -<span class="keyword">print</span> |xargs <span class="keyword">grep</span> <span class="string">"License"</span>
</code></pre><p>  类似这个可以查找含有”License”的文件、文件夹</p>
</li>
</ul>
<h2 id="总结">总结</h2><blockquote>
<p>find命令是一个非常优秀的工具，它可以按照用户指定的准则来匹配文件。使用exec和xargs可以使用户对所匹配到的文件执行几乎所有的命令。<br>但是这些命令还是得常用，但能熟能生巧啊-_-</p>
</blockquote>
<h2 id="参考">参考</h2><ul>
<li><a href="http://blog.chinaunix.net/uid-20082146-id-83489.html" target="_blank" rel="external">find命令</a></li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><code>find</code>命令极为好使，在面试中也常常会被问到，所以在这里再好好学习一下^_^<br>注：本文使用的环境是CentOS6.5</p>
</blockquote>
<h2 id="Find介绍">Find介绍</h2><pre><code>功能：在目录结构中搜索文件，并执行指定的操作。此命令提供了相当多的查找条件，功能很强大。 
语法：<span class="built_in">find</span> 起始目录 寻找条件 操作 
说明：<span class="built_in">find</span>命令从指定的起始目录开始，递归地搜索其各个子目录，查找满足寻找条件的文件并对之采取相关的操作。 
</code></pre><p>其实关于<code>Linux</code>下的命令一般通过<code>—help</code>就可以大致入门使用，实在不行再用<code>man</code>来看更为完整版的手册。<br>下面先长长得列一下：<br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yyl8781697.github.io/tags/Linux/"/>
    
      <category term="Linux" scheme="http://yyl8781697.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对策字符串的最大长度]]></title>
    <link href="http://yyl8781697.github.io/2015/07/25/Algorithm/The-Longest-Palindrome/"/>
    <id>http://yyl8781697.github.io/2015/07/25/Algorithm/The-Longest-Palindrome/</id>
    <published>2015-07-25T07:03:19.000Z</published>
    <updated>2015-07-25T12:06:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>输入一个字符串,输出该字符串中对称的子字符串的最大长度。比如输入字符串 “google”,由于该字符串里最长的对称子字符串是“goog”,因此输出 4。
</code></pre><h2 id="解析">解析</h2><p>该题目比较直观的解法有：</p>
<ol>
<li>暴力法：遍历所有可能的子串，然后判断子串是否为回文，故总得复杂度为O(n^3)</li>
<li>遍历字符串，以当前遍历为中心点，然后向两边扩展，直至扩展到不是回文，总复杂度为O(n^2)</li>
</ol>
<p>还有后缀树也可以解，不过需要较大的空间，本文使用的是manacher算法：</p>
<pre><code>Manacher最早发现了可以用<span class="function"><span class="title">O</span><span class="params">(n)</span></span>的时间复杂度来解决该问题，所以这种方法称之为Manacher算法。
</code></pre><p>现在以查询字符串”abaab”为例，该算法为了将”aba”和”baab” 奇偶形式统一考虑，做了一个很精妙的预处理：每每两个字符串以及两端都加一个标志符号#，就形成了<br>“#a#b#a#a#b#”新字符串，那么”aba”则可以看做”#a#b#a#”，同时”baab”转为#b#a#a#b#”，就都为奇数形式了<br><a id="more"></a></p>
<pre><code>假设当前的字符串长度为<span class="keyword">n</span>,则添加的#个数为2*<span class="keyword">n</span>+1
</code></pre><p>接下来需要添加一个辅助数组p,其中p[i]的值表示第i位上可以形成的最大回文半径(比如p[1]=2  因为#a#的半径为2)，全部先列出的话为：</p>
<pre><code>新串:<span class="array"># a </span><span class="array"># b </span><span class="array"># a </span><span class="array"># a </span><span class="array"># b </span>#
p[]:<span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span>
</code></pre><p>其实我们可以通过p[i]的值就可以得到每个字串相应位置的回文长度</p>
<pre><code>半径<span class="tag">p</span>[i]的回文长度为<span class="number">2</span>*<span class="tag">p</span>[i]-<span class="number">1</span>，而每个在新字符串上每个回文两端必定是#，也是也就是相当于对原回文做了#的添加操作，假设原回文串为x长度，根据上面的添加#计算方式得到添加后的回文串为<span class="number">2</span>*x+<span class="number">1</span>
故<span class="number">2</span>*<span class="tag">p</span>[i]-<span class="number">1</span>=<span class="number">2</span>*x+<span class="number">1</span> 
可得x=<span class="tag">p</span>[i]-<span class="number">1</span>
</code></pre><p>那么现在的问题就是相当于如何求出新字符串上p数组各个元素的值了,当然计算这个也不能靠暴力来算，不然就没意思了，大概我们了解到计算p[i]的时候 p<a href="j&lt;i">[j]</a>的值都是已经算出来了，同时回文串有对称性质，所以我们接下来可以这么看</p>
<pre><code>现在要求<span class="tag">p</span>[<span class="number">5</span>]，根据P[<span class="number">3</span>]=<span class="number">4</span>可知，<span class="tag">p</span>[<span class="number">5</span>]是包含在<span class="tag">p</span>[<span class="number">3</span>]的回文串中，又因为回文的对称性，所以<span class="tag">p</span>[<span class="number">3</span>]左侧一定存在一个字符串与<span class="tag">p</span>[<span class="number">5</span>]一致，
其实这里就可以算出其对称串为<span class="number">2</span>*<span class="number">3</span>-<span class="number">5</span>=<span class="number">1</span>  也就是<span class="tag">p</span>[<span class="number">1</span>]，P[<span class="number">1</span>]是已经算出的=<span class="number">2</span>  所以<span class="tag">p</span>[<span class="number">5</span>]也必定至少为<span class="number">2</span>（这里要考虑P[<span class="number">3</span>]回文的右界，不能超过）
所以此时<span class="tag">p</span>[<span class="number">5</span>]只需要从<span class="tag">p</span>[<span class="number">3</span>]和<span class="tag">p</span>[<span class="number">7</span>]往两侧扩展即可，判断其存在的最大回文，这样就可以大大减少了重复计算
</code></pre><p>接下来借用别人的图来解释一下<br><img src="/img/The-Longest-Palindrome/p1.png" alt=""></p>
<blockquote>
<p>对应上面的例子你可以将变量这么认为:i=5,id=3,j=1(通过2*id-i计算) 而mx=p[id]+4，其中id表示先前存在的能到最大右边的回文中心标记。。。</p>
</blockquote>
<p>所以当mx&gt;i的时候  就可以说明在计算i的时候  可以根据id找到左侧对应的点  这样就可以减少计算量</p>
<p>但是另一种情况就是p[j]的回文范围超越了p[id]的回文范围，那这样就不能完全使用p[j]的值了<br><img src="/img/The-Longest-Palindrome/p2.png" alt=""><br>此时p[i]已知的最大可确保回文的范围就是mx-i</p>
<p>综合上述：初始化p[i]=min(p[2*id-i],mx-i)  当mx&gt;i</p>
<p>好，该算法的核心已经说明了接下来直接上代码：</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * Manacher 方法</span><br><span class="line"> * 通过增加#字符将问题统一转为奇数回文的计算</span><br><span class="line"> * 借助半径辅助数组，每次计算当前辅助数组的值的时候</span><br><span class="line"> * 利用回文的对称性可能避免重复计算</span><br><span class="line"> *<span class="javadoctag"> @param</span> str</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">manacher</span><span class="params">(String str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len=(str.length()&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span>[] f=<span class="keyword">new</span> <span class="keyword">char</span>[len];<span class="comment">//将每每两个字符中间加上#，同时首位也加#</span></span><br><span class="line">	<span class="keyword">int</span>[] p=<span class="keyword">new</span> <span class="keyword">int</span>[len];<span class="comment">//辅助数组 存储对应索引上能形成最大回文的半径</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		f[i&lt;&lt;<span class="number">1</span>]=<span class="string">'#'</span>;</span><br><span class="line">		f[(i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>]=str.charAt(i);</span><br><span class="line">	&#125;</span><br><span class="line">	f[len-<span class="number">1</span>]=<span class="string">'#'</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> id=<span class="number">0</span>,maxId=<span class="number">0</span>,maxLen=<span class="number">0</span>,maxIndex=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(maxId&gt;i)</span><br><span class="line">		&#123;</span><br><span class="line">			p[i]=Math.min(p[<span class="number">2</span>*id-i], maxId-i);<span class="comment">//找到对称点</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			p[i]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//继续往两边进行回文判断</span></span><br><span class="line">		<span class="keyword">while</span>((i-p[i])&gt;=<span class="number">0</span> &amp;&amp; (i+p[i])&lt;len &amp;&amp; f[i+p[i]]==f[i-p[i]])</span><br><span class="line">			p[i]++;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//更新当前可以到达的最远的索引id</span></span><br><span class="line">		<span class="keyword">if</span>(p[i]+i&gt;maxId)</span><br><span class="line">		&#123;</span><br><span class="line">			maxId=p[i]+i;</span><br><span class="line">			id=i;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//更新最大半径以及索引位置</span></span><br><span class="line">		<span class="keyword">if</span>(p[i]&gt;maxLen)</span><br><span class="line">		&#123;</span><br><span class="line">			maxLen=p[i];</span><br><span class="line">			maxIndex=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造回文字符串</span></span><br><span class="line">	<span class="keyword">char</span>[] ret=<span class="keyword">new</span> <span class="keyword">char</span>[maxLen-<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=maxIndex-maxLen+<span class="number">1</span>;i&lt;maxIndex+maxLen;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(f[i]!=<span class="string">'#'</span>)</span><br><span class="line">			ret[j++]=f[i];</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> String.valueOf(ret);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试的一些样例为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	System.out.println(manacher(<span class="string">"abaab"</span>));</span><br><span class="line">	System.out.println(manacher(<span class="string">"google"</span>));</span><br><span class="line">	System.out.println(manacher(<span class="string">"adfdfsedasdxdsa"</span>));</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<pre><code><span class="title">baab</span>
goog
asdxdsa
</code></pre><blockquote>
<p>他们都说这个方法复杂度为O(n)，应该也是，主要是比较maxId，其余的重复已经都是可以根据前面的结果算得</p>
</blockquote>
<h2 id="参考">参考</h2><ul>
<li><a href="http://blog.csdn.net/pi9nc/article/details/9251455" target="_blank" rel="external">Manacher算法处理字符串回文</a></li>
<li><a href="http://blog.csdn.net/yzl_rex/article/details/7908259" target="_blank" rel="external">Manacher算法：求解最长回文字符串，时间复杂度为O(N)</a></li>
<li>july 编程之美 73题</li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>输入一个字符串,输出该字符串中对称的子字符串的最大长度。比如输入字符串 “google”,由于该字符串里最长的对称子字符串是“goog”,因此输出 4。
</code></pre><h2 id="解析">解析</h2><p>该题目比较直观的解法有：</p>
<ol>
<li>暴力法：遍历所有可能的子串，然后判断子串是否为回文，故总得复杂度为O(n^3)</li>
<li>遍历字符串，以当前遍历为中心点，然后向两边扩展，直至扩展到不是回文，总复杂度为O(n^2)</li>
</ol>
<p>还有后缀树也可以解，不过需要较大的空间，本文使用的是manacher算法：</p>
<pre><code>Manacher最早发现了可以用<span class="function"><span class="title">O</span><span class="params">(n)</span></span>的时间复杂度来解决该问题，所以这种方法称之为Manacher算法。
</code></pre><p>现在以查询字符串”abaab”为例，该算法为了将”aba”和”baab” 奇偶形式统一考虑，做了一个很精妙的预处理：每每两个字符串以及两端都加一个标志符号#，就形成了<br>“#a#b#a#a#b#”新字符串，那么”aba”则可以看做”#a#b#a#”，同时”baab”转为#b#a#a#b#”，就都为奇数形式了<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[求旋转数组中的最小值]]></title>
    <link href="http://yyl8781697.github.io/2015/07/25/Algorithm/Min-Value-In-Ratate-Array/"/>
    <id>http://yyl8781697.github.io/2015/07/25/Algorithm/Min-Value-In-Ratate-Array/</id>
    <published>2015-07-25T02:42:58.000Z</published>
    <updated>2015-07-25T03:02:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>题目:把一个数组最开始的若干个元素搬到数组的末尾,我们称之为数组的旋转。输入一个 排好序的数组的一个旋转,
输出旋转数组的最小元素。例如数组<span class="list">{3, 4, 5, 1, 2}</span>为<span class="list">{1, 2, 3, 4, 5}</span>的一个旋转,该数 组的最小值为 <span class="number">1</span>。
</code></pre><h2 id="解析">解析</h2><blockquote>
<p>该题最容易想到的就是遍历，但是他的复杂度是O(n)，而作为面试题肯定是需要我们找出一种更优的方法</p>
</blockquote>
<p>这里使用可以二分法来解决该问题,假设数组a的长度为n，现在使用二分法过程中左端索引s,右端索引t，则中间位置为m=s+(t-s)/2<br>首先可以知道旋转数组在旋转之后a[0]&gt;a[n-1]是肯定成立的，</p>
<p>当a[s]&lt;=a[m]的时候，我们应该进去右侧继续查找，比如a[0]<a[2] 接下来我们只需要找a[3~4]即可（注意a[m]都已经大于a[s]了，所以这里取右侧的时候m舍去的）="" 同理，当a[s]="">a[m]的时候 进入左侧继续搜索，直到<br>可以发现当a[s]&lt;=a[t]的时候  a[s]肯定就是最小值了。</a[2]></p>
<a id="more"></a>
<pre><code>以[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]的旋转数组[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]为例
第一次搜索
[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]
 s     m       t
 此时<span class="tag">a</span>[s]&lt;<span class="tag">a</span>[m] 进入右侧，则有

[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]
         s m   t
此时<span class="tag">a</span>[s]&gt;<span class="tag">a</span>[m]，进入左侧
[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]
        sm t
此时<span class="tag">a</span>[s]=<span class="tag">a</span>[m] 继续右侧
[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]
           st
这里就满足<span class="tag">a</span>[s]&lt;=<span class="tag">a</span>[t]  则<span class="tag">a</span>[s]=<span class="number">1</span> 最小
</code></pre><blockquote>
<p>这样就可以将复杂度降为O(logn) ^_^</p>
</blockquote>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 求旋转数组中最小的值  避免遍历O(n)</span><br><span class="line"> * 可以使用二分法来做</span><br><span class="line"> * [4,5,6,7,8,1,2,3]</span><br><span class="line"> *<span class="javadoctag"> @param</span> a</span><br><span class="line"> *<span class="javadoctag"> @param</span> s</span><br><span class="line"> *<span class="javadoctag"> @param</span> t</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minValueRatateArray</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	 <span class="keyword">if</span>(a[s]&lt;=a[t])</span><br><span class="line">		 <span class="keyword">return</span> a[s];<span class="comment">//其实这个就是最小值了</span></span><br><span class="line">	 </span><br><span class="line">	 <span class="keyword">int</span> m=s+(t-s)/<span class="number">2</span>;<span class="comment">//中间数</span></span><br><span class="line">	 <span class="keyword">if</span>(a[s]&lt;=a[m])</span><br><span class="line">		 <span class="keyword">return</span> minValueRatateArray(a,m+<span class="number">1</span>,t);<span class="comment">//取右边</span></span><br><span class="line">	 <span class="function"><span class="keyword">else</span> </span><br><span class="line">		 return <span class="title">minValueRatateArray</span><span class="params">(a,s,m)</span></span>;<span class="comment">//取左边</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2><ul>
<li>July 微软面试100题系列 第69题</li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>题目:把一个数组最开始的若干个元素搬到数组的末尾,我们称之为数组的旋转。输入一个 排好序的数组的一个旋转,
输出旋转数组的最小元素。例如数组<span class="list">{3, 4, 5, 1, 2}</span>为<span class="list">{1, 2, 3, 4, 5}</span>的一个旋转,该数 组的最小值为 <span class="number">1</span>。
</code></pre><h2 id="解析">解析</h2><blockquote>
<p>该题最容易想到的就是遍历，但是他的复杂度是O(n)，而作为面试题肯定是需要我们找出一种更优的方法</p>
</blockquote>
<p>这里使用可以二分法来解决该问题,假设数组a的长度为n，现在使用二分法过程中左端索引s,右端索引t，则中间位置为m=s+(t-s)/2<br>首先可以知道旋转数组在旋转之后a[0]&gt;a[n-1]是肯定成立的，</p>
<p>当a[s]&lt;=a[m]的时候，我们应该进去右侧继续查找，比如a[0]<a[2] 接下来我们只需要找a[3~4]即可（注意a[m]都已经大于a[s]了，所以这里取右侧的时候m舍去的）
同理，当a[s]>a[m]的时候 进入左侧继续搜索，直到<br>可以发现当a[s]&lt;=a[t]的时候  a[s]肯定就是最小值了。</p>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[左边的数都小于等 于它,右边的数都大于等于它]]></title>
    <link href="http://yyl8781697.github.io/2015/07/25/Algorithm/Left-Lte-Right-Gte/"/>
    <id>http://yyl8781697.github.io/2015/07/25/Algorithm/Left-Lte-Right-Gte/</id>
    <published>2015-07-25T00:52:50.000Z</published>
    <updated>2015-07-27T13:51:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>一个 int 数组,里面数据无任何限制,要求求出所有这样的数 <span class="tag">a</span>[i],其左边的数都小于等 于它,右边的数都大于等于它。能否只用一个额外数组和少量其它空间实现
</code></pre><h2 id="解析">解析</h2><p>想其他的都是泪（递归、分治）<br>最妙的方法就是将原数组排序得到b，如果b[i]=a[i]，则a[i]就是满足该条件的数<br>这样正好满足只使用了一个额外数组^_^<br>最终的复杂度为<code>O(nlogn)</code><br><a id="more"></a></p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 左边的数都小于等 于它,右边的数都大于等于它</span><br><span class="line"> * 将原数组排序b 如果a[i]=b[i] 则该i对应的值满足条件</span><br><span class="line"> *<span class="javadoctag"> @param</span> a</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftLtRightGt</span><span class="params">(<span class="keyword">int</span>[] a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] b=a.clone();</span><br><span class="line">	Arrays.sort(b);<span class="comment">//O(nlogn)</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]==b[i])<span class="comment">//只要相等 就表示满足条件</span></span><br><span class="line">			System.out.println(i+<span class="string">":"</span>+a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2><p>July 微软面试题  第81题</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>一个 int 数组,里面数据无任何限制,要求求出所有这样的数 <span class="tag">a</span>[i],其左边的数都小于等 于它,右边的数都大于等于它。能否只用一个额外数组和少量其它空间实现
</code></pre><h2 id="解析">解析</h2><p>想其他的都是泪（递归、分治）<br>最妙的方法就是将原数组排序得到b，如果b[i]=a[i]，则a[i]就是满足该条件的数<br>这样正好满足只使用了一个额外数组^_^<br>最终的复杂度为<code>O(nlogn)</code><br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数值的整数次方]]></title>
    <link href="http://yyl8781697.github.io/2015/07/24/Algorithm/x-exponent/"/>
    <id>http://yyl8781697.github.io/2015/07/24/Algorithm/x-exponent/</id>
    <published>2015-07-24T12:05:12.000Z</published>
    <updated>2015-07-24T13:44:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>实现函数<span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> <span class="keyword">base</span>,<span class="keyword">int</span> exponent)</span>，求<span class="keyword">base</span>的exponent次方。不得使用库函数，同时不需要考虑大树问题。</span>
</code></pre><h2 id="解析">解析</h2><p>这题看似简单，但是请别这么写-_-<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> result=<span class="number">1.0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=exp;i++)</span><br><span class="line">		result*=result;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还需要考虑：</p>
<ol>
<li>exp是负数怎么办？？  恩，那就是需要求倒数了</li>
<li>exp是负数 但是base是0怎么办？？ 恩，那就是无穷大了</li>
<li>复杂度能否小于O(exp)吗？  a^5=a*a^4=a*(a*a)^2 所以可以使用递归法来做</li>
</ol>
<a id="more"></a>
<p>考虑了这么多，那么可以直接上完整代码了</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 数值的整数次方 </span><br><span class="line"> * 使用递归来求解，并且同时考虑特殊情况 </span><br><span class="line"> * 复杂度为O(exp)</span><br><span class="line"> *<span class="javadoctag"> @param</span> base</span><br><span class="line"> *<span class="javadoctag"> @param</span> exp</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (exp==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//任何数的0次方都是 1</span></span><br><span class="line">	<span class="keyword">if</span> (exp == <span class="number">1</span>) <span class="keyword">return</span> base;<span class="comment">//任何数的1 都是自己</span></span><br><span class="line">	<span class="keyword">if</span>(base == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(exp&lt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> Double.POSITIVE_INFINITY;<span class="comment">//0的负数次方都是 无穷大</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//0的正数次方都是0</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">double</span> half = power(base, Math.abs(exp) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//这里判断如何当前是奇数次数 还需要再乘以一个自己</span></span><br><span class="line">	<span class="keyword">double</span> ret= (((exp &amp; <span class="number">1</span>) == <span class="number">1</span>) ? base : <span class="number">1.0</span>) * half * half;</span><br><span class="line">	<span class="keyword">if</span>(exp&lt;<span class="number">0</span>)<span class="comment">//如果这个整数是负数的时候  则取倒数</span></span><br><span class="line">		ret=<span class="number">1</span>/ret;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2><ul>
<li><a href="http://www.cnblogs.com/xwdreamer/archive/2012/05/15/2502329.html" target="_blank" rel="external">http://www.cnblogs.com/xwdreamer/archive/2012/05/15/2502329.html</a></li>
<li>July 微软面试 第71题</li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>实现函数<span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> <span class="keyword">base</span>,<span class="keyword">int</span> exponent)</span>，求<span class="keyword">base</span>的exponent次方。不得使用库函数，同时不需要考虑大树问题。</span>
</code></pre><h2 id="解析">解析</h2><p>这题看似简单，但是请别这么写-_-<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> result=<span class="number">1.0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=exp;i++)</span><br><span class="line">		result*=result;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还需要考虑：</p>
<ol>
<li>exp是负数怎么办？？  恩，那就是需要求倒数了</li>
<li>exp是负数 但是base是0怎么办？？ 恩，那就是无穷大了</li>
<li>复杂度能否小于O(exp)吗？  a^5=a*a^4=a*(a*a)^2 所以可以使用递归法来做</li>
</ol>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
</feed>