<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Kubi Code'Blog]]></title>
  <subtitle><![CDATA[The palest ink is better than the best memory.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yyl8781697.github.io/"/>
  <updated>2015-07-27T14:58:19.000Z</updated>
  <id>http://yyl8781697.github.io/</id>
  
  <author>
    <name><![CDATA[Kubi Code]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Linux下的Find命令学习]]></title>
    <link href="http://yyl8781697.github.io/2015/07/26/Linux/Find-Command/"/>
    <id>http://yyl8781697.github.io/2015/07/26/Linux/Find-Command/</id>
    <published>2015-07-26T06:46:14.000Z</published>
    <updated>2015-07-27T14:58:19.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><code>find</code>命令极为好使，在面试中也常常会被问到，所以在这里再好好学习一下^_^<br>注：本文使用的环境是CentOS6.5</p>
</blockquote>
<h2 id="Find介绍">Find介绍</h2><pre><code>功能：在目录结构中搜索文件，并执行指定的操作。此命令提供了相当多的查找条件，功能很强大。 
语法：<span class="built_in">find</span> 起始目录 寻找条件 操作 
说明：<span class="built_in">find</span>命令从指定的起始目录开始，递归地搜索其各个子目录，查找满足寻找条件的文件并对之采取相关的操作。 
</code></pre><p>其实关于<code>Linux</code>下的命令一般通过<code>—help</code>就可以大致入门使用，实在不行再用<code>man</code>来看更为完整版的手册。<br>下面先长长得列一下：<br><a id="more"></a></p>
<pre><code>[root@master spark-1.3.1-bin-hadoop2.6]# find --<span class="keyword">help</span>
Usage: find [-<span class="keyword">H</span>] [-<span class="keyword">L</span>] [-P] [-Olevel] [-<span class="keyword">D</span> <span class="keyword">help</span>|tree|<span class="keyword">search</span>|stat|rates|opt|exec] [path...] [expression]

default path is the current directory; default expression is -<span class="keyword">print</span>
expression may consist of: operators, options, tests, and actions:

operators (decreasing precedence; -and is implicit where <span class="keyword">no</span> others are given):
      ( EXPR )   ! EXPR   -not EXPR   EXPR1 -a EXPR2   EXPR1 -and EXPR2
      EXPR1 -o EXPR2   EXPR1 -or EXPR2   EXPR1 , EXPR2

positional options (always true): -daystart -follow -regextype

normal options (always true, specified before other expressions):
      -depth --<span class="keyword">help</span> -maxdepth <span class="keyword">LEVELS</span> -mindepth <span class="keyword">LEVELS</span> -mount -noleaf
      --<span class="keyword">version</span> -xdev -ignore_readdir_race -noignore_readdir_race

tests (<span class="keyword">N</span> can be +<span class="keyword">N</span> or -<span class="keyword">N</span> or <span class="keyword">N</span>): -amin <span class="keyword">N</span> -anewer <span class="keyword">FILE</span> -atime <span class="keyword">N</span> -cmin <span class="keyword">N</span>
      -cnewer <span class="keyword">FILE</span> -ctime <span class="keyword">N</span> -empty -false -fstype <span class="keyword">TYPE</span> -gid <span class="keyword">N</span> -group NAME
      -ilname PATTERN -iname PATTERN -inum <span class="keyword">N</span> -iwholename PATTERN -iregex PATTERN
      -links <span class="keyword">N</span> -lname PATTERN -mmin <span class="keyword">N</span> -mtime <span class="keyword">N</span> -name PATTERN -newer <span class="keyword">FILE</span>
      -nouser -nogroup -path PATTERN -perm [+-]MODE -regex PATTERN
      -readable -writable -executable
      -wholename PATTERN -size <span class="keyword">N</span>[bcwkMG] -true -<span class="keyword">type</span> [bcdpflsD] -uid <span class="keyword">N</span>
      -used <span class="keyword">N</span> -user NAME -xtype [bcdpfls]
      -context CONTEXT


actions: -delete -print0 -printf <span class="keyword">FORMAT</span> -fprintf <span class="keyword">FILE</span> <span class="keyword">FORMAT</span> -<span class="keyword">print</span>
      -fprint0 <span class="keyword">FILE</span> -fprint <span class="keyword">FILE</span> -<span class="keyword">ls</span> -fls <span class="keyword">FILE</span> -prune -quit
      -exec COMMAND ; -exec COMMAND {} + -ok COMMAND ;
      -execdir COMMAND ; -execdir COMMAND {} + -okdir COMMAND ;

<span class="keyword">Report</span> (and track progress <span class="keyword">on</span> fixing) bugs via the findutils bug-reporting
page at http:<span class="comment">//savannah.gnu.org/ or, if you have no web access, by sending</span>
email to &lt;bug-findutils@gnu.org&gt;.
</code></pre><p>从<code>—help</code>中我们大致可以发现<code>find</code>有以下四大表达式：</p>
<ol>
<li>operators(逻辑运算)：就是<code>and</code>,<code>or</code>,<code>not</code>这些东西</li>
<li>options(可选项？)：感觉是一些额外可选的功能</li>
<li>tests(条件属性)：各种属性啦，文件名，文件大小之类的</li>
<li>acionts(行为)：find之后想干嘛呢？打印出来  or 去执行</li>
</ol>
<p>先来看一下当前的实验目录(使用了spark已编译的一个根目录)：</p>
<pre><code><span class="attr_selector">[root@master spark-1.3.1-bin-hadoop2.6]</span># <span class="tag">ll</span>
<span class="tag">total</span> 408
<span class="tag">drwxrwxr-x</span>. 2 1000 1000   4096 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">bin</span>
<span class="tag">-rw-rw-r--</span>. 1 1000 1000 278851 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">CHANGES</span><span class="class">.txt</span>
<span class="tag">drwxrwxr-x</span>. 2 1000 1000   4096 <span class="tag">May</span> 17 09<span class="pseudo">:00</span> <span class="tag">conf</span>
<span class="tag">drwxrwxr-x</span>. 3 1000 1000   4096 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">data</span>
<span class="tag">drwxrwxr-x</span>. 3 1000 1000   4096 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">ec2</span>
<span class="tag">drwxrwxr-x</span>. 3 1000 1000   4096 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">examples</span>
<span class="tag">drwxrwxr-x</span>. 2 1000 1000   4096 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">lib</span>
<span class="tag">-rw-rw-r--</span>. 1 1000 1000  46083 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">LICENSE</span>
<span class="tag">drwxr-xr-x</span>. 2 <span class="tag">root</span> <span class="tag">root</span>   4096 <span class="tag">Jul</span> 22 11<span class="pseudo">:28</span> <span class="tag">logs</span>
<span class="tag">-rw-rw-r--</span>. 1 1000 1000  22559 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">NOTICE</span>
<span class="tag">drwxrwxr-x</span>. 7 1000 1000   4096 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">python</span>
<span class="tag">-rw-rw-r--</span>. 1 1000 1000   3629 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">README</span><span class="class">.md</span>
<span class="tag">-rw-rw-r--</span>. 1 1000 1000    157 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">RELEASE</span>
<span class="tag">drwxr-xr-x</span>. 2 <span class="tag">root</span> <span class="tag">root</span>   4096 <span class="tag">Jul</span> 20 09<span class="pseudo">:33</span> <span class="tag">runjar</span>
<span class="tag">drwxrwxr-x</span>. 2 1000 1000   4096 <span class="tag">Apr</span> 11 01<span class="pseudo">:32</span> <span class="tag">sbin</span>
<span class="tag">drwx------</span>. 2 <span class="tag">root</span> <span class="tag">root</span>   4096 <span class="tag">May</span> 22 23<span class="pseudo">:24</span> <span class="tag">spark-99afc66e-6bb1-41ee-8497-e2abdbb3013f</span>
<span class="tag">drwx------</span>. 2 <span class="tag">root</span> <span class="tag">root</span>   4096 <span class="tag">May</span> 22 23<span class="pseudo">:24</span> <span class="tag">spark-e0919038-82ee-4d5d-b421-1f50f6a110ed</span>
<span class="tag">drwx------</span>. 2 <span class="tag">root</span> <span class="tag">root</span>   4096 <span class="tag">May</span> 22 23<span class="pseudo">:24</span> <span class="tag">spark-f37f1978-ad83-4208-86d8-2bdf8c3e5696</span>
</code></pre><p>在该目录下最简单的使用一个<code>find</code>操作</p>
<pre><code>[root<span class="annotation">@master</span> spark-<span class="number">1.3</span>.1-bin-hadoop2.6]# find -name <span class="string">"NOTICE"</span>
./NOTICE
</code></pre><p>可以看到<code>NOTEICE</code>这个文件就查询出来了。</p>
<h2 id="逻辑运算">逻辑运算</h2><p><code>find</code>命令通过逻辑运算可以完成强大的组合查询，先抛开这个，看看我们码农平常写的条件判断：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(f1 &amp;&amp; (f2 || f3) &amp;&amp; !f4)</span><br></pre></td></tr></table></figure></p>
<p>而<code>find</code>的逻辑运算与之对应的就是：</p>
<ul>
<li><p><code>&amp;&amp;</code>对应<code>-and</code>，简写为：<code>-a</code></p>
<pre><code>[root<span class="variable">@master</span> spark-<span class="number">1.3</span>.1-bin-hadoop2.6]# find -name <span class="string">"NOTICE"</span> -a -<span class="keyword">size</span> -<span class="number">20</span>
[root<span class="variable">@master</span> spark-<span class="number">1.3</span>.1-bin-hadoop2.6]# find -name <span class="string">"NOTICE"</span> -a -<span class="keyword">size</span> +<span class="number">20</span>
./NOTICE
[root<span class="variable">@master</span> spark-<span class="number">1.3</span>.1-bin-hadoop2.6]# find -name <span class="string">"NOTICE"</span> -<span class="keyword">size</span> +<span class="number">20</span>
./NOTICE
</code></pre><p>  可以发现”NOTICE”文件并且小于20是找不到的，但是大于20b的时候可以找到</p>
<blockquote>
<p>注意，缺省操作符的情况就是使用<code>-a</code>，所以第三条命令和第二条命令的效果是一样的。</p>
</blockquote>
</li>
<li><p><code>||</code>对应<code>-or</code>，简写为：<code>-o</code></p>
<pre><code>[root@master spark-<span class="number">1.3</span>.1-bin-hadoop2.6]<span class="preprocessor"># find -name <span class="title">"NOTICE"</span> -o -name <span class="title">"LICENSE"</span></span>
./LICE<span class="built_in">NSE</span>
./NOTICE
</code></pre><p>  在或操作下两个文件都能查询出来</p>
</li>
<li><p><code>!</code>还是对应<code>!</code></p>
<pre><code>[root<span class="variable">@master</span> spark-<span class="number">1.3</span>.1-bin-hadoop2.6]# find -maxdepth <span class="number">1</span> ! -name <span class="string">"NOTICE"</span> -<span class="keyword">size</span> +<span class="number">20</span>
./LICENSE
./CHANGES.txt
</code></pre><p>  这样就可以查找在当前目录下名字不叫“NOTICE”以及大于20b的文件/文件夹了</p>
</li>
</ul>
<blockquote>
<p>注意，关于操作符还可以使用括号将各个操作表达式括起来，用起来还是非常灵活的^_^</p>
</blockquote>
<h2 id="可选项">可选项</h2><p>这个还是蛮有用的，看<code>—help</code>命令其实就是，还有:</p>
<ul>
<li><code>-depth</code>:使用它之后貌似先会从里向外打印，比如先找到最深的文件夹，然后一层一层向外显示</li>
<li><code>-maxdepth</code>:限制递归的最大深度，如果只在当前目录下找，那么设置<code>-maxdepth 1</code>即可</li>
<li><code>-mindepth</code>:限制最小深度，比如<code>-mindepth 2</code> 只查找深度大于2的文件</li>
<li><code>-daystart</code>:限制查找的文件是今天起24小时的文件</li>
<li><code>-follow</code>:遵循通配符链接方式查找</li>
<li>还有其他等等</li>
</ul>
<h2 id="条件属性">条件属性</h2><p>在使用<code>find</code>的时候条件属性是我们的核心,这里有两个技巧</p>
<ol>
<li><p>如果属性后面跟着的条件是数字N，那么一般支持+,-操作，比如</p>
<pre><code>[root<span class="annotation">@master</span> spark-<span class="number">1.3</span>.1-bin-hadoop2.6]# find -maxdepth <span class="number">1</span> -<span class="class"><span class="keyword">type</span> <span class="title">f</span> <span class="title">-size</span> <span class="title">+22559c</span>
</span>./<span class="type">LICENSE</span>
./<span class="type">CHANGES</span>.txt
[root<span class="annotation">@master</span> spark-<span class="number">1.3</span>.1-bin-hadoop2.6]# find -maxdepth <span class="number">1</span> -<span class="class"><span class="keyword">type</span> <span class="title">f</span> <span class="title">-size</span> 22559<span class="title">c</span>
</span>./<span class="type">NOTICE</span>
[root<span class="annotation">@master</span> spark-<span class="number">1.3</span>.1-bin-hadoop2.6]# find -maxdepth <span class="number">1</span> -<span class="class"><span class="keyword">type</span> <span class="title">f</span> <span class="title">-size</span> <span class="title">-22559c</span>
</span>./<span class="type">README</span>.md
./<span class="type">RELEASE</span>
</code></pre><p> 上面3条命令分别就是查大于22559字节的文件，等于22559字节以及小于22559字节的文件</p>
</li>
<li><p>如果属性后面跟着的条件是字串，那么一般都支持通配符<code>*</code>、<code>?</code>、<code>［ ］</code></p>
<pre><code>[root@master spark-<span class="number">1</span>.<span class="number">3</span>.<span class="number">1</span>-bin-hadoop2.<span class="number">6</span>]# <span class="built_in">find</span> -maxdepth <span class="number">1</span> -<span class="built_in">type</span> f -name "RE*"
./README.<span class="built_in">md</span>
./RELEASE
</code></pre><p> 取”RE”开头的文件名</p>
</li>
</ol>
<p>接下来看一些常用的筛选属性(要知道全部的话看<code>—help</code>里面的信息即可)</p>
<ul>
<li><code>-name PATTERN</code>:根据文件名进行匹配<blockquote>
<p>估计是最为常用的一个属性之一了，上面的演示都是用它来作为示例，所以这里不加其他说明了</p>
</blockquote>
</li>
<li><code>-type [bcdpflsD]</code>:筛选查找的类型：<ul>
<li>b 块设备文件 </li>
<li>c 字符设备文件 </li>
<li>d 目录文件 </li>
<li>p 命名管道（FIFO） </li>
<li>f 普通文件 </li>
<li>l 符号链接文件（symbolic links） </li>
<li>s socket文件 </li>
</ul>
</li>
</ul>
<pre><code>[root@master spark-<span class="number">1.3</span>.1-bin-hadoop2.6]# find -maxdepth <span class="number">1</span> -<span class="typedef"><span class="keyword">type</span> f</span>
./<span class="type">LICENSE</span>
./<span class="type">CHANGES</span>.txt
./<span class="type">README</span>.md
./<span class="type">NOTICE</span>
./<span class="type">RELEASE</span>
[root@master spark-<span class="number">1.3</span>.1-bin-hadoop2.6]# find -maxdepth <span class="number">1</span> -<span class="typedef"><span class="keyword">type</span> d</span>
.
./sbin
./spark-f37f1978-ad83-<span class="number">4208</span>-<span class="number">86</span>d8-<span class="number">2</span>bdf8c3e5696
./ec2
./bin
./spark-<span class="number">99</span>afc66e-<span class="number">6</span>bb1-<span class="number">41</span>ee-<span class="number">8497</span>-e2abdbb3013f
./<span class="typedef"><span class="keyword">data</span></span>
./lib
./conf
./python
./examples
./runjar
./spark-e0919038-<span class="number">82</span>ee-<span class="number">4</span>d5d-b421-<span class="number">1</span>f50f6a110ed
./logs


上述命名分别是查找当前目录下的文件和文件夹
</code></pre><ul>
<li><code>- size</code>:根据文件大小来进行匹配，这里大小的单位默认是字节<code>b</code>，还可以显式的其他单位<code>bcwkMG</code></li>
<li><p><code>-perm</code>: 查找具有指定权限的文件和目录</p>
<pre><code>[root@master spark-<span class="number">1.3</span>.<span class="number">1</span>-bin-hadoop2.<span class="number">6</span>]<span class="comment"># find -maxdepth 1 -perm 700</span>
./spark<span class="operator">-f</span>37f1978-ad83-<span class="number">4208</span>-<span class="number">86</span>d8-<span class="number">2</span>bdf8c3e5696
./spark-<span class="number">99</span>afc66e-<span class="number">6</span>bb1-<span class="number">41</span>ee-<span class="number">8497</span><span class="operator">-e</span>2abdbb3013f
./spark<span class="operator">-e</span>0919038-<span class="number">82</span>ee-<span class="number">4</span>d5d-b421-<span class="number">1</span>f50f6a110ed
</code></pre><p>  查找自有创建者才能用全完控制权限的目录和文件</p>
</li>
<li><code>-empty</code>:查找大小为0的目录或者空文件 </li>
<li><code>-user NAME</code>:查找所属用户名的文件</li>
<li><code>-amin n</code>:查找n分钟以前被访问过的所有文件</li>
<li><code>-atime n</code>:查找n天以前被访问过的所有文件</li>
<li><code>-cmin n</code>:查找n分钟以前文件状态被修改过的所有文件</li>
<li><code>-ctime n</code>:查找n天以前文件状态被修改过的所有文件</li>
<li><code>-mmin n</code>:查找n分钟以前文件内容被修改过的所有文件</li>
<li><code>-mtime n</code>:查找n天以前文件内容被修改过的所有文件</li>
<li>等等等自己看<code>—help</code></li>
</ul>
<h2 id="行为">行为</h2><blockquote>
<p>这里的行为是指找到文件之后再做的行为操作</p>
</blockquote>
<ul>
<li><code>-print</code>:将找到的文件/文件夹的名称给打印出来</li>
<li><code>-ls</code>:将找到的文件/文件夹的的具体信息列出来</li>
<li><code>-delete</code>:将找到的文件/文件夹的删除掉</li>
<li><p><code>-exec command {} \;</code>:异常强大，在command 里面可以写linux的命令</p>
<p>  [root@master spark-1.3.1-bin-hadoop2.6]# find -maxdepth 1 -size +20 -exec ls -l {} \;<br>  -rw-rw-r—. 1 1000 1000 46083 Apr 11 01:32 ./LICENSE<br>  -rw-rw-r—. 1 1000 1000 278851 Apr 11 01:32 ./CHANGES.txt<br>  -rw-rw-r—. 1 1000 1000 22559 Apr 11 01:32 ./NOTICE</p>
<p>  比如来实现<code>-ls</code>的功能</p>
</li>
<li><p><code>-xargs</code>:也是异常强大，它会批次/依次的取得参数，进行相应的命令操作</p>
<pre><code><span class="keyword">find</span> -maxdepth <span class="number">1</span> -<span class="keyword">size</span> +<span class="number">20</span> -<span class="keyword">print</span> |xargs <span class="keyword">grep</span> <span class="string">"License"</span>
</code></pre><p>  类似这个可以查找含有”License”的文件、文件夹</p>
</li>
</ul>
<h2 id="总结">总结</h2><blockquote>
<p>find命令是一个非常优秀的工具，它可以按照用户指定的准则来匹配文件。使用exec和xargs可以使用户对所匹配到的文件执行几乎所有的命令。<br>但是这些命令还是得常用，但能熟能生巧啊-_-</p>
</blockquote>
<h2 id="参考">参考</h2><ul>
<li><a href="http://blog.chinaunix.net/uid-20082146-id-83489.html" target="_blank" rel="external">find命令</a></li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><code>find</code>命令极为好使，在面试中也常常会被问到，所以在这里再好好学习一下^_^<br>注：本文使用的环境是CentOS6.5</p>
</blockquote>
<h2 id="Find介绍">Find介绍</h2><pre><code>功能：在目录结构中搜索文件，并执行指定的操作。此命令提供了相当多的查找条件，功能很强大。 
语法：<span class="built_in">find</span> 起始目录 寻找条件 操作 
说明：<span class="built_in">find</span>命令从指定的起始目录开始，递归地搜索其各个子目录，查找满足寻找条件的文件并对之采取相关的操作。 
</code></pre><p>其实关于<code>Linux</code>下的命令一般通过<code>—help</code>就可以大致入门使用，实在不行再用<code>man</code>来看更为完整版的手册。<br>下面先长长得列一下：<br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yyl8781697.github.io/tags/Linux/"/>
    
      <category term="Linux" scheme="http://yyl8781697.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对策字符串的最大长度]]></title>
    <link href="http://yyl8781697.github.io/2015/07/25/Algorithm/The-Longest-Palindrome/"/>
    <id>http://yyl8781697.github.io/2015/07/25/Algorithm/The-Longest-Palindrome/</id>
    <published>2015-07-25T07:03:19.000Z</published>
    <updated>2015-07-25T12:06:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>输入一个字符串,输出该字符串中对称的子字符串的最大长度。比如输入字符串 “google”,由于该字符串里最长的对称子字符串是“goog”,因此输出 4。
</code></pre><h2 id="解析">解析</h2><p>该题目比较直观的解法有：</p>
<ol>
<li>暴力法：遍历所有可能的子串，然后判断子串是否为回文，故总得复杂度为O(n^3)</li>
<li>遍历字符串，以当前遍历为中心点，然后向两边扩展，直至扩展到不是回文，总复杂度为O(n^2)</li>
</ol>
<p>还有后缀树也可以解，不过需要较大的空间，本文使用的是manacher算法：</p>
<pre><code>Manacher最早发现了可以用<span class="function"><span class="title">O</span><span class="params">(n)</span></span>的时间复杂度来解决该问题，所以这种方法称之为Manacher算法。
</code></pre><p>现在以查询字符串”abaab”为例，该算法为了将”aba”和”baab” 奇偶形式统一考虑，做了一个很精妙的预处理：每每两个字符串以及两端都加一个标志符号#，就形成了<br>“#a#b#a#a#b#”新字符串，那么”aba”则可以看做”#a#b#a#”，同时”baab”转为#b#a#a#b#”，就都为奇数形式了<br><a id="more"></a></p>
<pre><code>假设当前的字符串长度为<span class="keyword">n</span>,则添加的#个数为2*<span class="keyword">n</span>+1
</code></pre><p>接下来需要添加一个辅助数组p,其中p[i]的值表示第i位上可以形成的最大回文半径(比如p[1]=2  因为#a#的半径为2)，全部先列出的话为：</p>
<pre><code>新串:<span class="array"># a </span><span class="array"># b </span><span class="array"># a </span><span class="array"># a </span><span class="array"># b </span>#
p[]:<span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span>
</code></pre><p>其实我们可以通过p[i]的值就可以得到每个字串相应位置的回文长度</p>
<pre><code>半径<span class="tag">p</span>[i]的回文长度为<span class="number">2</span>*<span class="tag">p</span>[i]-<span class="number">1</span>，而每个在新字符串上每个回文两端必定是#，也是也就是相当于对原回文做了#的添加操作，假设原回文串为x长度，根据上面的添加#计算方式得到添加后的回文串为<span class="number">2</span>*x+<span class="number">1</span>
故<span class="number">2</span>*<span class="tag">p</span>[i]-<span class="number">1</span>=<span class="number">2</span>*x+<span class="number">1</span> 
可得x=<span class="tag">p</span>[i]-<span class="number">1</span>
</code></pre><p>那么现在的问题就是相当于如何求出新字符串上p数组各个元素的值了,当然计算这个也不能靠暴力来算，不然就没意思了，大概我们了解到计算p[i]的时候 p<a href="j&lt;i">[j]</a>的值都是已经算出来了，同时回文串有对称性质，所以我们接下来可以这么看</p>
<pre><code>现在要求<span class="tag">p</span>[<span class="number">5</span>]，根据P[<span class="number">3</span>]=<span class="number">4</span>可知，<span class="tag">p</span>[<span class="number">5</span>]是包含在<span class="tag">p</span>[<span class="number">3</span>]的回文串中，又因为回文的对称性，所以<span class="tag">p</span>[<span class="number">3</span>]左侧一定存在一个字符串与<span class="tag">p</span>[<span class="number">5</span>]一致，
其实这里就可以算出其对称串为<span class="number">2</span>*<span class="number">3</span>-<span class="number">5</span>=<span class="number">1</span>  也就是<span class="tag">p</span>[<span class="number">1</span>]，P[<span class="number">1</span>]是已经算出的=<span class="number">2</span>  所以<span class="tag">p</span>[<span class="number">5</span>]也必定至少为<span class="number">2</span>（这里要考虑P[<span class="number">3</span>]回文的右界，不能超过）
所以此时<span class="tag">p</span>[<span class="number">5</span>]只需要从<span class="tag">p</span>[<span class="number">3</span>]和<span class="tag">p</span>[<span class="number">7</span>]往两侧扩展即可，判断其存在的最大回文，这样就可以大大减少了重复计算
</code></pre><p>接下来借用别人的图来解释一下<br><img src="/img/The-Longest-Palindrome/p1.png" alt=""></p>
<blockquote>
<p>对应上面的例子你可以将变量这么认为:i=5,id=3,j=1(通过2*id-i计算) 而mx=p[id]+4，其中id表示先前存在的能到最大右边的回文中心标记。。。</p>
</blockquote>
<p>所以当mx&gt;i的时候  就可以说明在计算i的时候  可以根据id找到左侧对应的点  这样就可以减少计算量</p>
<p>但是另一种情况就是p[j]的回文范围超越了p[id]的回文范围，那这样就不能完全使用p[j]的值了<br><img src="/img/The-Longest-Palindrome/p2.png" alt=""><br>此时p[i]已知的最大可确保回文的范围就是mx-i</p>
<p>综合上述：初始化p[i]=min(p[2*id-i],mx-i)  当mx&gt;i</p>
<p>好，该算法的核心已经说明了接下来直接上代码：</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * Manacher 方法</span><br><span class="line"> * 通过增加#字符将问题统一转为奇数回文的计算</span><br><span class="line"> * 借助半径辅助数组，每次计算当前辅助数组的值的时候</span><br><span class="line"> * 利用回文的对称性可能避免重复计算</span><br><span class="line"> *<span class="javadoctag"> @param</span> str</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">manacher</span><span class="params">(String str)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len=(str.length()&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span>[] f=<span class="keyword">new</span> <span class="keyword">char</span>[len];<span class="comment">//将每每两个字符中间加上#，同时首位也加#</span></span><br><span class="line">	<span class="keyword">int</span>[] p=<span class="keyword">new</span> <span class="keyword">int</span>[len];<span class="comment">//辅助数组 存储对应索引上能形成最大回文的半径</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		f[i&lt;&lt;<span class="number">1</span>]=<span class="string">'#'</span>;</span><br><span class="line">		f[(i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>]=str.charAt(i);</span><br><span class="line">	&#125;</span><br><span class="line">	f[len-<span class="number">1</span>]=<span class="string">'#'</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> id=<span class="number">0</span>,maxId=<span class="number">0</span>,maxLen=<span class="number">0</span>,maxIndex=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(maxId&gt;i)</span><br><span class="line">		&#123;</span><br><span class="line">			p[i]=Math.min(p[<span class="number">2</span>*id-i], maxId-i);<span class="comment">//找到对称点</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			p[i]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//继续往两边进行回文判断</span></span><br><span class="line">		<span class="keyword">while</span>((i-p[i])&gt;=<span class="number">0</span> &amp;&amp; (i+p[i])&lt;len &amp;&amp; f[i+p[i]]==f[i-p[i]])</span><br><span class="line">			p[i]++;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//更新当前可以到达的最远的索引id</span></span><br><span class="line">		<span class="keyword">if</span>(p[i]+i&gt;maxId)</span><br><span class="line">		&#123;</span><br><span class="line">			maxId=p[i]+i;</span><br><span class="line">			id=i;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//更新最大半径以及索引位置</span></span><br><span class="line">		<span class="keyword">if</span>(p[i]&gt;maxLen)</span><br><span class="line">		&#123;</span><br><span class="line">			maxLen=p[i];</span><br><span class="line">			maxIndex=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造回文字符串</span></span><br><span class="line">	<span class="keyword">char</span>[] ret=<span class="keyword">new</span> <span class="keyword">char</span>[maxLen-<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=maxIndex-maxLen+<span class="number">1</span>;i&lt;maxIndex+maxLen;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(f[i]!=<span class="string">'#'</span>)</span><br><span class="line">			ret[j++]=f[i];</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> String.valueOf(ret);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试的一些样例为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	System.out.println(manacher(<span class="string">"abaab"</span>));</span><br><span class="line">	System.out.println(manacher(<span class="string">"google"</span>));</span><br><span class="line">	System.out.println(manacher(<span class="string">"adfdfsedasdxdsa"</span>));</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<pre><code><span class="title">baab</span>
goog
asdxdsa
</code></pre><blockquote>
<p>他们都说这个方法复杂度为O(n)，应该也是，主要是比较maxId，其余的重复已经都是可以根据前面的结果算得</p>
</blockquote>
<h2 id="参考">参考</h2><ul>
<li><a href="http://blog.csdn.net/pi9nc/article/details/9251455" target="_blank" rel="external">Manacher算法处理字符串回文</a></li>
<li><a href="http://blog.csdn.net/yzl_rex/article/details/7908259" target="_blank" rel="external">Manacher算法：求解最长回文字符串，时间复杂度为O(N)</a></li>
<li>july 编程之美 73题</li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>输入一个字符串,输出该字符串中对称的子字符串的最大长度。比如输入字符串 “google”,由于该字符串里最长的对称子字符串是“goog”,因此输出 4。
</code></pre><h2 id="解析">解析</h2><p>该题目比较直观的解法有：</p>
<ol>
<li>暴力法：遍历所有可能的子串，然后判断子串是否为回文，故总得复杂度为O(n^3)</li>
<li>遍历字符串，以当前遍历为中心点，然后向两边扩展，直至扩展到不是回文，总复杂度为O(n^2)</li>
</ol>
<p>还有后缀树也可以解，不过需要较大的空间，本文使用的是manacher算法：</p>
<pre><code>Manacher最早发现了可以用<span class="function"><span class="title">O</span><span class="params">(n)</span></span>的时间复杂度来解决该问题，所以这种方法称之为Manacher算法。
</code></pre><p>现在以查询字符串”abaab”为例，该算法为了将”aba”和”baab” 奇偶形式统一考虑，做了一个很精妙的预处理：每每两个字符串以及两端都加一个标志符号#，就形成了<br>“#a#b#a#a#b#”新字符串，那么”aba”则可以看做”#a#b#a#”，同时”baab”转为#b#a#a#b#”，就都为奇数形式了<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[求旋转数组中的最小值]]></title>
    <link href="http://yyl8781697.github.io/2015/07/25/Algorithm/Min-Value-In-Ratate-Array/"/>
    <id>http://yyl8781697.github.io/2015/07/25/Algorithm/Min-Value-In-Ratate-Array/</id>
    <published>2015-07-25T02:42:58.000Z</published>
    <updated>2015-07-25T03:02:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>题目:把一个数组最开始的若干个元素搬到数组的末尾,我们称之为数组的旋转。输入一个 排好序的数组的一个旋转,
输出旋转数组的最小元素。例如数组<span class="list">{3, 4, 5, 1, 2}</span>为<span class="list">{1, 2, 3, 4, 5}</span>的一个旋转,该数 组的最小值为 <span class="number">1</span>。
</code></pre><h2 id="解析">解析</h2><blockquote>
<p>该题最容易想到的就是遍历，但是他的复杂度是O(n)，而作为面试题肯定是需要我们找出一种更优的方法</p>
</blockquote>
<p>这里使用可以二分法来解决该问题,假设数组a的长度为n，现在使用二分法过程中左端索引s,右端索引t，则中间位置为m=s+(t-s)/2<br>首先可以知道旋转数组在旋转之后a[0]&gt;a[n-1]是肯定成立的，</p>
<p>当a[s]&lt;=a[m]的时候，我们应该进去右侧继续查找，比如a[0]<a[2] 接下来我们只需要找a[3~4]即可（注意a[m]都已经大于a[s]了，所以这里取右侧的时候m舍去的）="" 同理，当a[s]="">a[m]的时候 进入左侧继续搜索，直到<br>可以发现当a[s]&lt;=a[t]的时候  a[s]肯定就是最小值了。</a[2]></p>
<a id="more"></a>
<pre><code>以[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]的旋转数组[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]为例
第一次搜索
[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]
 s     m       t
 此时<span class="tag">a</span>[s]&lt;<span class="tag">a</span>[m] 进入右侧，则有

[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]
         s m   t
此时<span class="tag">a</span>[s]&gt;<span class="tag">a</span>[m]，进入左侧
[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]
        sm t
此时<span class="tag">a</span>[s]=<span class="tag">a</span>[m] 继续右侧
[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]
           st
这里就满足<span class="tag">a</span>[s]&lt;=<span class="tag">a</span>[t]  则<span class="tag">a</span>[s]=<span class="number">1</span> 最小
</code></pre><blockquote>
<p>这样就可以将复杂度降为O(logn) ^_^</p>
</blockquote>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 求旋转数组中最小的值  避免遍历O(n)</span><br><span class="line"> * 可以使用二分法来做</span><br><span class="line"> * [4,5,6,7,8,1,2,3]</span><br><span class="line"> *<span class="javadoctag"> @param</span> a</span><br><span class="line"> *<span class="javadoctag"> @param</span> s</span><br><span class="line"> *<span class="javadoctag"> @param</span> t</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minValueRatateArray</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	 <span class="keyword">if</span>(a[s]&lt;=a[t])</span><br><span class="line">		 <span class="keyword">return</span> a[s];<span class="comment">//其实这个就是最小值了</span></span><br><span class="line">	 </span><br><span class="line">	 <span class="keyword">int</span> m=s+(t-s)/<span class="number">2</span>;<span class="comment">//中间数</span></span><br><span class="line">	 <span class="keyword">if</span>(a[s]&lt;=a[m])</span><br><span class="line">		 <span class="keyword">return</span> minValueRatateArray(a,m+<span class="number">1</span>,t);<span class="comment">//取右边</span></span><br><span class="line">	 <span class="function"><span class="keyword">else</span> </span><br><span class="line">		 return <span class="title">minValueRatateArray</span><span class="params">(a,s,m)</span></span>;<span class="comment">//取左边</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2><ul>
<li>July 微软面试100题系列 第69题</li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>题目:把一个数组最开始的若干个元素搬到数组的末尾,我们称之为数组的旋转。输入一个 排好序的数组的一个旋转,
输出旋转数组的最小元素。例如数组<span class="list">{3, 4, 5, 1, 2}</span>为<span class="list">{1, 2, 3, 4, 5}</span>的一个旋转,该数 组的最小值为 <span class="number">1</span>。
</code></pre><h2 id="解析">解析</h2><blockquote>
<p>该题最容易想到的就是遍历，但是他的复杂度是O(n)，而作为面试题肯定是需要我们找出一种更优的方法</p>
</blockquote>
<p>这里使用可以二分法来解决该问题,假设数组a的长度为n，现在使用二分法过程中左端索引s,右端索引t，则中间位置为m=s+(t-s)/2<br>首先可以知道旋转数组在旋转之后a[0]&gt;a[n-1]是肯定成立的，</p>
<p>当a[s]&lt;=a[m]的时候，我们应该进去右侧继续查找，比如a[0]<a[2] 接下来我们只需要找a[3~4]即可（注意a[m]都已经大于a[s]了，所以这里取右侧的时候m舍去的）
同理，当a[s]>a[m]的时候 进入左侧继续搜索，直到<br>可以发现当a[s]&lt;=a[t]的时候  a[s]肯定就是最小值了。</p>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[左边的数都小于等 于它,右边的数都大于等于它]]></title>
    <link href="http://yyl8781697.github.io/2015/07/25/Algorithm/Left-Lte-Right-Gte/"/>
    <id>http://yyl8781697.github.io/2015/07/25/Algorithm/Left-Lte-Right-Gte/</id>
    <published>2015-07-25T00:52:50.000Z</published>
    <updated>2015-07-27T13:51:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>一个 int 数组,里面数据无任何限制,要求求出所有这样的数 <span class="tag">a</span>[i],其左边的数都小于等 于它,右边的数都大于等于它。能否只用一个额外数组和少量其它空间实现
</code></pre><h2 id="解析">解析</h2><p>想其他的都是泪（递归、分治）<br>最妙的方法就是将原数组排序得到b，如果b[i]=a[i]，则a[i]就是满足该条件的数<br>这样正好满足只使用了一个额外数组^_^<br>最终的复杂度为<code>O(nlogn)</code><br><a id="more"></a></p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 左边的数都小于等 于它,右边的数都大于等于它</span><br><span class="line"> * 将原数组排序b 如果a[i]=b[i] 则该i对应的值满足条件</span><br><span class="line"> *<span class="javadoctag"> @param</span> a</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftLtRightGt</span><span class="params">(<span class="keyword">int</span>[] a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] b=a.clone();</span><br><span class="line">	Arrays.sort(b);<span class="comment">//O(nlogn)</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]==b[i])<span class="comment">//只要相等 就表示满足条件</span></span><br><span class="line">			System.out.println(i+<span class="string">":"</span>+a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2><p>July 微软面试题  第81题</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>一个 int 数组,里面数据无任何限制,要求求出所有这样的数 <span class="tag">a</span>[i],其左边的数都小于等 于它,右边的数都大于等于它。能否只用一个额外数组和少量其它空间实现
</code></pre><h2 id="解析">解析</h2><p>想其他的都是泪（递归、分治）<br>最妙的方法就是将原数组排序得到b，如果b[i]=a[i]，则a[i]就是满足该条件的数<br>这样正好满足只使用了一个额外数组^_^<br>最终的复杂度为<code>O(nlogn)</code><br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数值的整数次方]]></title>
    <link href="http://yyl8781697.github.io/2015/07/24/Algorithm/x-exponent/"/>
    <id>http://yyl8781697.github.io/2015/07/24/Algorithm/x-exponent/</id>
    <published>2015-07-24T12:05:12.000Z</published>
    <updated>2015-07-24T13:44:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>实现函数<span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> <span class="keyword">base</span>,<span class="keyword">int</span> exponent)</span>，求<span class="keyword">base</span>的exponent次方。不得使用库函数，同时不需要考虑大树问题。</span>
</code></pre><h2 id="解析">解析</h2><p>这题看似简单，但是请别这么写-_-<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> result=<span class="number">1.0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=exp;i++)</span><br><span class="line">		result*=result;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还需要考虑：</p>
<ol>
<li>exp是负数怎么办？？  恩，那就是需要求倒数了</li>
<li>exp是负数 但是base是0怎么办？？ 恩，那就是无穷大了</li>
<li>复杂度能否小于O(exp)吗？  a^5=a*a^4=a*(a*a)^2 所以可以使用递归法来做</li>
</ol>
<a id="more"></a>
<p>考虑了这么多，那么可以直接上完整代码了</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 数值的整数次方 </span><br><span class="line"> * 使用递归来求解，并且同时考虑特殊情况 </span><br><span class="line"> * 复杂度为O(exp)</span><br><span class="line"> *<span class="javadoctag"> @param</span> base</span><br><span class="line"> *<span class="javadoctag"> @param</span> exp</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (exp==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//任何数的0次方都是 1</span></span><br><span class="line">	<span class="keyword">if</span> (exp == <span class="number">1</span>) <span class="keyword">return</span> base;<span class="comment">//任何数的1 都是自己</span></span><br><span class="line">	<span class="keyword">if</span>(base == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(exp&lt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> Double.POSITIVE_INFINITY;<span class="comment">//0的负数次方都是 无穷大</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//0的正数次方都是0</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">double</span> half = power(base, Math.abs(exp) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//这里判断如何当前是奇数次数 还需要再乘以一个自己</span></span><br><span class="line">	<span class="keyword">double</span> ret= (((exp &amp; <span class="number">1</span>) == <span class="number">1</span>) ? base : <span class="number">1.0</span>) * half * half;</span><br><span class="line">	<span class="keyword">if</span>(exp&lt;<span class="number">0</span>)<span class="comment">//如果这个整数是负数的时候  则取倒数</span></span><br><span class="line">		ret=<span class="number">1</span>/ret;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2><ul>
<li><a href="http://www.cnblogs.com/xwdreamer/archive/2012/05/15/2502329.html" target="_blank" rel="external">http://www.cnblogs.com/xwdreamer/archive/2012/05/15/2502329.html</a></li>
<li>July 微软面试 第71题</li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>实现函数<span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> <span class="keyword">base</span>,<span class="keyword">int</span> exponent)</span>，求<span class="keyword">base</span>的exponent次方。不得使用库函数，同时不需要考虑大树问题。</span>
</code></pre><h2 id="解析">解析</h2><p>这题看似简单，但是请别这么写-_-<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> result=<span class="number">1.0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=exp;i++)</span><br><span class="line">		result*=result;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还需要考虑：</p>
<ol>
<li>exp是负数怎么办？？  恩，那就是需要求倒数了</li>
<li>exp是负数 但是base是0怎么办？？ 恩，那就是无穷大了</li>
<li>复杂度能否小于O(exp)吗？  a^5=a*a^4=a*(a*a)^2 所以可以使用递归法来做</li>
</ol>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[把数组排成最小的数]]></title>
    <link href="http://yyl8781697.github.io/2015/07/20/Algorithm/Minimum-Combination-in-Array/"/>
    <id>http://yyl8781697.github.io/2015/07/20/Algorithm/Minimum-Combination-in-Array/</id>
    <published>2015-07-20T12:31:43.000Z</published>
    <updated>2015-07-24T13:43:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>输入一个正整数数组，将它们连接起来排成一个数，输出能排出的所有数字中最小的一个。例如输入数组<span class="list">{32,  321}</span>，则输出这两个能排成的最小数字<span class="number">32132</span>。请给出解决问题的算法，并证明该算法。
</code></pre><h2 id="解析">解析</h2><p>假如有两个数字a,b，其关键思路不是比较a,b，而是比较ab和ba。。。<br>如果ab&lt;ba,则会有a&lt;b，所以这题的关键就是构建a,b的比较器</p>
<blockquote>
<p>不得不说，这个思路太妙了^_^<br><a id="more"></a></p>
</blockquote>
<p>关于证明：请看<a href="http://blog.csdn.net/cxllyg/article/details/7659525" target="_blank" rel="external">这个</a></p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 思路是比较ab和ba。。。如果ab&lt;ba,则会有a&lt;b</span><br><span class="line"> *<span class="javadoctag"> @param</span> a</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">minimumCombination</span><span class="params">(Integer[] a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Arrays.sort(a, <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a,Integer b)</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (a+<span class="string">""</span>+b).compareTo(b+<span class="string">""</span>+a);<span class="comment">//构建ab的比较器</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sb.append(a[i]);<span class="comment">//然后直接连起来就可以了</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> sb.toString();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Integer[] a=&#123;<span class="number">32</span>,<span class="number">321</span>,<span class="number">23</span>&#125;; </span><br><span class="line">	System.out.println(minimumCombination(a));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出</p>
<pre><code>2332132
</code></pre><h2 id="参考">参考</h2><ul>
<li>July 微软面试100题系列 第68题</li>
<li><a href="http://blog.csdn.net/cxllyg/article/details/7659525" target="_blank" rel="external">【百度面试题】把数组排成最小的数</a></li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>输入一个正整数数组，将它们连接起来排成一个数，输出能排出的所有数字中最小的一个。例如输入数组<span class="list">{32,  321}</span>，则输出这两个能排成的最小数字<span class="number">32132</span>。请给出解决问题的算法，并证明该算法。
</code></pre><h2 id="解析">解析</h2><p>假如有两个数字a,b，其关键思路不是比较a,b，而是比较ab和ba。。。<br>如果ab&lt;ba,则会有a&lt;b，所以这题的关键就是构建a,b的比较器</p>
<blockquote>
<p>不得不说，这个思路太妙了^_^<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[火车票 查询问题  针对12306设计一个快速的查询系统]]></title>
    <link href="http://yyl8781697.github.io/2015/07/19/Algorithm/TrainTickets/"/>
    <id>http://yyl8781697.github.io/2015/07/19/Algorithm/TrainTickets/</id>
    <published>2015-07-19T14:22:31.000Z</published>
    <updated>2015-07-24T13:43:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>火车票 查询问题  针对12306设计一个快速的查询系统
</code></pre><blockquote>
<p>这个网上看到的，好像是百度的一道面试题</p>
</blockquote>
<h2 id="解析">解析</h2><blockquote>
<p>思想就是将火车票区间的每个站按位映射，然后通过位操作法来查询，这种方式应该比较快，并且存储比较小</p>
</blockquote>
<p>比如宁波到上海的高铁G7518有7个站：宁波-&gt;余姚北-&gt;绍兴北-&gt;杭州东-&gt;桐乡-&gt;嘉善南-&gt;上海虹桥<br>那么这趟车的一张票可以用0X7F来存储：01111111，低位表示出发，高位表示终止<br>那么我如果需要查询的话：查宁波到杭州东就为:00000111（第4站杭州东站只作为达到之用，不会占用其他票，所以置0即可），然后这两个数做一个与操作就可以，如果与操作之后的值还是00000111的话，就表示有票<br>还有购买的话 只需要做抑或操作即可,01111111^00000111=01111000，这样就表示余票就只有杭州东到上海虹桥的票了</p>
<a id="more"></a>
<p>有了，有这种思路之后，可以简单的看几个代码片段</p>
<h2 id="查询票的构建">查询票的构建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 根据出发和达到站构建票</span><br><span class="line"> *<span class="javadoctag"> @param</span> start</span><br><span class="line"> *<span class="javadoctag"> @param</span> end</span><br><span class="line"> *<span class="javadoctag"> @return</span> -1表示没有这些站点</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">buildTicket</span><span class="params">(String start,String end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!STATION_MAP.containsKey(start) || !STATION_MAP.containsKey(end))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//表示没有这些站点  或者站点名字出错</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> si=STATION_MAP.get(start),ei=STATION_MAP.get(end);</span><br><span class="line">	<span class="keyword">int</span> qTicket=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(si&lt;ei)</span><br><span class="line">	&#123;</span><br><span class="line">		qTicket|=<span class="number">0x1</span>&lt;&lt;si;<span class="comment">//在相应的位置上置1  注意  达到站是不置1  </span></span><br><span class="line">		si++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> qTicket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查票的时候往往是一个起始站，还有一个到达站，这里我们就要构建乘车区间的位置为1</p>
<blockquote>
<p>注意：到达站只做到达之用，并不是经过它，为了顺利让到达站还可以作为其他票的起始点，所以这里达到站不置1<br>同时为了方法无法找到对应的区间，所以这里要先判断一下</p>
</blockquote>
<h2 id="查询">查询</h2><p>查询只需要进行一个与操作即可，并且不需要改变原数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 查询是否有票</span><br><span class="line"> *<span class="javadoctag"> @param</span> start</span><br><span class="line"> *<span class="javadoctag"> @param</span> end</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">query</span><span class="params">(String start,String end)</span></span><br><span class="line"></span>&#123;		</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.query(<span class="keyword">this</span>.buildTicket(start, end));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> State <span class="title">query</span><span class="params">(<span class="keyword">int</span> qTicket)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(qTicket==-<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> State.ERROR;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (rTicket&amp;qTicket)==qTicket?State.SUCCESS:State.FAILED;<span class="comment">//如果进行与操作之后值还是查询票的数据 就表示有票</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="购买">购买</h2><p>购买时需要改变原存储数据，这里只需要进行异或操作即可，将购买区间的位置0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 买票操作</span><br><span class="line"> *<span class="javadoctag"> @param</span> start</span><br><span class="line"> *<span class="javadoctag"> @param</span> end</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">buy</span><span class="params">(String start,String end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> qTicket=<span class="keyword">this</span>.buildTicket(start, end);</span><br><span class="line">	State state=<span class="keyword">this</span>.query(qTicket);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(state==State.SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>.rTicket^=qTicket;<span class="comment">//进行异或操作 将票买了</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="退票">退票</h2><p>退票操作起始也需要进行或运算，将原来置0的的位置置1即可，不过为了安全，在或运算之前先判断要退的票是否是该票区间的位都已经置0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 退票操作</span><br><span class="line"> *<span class="javadoctag"> @param</span> start</span><br><span class="line"> *<span class="javadoctag"> @param</span> end</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">refund</span><span class="params">(String start,String end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> qTicket=<span class="keyword">this</span>.buildTicket(start, end);</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 1100010</span><br><span class="line">	 * 0011100</span><br><span class="line">	 * 这里是为了判断退票的区间在余票中是否被正好买掉</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span>((<span class="keyword">this</span>.rTicket|qTicket)-<span class="keyword">this</span>.rTicket==qTicket)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>.rTicket|=qTicket;<span class="comment">//将票归还</span></span><br><span class="line">		<span class="keyword">return</span> State.SUCCESS;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> State.ERROR;<span class="comment">//发生意外错误了</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="全部贴上来">全部贴上来</h2><p>全部的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 火车票 查询问题  针对12306设计一个快速的查询系统</span><br><span class="line"> * 思想就是将火车票区间的每个站按位映射，然后通过位操作法来查询</span><br><span class="line"> * 注：本代码只是演示了查询的流程  关于同步方面并未考虑</span><br><span class="line"> *<span class="javadoctag"> @author</span> yanyl</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainTickets</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 一个宁波到上海的高铁为例</span><br><span class="line">	 * 每一个元素都是表示停靠站点</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String,Integer&gt; STATION_MAP;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 和STATION_MAP一样的信息  </span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String[] STATION_ARRAY=&#123;<span class="string">"宁波"</span>,<span class="string">"余姚北"</span>,<span class="string">"绍兴北"</span>,<span class="string">"杭州东"</span>,<span class="string">"桐乡"</span>,<span class="string">"嘉善南"</span>,<span class="string">"上海虹桥"</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TrainTickets</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//初始化一下站点信息</span></span><br><span class="line">		STATION_MAP=<span class="keyword">new</span> HashMap&lt;String,Integer&gt;()&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;STATION_ARRAY.length;i++)</span><br><span class="line">				&#123;</span><br><span class="line">					put(STATION_ARRAY[i],i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 01111111  低位表示起始  高位表示终止  一共7站</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> rTicket=<span class="number">0x7F</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">enum</span> State&#123;</span><br><span class="line">		<span class="javadoc">/**</span><br><span class="line">		 * 成功标志 有票 或者购买成功</span><br><span class="line">		 */</span></span><br><span class="line">		SUCCESS,</span><br><span class="line">		<span class="javadoc">/**</span><br><span class="line">		 * 失败标志 无票 或者购买失败</span><br><span class="line">		 */</span></span><br><span class="line">		FAILED,</span><br><span class="line">		<span class="javadoc">/**</span><br><span class="line">		 * 错误标志 可能使两个站点不存在</span><br><span class="line">		 */</span></span><br><span class="line">		ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 查询是否有票</span><br><span class="line">	 *<span class="javadoctag"> @param</span> start</span><br><span class="line">	 *<span class="javadoctag"> @param</span> end</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> State <span class="title">query</span><span class="params">(String start,String end)</span></span><br><span class="line">	</span>&#123;		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.query(<span class="keyword">this</span>.buildTicket(start, end));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> State <span class="title">query</span><span class="params">(<span class="keyword">int</span> qTicket)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(qTicket==-<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> State.ERROR;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> (rTicket&amp;qTicket)==qTicket?State.SUCCESS:State.FAILED;<span class="comment">//如果进行与操作之后值还是查询票的数据 就表示有票</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 买票操作</span><br><span class="line">	 *<span class="javadoctag"> @param</span> start</span><br><span class="line">	 *<span class="javadoctag"> @param</span> end</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> State <span class="title">buy</span><span class="params">(String start,String end)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> qTicket=<span class="keyword">this</span>.buildTicket(start, end);</span><br><span class="line">		State state=<span class="keyword">this</span>.query(qTicket);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(state==State.SUCCESS)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>.rTicket^=qTicket;<span class="comment">//进行异或操作 将票买了</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 退票操作</span><br><span class="line">	 *<span class="javadoctag"> @param</span> start</span><br><span class="line">	 *<span class="javadoctag"> @param</span> end</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> State <span class="title">refund</span><span class="params">(String start,String end)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> qTicket=<span class="keyword">this</span>.buildTicket(start, end);</span><br><span class="line">		</span><br><span class="line">		<span class="javadoc">/**</span><br><span class="line">		 * 1100010</span><br><span class="line">		 * 0011100</span><br><span class="line">		 * 这里是为了判断退票的区间在余票中是否被正好买掉</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="keyword">if</span>((<span class="keyword">this</span>.rTicket|qTicket)-<span class="keyword">this</span>.rTicket==qTicket)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">this</span>.rTicket|=qTicket;<span class="comment">//将票归还</span></span><br><span class="line">			<span class="keyword">return</span> State.SUCCESS;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> State.ERROR;<span class="comment">//发生意外错误了</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 根据出发和达到站构建票</span><br><span class="line">	 *<span class="javadoctag"> @param</span> start</span><br><span class="line">	 *<span class="javadoctag"> @param</span> end</span><br><span class="line">	 *<span class="javadoctag"> @return</span> -1表示没有这些站点</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">buildTicket</span><span class="params">(String start,String end)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!STATION_MAP.containsKey(start) || !STATION_MAP.containsKey(end))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//表示没有这些站点  或者站点名字出错</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> si=STATION_MAP.get(start),ei=STATION_MAP.get(end);</span><br><span class="line">		<span class="keyword">int</span> qTicket=<span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(si&lt;ei)</span><br><span class="line">		&#123;</span><br><span class="line">			qTicket|=<span class="number">0x1</span>&lt;&lt;si;<span class="comment">//在相应的位置上置1  注意  达到站是不置1  </span></span><br><span class="line">			si++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> qTicket;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 获取余票状态</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">remaining</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">boolean</span> cc=<span class="keyword">false</span>;<span class="comment">//false 表示前一站已经被买了 </span></span><br><span class="line">		sb.append(<span class="string">"余票状态："</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;STATION_ARRAY.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> mark=<span class="number">0x1</span>&lt;&lt;i;</span><br><span class="line">			<span class="keyword">if</span>((<span class="keyword">this</span>.rTicket&amp;mark)==mark)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(cc)</span><br><span class="line">				&#123;</span><br><span class="line">					sb.append(<span class="string">"-&gt;"</span>);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					sb.append(<span class="string">"  "</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				sb.append(STATION_ARRAY[i]);</span><br><span class="line">				cc=<span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cc=<span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TrainTickets tt=<span class="keyword">new</span> TrainTickets();</span><br><span class="line">		System.out.println(tt.remaining());</span><br><span class="line">		System.out.println(<span class="string">"查询 宁波-&gt;杭州南:"</span>+tt.query(<span class="string">"宁波"</span>,<span class="string">"杭州南"</span>));</span><br><span class="line">		System.out.println(<span class="string">"查询 宁波-&gt;杭州东:"</span>+tt.query(<span class="string">"宁波"</span>,<span class="string">"杭州东"</span>));</span><br><span class="line">		System.out.println(<span class="string">"购买 宁波-&gt;杭州东:"</span>+tt.buy(<span class="string">"宁波"</span>,<span class="string">"杭州东"</span>));</span><br><span class="line">		System.out.println(tt.remaining());</span><br><span class="line">		System.out.println(<span class="string">"购买 宁波-&gt;杭州东:"</span>+tt.buy(<span class="string">"宁波"</span>,<span class="string">"杭州东"</span>));</span><br><span class="line">		System.out.println(<span class="string">"购买 宁波-&gt;绍兴北:"</span>+tt.buy(<span class="string">"宁波"</span>,<span class="string">"绍兴北"</span>));</span><br><span class="line">		System.out.println(<span class="string">"购买 绍兴北-&gt;桐乡:"</span>+tt.buy(<span class="string">"绍兴北"</span>,<span class="string">"桐乡"</span>));</span><br><span class="line">		System.out.println(<span class="string">"购买 杭州东-&gt;桐乡:"</span>+tt.buy(<span class="string">"杭州东"</span>,<span class="string">"桐乡"</span>));</span><br><span class="line">		System.out.println(tt.remaining());</span><br><span class="line">		System.out.println(<span class="string">"退票 宁波-&gt;杭州东:"</span>+tt.refund(<span class="string">"宁波"</span>,<span class="string">"杭州东"</span>));</span><br><span class="line">		System.out.println(tt.remaining());</span><br><span class="line">		System.out.println(<span class="string">"购买 宁波-&gt;杭州东:"</span>+tt.buy(<span class="string">"宁波"</span>,<span class="string">"杭州东"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后的测试运算结果为：</p>
<pre><code>余票状态：  宁波-&gt;余姚北-&gt;绍兴北-&gt;杭州东-&gt;桐乡-&gt;嘉善南-&gt;上海虹桥
查询 宁波-&gt;杭州南<span class="symbol">:ERROR</span>
查询 宁波-&gt;杭州东<span class="symbol">:SUCCESS</span>
购买 宁波-&gt;杭州东<span class="symbol">:SUCCESS</span>
余票状态：  杭州东-&gt;桐乡-&gt;嘉善南-&gt;上海虹桥
购买 宁波-&gt;杭州东<span class="symbol">:FAILED</span>
购买 宁波-&gt;绍兴北<span class="symbol">:FAILED</span>
购买 绍兴北-&gt;桐乡<span class="symbol">:FAILED</span>
购买 杭州东-&gt;桐乡<span class="symbol">:SUCCESS</span>
余票状态：  桐乡-&gt;嘉善南-&gt;上海虹桥
退票 宁波-&gt;杭州东<span class="symbol">:SUCCESS</span>
余票状态：  宁波-&gt;余姚北-&gt;绍兴北  桐乡-&gt;嘉善南-&gt;上海虹桥
购买 宁波-&gt;杭州东<span class="symbol">:SUCCESS</span>
</code></pre><p>心细的小伙伴可以发现最后一次余票查询有bug，是的，应该有绍兴北到杭州东的票，不过这里只是显示问题而已，修改<code>remaining()</code>方法即可，因为看最后一条记录也的确都是可以购买到得</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>火车票 查询问题  针对12306设计一个快速的查询系统
</code></pre><blockquote>
<p>这个网上看到的，好像是百度的一道面试题</p>
</blockquote>
<h2 id="解析">解析</h2><blockquote>
<p>思想就是将火车票区间的每个站按位映射，然后通过位操作法来查询，这种方式应该比较快，并且存储比较小</p>
</blockquote>
<p>比如宁波到上海的高铁G7518有7个站：宁波-&gt;余姚北-&gt;绍兴北-&gt;杭州东-&gt;桐乡-&gt;嘉善南-&gt;上海虹桥<br>那么这趟车的一张票可以用0X7F来存储：01111111，低位表示出发，高位表示终止<br>那么我如果需要查询的话：查宁波到杭州东就为:00000111（第4站杭州东站只作为达到之用，不会占用其他票，所以置0即可），然后这两个数做一个与操作就可以，如果与操作之后的值还是00000111的话，就表示有票<br>还有购买的话 只需要做抑或操作即可,01111111^00000111=01111000，这样就表示余票就只有杭州东到上海虹桥的票了</p>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Java Base" scheme="http://yyl8781697.github.io/tags/Java-Base/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最长递增子序列]]></title>
    <link href="http://yyl8781697.github.io/2015/07/19/Algorithm/Longest/"/>
    <id>http://yyl8781697.github.io/2015/07/19/Algorithm/Longest/</id>
    <published>2015-07-19T08:31:57.000Z</published>
    <updated>2015-07-24T13:44:51.000Z</updated>
    <content type="html"><![CDATA[<p>题目</p>
<pre><code>给定一个长度为<span class="keyword">N</span>的数组，找出一个最长的单调自增子序列（不一定连续，但是顺序不能乱）。例如：给定一个长度为<span class="number">6</span>的数组A<span class="list">{5， 6， 7， 1， 2， 8}</span>，则其最长的单调递增子序列为<span class="list">{5，6，7，8}</span>，长度为<span class="number">4.</span>
</code></pre><h2 id="解析">解析</h2><blockquote>
<p>此题面试中非常常见，其实比较简单，一般面试中不要慌，按条理来一般都能答出 ^_^</p>
</blockquote>
<p>N长度的数组，关于最长递增子序列有max(l(i))=max(l(i-1)),i&gt;1, a[i]&gt;a[i-1]，这个关系式很重要<br>再来看假如N=1，那么l=1<br>如果N=2,有{16,24}，那么可以发现l=2，因为max(l(0))=1,24&gt;16,所以max(l(1))=max(l(0))+1<br>好了，其实我们可以维护一个N的辅助数组，每个值表示在当前元素下考虑后面的元素可能组成的最长递增子序列,比如刚刚为N=2，有f[0]=2,f[1]=1<br><a id="more"></a><br>现在来看一个长一点的数组：</p>
<pre><code><span class="atom">a</span>={<span class="number">3</span>,<span class="number">18</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="number">41</span>,<span class="number">16</span>,<span class="number">24</span>}
我们从后往前进行遍历（第一个索引为<span class="number">0</span>）
<span class="atom">a</span>[<span class="number">9</span>]=<span class="number">24</span>，为最后一个元素，所以辅助数组<span class="atom">b</span>中<span class="atom">f</span>[<span class="number">9</span>]=<span class="number">1</span> 表示它以及它最后可能组成的最长递增子序列为<span class="number">1</span>
则有
<span class="atom">f</span>={<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="number">1</span>}
<span class="atom">a</span>[<span class="number">8</span>]=<span class="number">16</span>，所以<span class="atom">a</span>[<span class="number">8</span>]&lt;<span class="atom">a</span>[<span class="number">9</span>],故<span class="atom">f</span>[<span class="number">8</span>]=<span class="number">2</span>
<span class="atom">f</span>={<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="number">2</span>,<span class="number">1</span>}
而<span class="atom">a</span>[<span class="number">7</span>]=<span class="number">41</span>&gt;<span class="atom">a</span>[<span class="number">8</span>]，同时<span class="atom">a</span>[<span class="number">7</span>]&gt;<span class="number">10</span>，所以考虑<span class="atom">a</span>[<span class="number">7</span>]以后的元素它可能的最长递增子序列为<span class="number">1</span>
<span class="atom">f</span>={<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>}
现在来看<span class="atom">a</span>[<span class="number">6</span>]=<span class="number">23</span>&lt;<span class="atom">a</span>[<span class="number">41</span>]，暂时<span class="atom">f</span>[<span class="number">6</span>]=<span class="atom">f</span>[<span class="number">7</span>]+<span class="number">1</span>=<span class="number">2</span> 再来看<span class="atom">a</span>[<span class="number">6</span>]&lt;<span class="atom">a</span>[<span class="number">9</span>] 所以<span class="atom">f</span>[<span class="number">6</span>]=<span class="atom">f</span>[<span class="number">9</span>]+<span class="number">1</span> 还是<span class="number">2</span>
<span class="atom">f</span>={<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>}
再来看一个<span class="atom">a</span>[<span class="number">5</span>]=<span class="number">12</span>，<span class="atom">a</span>[<span class="number">5</span>]&lt;<span class="atom">a</span>[<span class="number">6</span>] 故<span class="atom">f</span>[<span class="number">5</span>]=<span class="atom">f</span>[<span class="number">6</span>]+<span class="number">1</span>=<span class="number">3</span> 再继续<span class="atom">a</span>[<span class="number">7</span>],<span class="atom">a</span>[<span class="number">8</span>],<span class="atom">a</span>[<span class="number">9</span>]对比之后<span class="atom">f</span>[<span class="number">5</span>]还是等于<span class="number">3</span>
<span class="atom">f</span>={<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="name">_</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>}
.
.
.
<span class="atom">f</span>={<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>}

然后根据数组<span class="atom">b</span>取降序位置的索引<span class="number">6</span>，<span class="number">5</span>，<span class="number">4</span>，<span class="number">3</span>，<span class="number">2</span>，<span class="number">1</span>在<span class="atom">a</span>上打印出来即可
</code></pre><p>这里主要是介绍动态规划法：<br>貌似还有最大公共子序列法以及一个插入法来求</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] a=&#123;<span class="number">3</span>,<span class="number">18</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="number">41</span>,<span class="number">16</span>,<span class="number">24</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span>[] f=<span class="keyword">new</span> <span class="keyword">int</span>[a.length];<span class="comment">//存放当前索引位置上以它为起点可能存在的最长子序列个数</span></span><br><span class="line">	<span class="keyword">int</span> maxIndex=-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> maxLen=-<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=a.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		f[i]=<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(i==a.length-<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;a.length;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&lt;a[j] &amp;&amp; f[i]&lt;=f[j])</span><br><span class="line">			&#123;</span><br><span class="line">				f[i]=f[j]+<span class="number">1</span>;<span class="comment">//计算当前以当前位置为索引起始点的最长自增字符串个数</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(f[i]&gt;maxLen)</span><br><span class="line">		&#123;</span><br><span class="line">			maxLen=f[i];<span class="comment">//得到最长的标志</span></span><br><span class="line">			maxIndex=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=maxIndex;i&lt;a.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(f[i]==maxLen)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line">			maxLen--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<pre><code>3
7
10
12
23
41
</code></pre><h2 id="参考">参考</h2><p><a href="http://qiemengdao.iteye.com/blog/1660229" target="_blank" rel="external">http://qiemengdao.iteye.com/blog/1660229</a></p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>题目</p>
<pre><code>给定一个长度为<span class="keyword">N</span>的数组，找出一个最长的单调自增子序列（不一定连续，但是顺序不能乱）。例如：给定一个长度为<span class="number">6</span>的数组A<span class="list">{5， 6， 7， 1， 2， 8}</span>，则其最长的单调递增子序列为<span class="list">{5，6，7，8}</span>，长度为<span class="number">4.</span>
</code></pre><h2 id="解析">解析</h2><blockquote>
<p>此题面试中非常常见，其实比较简单，一般面试中不要慌，按条理来一般都能答出 ^_^</p>
</blockquote>
<p>N长度的数组，关于最长递增子序列有max(l(i))=max(l(i-1)),i&gt;1, a[i]&gt;a[i-1]，这个关系式很重要<br>再来看假如N=1，那么l=1<br>如果N=2,有{16,24}，那么可以发现l=2，因为max(l(0))=1,24&gt;16,所以max(l(1))=max(l(0))+1<br>好了，其实我们可以维护一个N的辅助数组，每个值表示在当前元素下考虑后面的元素可能组成的最长递增子序列,比如刚刚为N=2，有f[0]=2,f[1]=1<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[打印一个集合所有的子集和]]></title>
    <link href="http://yyl8781697.github.io/2015/07/19/Algorithm/SubCollection/"/>
    <id>http://yyl8781697.github.io/2015/07/19/Algorithm/SubCollection/</id>
    <published>2015-07-19T07:39:20.000Z</published>
    <updated>2015-07-24T13:45:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>打印一个集合所有的子集和，比如<span class="list">{a,b,c}</span>的子集和有<span class="list">{a}</span>,<span class="list">{b}</span>,<span class="list">{c}</span>,<span class="list">{a,b}</span>,<span class="list">{a,c}</span>,<span class="list">{b,c}</span>,<span class="list">{a,b,c}</span>以及 空
</code></pre><h2 id="解析">解析</h2><p>一个元素个数为n的集合所包含的所有组合的子集个数有2^n个，这样其实就可以将所以集合的情况映射到0~2^n-1个，然后按位取元素即可</p>
<pre><code>比如<span class="list">{a,b,c}</span>这个三元素的集合按位映射
<span class="list">{0,0,0}</span>=&gt;空
<span class="list">{0,0,1}</span>=&gt;<span class="list">{c}</span>
<span class="list">{0,1,0}</span>=&gt;<span class="list">{b}</span>
<span class="list">{0,1,1}</span>=&gt;<span class="list">{b,c}</span>
.
.
.
<span class="list">{1,1,1}</span>=&gt;<span class="list">{a,b,c}</span>
</code></pre><a id="more"></a>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 将集合映射到位，然后进行与操作,然后一个集合可能含有的子元素最多是2^n个</span><br><span class="line"> *<span class="javadoctag"> @param</span> cs</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">subCollection</span><span class="params">(<span class="keyword">char</span>[] cs)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len=cs.length,maxNum=<span class="number">1</span>&lt;&lt;len;</span><br><span class="line">	<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> mark=<span class="number">0x1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxNum;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len &amp;&amp; temp!=<span class="number">0</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>((temp&amp;mark)==<span class="number">1</span>)<span class="comment">//取最低位的数字是否为1   </span></span><br><span class="line">			&#123;</span><br><span class="line">				System.out.print(cs[j]);</span><br><span class="line">			&#125;</span><br><span class="line">			temp=temp&gt;&gt;<span class="number">1</span>;<span class="comment">//右移一位</span></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的复杂度为<code>O(n*2^n)</code>，最主要的是这种方式代码写起来很方便<br>其测试代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span>[] cs=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line">	subCollection(cs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出的结果为</p>
<pre><code><span class="tag">a</span>
<span class="tag">b</span>
ab
c
ac
bc
abc
</code></pre><h2 id="参考">参考</h2><p>July微软100道面试题  忘了第哪一道 -_-</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>打印一个集合所有的子集和，比如<span class="list">{a,b,c}</span>的子集和有<span class="list">{a}</span>,<span class="list">{b}</span>,<span class="list">{c}</span>,<span class="list">{a,b}</span>,<span class="list">{a,c}</span>,<span class="list">{b,c}</span>,<span class="list">{a,b,c}</span>以及 空
</code></pre><h2 id="解析">解析</h2><p>一个元素个数为n的集合所包含的所有组合的子集个数有2^n个，这样其实就可以将所以集合的情况映射到0~2^n-1个，然后按位取元素即可</p>
<pre><code>比如<span class="list">{a,b,c}</span>这个三元素的集合按位映射
<span class="list">{0,0,0}</span>=&gt;空
<span class="list">{0,0,1}</span>=&gt;<span class="list">{c}</span>
<span class="list">{0,1,0}</span>=&gt;<span class="list">{b}</span>
<span class="list">{0,1,1}</span>=&gt;<span class="list">{b,c}</span>
.
.
.
<span class="list">{1,1,1}</span>=&gt;<span class="list">{a,b,c}</span>
</code></pre>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[奇数偶数分离 奇数在左侧,偶数在右侧,要求复杂度为O(N)]]></title>
    <link href="http://yyl8781697.github.io/2015/07/19/Algorithm/OddEvenSplit/"/>
    <id>http://yyl8781697.github.io/2015/07/19/Algorithm/OddEvenSplit/</id>
    <published>2015-07-19T07:20:01.000Z</published>
    <updated>2015-07-24T13:45:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>奇数偶数分离 奇数在左侧  偶数在右侧 要求复杂度为<span class="function"><span class="title">O</span><span class="params">(N)</span></span>
</code></pre><h2 id="解析">解析</h2><p>本题的难点主要是在O(N)复杂度的要求，但是想想有没有类似对数组左右分离的操作？<br>对，就是快速排序，在使用快速排序的分区中左边都是小于基准，右边都是大于基准<br>所以，同理，现在按照快排分区的思想，左边都是为奇数，右边都是为偶数，基数无论为奇偶皆可<br><a id="more"></a></p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 使用快速排序的分区思想，只是&amp;lt;和&amp;gt;变为奇数和偶数而已</span><br><span class="line"> *<span class="javadoctag"> @param</span> a</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oddEvenSplit</span><span class="params">(<span class="keyword">int</span>[] a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.length&lt;<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> k=a[<span class="number">0</span>],i=<span class="number">0</span>,j=a.length-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>((a[j]&amp;<span class="number">1</span>)==<span class="number">0</span> &amp;&amp; i&lt;j)<span class="comment">//从右往左找  直到遇到奇数</span></span><br><span class="line">			j--;</span><br><span class="line">		a[i]=a[j];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>((a[i]&amp;<span class="number">1</span>)==<span class="number">1</span> &amp;&amp; i&lt;j)<span class="comment">//从左往右找  直到遇到偶数</span></span><br><span class="line">			i++;</span><br><span class="line">		a[j]=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	a[i]=k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看下测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">	oddEvenSplit(a);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">		System.out.print(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出的结果为：</p>
<pre><code>75314628
</code></pre><p>可以发现这里是以1为基准，1左边的都是奇数，1右边的都是偶数</p>
<h2 id="参考">参考</h2><p>July微软100道面试题  忘了第哪一道 -_-</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>奇数偶数分离 奇数在左侧  偶数在右侧 要求复杂度为<span class="function"><span class="title">O</span><span class="params">(N)</span></span>
</code></pre><h2 id="解析">解析</h2><p>本题的难点主要是在O(N)复杂度的要求，但是想想有没有类似对数组左右分离的操作？<br>对，就是快速排序，在使用快速排序的分区中左边都是小于基准，右边都是大于基准<br>所以，同理，现在按照快排分区的思想，左边都是为奇数，右边都是为偶数，基数无论为奇偶皆可<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从52张牌中随意取5张，看是否能组成顺子]]></title>
    <link href="http://yyl8781697.github.io/2015/07/18/Algorithm/CardStraight/"/>
    <id>http://yyl8781697.github.io/2015/07/18/Algorithm/CardStraight/</id>
    <published>2015-07-18T15:23:27.000Z</published>
    <updated>2015-07-24T13:45:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>从52张牌中随意取5张，看是否能组成顺子
其中1~k 表示1~13  大小王可以代替任意数字
</code></pre><h2 id="解题">解题</h2><p>首先可以将牌映射到数组上，然后将数组排序<br>在使用左右两端的指针向中间靠<br>如果左指针与接下来的值相差1或者接下来的值时大小王 则过到下一个<br>否则判断右指针是否有大小王  有的话右指针左移一位<br><a id="more"></a></p>
<pre><code>现在有牌排序之后的样纸
<span class="number">1</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">5</span>，king
^           ^
第一次判断的时候可以发现<span class="number">1</span>=<span class="number">2</span>-<span class="number">1</span>  正好成顺序
<span class="number">1</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">5</span>，king
   ^        ^
但是在第二次迭代中会发现这次<span class="number">2</span>!=<span class="number">4</span>-<span class="number">1</span>
所以要去判断最后面是否存在<span class="tag">q</span>,如果存在，这右指针前面移动
<span class="number">1</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">5</span>，king
   ^    ^

然后这里不断迭代即可，直到左右指针碰到一起
</code></pre><h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 先排序</span><br><span class="line"> * 在使用左右两端的指针向中间靠</span><br><span class="line"> * 如果左指针与接下来的值相差1或者接下来的值时大小王 则过到下一个</span><br><span class="line"> * 否则判断右指针是否有大小王  有的话右指针左移一位</span><br><span class="line"> *<span class="javadoctag"> @param</span> a</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">cardStraight</span><span class="params">(<span class="keyword">int</span>[] a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Arrays.sort(a);<span class="comment">//进行排序 O(nlogn)</span></span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=a.length-<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">int</span> cur=a[i];<span class="comment">//表示当前比较的牌 不是前后两张牌是否是连续的或者是用大小王来代替的 这个cur的计数都会+1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(cur==a[i+<span class="number">1</span>]-<span class="number">1</span>||a[i+<span class="number">1</span>]==Integer.MAX_VALUE)</span><br><span class="line">		&#123;</span><br><span class="line">			i++;<span class="comment">//这里表示上下两张牌连续 后者最后一张可以用的牌位大小王</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j]==Integer.MAX_VALUE)<span class="comment">//不通过  判断最后一张牌是不是大小王</span></span><br><span class="line">			&#123;</span><br><span class="line">				j--;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				flag=<span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cur++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看一下测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里使用Integer.MAX_VALUE表示大小王</span></span><br><span class="line">	<span class="keyword">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	System.out.println(cardStraight(a));</span><br><span class="line">	<span class="keyword">int</span>[] b=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	System.out.println(cardStraight(b));</span><br><span class="line">	<span class="keyword">int</span>[] c=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,Integer.MAX_VALUE&#125;;<span class="comment">//有一个大小王</span></span><br><span class="line">	System.out.println(cardStraight(c));</span><br><span class="line">	<span class="keyword">int</span>[] d=&#123;<span class="number">1</span>,Integer.MAX_VALUE,Integer.MAX_VALUE,<span class="number">4</span>,Integer.MAX_VALUE&#125;;<span class="comment">//有好多大小王</span></span><br><span class="line">	System.out.println(cardStraight(d));</span><br><span class="line">	<span class="keyword">int</span>[] e=&#123;<span class="number">1</span>,Integer.MAX_VALUE,Integer.MAX_VALUE,<span class="number">6</span>,Integer.MAX_VALUE&#125;;<span class="comment">//有好多大小王  但是最大的牌也太大了</span></span><br><span class="line">	System.out.println(cardStraight(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终结果为：</p>
<pre><code><span class="literal">true</span>
<span class="literal">false</span>
<span class="literal">true</span>
<span class="literal">true</span>
<span class="literal">false</span>
</code></pre><hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>从52张牌中随意取5张，看是否能组成顺子
其中1~k 表示1~13  大小王可以代替任意数字
</code></pre><h2 id="解题">解题</h2><p>首先可以将牌映射到数组上，然后将数组排序<br>在使用左右两端的指针向中间靠<br>如果左指针与接下来的值相差1或者接下来的值时大小王 则过到下一个<br>否则判断右指针是否有大小王  有的话右指针左移一位<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用递归的方法将栈颠倒]]></title>
    <link href="http://yyl8781697.github.io/2015/07/18/Algorithm/Put-Upside-Down-Stack/"/>
    <id>http://yyl8781697.github.io/2015/07/18/Algorithm/Put-Upside-Down-Stack/</id>
    <published>2015-07-17T16:33:15.000Z</published>
    <updated>2015-07-24T13:45:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>使用递归的方法将栈颠倒
</code></pre><h2 id="解题">解题</h2><p>假设当前的入栈顺序为1,2,3,4,5  那么我们的目标是将栈内的顺序改为5,4,3,2,2,1<br>先来看如果将数据搞成了1 和5,4,3,2  那么只需要将1放在栈的尾部即可，就可以变成了5,4,3,2,1<br>那么如何将2，3，4，5变为5,4,3,2呢，其实同理，也是分为2和5,4,2 一致递归<br><a id="more"></a><br>关于如何将元素放入栈的尾部？</p>
<pre><code>将e放到底部
先递归逐个将元素取出来  取至空的时候将e给<span class="keyword">push</span>进去
然后再依次将取出来的元素也给<span class="keyword">push</span>进去
</code></pre><h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 1,2,3,4,5看成1和2,3,4,5</span><br><span class="line"> * 假如已经将2,3,4,5倒转置5,4,3,2  那么只需要将1放到末尾即可</span><br><span class="line"> * 同时关于2,3,4,5的倒置也可以看做3,4,5和2的分离</span><br><span class="line"> * 逐步递归即可</span><br><span class="line"> *<span class="javadoctag"> @param</span> stack</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">putUpsideDownStack</span><span class="params">(Stack&lt;E&gt; stack)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(stack.size()&lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	</span><br><span class="line">	E t=stack.pop();</span><br><span class="line">	putUpsideDownStack(stack);</span><br><span class="line">	addToBottom(stack,t);<span class="comment">//将当前元素放到底部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 将e放到底部</span><br><span class="line"> * 先递归逐个将元素取出来  取至空的时候将e给push进去</span><br><span class="line"> * 然后再依次将取出来的元素也给push进去</span><br><span class="line"> *<span class="javadoctag"> @param</span> stack</span><br><span class="line"> *<span class="javadoctag"> @param</span> e</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addToBottom</span><span class="params">(Stack&lt;E&gt; stack,E e)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(stack.size()==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		stack.push(e);<span class="comment">//放到底部</span></span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	E t=stack.pop();</span><br><span class="line">	addToBottom(stack,e);</span><br><span class="line">	stack.push(t);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证结果可以看到<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">	stack.push(<span class="number">1</span>);</span><br><span class="line">	stack.push(<span class="number">2</span>);</span><br><span class="line">	stack.push(<span class="number">3</span>);</span><br><span class="line">	stack.push(<span class="number">4</span>);</span><br><span class="line">	stack.push(<span class="number">5</span>);</span><br><span class="line">	putUpsideDownStack(stack);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(stack.size()&gt;<span class="number">0</span>)</span><br><span class="line">		System.out.println(stack.pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>1
2
3
4
5
</code></pre><h2 id="参考">参考</h2><p><a href="http://blog.csdn.net/cxllyg/article/details/7655935" target="_blank" rel="external">http://blog.csdn.net/cxllyg/article/details/7655935</a></p>
<blockquote>
<p>其实我只是将参考里面的意思给复述了一下，我好自己理解-_-</p>
</blockquote>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>使用递归的方法将栈颠倒
</code></pre><h2 id="解题">解题</h2><p>假设当前的入栈顺序为1,2,3,4,5  那么我们的目标是将栈内的顺序改为5,4,3,2,2,1<br>先来看如果将数据搞成了1 和5,4,3,2  那么只需要将1放在栈的尾部即可，就可以变成了5,4,3,2,1<br>那么如何将2，3，4，5变为5,4,3,2呢，其实同理，也是分为2和5,4,2 一致递归<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在O(1)时间内删除一个单链表上指定的节点]]></title>
    <link href="http://yyl8781697.github.io/2015/07/17/Algorithm/DeleteNode-In-O1/"/>
    <id>http://yyl8781697.github.io/2015/07/17/Algorithm/DeleteNode-In-O1/</id>
    <published>2015-07-16T23:19:56.000Z</published>
    <updated>2015-07-24T13:46:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>在<span class="function"><span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span>时间内删除一个单链表上指定的节点
</code></pre><h2 id="解题">解题</h2><p>这题主要是需要O(1)的复杂度，我们之前一般删除节点的方法都是找到要删除节点p，然后p.parent.next=p.next就可以了，但是那个复杂度是O(n)</p>
<p>不过这里有一种我称为狸猫换太子的方法来解决这个问题<br><a id="more"></a></p>
<pre><code><span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>
 假如现在要删除p.<span class="typedef"><span class="keyword">data</span>=3</span>
 首先将p.<span class="typedef"><span class="keyword">data</span>=p.next.<span class="keyword">data</span></span>
 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>
 然后将p.next删除
 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>

 如果是尾节点  需要重新遍历
</code></pre><p>思路很精妙，就是将p.next作为傀儡，删除它</p>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line"> * 假如现在要删除p.data=3</span><br><span class="line"> * 首先将p.data=p.next.data</span><br><span class="line"> * 1-&gt;2-&gt;4-&gt;4-&gt;5</span><br><span class="line"> * 然后将p.next删除</span><br><span class="line"> * 1-&gt;2-&gt;4-&gt;5</span><br><span class="line"> * </span><br><span class="line"> * 如果是尾节点  需要重新遍历</span><br><span class="line"> * 还有 如果是p==head  则直接得置空  但是在java中这个操作不是很好做。所以。。。</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> *<span class="javadoctag"> @param</span> head</span><br><span class="line"> *<span class="javadoctag"> @param</span> dNode</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteNodeInO1</span><span class="params">(Link head,Link p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(p.next==<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//表示尾部节点</span></span><br><span class="line">		Link q=head;</span><br><span class="line">		<span class="keyword">while</span>(q.next!=p)</span><br><span class="line">			q=q.next;<span class="comment">//找到尾节点的前一个节点</span></span><br><span class="line">		q.next=<span class="keyword">null</span>;<span class="comment">//进行删除</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		p.data=p.next.data;</span><br><span class="line">		p.next=p.next.next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Link head)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Link p=head;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.print(p.data);</span><br><span class="line">		p=p.next;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Link</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">public</span> Link next;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> data)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data=data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只是要删除节点是头部或者尾部的时候需要额外考虑，按遍历的方法删除即可</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>在<span class="function"><span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span>时间内删除一个单链表上指定的节点
</code></pre><h2 id="解题">解题</h2><p>这题主要是需要O(1)的复杂度，我们之前一般删除节点的方法都是找到要删除节点p，然后p.parent.next=p.next就可以了，但是那个复杂度是O(n)</p>
<p>不过这里有一种我称为狸猫换太子的方法来解决这个问题<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[链表的逆序输出]]></title>
    <link href="http://yyl8781697.github.io/2015/07/16/Algorithm/Print-Tail-Head/"/>
    <id>http://yyl8781697.github.io/2015/07/16/Algorithm/Print-Tail-Head/</id>
    <published>2015-07-16T15:52:12.000Z</published>
    <updated>2015-07-24T13:46:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题">问题</h2><pre><code>如何将一个链表进行逆序输出，比如<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>的链表输出为<span class="number">4321</span>
</code></pre><h2 id="解题">解题</h2><ol>
<li>最方便可能就是先讲原生链表翻转，再按翻转的输出，这样会破坏原有链表的结构</li>
<li>第二种就是先遍历存放到一个数组或者栈中，然后从后往前输出即可，就需要额外的O(n)空间。</li>
</ol>
<p>这两种方法都是需要额外的复杂度或者空间，网络行流传更好的方法就是使用递归-_-! 神方法啊，递归一次即可。。<br><a id="more"></a></p>
<h3 id="代码">代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 使用递归 不消耗其他的空间</span><br><span class="line"> *<span class="javadoctag"> @param</span> link</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTail2Head</span><span class="params">(Link link)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(link!=<span class="keyword">null</span> &amp;&amp; link.next!=<span class="keyword">null</span>)</span><br><span class="line">		printTail2Head(link.next);</span><br><span class="line">	System.out.println(link.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Link</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">public</span> Link next;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> data)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data=data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种方法固然好，但是注意，如果链表的长度很长，也许会给<code>stackOverflowException</code>的异常。</p>
</blockquote>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="问题">问题</h2><pre><code>如何将一个链表进行逆序输出，比如<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>的链表输出为<span class="number">4321</span>
</code></pre><h2 id="解题">解题</h2><ol>
<li>最方便可能就是先讲原生链表翻转，再按翻转的输出，这样会破坏原有链表的结构</li>
<li>第二种就是先遍历存放到一个数组或者栈中，然后从后往前输出即可，就需要额外的O(n)空间。</li>
</ol>
<p>这两种方法都是需要额外的复杂度或者空间，网络行流传更好的方法就是使用递归-_-! 神方法啊，递归一次即可。。<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[链表的翻转]]></title>
    <link href="http://yyl8781697.github.io/2015/07/16/Algorithm/LinkedList-Revert/"/>
    <id>http://yyl8781697.github.io/2015/07/16/Algorithm/LinkedList-Revert/</id>
    <published>2015-07-16T15:28:28.000Z</published>
    <updated>2015-07-25T01:25:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>将链表<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>翻转成<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>。
</code></pre><h2 id="解题">解题</h2><p>最简单就是遍历链表，然后保存到一个数组中，然后再向后构建数组，当然，这种方式不好，会有额外开销。-_-<br>这里来介绍一下另一种方法：<br>假设现在的链表是</p>
<pre><code><span class="built_in">null</span><span class="subst">-&gt;</span><span class="number">1</span><span class="subst">-&gt;</span><span class="number">2</span><span class="subst">-&gt;</span><span class="number">3</span><span class="subst">-&gt;</span><span class="number">4</span><span class="subst">-&gt;</span><span class="built_in">null</span>
</code></pre><p>如果我们想办法将2移到1的前面，然后3又移到2的前面，最后将4移动3的前面，这不就完了嘛？<br>好，现在开始移动：</p>
<pre><code>    <span class="number">2</span>
   <span class="subst">/</span> <span class="subst">\</span> 
<span class="built_in">null</span>  <span class="number">1</span><span class="subst">-&gt;</span><span class="number">3</span><span class="subst">-&gt;</span><span class="number">4</span><span class="subst">-&gt;</span><span class="built_in">null</span>
将<span class="number">1</span>指向<span class="number">2</span>的next，然后将<span class="number">2</span>的next指向head的next，然后head的next指向<span class="number">2</span>

    <span class="number">3</span><span class="subst">-</span><span class="number">2</span>
   <span class="subst">/</span>  <span class="subst">|</span>
<span class="built_in">null</span>  <span class="number">1</span><span class="subst">-&gt;</span><span class="number">4</span><span class="subst">-&gt;</span><span class="built_in">null</span>
然后再移动<span class="number">3</span>

    <span class="number">4</span><span class="subst">-</span><span class="number">3</span><span class="subst">-</span><span class="number">2</span>
   <span class="subst">/</span>    <span class="subst">|</span>
<span class="built_in">null</span>    <span class="number">1</span><span class="subst">-&gt;</span><span class="built_in">null</span>
再移动<span class="number">4</span>
</code></pre><blockquote>
<p>这种方式就不需要额外的空间，也只需要遍历一遍即可。</p>
</blockquote>
<a id="more"></a>
<h2 id="代码">代码</h2><p>具体的代码如下，链表节点的数据结构为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">public</span> Node next;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val,Node next)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.val=val;</span><br><span class="line">		<span class="keyword">this</span>.next=next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>则其翻转的函数为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">revert</span><span class="params">(Node head)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Node temp=head.next;</span><br><span class="line">	Node p=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span>(temp.next!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p=temp.next;<span class="comment">//保存1号的下一个节点</span></span><br><span class="line">		temp.next=p.next;<span class="comment">//将1号的下一个节点删除</span></span><br><span class="line">		p.next=head.next;<span class="comment">//将1号的下一个节点指向链表第一点节点（非头部）</span></span><br><span class="line">		head.next=p;<span class="comment">//更新头部的指向</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试的代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	Node node4=<span class="keyword">new</span> Node(<span class="number">4</span>,<span class="keyword">null</span>);</span><br><span class="line">	Node node3=<span class="keyword">new</span> Node(<span class="number">3</span>,node4);</span><br><span class="line">	Node node2=<span class="keyword">new</span> Node(<span class="number">2</span>,node3);</span><br><span class="line">	Node node1=<span class="keyword">new</span> Node(<span class="number">1</span>,node2);</span><br><span class="line">	Node head=<span class="keyword">new</span> Node(-<span class="number">1</span>,node1);</span><br><span class="line">	print(head);</span><br><span class="line">	revert(head);</span><br><span class="line">	print(head);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终的输出为</p>
<pre><code>1,2,3,4,
4,3,2,1,
</code></pre><h2 id="参考">参考</h2><ol>
<li><a href="http://blog.csdn.net/chuyuqing/article/details/44457665" target="_blank" rel="external">http://blog.csdn.net/chuyuqing/article/details/44457665</a></li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>将链表<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>翻转成<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>。
</code></pre><h2 id="解题">解题</h2><p>最简单就是遍历链表，然后保存到一个数组中，然后再向后构建数组，当然，这种方式不好，会有额外开销。-_-<br>这里来介绍一下另一种方法：<br>假设现在的链表是</p>
<pre><code><span class="built_in">null</span><span class="subst">-&gt;</span><span class="number">1</span><span class="subst">-&gt;</span><span class="number">2</span><span class="subst">-&gt;</span><span class="number">3</span><span class="subst">-&gt;</span><span class="number">4</span><span class="subst">-&gt;</span><span class="built_in">null</span>
</code></pre><p>如果我们想办法将2移到1的前面，然后3又移到2的前面，最后将4移动3的前面，这不就完了嘛？<br>好，现在开始移动：</p>
<pre><code>    <span class="number">2</span>
   <span class="subst">/</span> <span class="subst">\</span> 
<span class="built_in">null</span>  <span class="number">1</span><span class="subst">-&gt;</span><span class="number">3</span><span class="subst">-&gt;</span><span class="number">4</span><span class="subst">-&gt;</span><span class="built_in">null</span>
将<span class="number">1</span>指向<span class="number">2</span>的next，然后将<span class="number">2</span>的next指向head的next，然后head的next指向<span class="number">2</span>

    <span class="number">3</span><span class="subst">-</span><span class="number">2</span>
   <span class="subst">/</span>  <span class="subst">|</span>
<span class="built_in">null</span>  <span class="number">1</span><span class="subst">-&gt;</span><span class="number">4</span><span class="subst">-&gt;</span><span class="built_in">null</span>
然后再移动<span class="number">3</span>

    <span class="number">4</span><span class="subst">-</span><span class="number">3</span><span class="subst">-</span><span class="number">2</span>
   <span class="subst">/</span>    <span class="subst">|</span>
<span class="built_in">null</span>    <span class="number">1</span><span class="subst">-&gt;</span><span class="built_in">null</span>
再移动<span class="number">4</span>
</code></pre><blockquote>
<p>这种方式就不需要额外的空间，也只需要遍历一遍即可。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[graphx上的一些简单应用]]></title>
    <link href="http://yyl8781697.github.io/2015/07/07/Spark/Graphs-Applications/"/>
    <id>http://yyl8781697.github.io/2015/07/07/Spark/Graphs-Applications/</id>
    <published>2015-07-07T14:59:23.000Z</published>
    <updated>2015-07-25T01:25:13.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文是温习<a href="http://www.csdn.net/article/2014-08-07/2821097" target="_blank" rel="external">快刀初试：Spark GraphX在淘宝的实践</a>这篇文章中明风大神提到得几个graphx的应用,并且自己使用graphx将其实现一下^_^</p>
</blockquote>
<h2 id="看实验用的图：">看实验用的图：</h2><p><img src="/img/Graphx-Application/sampleG.jpg" alt=""></p>
<p>该图可以使用如下代码来进行标示<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">sc=new</span> <span class="title">SparkContext</span>(</span>);</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">edge=List</span>(</span><span class="comment">//边的信息</span></span><br><span class="line">    (<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">3</span>,<span class="number">5</span>),(<span class="number">3</span>,<span class="number">6</span>),</span><br><span class="line">    (<span class="number">4</span>,<span class="number">5</span>),(<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>),(<span class="number">7</span>,<span class="number">9</span>),(<span class="number">8</span>,<span class="number">9</span>))</span><br><span class="line">   </span><br><span class="line"><span class="comment">//构建边的rdd</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">edgeRdd=sc</span>.<span class="title">parallelize</span>(</span>edge).map(x=&gt;&#123;</span><br><span class="line">  <span class="type">Edge</span>(x._1.toLong,x._2.toLong,<span class="type">None</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建图 顶点Int类型</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">g=Graph</span>.<span class="title">fromEdges</span>(</span>edgeRdd, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="度分布">度分布</h2><blockquote>
<p>可以了解图中“超级节点”的个数和规模，以及所有节点度的分布曲线。</p>
</blockquote>
<p>在<code>graphx</code>中求解度分布分享简单，一个<code>API</code>即可<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.degrees.collect.foreach(println(_))</span><br></pre></td></tr></table></figure></p>
<p>同时将其度的rdd数据收集到Driver中打印出来,第一列表示顶点id，第二列表示各个顶点的度</p>
<pre><code><span class="list">(<span class="keyword">4</span>,<span class="number">2</span>)</span>
<span class="list">(<span class="keyword">6</span>,<span class="number">2</span>)</span>
<span class="list">(<span class="keyword">8</span>,<span class="number">2</span>)</span>
<span class="list">(<span class="keyword">2</span>,<span class="number">2</span>)</span>
<span class="list">(<span class="keyword">1</span>,<span class="number">2</span>)</span>
<span class="list">(<span class="keyword">3</span>,<span class="number">5</span>)</span>
<span class="list">(<span class="keyword">7</span>,<span class="number">2</span>)</span>
<span class="list">(<span class="keyword">9</span>,<span class="number">2</span>)</span>
<span class="list">(<span class="keyword">5</span>,<span class="number">3</span>)</span>
</code></pre><h2 id="二跳邻居">二跳邻居</h2><blockquote>
<p>App中好友的好友的秘密，传播范围更加广，信息更加丰富</p>
</blockquote>
<pre><code>使用两次遍历，首先进行初始化的时候将自己的生命值设为<span class="number">2</span>，第一次遍历向邻居节点传播自身带的ID以及生命值为<span class="number">1</span><span class="comment">(2-1)</span>的消息，第二次遍历的时候收到消息的邻居再转发一次，生命值为<span class="number">0</span>，最终汇总统计的时候 只需要对带有消息为<span class="number">0</span>ID的进行统计即可得到二跳邻居
</code></pre><p>上面的需求使用<code>pregel</code>很方便就能解决，按照最短路径的方法来做，首先是消息的更新、发送和合并方法的定义：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">VMap=Map</span>[</span><span class="type">VertexId</span>,<span class="type">Int</span>]</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 节点数据的更新 就是集合的union</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vprog</span>(</span>vid:<span class="type">VertexId</span>,vdata:<span class="type">VMap</span>,message:<span class="type">VMap</span>)</span><br><span class="line">:<span class="type">Map</span>[<span class="type">VertexId</span>,<span class="type">Int</span>]=addMaps(vdata,message)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 发送消息</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendMsg</span>(</span>e:<span class="type">EdgeTriplet</span>[<span class="type">VMap</span>, _])=&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//取两个集合的差集  然后将生命值减1</span></span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">srcMap=</span>(</span>e.dstAttr.keySet -- e.srcAttr.keySet).map &#123; k =&gt; k-&gt;(e.dstAttr(k)-<span class="number">1</span>) &#125;.toMap</span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">dstMap=</span>(</span>e.srcAttr.keySet -- e.dstAttr.keySet).map &#123; k =&gt; k-&gt;(e.srcAttr(k)-<span class="number">1</span>) &#125;.toMap</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(srcMap.size==<span class="number">0</span> &amp;&amp; dstMap.size==<span class="number">0</span>)</span><br><span class="line">    <span class="type">Iterator</span>.empty</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="type">Iterator</span>((e.dstId,dstMap),(e.srcId,srcMap))</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 消息的合并</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addMaps</span>(</span>spmap1: <span class="type">VMap</span>, spmap2: <span class="type">VMap</span>): <span class="type">VMap</span> =</span><br><span class="line">(spmap1.keySet ++ spmap2.keySet).map &#123;</span><br><span class="line">  k =&gt; k -&gt; math.min(spmap1.getOrElse(k, <span class="type">Int</span>.<span class="type">MaxValue</span>), spmap2.getOrElse(k, <span class="type">Int</span>.<span class="type">MaxValue</span>))</span><br><span class="line">&#125;.toMap</span><br></pre></td></tr></table></figure></p>
<p>接着直接使用<code>pregel</code>的接口即可：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">two=2</span>  <span class="title">//这里是二跳邻居</span> <span class="title">所以只需要定义为2即可</span></span><br><span class="line"></span><span class="function"><span class="keyword">val</span> <span class="title">newG=g</span>.<span class="title">mapVertices</span>(</span>(vid,_)=&gt;<span class="type">Map</span>[<span class="type">VertexId</span>,<span class="type">Int</span>](vid-&gt;two))</span><br><span class="line">            .pregel(<span class="type">Map</span>[<span class="type">VertexId</span>,<span class="type">Int</span>](), two, <span class="type">EdgeDirection</span>.<span class="type">Out</span>)(vprog, sendMsg, addMaps)</span><br></pre></td></tr></table></figure></p>
<p>现在可以看一下二次遍历之后各个顶点的数据：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newG.vertices.collect().foreach(println(_))</span><br></pre></td></tr></table></figure></p>
<pre><code>(<span class="number">4</span>,<span class="built_in">Map</span>(<span class="number">5</span> <span class="subst">-&gt; </span><span class="number">1</span>, <span class="number">1</span> <span class="subst">-&gt; </span><span class="number">0</span>, <span class="number">6</span> <span class="subst">-&gt; </span><span class="number">0</span>, <span class="number">2</span> <span class="subst">-&gt; </span><span class="number">0</span>, <span class="number">3</span> <span class="subst">-&gt; </span><span class="number">1</span>, <span class="number">4</span> <span class="subst">-&gt; </span><span class="number">2</span>))
(<span class="number">6</span>,<span class="built_in">Map</span>(<span class="number">5</span> <span class="subst">-&gt; </span><span class="number">1</span>, <span class="number">1</span> <span class="subst">-&gt; </span><span class="number">0</span>, <span class="number">6</span> <span class="subst">-&gt; </span><span class="number">2</span>, <span class="number">2</span> <span class="subst">-&gt; </span><span class="number">0</span>, <span class="number">3</span> <span class="subst">-&gt; </span><span class="number">1</span>, <span class="number">4</span> <span class="subst">-&gt; </span><span class="number">0</span>))
(<span class="number">8</span>,<span class="built_in">Map</span>(<span class="number">8</span> <span class="subst">-&gt; </span><span class="number">2</span>, <span class="number">7</span> <span class="subst">-&gt; </span><span class="number">1</span>, <span class="number">9</span> <span class="subst">-&gt; </span><span class="number">1</span>))
(<span class="number">2</span>,<span class="built_in">Map</span>(<span class="number">5</span> <span class="subst">-&gt; </span><span class="number">0</span>, <span class="number">1</span> <span class="subst">-&gt; </span><span class="number">1</span>, <span class="number">6</span> <span class="subst">-&gt; </span><span class="number">0</span>, <span class="number">2</span> <span class="subst">-&gt; </span><span class="number">2</span>, <span class="number">3</span> <span class="subst">-&gt; </span><span class="number">1</span>, <span class="number">4</span> <span class="subst">-&gt; </span><span class="number">0</span>))
(<span class="number">1</span>,<span class="built_in">Map</span>(<span class="number">5</span> <span class="subst">-&gt; </span><span class="number">0</span>, <span class="number">1</span> <span class="subst">-&gt; </span><span class="number">2</span>, <span class="number">6</span> <span class="subst">-&gt; </span><span class="number">0</span>, <span class="number">2</span> <span class="subst">-&gt; </span><span class="number">1</span>, <span class="number">3</span> <span class="subst">-&gt; </span><span class="number">1</span>, <span class="number">4</span> <span class="subst">-&gt; </span><span class="number">0</span>))
(<span class="number">3</span>,<span class="built_in">Map</span>(<span class="number">5</span> <span class="subst">-&gt; </span><span class="number">1</span>, <span class="number">1</span> <span class="subst">-&gt; </span><span class="number">1</span>, <span class="number">6</span> <span class="subst">-&gt; </span><span class="number">1</span>, <span class="number">2</span> <span class="subst">-&gt; </span><span class="number">1</span>, <span class="number">3</span> <span class="subst">-&gt; </span><span class="number">2</span>, <span class="number">4</span> <span class="subst">-&gt; </span><span class="number">1</span>))
(<span class="number">7</span>,<span class="built_in">Map</span>(<span class="number">7</span> <span class="subst">-&gt; </span><span class="number">2</span>, <span class="number">8</span> <span class="subst">-&gt; </span><span class="number">1</span>, <span class="number">9</span> <span class="subst">-&gt; </span><span class="number">1</span>))
(<span class="number">9</span>,<span class="built_in">Map</span>(<span class="number">9</span> <span class="subst">-&gt; </span><span class="number">2</span>, <span class="number">7</span> <span class="subst">-&gt; </span><span class="number">1</span>, <span class="number">8</span> <span class="subst">-&gt; </span><span class="number">1</span>))
(<span class="number">5</span>,<span class="built_in">Map</span>(<span class="number">5</span> <span class="subst">-&gt; </span><span class="number">2</span>, <span class="number">1</span> <span class="subst">-&gt; </span><span class="number">0</span>, <span class="number">6</span> <span class="subst">-&gt; </span><span class="number">1</span>, <span class="number">2</span> <span class="subst">-&gt; </span><span class="number">0</span>, <span class="number">3</span> <span class="subst">-&gt; </span><span class="number">1</span>, <span class="number">4</span> <span class="subst">-&gt; </span><span class="number">1</span>))
</code></pre><p><code>Map</code>中的key表示周边的顶点id，其value就是对应顶点id的生命值，所以我们现在对该<code>rdd</code>再做一次<code>mapValues</code>处理即可得到最后的二跳邻居<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//过滤得到二跳邻居 就是value=0 的顶点</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">twoJumpFirends=newG</span>.<span class="title">vertices</span></span><br><span class="line"></span>.mapValues(_.filter(_._2==<span class="number">0</span>).keys)</span><br></pre></td></tr></table></figure></p>
<p>之后将其打印出来<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">twoJumpFirends.collect().foreach(println(_))</span><br></pre></td></tr></table></figure></p>
<pre><code><span class="list">(<span class="keyword">4</span>,Set<span class="list">(<span class="keyword">1</span>, <span class="number">6</span>, <span class="number">2</span>)</span>)</span>
<span class="list">(<span class="keyword">6</span>,Set<span class="list">(<span class="keyword">1</span>, <span class="number">2</span>, <span class="number">4</span>)</span>)</span>
<span class="list">(<span class="keyword">8</span>,Set<span class="list">()</span>)</span>
<span class="list">(<span class="keyword">2</span>,Set<span class="list">(<span class="keyword">5</span>, <span class="number">6</span>, <span class="number">4</span>)</span>)</span>
<span class="list">(<span class="keyword">1</span>,Set<span class="list">(<span class="keyword">5</span>, <span class="number">6</span>, <span class="number">4</span>)</span>)</span>
<span class="list">(<span class="keyword">3</span>,Set<span class="list">()</span>)</span>
<span class="list">(<span class="keyword">7</span>,Set<span class="list">()</span>)</span>
<span class="list">(<span class="keyword">9</span>,Set<span class="list">()</span>)</span>
<span class="list">(<span class="keyword">5</span>,Set<span class="list">(<span class="keyword">1</span>, <span class="number">2</span>)</span>)</span>
</code></pre><h2 id="连通图">连通图</h2><blockquote>
<p>连通图的检测可以弄清一个图有多少个连通部分以及每个连通部分有多少个节点，这样可以在小图上进行更加精细的操作</p>
</blockquote>
<pre><code>使用<span class="keyword">ConnectedComponents</span>和StronglyConnectedComponents接口即可完成计算，其原理就是使用pregel模型，每次都是向邻居节点发送自己的ID，然后合并消息和更新消息方法都是保留最小的ID即可，在任意两条边需要传播的ID一样时迭代停止。
</code></pre><blockquote>
<p>关于连通的Spark实现可以看这个<a href="http://kubicode.me/2015/06/18/Spark/Connect-Component-From-Baidu-Interview-Using-Spark-V2/" target="_blank" rel="external">使用Spark求解大图的连通组件(第二版)</a>，当然在graphx源码中<code>org.apache.spark.graphx.lib.ConnectedComponents</code>就是相关源码的实现。</p>
</blockquote>
<h2 id="多图合并工具">多图合并工具</h2><pre><code>直接使用outerJoinVertices就可以进行很方便的操作
</code></pre><h2 id="能量传播模型">能量传播模型</h2><blockquote>
<p>加权网络是经典的能量传播图模型之一<br></p>
</blockquote>
<pre><code>最简单的使用随机游走模型，每次都是将自己的能量值x传播强度传播给邻居，不断迭代。
</code></pre><p>下面是淘宝的信誉度的检测：<br><br>模型的思路是：物以类聚，人以群分。常和信誉度高的用户进行交易的，信誉度自然较高；常和信誉度差的用户有业务来往的，信誉度自然较低。</p>
<pre><code>首先以用户为点，买卖关系为边生成图，对选出来的用户分别赋予相同的正负能量值（比如信誉高的种子的<span class="variable">trustRank=</span><span class="number">1</span>，信誉度低的种子<span class="variable">badRank=</span><span class="number">1</span>），然后进行两轮随机游走，一轮是高信誉用户传播trustRank，另一轮是低信誉用户传播badRank，两轮结束之后对每个用户进行<span class="variable">finalRank=</span>trustRank-badRank的计算，finalRank高的即为信誉较好的用户。

下面是淘宝的改进：
但是这种方法得到的AUC很低（之前初始的传播强度为<span class="number">0.85</span>），需要给每条边加上一个组合权重（比如由交易次数，计算金额等多个特征计算出来的一个权重），通过使用partialDerivativeAUC方法，在训练集上计算AUC，然后对AUC求偏导，得到每个关系维度的独立权重和偏移量（这里不知道怎么得到的-_-），生成新的权重调节器（WeightAdjustor），然后对图上所有的边进行权重更新，再进行一次大的迭代，直到AUC趋于稳定，终止计算。
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文是温习<a href="http://www.csdn.net/article/2014-08-07/2821097">快刀初试：Spark GraphX在淘宝的实践</a>这篇文章中明风大神提到得几个graphx的应用,并且自己使用graphx将其实现一下^_^</p>
</blockquote>
<h2 id="看实验用的图：">看实验用的图：</h2><p><img src="/img/Graphx-Application/sampleG.jpg" alt=""></p>
<p>该图可以使用如下代码来进行标示<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">sc=new</span> <span class="title">SparkContext</span>(</span>);</span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">edge=List</span>(</span><span class="comment">//边的信息</span></span><br><span class="line">    (<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">3</span>,<span class="number">5</span>),(<span class="number">3</span>,<span class="number">6</span>),</span><br><span class="line">    (<span class="number">4</span>,<span class="number">5</span>),(<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>),(<span class="number">7</span>,<span class="number">9</span>),(<span class="number">8</span>,<span class="number">9</span>))</span><br><span class="line">   </span><br><span class="line"><span class="comment">//构建边的rdd</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">edgeRdd=sc</span>.<span class="title">parallelize</span>(</span>edge).map(x=&gt;&#123;</span><br><span class="line">  <span class="type">Edge</span>(x._1.toLong,x._2.toLong,<span class="type">None</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建图 顶点Int类型</span></span><br><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">g=Graph</span>.<span class="title">fromEdges</span>(</span>edgeRdd, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Spark" scheme="http://yyl8781697.github.io/tags/Spark/"/>
    
      <category term="Spark" scheme="http://yyl8781697.github.io/categories/Spark/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[假设你有一个用 1001 个整数组成的数组,这些整数是任意排列的]]></title>
    <link href="http://yyl8781697.github.io/2015/07/05/Algorithm/1-2-n/"/>
    <id>http://yyl8781697.github.io/2015/07/05/Algorithm/1-2-n/</id>
    <published>2015-07-05T15:41:26.000Z</published>
    <updated>2015-07-25T01:25:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>假设你有一个用 <span class="number">1001</span> 个整数组成的数组,这些整数是任意排列的,但是你知道所有的整 数都在 <span class="number">1</span> 到 <span class="number">1000</span><span class="comment">(包括 1000)</span>之间。此外,除一个数字出现两次外,其他所有数字只出现一 次。假设你只能对这个数组做一次处理,用一种算法找出重复的那个数字。如果你在运算中 使用了辅助的存储方式,那么你能找到不用这种方式的算法吗?
</code></pre><h2 id="方法1">方法1</h2><p>这里都说1~1000都至少包含一遍了，所以求和在减去1~1000的和即可<br>假设遍历数组之后的求和为sum，则那个数字就是sum-(1000*10001/2)</p>
<blockquote>
<p>但是如果这里不是1000，而是这个数字非常的大，求和就可能出现溢出</p>
</blockquote>
<h2 id="方法2">方法2</h2><p>还记得有一道经典的<a href="https://leetcode.com/problems/single-number/" target="_blank" rel="external">leetcode题目</a>就是一个数组中每个数出现2次，只有一个数字出现了3次，找出这个数字。<br>该题目的思路是A^A=0,A^0=A</p>
<a id="more"></a>
<p>按这个思路，因为我们知道1~1000已经出现一遍了，那么在遍历的时候自变量i也会从1~1000出现一遍，所以可以利用i来构造每个数字出现两次的情况，所以解题思路就是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchTwiceNum</span><span class="params">(<span class="keyword">int</span> a[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k=a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		k^=a[i]^i;<span class="comment">//通过i来构造</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样操作就不会出现溢出的情况了</p>
<h2 id="参考">参考</h2><ul>
<li>July微软面试题第8题</li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>假设你有一个用 <span class="number">1001</span> 个整数组成的数组,这些整数是任意排列的,但是你知道所有的整 数都在 <span class="number">1</span> 到 <span class="number">1000</span><span class="comment">(包括 1000)</span>之间。此外,除一个数字出现两次外,其他所有数字只出现一 次。假设你只能对这个数组做一次处理,用一种算法找出重复的那个数字。如果你在运算中 使用了辅助的存储方式,那么你能找到不用这种方式的算法吗?
</code></pre><h2 id="方法1">方法1</h2><p>这里都说1~1000都至少包含一遍了，所以求和在减去1~1000的和即可<br>假设遍历数组之后的求和为sum，则那个数字就是sum-(1000*10001/2)</p>
<blockquote>
<p>但是如果这里不是1000，而是这个数字非常的大，求和就可能出现溢出</p>
</blockquote>
<h2 id="方法2">方法2</h2><p>还记得有一道经典的<a href="https://leetcode.com/problems/single-number/">leetcode题目</a>就是一个数组中每个数出现2次，只有一个数字出现了3次，找出这个数字。<br>该题目的思路是A^A=0,A^0=A</p>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[单向列表是否有环，两个链表是否相交，以及交点]]></title>
    <link href="http://yyl8781697.github.io/2015/07/03/Algorithm/Single-Linked-Cycle-Y/"/>
    <id>http://yyl8781697.github.io/2015/07/03/Algorithm/Single-Linked-Cycle-Y/</id>
    <published>2015-07-02T16:49:20.000Z</published>
    <updated>2015-07-25T01:25:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="单向链表的结构">单向链表的结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">public</span> Link next;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> data)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data=data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//为了打印方便而加上去的。。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> String.format(<span class="string">"data:%s"</span>,<span class="keyword">this</span>.data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单向链表是否有环">单向链表是否有环</h2><p>这题的思路很简单，先创建两个指针都指向链表的头部，一个fast指针每次走两步，另一个slow指针每次都走一步，如果fast指针能走到null的地方就说明该单链表没有环，否则fast和slow节点一定会走到同一个节点，表示有环</p>
<a id="more"></a>
<p>具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 判断是否有环</span><br><span class="line"> *<span class="javadoctag"> @param</span> head</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCycle</span><span class="params">(Link head)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(head!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Link fast=head,slow=head;</span><br><span class="line">		<span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)<span class="comment">//如果走到尾的肯定是fast先 所以这里只需要判断fast即可</span></span><br><span class="line">		&#123;</span><br><span class="line">			slow=slow.next;</span><br><span class="line">			fast=fast.next.next;</span><br><span class="line">			<span class="keyword">if</span>(fast==slow)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//两个指针指向了同一个节点 表示有环</span></span><br><span class="line">				flag=<span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="判断两个单向链表是否相交">判断两个单向链表是否相交</h2><p>这里可以想一下，单向链表的相交是什么情况？<br>那肯定是一个Y字形的，因为两个链表都是单向的嘛^_^，所以有两种解法</p>
<ol>
<li>利用上面的环，先遍历其中一个链表，另其首尾相连，（其实如果相交就会构成一个含有环的单链表），此时再从另一个链表的头部出发找是否有环就可以了</li>
<li>将两个链表都遍历到尾结果，如果这两个尾节点是同一个节点，说明就是相交</li>
</ol>
<blockquote>
<p>其实还可以使用hash的方法，也就是遍历两个链表进行hash，同一个节点的hash值肯定是一样的，然后就是两个集合的包含元素查找即可</p>
</blockquote>
<h2 id="判断两个相交的链表的交点1">判断两个相交的链表的交点1</h2><p>其实这里根据上一问可知，如果有交点，那个交点就是环的入口点，所以先根据环的方法找入口点，然后将fast指针指向链表的头部，但是这个fast节点之后都是走一步，和slow同时走，它们相等的地方就是环的交点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 两个链表是否相交  就是Y形状</span><br><span class="line"> *<span class="javadoctag"> @param</span> head</span><br><span class="line"> *<span class="javadoctag"> @return</span> //如果相交 返回交点</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Link <span class="title">isY</span><span class="params">(Link head1,Link head2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Link y=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span>(head1!=<span class="keyword">null</span> &amp;&amp; head2!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Link h=head1;</span><br><span class="line">		<span class="keyword">while</span>(h.next!=<span class="keyword">null</span>)</span><br><span class="line">			h=h.next;</span><br><span class="line">		h.next=head1;<span class="comment">//将链表1的收尾相连</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(head2!=<span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Link fast=head2,slow=head2;</span><br><span class="line">			<span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				slow=slow.next;</span><br><span class="line">				fast=fast.next.next;</span><br><span class="line">				<span class="keyword">if</span>(fast==slow)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//两个指针指向了同一个节点 表示有环</span></span><br><span class="line">					flag=<span class="keyword">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(flag)</span><br><span class="line">			&#123;</span><br><span class="line">				fast=head2;<span class="comment">//回到起点</span></span><br><span class="line">				<span class="keyword">while</span>(slow!=fast)</span><br><span class="line">				&#123;</span><br><span class="line">					slow=slow.next;</span><br><span class="line">					fast=fast.next;</span><br><span class="line">				&#125;</span><br><span class="line">				y=fast;<span class="comment">//得到交点</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		h.next=<span class="keyword">null</span>;<span class="comment">//将第一个链表该为单链表</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ps.如果需要看交点具体的推导看<a href="http://www.cnblogs.com/BeyondAnyTime/archive/2012/07/06/2580026.html" target="_blank" rel="external">http://www.cnblogs.com/BeyondAnyTime/archive/2012/07/06/2580026.html</a></p>
</blockquote>
<h2 id="判断两个相交的链表的交点2">判断两个相交的链表的交点2</h2><p>求出两个单链表的尾节点，在这个过程中可以很容易得到两个链表的长度，len1,len2，然后先让长的链表走abs(len1-len2)，然后让两个链表齐头并进就可以找到交点，复杂度是O(n+m)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 两个链表是否相交  就是Y形状</span><br><span class="line"> * 首先首先将两个环各自走到尾部，记录tail1和len1，以及tail2和len2</span><br><span class="line"> * 如果tail1=tail2  则相交</span><br><span class="line"> * 然后先让长的链表走abs(len1-len2)，然后让两个链表齐头并进就可以找到交点，复杂度是O(n+m)</span><br><span class="line"> *<span class="javadoctag"> @param</span> head1</span><br><span class="line"> *<span class="javadoctag"> @param</span> head2</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Link <span class="title">isY2</span><span class="params">(Link head1,Link head2)</span></span>&#123;</span><br><span class="line">	Link y=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span>(head1!=<span class="keyword">null</span> &amp;&amp; head2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		Link tail1=head1,tail2=head2;</span><br><span class="line">		<span class="keyword">int</span> len1=<span class="number">1</span>,len2=<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//记录两个链表的尾部节点 以及他们的长度</span></span><br><span class="line">		<span class="keyword">while</span>(tail1.next!=<span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			len1++;</span><br><span class="line">			tail1=tail1.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(tail2.next!=<span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			len2++;</span><br><span class="line">			tail2=tail2.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//两个尾部相等就表示相交</span></span><br><span class="line">		<span class="keyword">if</span>(tail1==tail2)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//区分长链表和端链表</span></span><br><span class="line">			Link longLink=head1,shortLink=head2;</span><br><span class="line">			<span class="keyword">if</span>(len1&lt;len2)</span><br><span class="line">			&#123;</span><br><span class="line">				longLink=head2;</span><br><span class="line">				shortLink=head1;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//将长链表先走abs(len1-len2)步</span></span><br><span class="line">			<span class="keyword">int</span> diff=Math.abs(len1-len2);</span><br><span class="line">			<span class="keyword">while</span>(diff&gt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				longLink=longLink.next;</span><br><span class="line">				diff--;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span>(longLink!=shortLink)</span><br><span class="line">			&#123;</span><br><span class="line">				longLink=longLink.next;</span><br><span class="line">				shortLink=shortLink.next;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			y=longLink;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="演示结果代码">演示结果代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Link head1=<span class="keyword">new</span> Link(<span class="number">1</span>);</span><br><span class="line">	Link link1=<span class="keyword">new</span> Link(<span class="number">2</span>);</span><br><span class="line">	head1.next=link1;</span><br><span class="line">	Link link2=<span class="keyword">new</span> Link(<span class="number">3</span>);</span><br><span class="line">	link1.next=link2;</span><br><span class="line">	Link link3=<span class="keyword">new</span> Link(<span class="number">4</span>);</span><br><span class="line">	link2.next=link3;</span><br><span class="line">	Link link4=<span class="keyword">new</span> Link(<span class="number">5</span>);</span><br><span class="line">	link3.next=link4;</span><br><span class="line">	Link link5=<span class="keyword">new</span> Link(<span class="number">6</span>);</span><br><span class="line">	link4.next=link5;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	System.out.println(isCycle(head1));</span><br><span class="line">	link5.next=link2;<span class="comment">//使链表相交</span></span><br><span class="line">	System.out.println(isCycle(head1));</span><br><span class="line">	link5.next=<span class="keyword">null</span>;<span class="comment">//重置为单链表</span></span><br><span class="line">	</span><br><span class="line">	Link head2=<span class="keyword">new</span> Link(<span class="number">7</span>);</span><br><span class="line">	Link link6=<span class="keyword">new</span> Link(<span class="number">8</span>);</span><br><span class="line">	head2.next=link6;</span><br><span class="line">	Link link7=<span class="keyword">new</span> Link(<span class="number">9</span>);</span><br><span class="line">	link6.next=link7;<span class="comment">//新建一个单列表</span></span><br><span class="line">	</span><br><span class="line">	System.out.println(isY(head1,head2));</span><br><span class="line">	link7.next=link2;<span class="comment">//将第二的单链表的某个元素指向第一个链表</span></span><br><span class="line">	System.out.println(isY(head1,head2));</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体结果</p>
<pre><code><span class="literal">false</span>
<span class="literal">true</span>
<span class="literal">null</span>
<span class="string">data:</span><span class="number">3</span>
</code></pre><hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="单向链表的结构">单向链表的结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">public</span> Link next;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> data)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data=data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//为了打印方便而加上去的。。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> String.format(<span class="string">"data:%s"</span>,<span class="keyword">this</span>.data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单向链表是否有环">单向链表是否有环</h2><p>这题的思路很简单，先创建两个指针都指向链表的头部，一个fast指针每次走两步，另一个slow指针每次都走一步，如果fast指针能走到null的地方就说明该单链表没有环，否则fast和slow节点一定会走到同一个节点，表示有环</p>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[定义栈的数据结构，要求添加一个min函数，能够得到栈的最小元素]]></title>
    <link href="http://yyl8781697.github.io/2015/07/02/Algorithm/MinStack/"/>
    <id>http://yyl8781697.github.io/2015/07/02/Algorithm/MinStack/</id>
    <published>2015-07-02T15:11:04.000Z</published>
    <updated>2015-07-25T01:26:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>定义栈的数据结构，要求添加一个min函数，能够得到栈的最小元素。要求函数min、push以及pop的时间复杂度都是<span class="function"><span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span>。
</code></pre><h2 id="解题">解题</h2><p>这道题目的主要难点就是需要的复杂度为O(1)，也就是说在求最小值的时候无法遍历该栈。<br>正确地解法就是使用一个辅助栈（数组），为维持当前栈容量下地最小值情况</p>
<p>比如</p>
<pre><code>栈数据
3,5,2,4,1
辅助数据
0,0,2,2,4
</code></pre><p>将5压入栈的时候，发现上一个栈顶元素下的最小值是3，故这里无法更新最小值，仍旧将当前的最小值置为3（索引位置为0），但是当2压入栈的时候<br>，可以发展2&lt;3，所以在该类情况下会将当前栈的最小值更新为2（即索引为2）<br>这种设计在出栈的时候只需要将栈数据的栈顶出掉即可，同样在求最小值的时候只要返回当前辅助数据中索引值在栈数据中的值即可<br>这样就非常方便地实现了O（1）的要求，同时因为辅助栈是存储索引位置，索引并不会占用很大的内容空间</p>
<a id="more"></a>
<h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//存储栈的元素</span></span><br><span class="line">	<span class="keyword">private</span> Object[] elementData;</span><br><span class="line">	<span class="comment">//存储当前栈尺寸下最小元素的位置</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] minPos;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//栈的实际大小</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//栈的总容量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> capacity=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//栈的默认容量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELAULT_CAPACITY=<span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(DELAULT_CAPACITY);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">(<span class="keyword">int</span> capacity)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.elementData=<span class="keyword">new</span> Object[capacity];</span><br><span class="line">		<span class="keyword">this</span>.minPos=<span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 将数据压入栈</span><br><span class="line">	 *<span class="javadoctag"> @param</span> e</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		ensureCapacity(size+<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		elementData[size]=e;</span><br><span class="line">		<span class="comment">//这里来维护最小元素位置的数组</span></span><br><span class="line">		<span class="keyword">if</span>(size==<span class="number">0</span> || e.compareTo((E)elementData[minPos[size-<span class="number">1</span>]])&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//更新栈的最小元素</span></span><br><span class="line">			minPos[size]=size;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			minPos[size]=size-<span class="number">1</span>;<span class="comment">//保持原来的为最小</span></span><br><span class="line">		&#125;</span><br><span class="line">		size++;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 出栈  直接出</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 *<span class="javadoctag"> @throws</span> EmptyStackException</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> EmptyStackException</span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(size&lt;=<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">		</span><br><span class="line">		size--;</span><br><span class="line">		<span class="keyword">return</span> (E)elementData[size];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 取最小值  直接在辅助的数组上取值即可</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 *<span class="javadoctag"> @throws</span> EmptyStackException</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">min</span><span class="params">()</span> <span class="keyword">throws</span> EmptyStackException</span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(size&lt;=<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> (E)elementData[minPos[size-<span class="number">1</span>]];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 确保容量足够</span><br><span class="line">	 *<span class="javadoctag"> @param</span> minCapacity</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(minCapacity&gt;capacity)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//需要扩容</span></span><br><span class="line">			<span class="keyword">int</span> newCapacity = minCapacity + (minCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">			elementData=Arrays.copyOf(elementData, newCapacity);<span class="comment">//拷贝数组</span></span><br><span class="line">			minPos=Arrays.copyOf(minPos, newCapacity);</span><br><span class="line">			capacity=newCapacity;<span class="comment">//更新容量</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStack</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"\r\n栈数据"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">			System.out.print(<span class="keyword">this</span>.elementData[i]+<span class="string">","</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"\r\n辅助数据"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">			System.out.print(<span class="keyword">this</span>.minPos[i]+<span class="string">","</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现这个栈的代码如上，使用main函数的测试如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	MinStack&lt;Integer&gt; minStack=<span class="keyword">new</span> MinStack&lt;Integer&gt;();</span><br><span class="line">	minStack.push(<span class="number">3</span>);</span><br><span class="line">	minStack.push(<span class="number">5</span>);</span><br><span class="line">	minStack.push(<span class="number">2</span>);</span><br><span class="line">	minStack.push(<span class="number">4</span>);</span><br><span class="line">	minStack.push(<span class="number">1</span>);</span><br><span class="line">	minStack.printStack();</span><br><span class="line">	System.out.println(<span class="string">"最小值:"</span>+minStack.min());</span><br><span class="line">	minStack.pop();</span><br><span class="line">	minStack.printStack();</span><br><span class="line">	System.out.println(<span class="string">"最小值:"</span>+minStack.min());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终就可以打印出:</p>
<pre><code>栈数据
3,5,2,4,1,
辅助数据
0,0,2,2,4,
最小值<span class="pseudo">:1</span>

栈数据
3,5,2,4,
辅助数据
0,0,2,2,
最小值<span class="pseudo">:2</span>
</code></pre><h2 id="参考">参考</h2><ul>
<li><a href="http://zhedahht.blog.163.com/blog/static/25411174200712895228171/" target="_blank" rel="external">http://zhedahht.blog.163.com/blog/static/25411174200712895228171/</a></li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>定义栈的数据结构，要求添加一个min函数，能够得到栈的最小元素。要求函数min、push以及pop的时间复杂度都是<span class="function"><span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span>。
</code></pre><h2 id="解题">解题</h2><p>这道题目的主要难点就是需要的复杂度为O(1)，也就是说在求最小值的时候无法遍历该栈。<br>正确地解法就是使用一个辅助栈（数组），为维持当前栈容量下地最小值情况</p>
<p>比如</p>
<pre><code>栈数据
3,5,2,4,1
辅助数据
0,0,2,2,4
</code></pre><p>将5压入栈的时候，发现上一个栈顶元素下的最小值是3，故这里无法更新最小值，仍旧将当前的最小值置为3（索引位置为0），但是当2压入栈的时候<br>，可以发展2&lt;3，所以在该类情况下会将当前栈的最小值更新为2（即索引为2）<br>这种设计在出栈的时候只需要将栈数据的栈顶出掉即可，同样在求最小值的时候只要返回当前辅助数据中索引值在栈数据中的值即可<br>这样就非常方便地实现了O（1）的要求，同时因为辅助栈是存储索引位置，索引并不会占用很大的内容空间</p>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉排序树转为双向链表]]></title>
    <link href="http://yyl8781697.github.io/2015/07/01/Algorithm/Binary-Search-Tree-2-Double-LinkedList/"/>
    <id>http://yyl8781697.github.io/2015/07/01/Algorithm/Binary-Search-Tree-2-Double-LinkedList/</id>
    <published>2015-06-30T23:36:00.000Z</published>
    <updated>2015-07-25T01:26:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>输入一棵排序二叉树，将此树转换成一个排序的双向链表，要求不能创建任何新的借点，只能调整指针的指向.
</code></pre><h2 id="分析">分析</h2><blockquote>
<p>二叉排序树的中序遍历可以得到它的排序元素，但是，但是“它不能创建任何新的节点，只能调整指针的指向”，所以，直接中序法就不可行了。</p>
</blockquote>
<p>大致思路是如下的：</p>
<ul>
<li>如果当前根节点的左子树不为空，则<ol>
<li>递归左子树</li>
<li>查找左子树最大的元素</li>
<li>将该元素的<code>right</code>指针指向根节点，将根节点的<code>left</code>指针指向该元素</li>
</ol>
</li>
<li>如果当前根节点的右子树不为空，则<ol>
<li>递归右子树</li>
<li>查找右子树最小的元素</li>
<li>将该元素的<code>left</code>指针指向根节点，将根节点的<code>right</code>指针指向该元素</li>
</ol>
</li>
</ul>
<a id="more"></a>
<blockquote>
<p>注：<code>tree</code>的<code>left</code>和<code>right</code>结构正好对应<code>list</code>的<code>pre</code>和<code>next</code>结构</p>
</blockquote>
<pre><code>      <span class="number">8</span>    
    /   <span class="string">\</span>
   <span class="number">3</span>     <span class="number">10</span>
 /   <span class="string">\</span>     <span class="string">\</span>
<span class="number">1</span>     <span class="number">6</span>     <span class="number">14</span>
    /  <span class="string">\</span>   /
   <span class="number">4</span>    <span class="number">7</span> <span class="number">13</span> 

它依次调整的点为：<span class="number">1</span>(l),<span class="number">4</span>(l),<span class="number">7</span>(r),<span class="number">4</span>(r),<span class="number">7</span>(l),<span class="number">13</span>(l),<span class="number">13</span>(r),<span class="number">10</span>(r)
      <span class="number">8</span>    
    /   <span class="string">\</span>
 <span class="number">1</span>-<span class="number">3</span>     <span class="number">10</span>
    <span class="string">\</span>     <span class="string">\</span>
    <span class="number">6</span>     <span class="number">14</span>
    /  <span class="string">\</span>   /
   <span class="number">4</span>    <span class="number">7</span> <span class="number">13</span> 
   <span class="number">1</span>为<span class="number">3</span>左子树的最大点，所以的右指针指向<span class="number">3</span>，<span class="number">3</span>的左指针指向<span class="number">1</span>


       <span class="number">8</span>    
    /   <span class="string">\</span>
 <span class="number">1</span>-<span class="number">3</span>     <span class="number">10</span>
    <span class="string">\</span>     <span class="string">\</span>
   <span class="number">4</span>-<span class="number">6</span>     <span class="number">14</span>
      <span class="string">\</span>   /
       <span class="number">7</span> <span class="number">13</span> 

 <span class="number">4</span>为<span class="number">6</span>的左子树的最大值，所以<span class="number">4</span>的右指针指向<span class="number">6</span>，<span class="number">6</span>左指针<span class="number">4</span>

      <span class="number">8</span>    
    /   <span class="string">\</span>
 <span class="number">1</span>-<span class="number">3</span>     <span class="number">10</span>
    <span class="string">\</span>     <span class="string">\</span>
   <span class="number">4</span>-<span class="number">6</span>-<span class="number">7</span>   <span class="number">14</span>
          /
         <span class="number">13</span>

 <span class="number">7</span>为<span class="number">6</span>的右子树的最小值，所以<span class="number">7</span>的左指针指向<span class="number">6</span>，<span class="number">6</span>右指针<span class="number">4</span>

     <span class="number">8</span>    
    /   <span class="string">\</span>
 <span class="number">1</span>-<span class="number">3</span>     <span class="number">10</span>
    <span class="string">\</span>     <span class="string">\</span>
     <span class="number">4</span>-<span class="number">6</span>-<span class="number">7</span> <span class="number">14</span>
          /
         <span class="number">13</span>

 <span class="number">4</span>为<span class="number">3</span>的右子树的最小值，所以<span class="number">4</span>的左指针指向<span class="number">3</span>，<span class="number">3</span>右指针<span class="number">4</span>

 <span class="number">1</span>-<span class="number">3</span>-<span class="number">4</span>-<span class="number">6</span>-<span class="number">7</span>-<span class="number">8</span>    
           <span class="string">\</span>
            <span class="number">10</span>
             <span class="string">\</span>
             <span class="number">14</span>
             /
            <span class="number">13</span>

<span class="number">7</span>为<span class="number">8</span>左子树的最小值，所以<span class="number">7</span>的右指针指向<span class="number">8</span>，<span class="number">8</span>的左指针指向<span class="number">7</span>
这样就完成了根节点左边的转换，右边的转换思路一致
</code></pre><h2 id="代码实现">代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 查找左子树中最大的节点</span><br><span class="line"> *<span class="javadoctag"> @param</span> T</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title">findMaxNodeInLeft</span><span class="params">(TreeNode T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	TreeNode t=T.left;</span><br><span class="line">	<span class="keyword">if</span>(t!=<span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">while</span>(t.right!=<span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			t=t.right;<span class="comment">//因为肯定右子树更加大</span></span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 查找右子树种的最小节点</span><br><span class="line"> *<span class="javadoctag"> @param</span> T</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title">findMinNodeInRight</span><span class="params">(TreeNode T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	TreeNode t=T.right;</span><br><span class="line">	<span class="keyword">if</span>(t!=<span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">while</span>(t.left!=<span class="keyword">null</span>)</span><br><span class="line">			t=t.left;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 二叉排序树转双向链表</span><br><span class="line"> *<span class="javadoctag"> @param</span> T</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">convertNode</span><span class="params">(TreeNode T)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T.left!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		convertNode(T.left);</span><br><span class="line">		TreeNode t=findMaxNodeInLeft(T);<span class="comment">//左子树中最大的点  它一定是在叶子上面</span></span><br><span class="line">		t.right=T;<span class="comment">//将左子树最小的点连在根节点的左侧</span></span><br><span class="line">		T.left=t;</span><br><span class="line">		t.parent=<span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T.right!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		convertNode(T.right);</span><br><span class="line">		TreeNode t=findMinNodeInRight(T);</span><br><span class="line">		t.left=T;<span class="comment">//将右子树最小的点连点根节点的右侧</span></span><br><span class="line">		T.right=t;</span><br><span class="line">		t.parent=<span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具体实验代码">具体实验代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	TreeNode root=<span class="keyword">new</span> TreeNode();</span><br><span class="line">	root.parent=<span class="keyword">new</span> TreeNode(Integer.MAX_VALUE);<span class="comment">//凭空设置一个超级根节点  </span></span><br><span class="line">	root.parent.right=root;<span class="comment">//超级根节点接管根节点</span></span><br><span class="line">	insert(root,<span class="number">8</span>);</span><br><span class="line">	insert(root,<span class="number">3</span>);</span><br><span class="line">	insert(root,<span class="number">10</span>);</span><br><span class="line">	insert(root,<span class="number">1</span>);</span><br><span class="line">	insert(root,<span class="number">6</span>);</span><br><span class="line">	insert(root,<span class="number">14</span>);</span><br><span class="line">	insert(root,<span class="number">4</span>);</span><br><span class="line">	insert(root,<span class="number">7</span>);</span><br><span class="line">	insert(root,<span class="number">13</span>);<span class="comment">//上面的insert是构建排序二叉树</span></span><br><span class="line">	System.out.println(root);</span><br><span class="line">	convertNode(root);</span><br><span class="line">	System.out.println(root);</span><br><span class="line">	</span><br><span class="line">	TreeNode head=root;</span><br><span class="line">	<span class="keyword">while</span>(head.left!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		head=head.left;<span class="comment">//查找头结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将双向链表打印出来</span></span><br><span class="line">	<span class="keyword">while</span>(head.right!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(head.data);</span><br><span class="line">		head=head.right;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于二叉排序树具体介绍看我之前的<a href="http://kubicode.me/2015/06/29/Data%20Struct/Binary-Search-Tree/" target="_blank" rel="external">二叉排序树</a></p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>输入一棵排序二叉树，将此树转换成一个排序的双向链表，要求不能创建任何新的借点，只能调整指针的指向.
</code></pre><h2 id="分析">分析</h2><blockquote>
<p>二叉排序树的中序遍历可以得到它的排序元素，但是，但是“它不能创建任何新的节点，只能调整指针的指向”，所以，直接中序法就不可行了。</p>
</blockquote>
<p>大致思路是如下的：</p>
<ul>
<li>如果当前根节点的左子树不为空，则<ol>
<li>递归左子树</li>
<li>查找左子树最大的元素</li>
<li>将该元素的<code>right</code>指针指向根节点，将根节点的<code>left</code>指针指向该元素</li>
</ol>
</li>
<li>如果当前根节点的右子树不为空，则<ol>
<li>递归右子树</li>
<li>查找右子树最小的元素</li>
<li>将该元素的<code>left</code>指针指向根节点，将根节点的<code>right</code>指针指向该元素</li>
</ol>
</li>
</ul>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
</feed>