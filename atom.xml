<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Kubi Code'Blog]]></title>
  <subtitle><![CDATA[The palest ink is better than the best memory.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://kubicode.me/"/>
  <updated>2016-04-16T12:05:53.000Z</updated>
  <id>http://kubicode.me/</id>
  
  <author>
    <name><![CDATA[Kubi Code]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[聊聊机器学习中的损失函数]]></title>
    <link href="http://kubicode.me/2016/04/11/Machine%20Learning/Say-About-Loss-Function/"/>
    <id>http://kubicode.me/2016/04/11/Machine Learning/Say-About-Loss-Function/</id>
    <published>2016-04-11T13:06:23.000Z</published>
    <updated>2016-04-16T12:05:53.000Z</updated>
    <content type="html"><![CDATA[<p>机器学习算法一般都是对损失函数(<code>Loss Function</code>)求最优，大部分损失函数都是包含两项：<code>损失误差项(loss term)</code>以及<code>正则项(regularization term)</code>:<br>$$J(w)=\sum_iL(m_i(w))+\lambda R(w)$$</p>
<h2 id="损失误差项">损失误差项</h2><p>常用的损失误差项有5种:</p>
<ol>
<li><code>Gold Standard</code></li>
<li><code>Hinge</code>:Svm</li>
<li><code>log</code>:logistic regression(cross entropy error)</li>
<li><code>squared</code>:linear regression</li>
<li><code>Exponential</code>:Boosting</li>
</ol>
<a id="more"></a>
<h3 id="Gold_Standard_Loss">Gold Standard Loss</h3><p><code>Gold Standard</code>又称<code>0-1</code>误差，其结果又称为<code>犯错</code>与<code>不犯错</code>,用途比较广(比如<a href="http://kubicode.me/2015/08/06/Machine%20Learning/Perceptron-Learning-Algorithm/" target="_blank" rel="external">PLA</a>模型)，其损失函数也是相当的简单:<br>$$ y=\left\{<br>\begin{aligned}<br>0 &amp; \quad if \quad m \geq 0 \\<br>1 &amp; \quad if \quad m \le 0\\<br>\end{aligned}<br>\right.$$</p>
<h3 id="Hinge_Loss">Hinge Loss</h3><p><code>Hinge</code>的叫法来源于其损失函数的图形，为一个折线，通用函数方式为:<br>$$L(m_i) = max(0,1-m_i(w))$$</p>
<p><code>Hinge</code>可以解 间距最大化 问题，带有代表性的就是<code>svm</code>,最初的<code>svm</code>优化函数如下:<br>$$\underset{w,\zeta}{argmin} \frac{1}{2}||w||^2+ C\sum_i \zeta_i \\<br>st.\quad \forall y_iw^Tx_i \geq 1- \zeta_i \\<br>\zeta_i \geq 0 $$</p>
<p>将约束项进行变形则为:<br>$$\zeta_i \geq 1-y_iw^Tx_i$$<br>则可以将损失函数进一步写为:<br>$$\begin{equation}\begin{split}J(w)&amp;=\frac{1}{2}||w||^2 + C\sum_i max(0,1-y_iw^Tx_i) \\<br>&amp;= \frac{1}{2}||w||^2 + C\sum_i max(0,1-m_i(w)) \\<br>&amp;= \frac{1}{2}||w||^2 + C\sum_i L_{Linge}(m_i)<br>\end{split}\end{equation}$$</p>
<p>因此<code>svm</code>的损失函数可以看成<code>L2-Norm</code>和<code>Hinge</code>损失误差之和.</p>
<h3 id="Log_Loss">Log Loss</h3><p><code>log</code>类型损失函数的优势可以将连乘转为求和，由于是单调函数，不会改变原结果，并且还很方面求最优，因此<code>log</code>类型的损失函数函数也非常常用，比较著名的一种就是交叉熵(<code>cross entropy</code>)，也就是<code>logistic regression</code>用的损失函数:<br>$$J(w)=\lambda||w||^2+\sum_i y_i log g_w(x_i)+(1-y_i)(log 1-g_w(x_i),y_i \in\{0,1\}$$<br>其中:<br>$$g_w(x_i)=\frac{1}{1+e^{-f_w(x_i)}} \\<br>f_w(x_i) = w^Tx_i<br>$$</p>
<h3 id="Squared_Loss">Squared Loss</h3><p>平方误差，线性回归中最常用:<br>$$L_2(m)=(f_w(x)-y)^2=(m-1)^2$$</p>
<h3 id="Exponential_Loss">Exponential Loss</h3><p>指数误差，在<code>boosting</code>算法中比较常见:<br>$$J(w)=\lambda R(w)+\sum_i exp(-y_if_w(x_i)) \\<br>L_{exp}(m_i) = exp(-m_i(w))<br>$$</p>
<h3 id="误差项对比">误差项对比</h3><p>上面5种误差项的函数为:</p>
<center><img src="/img/Say-About-Loss-Function/error_function.png" width="400px"></center><br>&gt;黑色为<code>Squared Loss</code>,<span style="color:red">红色</span>为<code>Hinge Loss</code>,<span style="color:yellow">黄色</span>为:<code>Log Loss</code>,<span style="color:green">绿色</span>为:<code>Exponential Loss</code>,<span style="color:blue">蓝色</span>为:<code>Gold Standard</code><br><br>观察图中:<br><br>1. <code>Hinge Loss</code>中当$m_i(w) &gt; 1$ 时，其损失项始终未0，当$m_i(w) &lt; 1$时，其损失项的值呈线性增长（正好符合<code>svm</code>的需求）.<br>2. <code>Squared、Log、Exponential</code>三种损失函数已经<code>Hinge</code>的左侧都是凸函数，并且<code>Gold Stantard</code>损失为他们的下界:<br>    $$\zeta_{01} \leq  \hat{\zeta}_{01}(h)+fudge$$<br>3. 当需要求最大似然时(也就是概率最大化)，使用<code>Log Loss</code>最合适，但是一般会加上一个负号将其转换为求最小<br>4. 损失函数和的<code>凸特征</code>以及有<code>界</code>是非常重要的，可以防止在一些可以求得无穷的工作上白白浪费时间。有时候为了让函数有界和凸特征，一般会使用一些代理函数来进行替换。<br><br>##正则项<br>&gt;加入正在项是为了降低模型复杂度，在一定程度上可以有效防止模型过拟合<br><br>常用的正则项有:<br>$$<br>R_2 = \frac{1}{2}||w||^2 \\<br>R_1 = \sum_i |w_i| \\<br>R_0 = |\{i:w_i \neq 0 \}|<br>$$<br>这些正则项可以通用的写成:<br>$$R_p =(\sum_i |w_i|^p)^{\frac{1}{p}}$$<br><br>其中：<br>1. $R_2$最常用，因为它是凸函数，非常方便可以用<code>梯度下降法</code>最优化<br>2. $R_1$含有特征选择功能，因此经过$R_1$计算之后会有大量的0权重出现，这样的话我们在实际计算中只需要计算有值特征即可，可以加快速算法的运行速度<br>3. $R_0$，额~这个暂时不知道哪里用-_-<br><br>当$p \leqslant 1$时其正则项就为非凸函数了<br><center><img src="/img/Say-About-Loss-Function/reg.png" width="600px"></center>


<h2 id="参考">参考</h2><ol>
<li><a href="http://www.ics.uci.edu/~dramanan/teaching/ics273a_winter08/lectures/lecture14.pdf" target="_blank" rel="external">http://www.ics.uci.edu/~dramanan/teaching/ics273a_winter08/lectures/lecture14.pdf</a></li>
<li><a href="https://www.wikiwand.com/en/Hinge_loss" target="_blank" rel="external">https://www.wikiwand.com/en/Hinge_loss</a></li>
<li><a href="http://www.cnblogs.com/rocketfan/p/4081585.html" target="_blank" rel="external">http://www.cnblogs.com/rocketfan/p/4081585.html</a></li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>机器学习算法一般都是对损失函数(<code>Loss Function</code>)求最优，大部分损失函数都是包含两项：<code>损失误差项(loss term)</code>以及<code>正则项(regularization term)</code>:<br>$$J(w)=\sum_iL(m_i(w))+\lambda R(w)$$</p>
<h2 id="损失误差项">损失误差项</h2><p>常用的损失误差项有5种:</p>
<ol>
<li><code>Gold Standard</code></li>
<li><code>Hinge</code>:Svm</li>
<li><code>log</code>:logistic regression(cross entropy error)</li>
<li><code>squared</code>:linear regression</li>
<li><code>Exponential</code>:Boosting</li>
</ol>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://kubicode.me/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://kubicode.me/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Learning To Rank中Pairwise方法的学习]]></title>
    <link href="http://kubicode.me/2016/04/10/Machine%20Learning/LTR-Pairwise-Study/"/>
    <id>http://kubicode.me/2016/04/10/Machine Learning/LTR-Pairwise-Study/</id>
    <published>2016-04-10T09:05:18.000Z</published>
    <updated>2016-04-11T13:08:38.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>由于<code>Pairwise</code>方式的排序学习方法 训练样本构建方便、速度快同时效果也还可以，因此在工业界和学术的应用非常广泛，其中<a href="http://kubicode.me/2016/03/30/Machine%20Learning/RankSvm-Optimizing-Search-Engines-using-Clickthrough-Data/" target="_blank" rel="external">RankSvm</a>是最经典的一种，将其余的相关实现方法学习总结简单的记录到本文中。^_^</p>
</blockquote>
<h2 id="IRSVM">IRSVM</h2><p><code>IRSVM</code>直接是<code>RankSvm</code>的改进，<code>RankSvm</code>的训练目标是让序列pair的<code>不一致pair对</code>对最少，其优化函数为：<br>$$\tau(r_a,r_b)=\frac{P-Q}{P+Q}=1-\frac{2Q}{\binom{m}{2}}$$<br>因此直接暴露了两大问题:</p>
<h3 id="问题1:位置误差">问题1:位置误差</h3><a id="more"></a>
<pre><code><span class="tag">Example1</span>:
档位<span class="pseudo">:3</span>,2,1
排序1<span class="pseudo">:2</span> 3 2 1 1 1 1
排序2<span class="pseudo">:3</span> 2 1 2 1 1 1
</code></pre><p>从样例1中可以看到如果是按$\tau$最大化进行优化的话，<code>排序1</code>中<code>2 3</code>为不一致pair,排序2中<code>1 2</code>为不一致pair，因此他们的$\tau$得分是一致的，但是明显可以看到排序2的应该为更优，因为越<code>top</code>级别的重要性越大<br>因此<code>IRSVM</code>考虑了计算$\tau$时将位置顺序纳入误差</p>
<h3 id="问题2:长度误差">问题2:长度误差</h3><pre><code><span class="tag">Example2</span>:
档位<span class="pseudo">:3</span>,2,1
排序3<span class="pseudo">:3</span> 2 2 1 1 1 1
排序4<span class="pseudo">:3</span> 3 2 2 2 1 1 1 1 1
</code></pre><p>现观察样例2，可以发现<code>排序3</code>和<code>排序4</code>中均未出现<code>不一致pair</code>的文档对，因此他们的$\tau$得分是一样的，并且均为1，但是<code>排序3</code>中存在<code>28</code>个文档对，而<code>排序4</code>中存在<code>45</code>个文档对，所以<code>排序4</code>存在更多的训练数据，因此<code>排序4</code>的数据相当于<code>RankSvm</code>来说更加重要。<br>因此<code>IRSVM</code>将召回的文档个数纳入了排序</p>
<blockquote>
<p>其实这点比较纠结，实际使用中会进行数据过滤，而且最终训练的时候也一般都是取<code>top10</code>进行训练，所以这个问题并不会很明显</p>
</blockquote>
<h3 id="优化学习方法">优化学习方法</h3><p>所以<code>IRSVM</code>考虑了不同排序位置的不同重要性，以及各个<code>query</code>召回的数量，对原始的<code>RankSVM</code>损失函数进行修改得到如下:<br>$$\underset{w}{min} \sum_{i=1}^N \tau_{k(i)} \mu_{q(i))} [1-y_i(w,x_i^{(1)}-x_i^{(2)})]_+ + \lambda||w||^2$$</p>
<p>其实重要是添加了位置得分因子$\tau_{k(i)}$，使用<code>NDCG@1</code>中的方法进行折损，以及添加了<code>query</code>召回的文档长度因子$\mu_{q(i)}$，使用的是最简单粗暴的$\frac{1}{n_q}$进行计算，其中$n_q$表示召回的文档数量。</p>
<p>[2]中提出<code>IRSVM</code>的时候还使用了<code>SGD</code>和<code>线性规划</code>进行了优化</p>
<h2 id="参考">参考</h2><ol>
<li>《Learning to Rank for Information Retrieval and Natural Language Processing》.Hang Li</li>
<li>Cao Y, Xu J, Liu T Y, et al. Adapting ranking SVM to document retrieval[C]// SIGIR 2006: Proceedings of the International ACM SIGIR Conference on Research and Development in Information Retrieval, Seattle, Washington, Usa, August. 2006:186-193.</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>由于<code>Pairwise</code>方式的排序学习方法 训练样本构建方便、速度快同时效果也还可以，因此在工业界和学术的应用非常广泛，其中<a href="http://kubicode.me/2016/03/30/Machine%20Learning/RankSvm-Optimizing-Search-Engines-using-Clickthrough-Data/">RankSvm</a>是最经典的一种，将其余的相关实现方法学习总结简单的记录到本文中。^_^</p>
</blockquote>
<h2 id="IRSVM">IRSVM</h2><p><code>IRSVM</code>直接是<code>RankSvm</code>的改进，<code>RankSvm</code>的训练目标是让序列pair的<code>不一致pair对</code>对最少，其优化函数为：<br>$$\tau(r_a,r_b)=\frac{P-Q}{P+Q}=1-\frac{2Q}{\binom{m}{2}}$$<br>因此直接暴露了两大问题:</p>
<h3 id="问题1:位置误差">问题1:位置误差</h3>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://kubicode.me/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://kubicode.me/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RankSvm-基于点击数据的搜索排序算法]]></title>
    <link href="http://kubicode.me/2016/03/30/Machine%20Learning/RankSvm-Optimizing-Search-Engines-using-Clickthrough-Data/"/>
    <id>http://kubicode.me/2016/03/30/Machine Learning/RankSvm-Optimizing-Search-Engines-using-Clickthrough-Data/</id>
    <published>2016-03-30T12:49:53.000Z</published>
    <updated>2016-04-04T15:21:20.000Z</updated>
    <content type="html"><![CDATA[<pre><code>RankSvm是Pairwise的学习排序中最早也是非常著名的一种算法，主要解决了传统PontWise构建训练样本难的问题，
并且基于<span class="built_in">Pair</span>的构建的训练样本也更为接近排序概念
</code></pre><h2 id="基本介绍">基本介绍</h2><p>RankSvm是在2002年提出的，之前工作关于LTR的工作貌似只有Pointwise相关的,比如PRanking,这样的排序学习算法Work需要含有档位标注的训练样本，一般有以下几种获取方式：</p>
<ol>
<li>需要人工/专家标注</li>
<li>诱导用户对展现的搜索结果进行反馈</li>
</ol>
<p>这样就会存在会成本高、可持续性低、受标准者影响大等缺点。<br><a id="more"></a></p>
<p>而RankSvm只需要根据搜索引擎的点击日志构建<code>Pair</code>对即可，相对于先前的工作在算法的实用性上有了非常大的改善。</p>
<h2 id="训练样本设计">训练样本设计</h2><p>一般搜索引擎都会记录用户搜索后展现的结果以及用户的点击情况，这种日志成本较低，并且改造系统也较为方便，而RankSvm的训练样本就是从这种点击日志中进行提取。</p>
<p>由于用户点击的<code>doc</code>概率和排序的位置影响很大，虽然一般都是偏爱相关性较大的<code>doc</code>，但是如果这种<code>doc</code>排在很后面的话其实用户也几乎不会点，所有<code>rankSvm</code>就只考虑top级别的点击日志，一般为<code>top 10</code></p>
<p>另外在构建训练数据时同一<code>query</code>下认为用户被点击<code>doc</code>相关性要高于没有被点击的<code>doc</code>，但是由于用户是从上往下浏览网页的，所以排在前面的<code>doc</code>被点击的概率会大于后面的<code>doc</code>，因此<code>RankSvm</code>使用的最终策略为:</p>
<blockquote>
<p><code>pair</code>构建策略:给定一组排序情况($doc_1,doc_2,doc_3,…$),以及$C$记录了用户点击<code>doc</code>的情况,则有<br>$$doc_i{\overset{r^*}{&lt;}} doc_j$$对于所有<code>pair</code>对$1 \leq i$,同时$i \in C$ ,$j \notin C$</p>
</blockquote>
<p>$r^*$表示应有的优化排序，也就是<code>被点击文档</code>的相关性要大于<code>排在该文档前面</code>并且<code>未被点击的文档</code>，看上去很绕口，看个栗子：</p>
<p>假如某个用户搜索某个<code>query</code>得到首页10个<code>doc</code>，按顺序使用$doc_i$进行表示,如果该用户点击了$1,3,7$三个文档，则认为有:<br>$$doc_3 {\overset{r^*}{&lt;}} doc_2 \\<br>doc_7 {\overset{r^*}{&lt;}} doc_2    \\<br>doc_7 {\overset{r^*}{&lt;}} doc_4    \\<br>doc_7 {\overset{r^*}{&lt;}} doc_5    \\<br>doc_7 {\overset{r^*}{&lt;}} doc_6$$</p>
<p>表示该<code>query</code>下$doc_3$的相关性要高于$doc_2$，理应排在前面，而$doc7$的相关性也应该要高于$doc_{2,4,5,6}$，但是可以发现未见$doc_1$的相关性鉴定，这是由于$doc_1$已经是排在了第一位，本身位置点击概率就就是最高的，所以无法判断与其他文档相关性的高低，同理，$doc_{8,9,10}$也未纳入相关性的排序中。</p>
<p>训练样本可以通过这样方式进行构建，但是遗憾的是并没有一种机器学习算法能直接使用这种数据进行训练学习-_-</p>
<h2 id="基本思想">基本思想</h2><p>在上面的栗子中，我们希望用新算法完成$doc_{1,3,7}$排在<code>top 3</code>，那这样的文档的真实相关性高的将会排到前面，<code>RankSvm</code>采用$Kendall’s \quad \tau$来统计实际排序与算法排序的度量，先看下面两个变量:</p>
<ol>
<li>$P$表示排序序列中保持一致性的<code>Pair</code>对数量，也就是真实相关性高的排在第的前面。</li>
<li>$Q$表示排序序列中保持不一致的<code>Pair</code>对数量（就是为逆序了），也就是由于算法的误差导致真实相关性低的排在了高的前面</li>
<li>同时$P+Q=\binom{m}{2}$，$m$表示序列中文档的数量，因为长度为$m$的序列可能组成的<code>pair</code>对为$m$的2组合</li>
</ol>
<p>则$\tau$的计算方式为:<br>$$\tau(r_a,r_b)=\frac{P-Q}{P+Q}=1-\frac{2Q}{\binom{m}{2}}$$</p>
<blockquote>
<p>$r_a$为真实排序，$r_b$为算法排序</p>
</blockquote>
<p>比如实际文档中的顺序为:<br>$$d_1{\overset{r^*}{&lt;}}d_2{\overset{r^*}{&lt;}}d_3{\overset{r^*}{&lt;}}d_4{\overset{r^*}{&lt;}}d_5$$<br>但是算法的排序顺序为:<br>$$d_3{\overset{\hat{r}}{&lt;}}d_1{\overset{\hat{r}}{&lt;}}d_2{\overset{\hat{r}}{&lt;}}d_4{\overset{\hat{r}}{&lt;}}d_5$$</p>
<p>因此可以发现算法排序中有3对<code>pair</code>不一致了($\{d_2,d_3\}$,$\{d_1,d_2\}$,$\{d_1,d_3\}$)，所以$Q=3$，$Q=7$，最终的$\tau(r,\hat{r})=\frac{7-3}{10}=4$<br>$\tau$的值越大，表示排序效果越接近真实，比如上面的$\tau(r,r)=\frac{10-0}{10}=1$</p>
<blockquote>
<p><code>RankSvm</code>还证明了由$Q$的倒数正相关的一个式子为平均准确率指标的下界(具体证明看原文附录):<br>$$AvgPrec(\hat{r}) \geq \frac{1}{R} \left[Q+\binom{R+1}{2}\right]^{-1} \left(\sum_{i=1}^{R} \sqrt{i}\right)^2$$<br>$R$为排序出现的文档中与query相关文档数量(这个是<a href="http://kubicode.me/2016/02/15/Machine%20Learning/Learning-To-Rank-Base-Knowledge/#MAP" target="_blank" rel="external">Mean Average Precision</a>中的标注，与<code>Pair</code>对的样本稍微有点差别)<br>从这个角度也可以看到$\tau$来衡量排序效果好坏的合理性.</p>
</blockquote>
<p>假设现在有$n$个$q_i$作为训练样本，他们各自的目标排序为$r_i^*$，也就是:<br>$$(q_1,r_1^*),(q_2,r_2^*),(q_3,r_3^*),…(q_n,r_n^*)$$</p>
<p>其中算法排序为$\hat{r}_i$，则排序算法的优化目标是将下列式子<br>$$\tau_{s}=\frac{1}{n} \sum_{i=1}^{n}\tau(r_i^*，\hat{t}_i)$$<br>进行最大化.</p>
<h2 id="RankSvm排序">RankSvm排序</h2><p>假设能找到一个排序算法能使得上面的$\tau_s$得到最大化，对于一个指定的查询$q$，每个文档$d_i$使用特征向量映射方法$\Phi(q,d_i)$，如果是直接使用线性排序方法:<br>$$(d_i,d_j) \in \hat{r} \Leftrightarrow \vec{w} \Phi(q,d_i)&gt;\vec{w} \Phi(q,d_j)$$<br>$\vec{w}$表示权重向量，线性排序下，排序分数为<code>权重 x 特征向量</code></p>
<p><center><img src="/img/RankSvm-Optimizing-Search-Engines-using-Clickthrough-Data/linear_example.png" width="400px"></center><br>上图表示一个二维的<code>权重</code>与<code>特征</code>图，在排序的顺序的就是特征在权重上的映射位置顺序，比如单从$W_1$维度进行观察可以看到的排序顺序为<code>{1,2,3,4}</code>，而如果按$W_2$维度则是<code>{2,3,1,4}</code>。</p>
<p>为了最大化$\tau_s$，可以最小化$    Q$来代替，也就是说对于线性的排序，$Q=0$就是表示下面的等式全成立(也就是最大化)<br>$$<br>\forall (d_i,d_j) \in r_1^* : \vec{w} \Phi(q,d_i)&gt;\vec{w} \Phi(q,d_j) \\<br>… \\<br>\forall (d_i,d_j) \in r_n^* : \vec{w} \Phi(q,d_i)&gt;\vec{w} \Phi(q,d_j)<br>$$</p>
<p>不幸的是，优化这个是一个<code>NP难题</code>。<br>然而<code>SVM</code>在由于软间距最大时可以看到熟悉的身影：<br>minimize:<br>$$\frac{1}{2} \vec{w} \cdot \vec{w} + C \sum \xi_{i,j,k}$$<br>subject to:<br>$$<br>\forall (d_i,d_j) \in r_1^* : \vec{w} \Phi(q,d_i) \geq \vec{w} \Phi(q,d_j) + 1 - \xi_{i,j,1} \\<br>… \\<br>\forall (d_i,d_j) \in r_n^* : \vec{w} \Phi(q,d_i) \geq \vec{w} \Phi(q,d_j) +1 - \xi_{i,j,n} \\<br>\forall_i \forall_j \forall_k:\xi_{i,j,k} \geq 0<br>$$</p>
<blockquote>
<p>$\xi$为松弛项，$C$表示平衡项</p>
</blockquote>
<p>因此优化该问题时可以将约束转为:<br>$$\vec{w} \Phi(q,d_i)-\vec{w} \Phi(q,d_j) \geq 1 - \xi_{i,j,1}$$<br>并且由于是线性排序，可以进一步精简为:<br>$$\vec{w} \left(\Phi(q,d_i)-\Phi(q,d_j)\right) \geq 1 - \xi_{i,j,1}$$</p>
<p>在<code>Pair</code>对中只可能$d_i$是否排在$d_j$前面是一个二值结果，所以我们可以将$d_i$排在$d_j$前面的<code>Pair</code>为正标签，否则为负标签:</p>
<p>$$ y=\left\{<br>\begin{aligned}<br>+1 &amp; \quad if \quad \vec{w} \Phi(q,d_i)&gt;\vec{w} \Phi(q,d_j) \\<br>-1 &amp; \quad otherwise\\<br>\end{aligned}<br>\right.$$</p>
<p>则最终可以将约束可以写成:<br>$$y_i \cdot \vec{w} \left(\Phi(q,d_i)-\Phi(q,d_j)\right) \geq 1 - \xi_{i,j,1}$$</p>
<blockquote>
<p>其中传统的偏置项在<code>RankSvm</code>是不需要的，以为正好<code>Pair</code>相减时就消掉了</p>
</blockquote>
<p>这样就可以完全将上面构建的样本转为一个分类问题，使用<code>SVM</code>的对偶形式进行求解，并且还可以使用核函数进行非线性的分类^_^</p>
<p>训练完<code>Svm</code>之后，在正真排序时只需要将原始$doc$的特征向量输入<code>Svm</code>模型即可:<br>$$resv(q,d_i)= \vec{w} \Phi(q,d_i) = \sum_l^n a_{l}^*y_i(\Phi(q,d_i) \cdot \Phi(q,d_l)) $$</p>
<p><center><img src="/img/RankSvm-Optimizing-Search-Engines-using-Clickthrough-Data/binary_classifiy.png" width="400px"></center><br>上面是表示两个不同的<code>query</code>所表示的特征空间，不同的形状表示文档与对应<code>query</code>的相关性档位,三角形$x_1$表示相关性档位高，圆圈$x_2$表示相关性档位一般，叉叉$x_3$表示相关性档位差。<br>将这些样本转为<code>Pair</code>对之后可以有：</p>
<p><center><img src="/img/RankSvm-Optimizing-Search-Engines-using-Clickthrough-Data/pair_wise_result.png" width="400px"></center><br>可以发现$x_1-x_3$和$x_1-x_2$为正样本，而$x_2-x_1$和$x_3-x_1$为负样本，因此可以形成对应的训练数据进行训练,其实这样形成的样本是对称的，因此在实际使用中一般只保留一侧即可。</p>
<h2 id="总结">总结</h2><p><code>RankSvm</code>很好的解决原始训练样本构建难的问题，根据点击日志构建样本，既考虑了<code>doc</code>之间的顺序，又保证了可持续性，并且其<code>Pair</code>对的训练正好可以使用<code>Svm</code>进行求最优化，而<code>Svm</code>分类器已经是非常成熟并且广泛使用的一种机器学习算法。<br>因此<code>RankSvm</code>虽然在2002年就提出，但是至今在工业界还是广泛使用，但是现在的主要难点是样本<code>Pair</code>对的构建，针对不同的场景也不同的策略，不一定只是根据点击顺序，实际使用中还要考虑新样本数据。</p>
<h2 id="参考">参考</h2><ol>
<li>Joachims T. Optimizing search engines using clickthrough data[C]// Proceedings of the eighth ACM SIGKDD international conference on Knowledge discovery and data mining. ACM, 2002:133-142.</li>
<li>《Learning to Rank for Information Retrieval and Natural Language Processing》.Hang Li</li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>RankSvm是Pairwise的学习排序中最早也是非常著名的一种算法，主要解决了传统PontWise构建训练样本难的问题，
并且基于<span class="built_in">Pair</span>的构建的训练样本也更为接近排序概念
</code></pre><h2 id="基本介绍">基本介绍</h2><p>RankSvm是在2002年提出的，之前工作关于LTR的工作貌似只有Pointwise相关的,比如PRanking,这样的排序学习算法Work需要含有档位标注的训练样本，一般有以下几种获取方式：</p>
<ol>
<li>需要人工/专家标注</li>
<li>诱导用户对展现的搜索结果进行反馈</li>
</ol>
<p>这样就会存在会成本高、可持续性低、受标准者影响大等缺点。<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://kubicode.me/tags/Machine-Learning/"/>
    
      <category term="Search Engine" scheme="http://kubicode.me/tags/Search-Engine/"/>
    
      <category term="Machine Learning" scheme="http://kubicode.me/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[McRank:一种基于多分类和梯度提升树的排序学习]]></title>
    <link href="http://kubicode.me/2016/03/28/Machine%20Learning/McRank-Learning-to-Rank-Multiple-Classification-and-Gradient-Boosting/"/>
    <id>http://kubicode.me/2016/03/28/Machine Learning/McRank-Learning-to-Rank-Multiple-Classification-and-Gradient-Boosting/</id>
    <published>2016-03-28T08:37:53.000Z</published>
    <updated>2016-03-30T07:45:10.000Z</updated>
    <content type="html"><![CDATA[<pre><code><span class="name">McRank</span>是学习排序(<span class="name">Learning</span> <span class="atom">to</span> <span class="name">Rank</span>)的单文档排序分支(<span class="name">Pointwise</span>)中较为经典的一种，本文是读原<span class="name">Paper</span>[<span class="number">1</span>]之后自己的一个理解.
</code></pre><h2 id="基本介绍">基本介绍</h2><p><code>MacRank</code>的全称是<code>Multiple Classification Rank</code>,可以理解为将<a href="http://kubicode.me/2016/02/15/Machine%20Learning/Learning-To-Rank-Base-Knowledge/" target="_blank" rel="external">学习排序</a>转为机器学习中的一个多分类问题.<br><code>McRank</code>对<code>DCG</code>指标进行优化，并且可以证明<code>DCG</code>的误差可以被分类误差给<code>bounded</code>住.</p>
<h2 id="折损累积增益">折损累积增益</h2><blockquote>
<p><code>DCG</code>(Discounted Cumulative Gain)是在信息检索领域评估一个<code>rank</code>好坏的常用指标。(在实际使用中一般会进行归一化，称为<code>NDCG</code>，可以看<a href="http://kubicode.me/2016/02/15/Machine%20Learning/Learning-To-Rank-Base-Knowledge/#NDCG" target="_blank" rel="external">这里</a>).</p>
</blockquote>
<p>假设在指定的<code>query</code>下通过某个排序算法对$n$个文档进行排序，则可以得到<br>$$DCG=\sum_{i=1}^{n}c_{[\pi_i]}(2^{y_i}-1)$$<br><a id="more"></a></p>
<p>其中:</p>
<ol>
<li>$i$表示原文档的索引顺序</li>
<li>$c_{[\pi_i]}=log(i+1)$</li>
<li>$y_i$表示对应文档与<code>query</code>相关性的程度，一般用档位$\{0,1,2,3,4\}$来表示</li>
</ol>
<p>最终的<code>DCG</code>值越大，表示排序效果越好,假如直接根据档位降序得到的排序结果中<code>DCG</code>是最大的，实际使用中一般根据当前可能的最大<code>DCG</code>进行归一化</p>
<h2 id="排序思想">排序思想</h2><p>现在已经知道了文档与<code>query</code>之间一般用档位衡量，而假如按档位降序的<code>DCG</code>值最高,所以排序问题可以转为指定<code>query</code>对文档相关性类别的预测，即多分类问题。</p>
<h3 id="DNCG误差计算">DNCG误差计算</h3><p>现在可以这么理解，我们希望的是<code>DCG</code>越大越好，也即是<code>DCG</code>误差越小越好，但如果是分类问题将直接优化的是分类误差，那如果<code>DCG</code>误差能够被分类误差给<code>bouded</code>住，就可以通过优化分类误差来间接的优化<code>DCG</code>误差了.</p>
<p>对于一个排序的置换映射函数$\pi$,<code>DCG</code>误差为$DCG_g-DCG_{\pi}$，其中$DCG_g$表示最优排序,就是根据实际的<code>query-doc</code>相关性分档降序的排序，所以肯定有$DCG_g \geq DCG_{\pi}$</p>
<p>现给定$n$个<code>URLS</code>的顺序为$\{1,2,3…n\}$，假设分类器分配的相关结果为$\hat{y}_i \in \{0,1,2,3,4\}$，置换映射函数$\pi$直接根据相关性进行排序，高档位的排在前面，相同档位可以随意排序，则可以有以下证明:</p>
<blockquote>
<p>先看变量^_^<br>$y_i$表示<code>query-doc</code>的实际相关性<br>$\hat{y}_i$表示<code>query-doc</code>的分类器预测相关性<br>$c_{[g_i]}$表示根据实际相关性得到的排序<br>$c_{[\pi_i]}$表示根据预测相关性得到的排序</p>
</blockquote>
<p>$$\begin{equation}\begin{split}DCG_{\pi}&amp;=\sum_{i=1}^{n}c_{[\pi_i]}(2^{y_i}-1) \\<br>&amp;=\sum_{i=1}^{n}c_{[\pi_i]}(2^{\hat{y}_i}-1)+\sum_{i=1}^{n}c_{[\pi_i]}(2^{y_i}-2^{\hat{y}_i}) \\<br>&amp;\geq \sum_{i=1}^{n}c_{[g_i]}(2^{\hat{y}_i}-1)+\sum_{i=1}^{n}c_{[\pi_i]}(2^{y_i}-2^{\hat{y}_i}) \\<br>&amp;=\sum_{i=1}^{n}c_{[g_i]}(2^{y_i}-1)-\sum_{i=1}^{n}c_{[g_i]}(2^{y_i}-2^{\hat{y}_i})+\sum_{i=1}^{n}c_{[\pi_i]}(2^{y_i}-2^{\hat{y}_i}) \\<br>&amp;=DCG_g+\sum_{i=1}^{n}(c_{[\pi_i]}-c_{[g_i]})(2^{y_i}-2^{\hat{y}_i})<br>\end{split}\end{equation}$$</p>
<p>解释下不等式$\sum_{i=1}^{n}c_{[\pi_i]}(2^{\hat{y}_i}-1) \geq \sum_{i=1}^{n}c_{[g_i]}(2^{\hat{y}_i}-1)$成立的原因:$c_{[\pi_i]}$是根据相关性$\hat{y}_i$排序得到的，也就是上面提到的最优排序，得到的$DCG$值是最大的(当然这个是分类器的预测值，不是真实值，就是假象的意思-_-)，所以换一种顺序$c_{[g_i]}$其$DCG$的值必定会小于等于最大值.</p>
<p>根据上面的推导就可以直接得到$DCG$的误差了:<br>$$\begin{equation}\begin{split}DCG_g-DCG_{\pi} &amp;\leq \sum_{i=1}^{n}(c_{[g_i]}-c_{[\pi_i]})(2^{y_i}-2^{\hat{y}_i}) \\<br>&amp; \leq \left(\sum_{i=1}^{n}(c_{[g_i]}-c_{[\pi_i]})^2\right)^{\frac{1}{2}}\left(\sum_{i=1}^{n}(2^{y_i}-2^{\hat{y}_i})^2\right)^{\frac{1}{2}} \\<br>&amp;\leq \left(2\sum_{i+1}^{n}c_{[i]}^2-2n\prod_{i=1}^nc_{[i]}^{\frac{2}{n}}\right)^{\frac{1}{2}} 15 \left(\sum_{i=1}^{n}1_{y_i \neq \hat{y}_i}\right)^{\frac{1}{2}} \\<br>&amp;= 15\sqrt{2} \left(\sum_{i+1}^{n}c_{[i]}^2-n\prod_{i=1}^nc_{[i]}^{\frac{2}{n}}\right)^{\frac{1}{2}}\left(\sum_{i=1}^{n}1_{y_i \neq \hat{y}_i}\right)^{\frac{1}{2}}<br>\end{split}\end{equation}$$</p>
<p>上面公式<code>1~2</code>是不等式是根据<code>柯西不等式</code>得到的，第<code>2~3行</code>平方展开的不等式成立是因为:</p>
<ol>
<li>$\sum_{i=1}^{n}c_{[\pi_i]}^2=\sum_{i=1}^{n}c_{[g_i]}^2=\sum_{i=1}^{n}c_{[i]}^2$,$\prod_{i=1}^{n}c_{[\pi_i]}^2=\prod_{i=1}^{n}c_{[g_i]}^2=\prod_{i=1}^{n}c_{[i]}^2$，他们虽然是顺序不一样，但是他们集合的内容是一样的，所以<code>求和</code>和<code>连乘</code>的等式是成立的。</li>
<li>两种相关性$y_i$和$\hat{y}_i$的值在<code>0~4</code>范围内,因此有$(2^{y_i}-2^{\hat{y}_i})^2\leq 15$，因为$2^4-2^0=15$</li>
</ol>
<p>因此当需要最小化<code>DCG</code>误差时只需要最小化分类误差$\sum_{i=1}^{n}1_{y_i \neq \hat{y}_i}$即可，但是该误差非凸也非平滑，实际使用中使用代理损失函数进行优化:<br>$$\sum_{i=1}^{N}\sum_{k=0}^{K-1}-log(p_{i,k})1_{y_i=k}$$<br>其中$p_{i,k}$表示<code>doc</code>输入每个档位的概率，$K$是总的档位数。</p>
<blockquote>
<p>我感觉:上面不等式里面的排序顺序时间使用$c_{[i]}$代替了，虽然表面上和分档结果无关，因此只需要优化分档即可，但是。。。实际上$c_{[\pi_i]}$的顺序是和分档预测有关的啊….</p>
</blockquote>
<h3 id="分类排序">分类排序</h3><p>上面提到过有了分档结果之后可以按档位顺序降序排序，得到的<code>DCG</code>就是最优的，但是这里存在一个问题，那就是相同档位之间是可以随便排的，就是导致排序的不稳定性，为了得到一种良好的排序机制，<code>McRank</code>在实际排序中会将分类结果转为一个连续的分数，按这个分数进行排序.</p>
<p>假设训练是$\{y_i,x_i\}_i^N$，$y_i$表示多分类的分档,则最终将会学习到的是每个类别的概率$p_{i,k}=Pr(y_i=k)$，则最后的排序分数为:<br>$$S_i=\sum_{k=0}^{K-1}p_i^kT(k)$$<br>其中$T(k)$表示随档位单调递增的函数，比如$T(k)=k$或者$T(k)=2^k$（<code>McRank</code>用的是前者）</p>
<blockquote>
<p>不同的单调递增函数不会对排序进行影响，同时如果对函数进行线性变换也会改变排序结果</p>
</blockquote>
<p>最终<code>McRank</code>是使用<code>Boosting Tree</code>进行多分类预测..</p>
<h3 id="有序分类">有序分类</h3><blockquote>
<p>好吧，其实上面<code>McRank</code>已经讲完了，但是Paper里面提到有序分类(<code>Ordinal Classfifcation</code>，貌似就是<code>Pointwise</code>里面的第三个分支)可以提升排序结果。</p>
</blockquote>
<p>这里在进行多分类时，可以发现每个类别(档位)并不是平等的，比如4档就是要比0档相关性更好，为了考虑这种的偏移，有序分类就是干这个的，多类别有序分类是学习一段区间内的累积概率$Pr(y_i&lt;k)$</p>
<p>首先将训练数据点分类两种$\{y_i \geq 4 \}$和$\{y_i \leq 3\}$，那这样称为了一个二分类问题，这里一样使用<code>boosting Tree</code>进行分类，同样关于$\{y_i \leq 3\}$也可以分为$\{y_i \geq 3 \}$和$\{y_i \leq 2\}$，如果迭代就可以进行变相多分类.</p>
<p>这种方式就是考虑目标类目的不均等性，带来的问题就是会增加训练开销(因为有重复计算，并且可能会带来较大的样本<a href="http://kubicode.me/2015/08/30/Machine%20Learning/Multiclass-Classification/#One-Vs-All" target="_blank" rel="external">不均衡性</a>。。。。)</p>
<blockquote>
<p>还有一个坏消息。。。<code>McRank</code>的Paper实验里面这种方式并没有比普通多分类提升多少效果-_-</p>
</blockquote>
<h2 id="总结">总结</h2><p><code>McRank</code>是非常经典的一种<code>Pointwise</code>学习排序，将排序转为机器学习的多分类预测，并且对其排序指标<code>DCG</code>误差可以被分类误差给<code>bounded</code>住，最终将分类结果的概率转为一个连续分数进行最终的排序，在实验里面显示该方法比基于回归的<code>subRank</code>以及<code>pairwise</code>的<code>LambdaRank</code>效果更好。</p>
<blockquote>
<p><code>McRank</code>速度快，效果也还行，最大的问题就是<code>训练样本的构建</code>比较麻烦..</p>
</blockquote>
<h2 id="参考">参考</h2><ol>
<li>Li P, Burges C J C, Wu Q. McRank: Learning to Rank Using Multiple Classification and Gradient Boosting[J]. Advances in Neural Information Processing Systems, 2007:897-904.</li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code><span class="name">McRank</span>是学习排序(<span class="name">Learning</span> <span class="atom">to</span> <span class="name">Rank</span>)的单文档排序分支(<span class="name">Pointwise</span>)中较为经典的一种，本文是读原<span class="name">Paper</span>[<span class="number">1</span>]之后自己的一个理解.
</code></pre><h2 id="基本介绍">基本介绍</h2><p><code>MacRank</code>的全称是<code>Multiple Classification Rank</code>,可以理解为将<a href="http://kubicode.me/2016/02/15/Machine%20Learning/Learning-To-Rank-Base-Knowledge/">学习排序</a>转为机器学习中的一个多分类问题.<br><code>McRank</code>对<code>DCG</code>指标进行优化，并且可以证明<code>DCG</code>的误差可以被分类误差给<code>bounded</code>住.</p>
<h2 id="折损累积增益">折损累积增益</h2><blockquote>
<p><code>DCG</code>(Discounted Cumulative Gain)是在信息检索领域评估一个<code>rank</code>好坏的常用指标。(在实际使用中一般会进行归一化，称为<code>NDCG</code>，可以看<a href="http://kubicode.me/2016/02/15/Machine%20Learning/Learning-To-Rank-Base-Knowledge/#NDCG">这里</a>).</p>
</blockquote>
<p>假设在指定的<code>query</code>下通过某个排序算法对$n$个文档进行排序，则可以得到<br>$$DCG=\sum_{i=1}^{n}c_{[\pi_i]}(2^{y_i}-1)$$<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://kubicode.me/tags/Machine-Learning/"/>
    
      <category term="Search Engine" scheme="http://kubicode.me/tags/Search-Engine/"/>
    
      <category term="Machine Learning" scheme="http://kubicode.me/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从Bayesion的角度来看Logistic Regression]]></title>
    <link href="http://kubicode.me/2016/03/26/Machine%20Learning/Bayesian-Logistic-Regression/"/>
    <id>http://kubicode.me/2016/03/26/Machine Learning/Bayesian-Logistic-Regression/</id>
    <published>2016-03-26T03:30:54.000Z</published>
    <updated>2016-03-29T16:55:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Logistic_Regression公式">Logistic Regression公式</h2><blockquote>
<p><code>Logistic Regression</code>（下面简称<code>LR</code>）是一个二分类的机器学习方法，给定一个输入向量$x_i$，输出$P(y_i|x_i)$,其中$y_i \in {0,1}$。</p>
</blockquote>
<p>作为一个二分类问题，$Y$的后验概率一般会写成这样:<br>$$P(Y=1|X)=\frac{1}{1+exp(- \omega - \sum_{i=1}^n {\omega_ix_i})}=\sigma(W^TX_i)$$<br>那么<br><a id="more"></a><br>$$P(Y=0|X)=1-\sigma(W^TX_i)$$</p>
<p>其中$\sigma(\cdot)$表示激活函数,为$S$形状，<code>x</code>轴可以取值无限大，<code>y</code>轴只能取到$(-1,1)$<br>$$\sigma(a)=\frac{1}{1+exp(-a)}$$</p>
<pre><code>由于LR表示简单，训练预测速度快，效果并不是很差<span class="comment">(加上正则化)</span>，所以深得学术和工业界的囍爱~^_^
</code></pre><h2 id="使用GNB推导">使用GNB推导</h2><blockquote>
<p>谈到LR的时候第一印象就是上面的公式，但是为啥是这个公式呢？这一小节就是从<code>GNB(Gaussion Navie Bayes)</code>的角度来看待这个问题~</p>
</blockquote>
<p>我们先对<code>GNB</code>模型做4个假设:</p>
<ol>
<li>$Y$是布尔值，服从伯努利分布，其中$\pi = P(Y=1)$</li>
<li>其中$X_i$是连续随机变量</li>
<li>对于每个$X_i$，$P(X_i|Y=y_k)$服从高斯分布$N(\mu_{ik},\sigma_i)$(大多数情况下，简单用的$N(\mu_k,\sigma)$)</li>
<li>在给定$Y$下，$X_i$与$X_j$条件独立</li>
</ol>
<p>现在让$P(Y|X)$服从<code>GBN</code>假设，通常根据贝叶斯公式可以得到以下:<br>$$P(Y=1|X)=\frac{P(X|Y=1)P(Y=1)}{P(Y=1)P(X|Y=1)+P(Y=0)P(X|Y=0)}$$</p>
<p>再对这个式子进行进一步处理:</p>
<p>$$<br>\begin{equation}\begin{split} P(Y=1|X)&amp;=\frac{1}{1+\frac{P(Y=0)P(X|Y=0)}{P(Y=1)P(X|Y=1)}}\quad\quad &amp;(1)\\<br>&amp;=\frac{1}{1+exp \left(ln\frac{P(Y=0)P(X|Y=0)}{P(Y=1)P(X|Y=1)}\right)}&amp;(2)\\<br>&amp;=\frac{1}{1+exp \left(ln\frac{P(Y=0)}{P(Y=1)}+\sum_iln\frac{P(x_i|Y=0)}{P(x_i|Y=1)}\right)}\quad\quad&amp;(3)\\<br>&amp;=\frac{1}{1+exp \left(ln\frac{1-\pi}{\pi}+\sum_iln\frac{P(x_i|Y=0)}{P(x_i|Y=1)}\right)} &amp;(4)<br>\end{split}\end{equation}<br>$$</p>
<p>其中:</p>
<ol>
<li>式子<code>(1)-&gt;(2)</code>是加了<code>exp</code>函数与<code>ln</code>函数正好相互抵消</li>
<li>式子<code>(2)-&gt;(3)</code>首先将<code>ln</code>函数的相乘转为相加，同时由于$X$中的各个$x_i$相互独立，所以原本写成连乘的式子又可以写成相加求和</li>
<li>式子<code>(3)-&gt;(4)</code>中$P(Y=1)$的概率是$\pi$，则$P(Y=0)$的概率是$1-\pi$</li>
</ol>
<p>在给定假设<code>3</code>情况下，对$\sum_iln\frac{P(x_i|Y=0)}{P(x_i|Y=1)}$进行进一步展开:<br>$$\begin{equation}\begin{split} \sum_iln\frac{P(x_i|Y=0)}{P(x_i|Y=1)} &amp;=\sum_iln\frac{\frac{1}{\sqrt{2\pi\sigma}}exp(\frac{-(x_i-\mu_{i0})^2}{2\sigma_i^2})}{\frac{1}{\sqrt{2\pi\sigma}}exp(\frac{-(x_i-\mu_{i1})^2}{2\sigma_i^2})}  &amp;(5)\\<br>&amp;= \sum_iln  exp\left(\frac{(x_i-\mu_{i1})^2-(x_i-\mu_{i0})^2}{2\sigma_i^2}\right) &amp;(6)\\<br>&amp;= \sum_i \left(\frac{(x_i^2-2x_i\mu_{i1}+\mu_{i1}^2)-(x_i^2-2x_i\mu_{i0}+\mu_{i0}^2)}{2\sigma_i^2}\right) \quad\quad &amp;(7)\\<br>&amp;= \sum_i \left(\frac{2x_i(\mu_{i0}-\mu{i1})+\mu_{i1}^2-\mu_{i0}^2}{2\sigma_i^2}\right) &amp;(8)\\<br>&amp;= \sum_i \left(\frac{\mu_{i0}-\mu_{i1}}{\sigma_i^2}x_i+\frac{\mu_{i1}^2-\mu_{i0}^2}{2\sigma_i^2}\right) &amp;(9)<br>\end{split}\end{equation}$$</p>
<ol>
<li>式子<code>(5)</code>根据假设<code>3</code>而得到，它是服从高斯分布</li>
<li>式子<code>(5)-&gt;(6)</code>是消除了公共因此，并且将指数上的相除转为了相减</li>
<li>式子<code>(6)-&gt;(7)</code>是对<code>ln</code>和<code>exp</code>进行了相互抵消，并且对其平方公式进行了展开</li>
<li>式子<code>(7)-&gt;(8)</code>是展开式中除去了公有的变量</li>
<li>式子<code>(8)-&gt;(9)</code>将$x_i$显眼得提了出来</li>
</ol>
<p>现从新将上面的展开式丢到$P(Y=1|X)$中则可以得到<br>$$P(Y=1|X)=\frac{1}{1+exp \left(ln\frac{1-\pi}{\pi}+\sum_i(\frac{\mu_{i0}-\mu_{i1}}{\sigma_i^2}x_i+\frac{\mu_{i1}^2-\mu_{i0}^2}{2\sigma_i^2})\right)}$$</p>
<p>相应地，则可以将其写为:<br>$$P(Y=1|X)=\frac{1}{1+exp (\omega_0+\sum_i\omega_ix_i)}$$</p>
<blockquote>
<p>可以发现这个式子就是<code>LR</code>的式子了</p>
</blockquote>
<p>其权重$\{\omega_1…\omega_n\}$为<br>$$\omega_i=\frac{\mu_{i0}-\mu_{i1}}{\sigma_i^2}$$<br>其偏置$\omega_0$为:<br>$$\omega_0=ln\frac{1-\pi}{\pi}+\sum_i\frac{\mu_{i1}^2-\mu_{i0}^2}{2\sigma_i^2}$$</p>
<h2 id="总结">总结</h2><p>文本是学习了从贝叶斯角度来看<code>LR</code>式子的来源，根据大家熟知的朴素贝叶斯公式，将定其特定类别下的特征符合高斯分布，根据贝叶斯公式一步步推导出了<code>LR</code>式子的样纸，还是很神奇的。^_^</p>
<h2 id="参考">参考</h2><p>1 <a href="http://web.cse.ohio-state.edu/~kulis/teaching/788_sp12/scribe_notes/lecture6.pdf" target="_blank" rel="external">http://web.cse.ohio-state.edu/~kulis/teaching/788_sp12/scribe_notes/lecture6.pdf</a>(基本就是看了这个，不过里面公式有不少笔误的。。)</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Logistic_Regression公式">Logistic Regression公式</h2><blockquote>
<p><code>Logistic Regression</code>（下面简称<code>LR</code>）是一个二分类的机器学习方法，给定一个输入向量$x_i$，输出$P(y_i|x_i)$,其中$y_i \in {0,1}$。</p>
</blockquote>
<p>作为一个二分类问题，$Y$的后验概率一般会写成这样:<br>$$P(Y=1|X)=\frac{1}{1+exp(- \omega - \sum_{i=1}^n {\omega_ix_i})}=\sigma(W^TX_i)$$<br>那么<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://kubicode.me/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://kubicode.me/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop Streaming导入自定义module]]></title>
    <link href="http://kubicode.me/2016/03/25/Hadoop/Hadoop-Streaming-Import-custom-module/"/>
    <id>http://kubicode.me/2016/03/25/Hadoop/Hadoop-Streaming-Import-custom-module/</id>
    <published>2016-03-24T16:17:54.000Z</published>
    <updated>2016-03-25T01:51:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题">问题</h2><p>今天发现用<code>Python</code>编写<code>Hadoop Streaming</code>脚本时，如果自己导入自定义的模块会报错-_-<br>列如<code>word count</code>中的<a href="http://kubicode.me/2015/11/08/Hadoop/Hadoop-Streaming-Primary-Learning-And-Debug/" target="_blank" rel="external">reducer</a>程序:<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding=utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> utils_helper</span><br><span class="line"></span><br><span class="line">lastk = <span class="keyword">None</span> <span class="comment">#这里标志最后一个k  用于控制同一个key 到一个组中</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">        w,c = line.split(<span class="string">'\t'</span>)</span><br><span class="line">        c = int(c) <span class="comment">#不转成int会比较麻烦  这是是计数</span></span><br><span class="line">        <span class="keyword">if</span> lastk == <span class="keyword">None</span>: <span class="comment">#这里是判断是否过来的是第一个key</span></span><br><span class="line">                lastk=w</span><br><span class="line">                count = utils_helper.add(count,c)</span><br><span class="line">        <span class="keyword">elif</span> lastk == w:</span><br><span class="line">                count += c</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"%s\t%s"</span>%(lastk,count)</span><br><span class="line">                lastk=w</span><br><span class="line">                count = c <span class="comment">#这里重置计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> lastk <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"%s\t%s"</span>%(lastk,count)</span><br></pre></td></tr></table></figure></p>
<p>故意使用一个自定义模块来测试<code>utils_helper.py</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x+y</span><br></pre></td></tr></table></figure></p>
<p>如果本地跑起来是(就是本地DEBUG)就可以正常跑的，但是放到<code>Hadoop</code>集群上跑的时候,使用的启动命令为:</p>
<pre><code>hadoop jar $HADOOP_HOME/share/hadoop/tools/lib/hadoop-streaming-2.7.0.jar \
-<span class="ruby">input /yyl/data/line.txt \
</span>-<span class="ruby">output /yyl/test/ouput/streaming2 \
</span>-<span class="ruby">mapper <span class="string">"python word_count_mapper.py"</span> \
</span>-<span class="ruby">reducer <span class="string">"python word_count_reducer.py"</span> \
</span>-<span class="ruby">file <span class="variable">$HADOOP_HOME</span>/runjar/pyscript/word_count_mapper.py \
</span>-<span class="ruby">file <span class="variable">$HADOOP_HOME</span>/runjar/pyscript/word_count_reducer.py \
</span>-<span class="ruby">file <span class="variable">$HADOOP_HOME</span>/runjar/pyscript/utils_helper.py \</span>
</code></pre><p>可以发现跑到<code>reducer</code>阶段时会报错:</p>
<pre><code><span class="number">16</span>/<span class="number">03</span>/<span class="number">24</span> <span class="number">12</span>:<span class="number">11</span>:<span class="number">40</span> INFO mapreduce<span class="class">.Job</span>: Running job: job_1458827745768_0018
<span class="number">16</span>/<span class="number">03</span>/<span class="number">24</span> <span class="number">12</span>:<span class="number">11</span>:<span class="number">53</span> INFO mapreduce<span class="class">.Job</span>: Job job_1458827745768_0018 running <span class="keyword">in</span> uber mode : false
<span class="number">16</span>/<span class="number">03</span>/<span class="number">24</span> <span class="number">12</span>:<span class="number">11</span>:<span class="number">53</span> INFO mapreduce<span class="class">.Job</span>:  map <span class="number">0%</span> reduce <span class="number">0%</span>
<span class="number">16</span>/<span class="number">03</span>/<span class="number">24</span> <span class="number">12</span>:<span class="number">12</span>:<span class="number">12</span> INFO mapreduce<span class="class">.Job</span>:  map <span class="number">100%</span> reduce <span class="number">0%</span>
<span class="number">16</span>/<span class="number">03</span>/<span class="number">24</span> <span class="number">12</span>:<span class="number">12</span>:<span class="number">22</span> INFO mapreduce<span class="class">.Job</span>: Task Id : attempt_1458827745768_0018_r_000000_0, Status : FAILED
Error: java<span class="class">.lang</span><span class="class">.RuntimeException</span>: PipeMapRed.<span class="function"><span class="title">waitOutputThreads</span><span class="params">()</span></span>: subprocess failed with <span class="tag">code</span> <span class="number">2</span>
    at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.streaming</span><span class="class">.PipeMapRed</span><span class="class">.waitOutputThreads</span>(PipeMapRed<span class="class">.java</span>:<span class="number">322</span>)
    at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.streaming</span><span class="class">.PipeMapRed</span><span class="class">.mapRedFinished</span>(PipeMapRed<span class="class">.java</span>:<span class="number">535</span>)
    at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.streaming</span><span class="class">.PipeReducer</span><span class="class">.close</span>(PipeReducer<span class="class">.java</span>:<span class="number">134</span>)
    at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.io</span><span class="class">.IOUtils</span><span class="class">.cleanup</span>(IOUtils<span class="class">.java</span>:<span class="number">244</span>)
    at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.ReduceTask</span><span class="class">.runOldReducer</span>(ReduceTask<span class="class">.java</span>:<span class="number">459</span>)
    at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.ReduceTask</span><span class="class">.run</span>(ReduceTask<span class="class">.java</span>:<span class="number">392</span>)
    at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.YarnChild</span>$<span class="number">2</span>.<span class="function"><span class="title">run</span><span class="params">(YarnChild.java:<span class="number">163</span>)</span></span>
    at java<span class="class">.security</span><span class="class">.AccessController</span><span class="class">.doPrivileged</span>(Native Method)
    at javax<span class="class">.security</span><span class="class">.auth</span><span class="class">.Subject</span><span class="class">.doAs</span>(Subject<span class="class">.java</span>:<span class="number">415</span>)
    at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.security</span><span class="class">.UserGroupInformation</span><span class="class">.doAs</span>(UserGroupInformation<span class="class">.java</span>:<span class="number">1657</span>)
    at org<span class="class">.apache</span><span class="class">.hadoop</span><span class="class">.mapred</span><span class="class">.YarnChild</span><span class="class">.main</span>(YarnChild<span class="class">.java</span>:<span class="number">158</span>)
</code></pre><p>这就疼了，代码应该没问题呀，尝试了好几遍之后还是这个错误。。。-_-!!</p>
<h2 id="解决方案">解决方案</h2><p>后来在<code>stackoverflow</code>发现有人问了同样的问题，并且我使用其中一个方案解决了:</p>
<pre><code>When Hadoop-Streaming starts <span class="keyword">the</span> python scripts, your python <span class="keyword">script</span>'s path <span class="keyword">is</span> <span class="keyword">where</span> <span class="keyword">the</span> <span class="keyword">script</span> <span class="type">file</span> really <span class="keyword">is</span>. However, hadoop starts them <span class="keyword">at</span> './', <span class="keyword">and</span> your lib.py(<span class="keyword">it</span>'s a symlink) <span class="keyword">is</span> <span class="keyword">at</span> './', too. So, <span class="keyword">try</span> <span class="keyword">to</span> add 'sys.path.append(<span class="string">"./"</span>)' <span class="keyword">before</span> you import lib.py like this: 
import sys
sys.path.append('./')
import lib
</code></pre><blockquote>
<p><code>lib.py</code>表示自定义包</p>
</blockquote>
<p>应该就是<code>-file</code>上传到计算机器之后文件路径的问题产生的，不过感觉他的理由有点疑惑，按他说的如果我上传之后会通过软连接组织到同一目录下再使用，所以如果直接导入包可能会出问题，那我如果上传之前就是在同一目录下应该就不会出问题吧？？这里并不是很理解，但是至少是导入包的问题是解决了^_^</p>
<h2 id="参考">参考</h2><ol>
<li><a href="http://stackoverflow.com/questions/18150208/how-to-import-a-custom-module-in-a-mapreduce-job" target="_blank" rel="external">http://stackoverflow.com/questions/18150208/how-to-import-a-custom-module-in-a-mapreduce-job</a></li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="问题">问题</h2><p>今天发现用<code>Python</code>编写<code>Hadoop Streaming</code>脚本时，如果自己导入自定义的模块会报错-_-<br>列如<code>word count</code>中的<a href="http://kubicode.me/2015/11/08/Hadoop/Hadoop-Streaming-Primary-Learning-And-Debug/">reducer</a>程序:<br>]]>
    
    </summary>
    
      <category term="Hadoop" scheme="http://kubicode.me/tags/Hadoop/"/>
    
      <category term="Hadoop" scheme="http://kubicode.me/categories/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[小技巧]让Hexo在使用Mathjax时支持多行公式]]></title>
    <link href="http://kubicode.me/2016/03/18/Hexo/The-Trick-about-Hexo-Support-MutliLine-Equation-using-Mathjax/"/>
    <id>http://kubicode.me/2016/03/18/Hexo/The-Trick-about-Hexo-Support-MutliLine-Equation-using-Mathjax/</id>
    <published>2016-03-18T01:46:24.000Z</published>
    <updated>2016-03-28T15:42:26.000Z</updated>
    <content type="html"><![CDATA[<p>还是在<code>Hexo</code>中使用<code>Mathjax</code>写<code>Latex</code>公式的问题，在需要些多行的公式的时候，<br>例如:</p>
<pre><code><span class="command">\begin</span><span class="special">{</span>equation<span class="special">}</span><span class="command">\begin</span><span class="special">{</span>split<span class="special">}</span> a<span class="special">&amp;</span>=b+c-d<span class="command">\\</span>
<span class="special">&amp;</span><span class="command">\quad</span> +e-f<span class="command">\\</span>
<span class="special">&amp;</span>=g+h<span class="command">\\</span>
<span class="special">&amp;</span> =i 
<span class="command">\end</span><span class="special">{</span>split<span class="special">}</span><span class="command">\end</span><span class="special">{</span>equation<span class="special">}</span>
</code></pre><p>其中:</p>
<ol>
<li><code>begin</code>和<code>end</code>表示公式的起始</li>
<li><code>\\</code>符号表示换行</li>
<li><code>&amp;</code>表示对齐</li>
</ol>
<a id="more"></a>
<p>结果渲染到html页面之后结果是这样的:<br><img src="/img/The-Trick-about-Hexo-Support-MutliLine-Equation-using-Mathjax/error.png" with="500px"></p>
<p>完全没换行啊，而且又有莫名其妙的空格，按照之前的经验，估计是<code>markdown</code>渲染的<code>html</code>的时候出了问题<br><img src="/img/The-Trick-about-Hexo-Support-MutliLine-Equation-using-Mathjax/error_code.png"></p>
<p>发现两个问题:</p>
<ol>
<li><code>&amp;</code>符号被转义成了<code>&amp;amp;</code></li>
<li>双反斜杠<code>\\</code>被转义成功了<code>\</code></li>
</ol>
<p>这就是公式没换行的原因，肯定是<code>marked.js</code>里面做了处理，不过仔细看<code>Mathjax</code>脚本的配置项中有一项为<code>processEscapes: true</code>，说明<code>MathJax</code>是支持转义符号的，所以类似<code>&amp;amp;</code>是不需要额外处理的。</p>
<p>那么压力就到了解反斜杠问题，最粗暴的是讲反斜杠的转义从<code>marked.js</code>里面去掉，但是可能会影响其他功能，既然两根反斜杠是转为一根，而<code>Latex</code>是两个换行，最简单的方法就是写4个反斜杠:</p>
<pre><code><span class="command">\begin</span><span class="special">{</span>equation<span class="special">}</span><span class="command">\begin</span><span class="special">{</span>split<span class="special">}</span> a<span class="special">&amp;</span>=b+c-d<span class="command">\\</span><span class="command">\\</span>
<span class="special">&amp;</span><span class="command">\quad</span> +e-f<span class="command">\\</span><span class="command">\\</span>
<span class="special">&amp;</span>=g+h<span class="command">\\</span><span class="command">\\</span>
<span class="special">&amp;</span> =i 
<span class="command">\end</span><span class="special">{</span>split<span class="special">}</span><span class="command">\end</span><span class="special">{</span>equation<span class="special">}</span>
</code></pre><p>就可以得到期待的结果了:</p>
<center><img src="/img/The-Trick-about-Hexo-Support-MutliLine-Equation-using-Mathjax/right.png"></center>

<p>这种处理就不影响<code>Hexo</code>自身的功能，又可以满足多行公式的书写^_^</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>还是在<code>Hexo</code>中使用<code>Mathjax</code>写<code>Latex</code>公式的问题，在需要些多行的公式的时候，<br>例如:</p>
<pre><code><span class="command">\begin</span><span class="special">{</span>equation<span class="special">}</span><span class="command">\begin</span><span class="special">{</span>split<span class="special">}</span> a<span class="special">&amp;</span>=b+c-d<span class="command">\\</span>
<span class="special">&amp;</span><span class="command">\quad</span> +e-f<span class="command">\\</span>
<span class="special">&amp;</span>=g+h<span class="command">\\</span>
<span class="special">&amp;</span> =i 
<span class="command">\end</span><span class="special">{</span>split<span class="special">}</span><span class="command">\end</span><span class="special">{</span>equation<span class="special">}</span>
</code></pre><p>其中:</p>
<ol>
<li><code>begin</code>和<code>end</code>表示公式的起始</li>
<li><code>\\</code>符号表示换行</li>
<li><code>&amp;</code>表示对齐</li>
</ol>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://kubicode.me/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://kubicode.me/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[修复Hexo写Mathjax公式多个下标失效的问题]]></title>
    <link href="http://kubicode.me/2016/03/16/Hexo/Fix-Hexo-Bug-In-Mathjax/"/>
    <id>http://kubicode.me/2016/03/16/Hexo/Fix-Hexo-Bug-In-Mathjax/</id>
    <published>2016-03-16T15:25:29.000Z</published>
    <updated>2016-03-28T01:47:42.000Z</updated>
    <content type="html"><![CDATA[<pre><code>这应该严格意义上不算Hexo的bug，但是在写Mathjax的时候就会踩中-_-
</code></pre><blockquote>
<p>说起<code>Markdown</code>写文章时，加粗的第一反应是<code>**</code>，斜体的第一反应是<code>*</code>，因为各种<code>Markdown</code>格式规范的文章里面都是这么教的，但是你不知道的是<code>__</code>可以支持粗体，<code>_</code>可以支持斜体，一般而言这是没什么问题，但是当在写<code>Latex</code>（<code>Hexo</code>里使用<code>Mathjax</code>实现）数据公式时，<code>_</code>表示下标，并且使用频率很高，当一行里面有多个<code>_</code>出现时，<code>Hexo</code>进行解析导致所期待的公式失效。</p>
</blockquote>
<p>自从用<code>Hexo</code>写数学公式的时候，就发现一点小问题，公式复杂了，在<code>Hexo</code>里面就不<code>work</code>，起初以为是<code>Mathjax</code>的支持不完善的缘故，后来发现用了<code>Mathjax</code>的其他博客里面都可以写复杂的公式，而今天又遇到了这个问题：<br>我的公式文本是:<br><code>对于每个$X_i$，$P(X_i|Y=y_k)$服从高斯分布$N(\mu_{ik},\sigma_i)$</code><br>结果生成页面查看之后却发现:<br><a id="more"></a></p>
<p><img src="/img/Fix-Hexo-Bug-In-Mathjax/error_display.png" width="500px"><br>这完全不是我期待的。。。数据公式完全没呈现，并且还变斜体了..<br>最初怀疑是不是公式写错了，结果每个公式去<a href="http://latex.codecogs.com/eqneditor/editor.php" target="_blank" rel="external">在线Latex编辑器</a>里面测试之后都是通过的。。。 这难道<code>Mathjax</code>又不支持了吗？？</p>
<p>趁着周末，得把这个问题解决一把~搞个单页再引用<code>Mathjax</code>之后上面的公式是<code>work</code>的，看<code>Hexo</code>里面渲染的html惊奇的发现:<br><img src="/img/Fix-Hexo-Bug-In-Mathjax/error_code.png" width="500px"><br>下划线<code>_</code>被渲染成<code>&lt;em&gt;</code>标签了，难怪<code>Mathjax</code>公式无法呈现了，<br>接下来<code>Hexo</code>的<code>Markdown</code>渲染引擎:</p>
<pre><code>yans-MacBook-Pro:node_modules yanyl$ grep -r \<span class="variable">&lt;em\&gt;</span> .
./hexo/node_modules/bunyan/docs/bunyan.<span class="number">1</span>.html:<span class="variable">&lt;em&gt;</span>names<span class="variable">&lt;/em&gt;</span> or numeric values. (See 'Log Levels' below.)<span class="variable">&lt;/p&gt;</span><span class="variable">&lt;/dd&gt;</span>
./hexo/node_modules/bunyan/docs/bunyan.<span class="number">1</span>.html:<span class="variable">&lt;dt&gt;</span><span class="variable">&lt;code&gt;</span>-L<span class="variable">&lt;/code&gt;</span>, <span class="variable">&lt;code&gt;</span>--time local<span class="variable">&lt;/code&gt;</span><span class="variable">&lt;/dt&gt;</span><span class="variable">&lt;dd&gt;</span><span class="variable">&lt;p&gt;</span>Display the time field <span class="keyword">in</span> <span class="variable">&lt;em&gt;</span>local<span class="variable">&lt;/em&gt;</span> time, rather than the <span class="keyword">default</span> UTC
./hexo-renderer-marked/node_modules/marked/lib/marked.js:  return '<span class="variable">&lt;em&gt;</span>' + text + '<span class="variable">&lt;/em&gt;</span>';
./hexo-renderer-marked/node_modules/marked/marked.<span class="keyword">min</span>.js:(function(){var <span class="built_in">block</span>={newline:/^\n+
</code></pre><blockquote>
<p>最后一个<code>marked.min.js</code>因为是单行的，所以后面的不贴了</p>
</blockquote>
<p><code>&lt;em&gt;</code>标签的渲染应该就在<code>marked.js</code>或者<code>marked.min.js</code>中，</p>
<pre><code>yans-MacBook-<span class="string">Pro:</span>node_modules yanyl$ grep -r <span class="string">"marked.js"</span> .
.<span class="regexp">/hexo-renderer-marked/</span>node_modules<span class="regexp">/marked/</span>bower.<span class="string">json:</span>  <span class="string">"main"</span>: <span class="string">"lib/marked.js"</span>,
.<span class="regexp">/hexo-renderer-marked/</span>node_modules<span class="regexp">/marked/</span>component.<span class="string">json:</span>  <span class="string">"scripts"</span>: [<span class="string">"lib/marked.js"</span>],
.<span class="regexp">/hexo-renderer-marked/</span>node_modules<span class="regexp">/marked/</span>component.<span class="string">json:</span>  <span class="string">"main"</span>: <span class="string">"lib/marked.js"</span>,
.<span class="regexp">/hexo-renderer-marked/</span>node_modules<span class="regexp">/marked/</span><span class="string">Makefile:</span>    <span class="annotation">@cp</span> lib/marked.js marked.js
.<span class="regexp">/hexo-renderer-marked/</span>node_modules<span class="regexp">/marked/</span><span class="string">Makefile:</span>    <span class="annotation">@uglifyjs</span> --comments <span class="string">'/\*[^\0]+?Copyright[^\0]+?\*/'</span> -o marked.min.js lib/marked.js
.<span class="regexp">/hexo-renderer-marked/</span>node_modules<span class="regexp">/marked/</span><span class="string">Makefile:</span>    <span class="annotation">@rm</span> marked.js
.<span class="regexp">/hexo-renderer-marked/</span>node_modules<span class="regexp">/marked/</span>man/marked.1:.TH marked <span class="number">1</span> <span class="string">"2014-01-31"</span> <span class="string">"v0.3.1"</span> <span class="string">"marked.js"</span>
.<span class="regexp">/hexo-renderer-marked/</span>node_modules<span class="regexp">/marked/</span><span class="keyword">package</span>.<span class="string">json:</span>  <span class="string">"main"</span>: <span class="string">"./lib/marked.js"</span>,
.<span class="regexp">/hexo-renderer-marked/</span>node_modules<span class="regexp">/marked/</span>README.<span class="string">md:</span>  &lt;script src=<span class="string">"lib/marked.js"</span>&gt;&lt;/script&gt;
yans-MacBook-<span class="string">Pro:</span>node_modules yanyl$ grep -r <span class="string">"marked.min.js"</span> .
.<span class="regexp">/hexo-renderer-marked/</span>node_modules<span class="regexp">/marked/</span><span class="string">Makefile:</span>    <span class="annotation">@uglifyjs</span> --comments <span class="string">'/\*[^\0]+?Copyright[^\0]+?\*/'</span> -o marked.min.js lib/marked.js
.<span class="regexp">/hexo-renderer-marked/</span>node_modules<span class="regexp">/marked/</span><span class="string">Makefile:</span>    <span class="annotation">@rm</span> marked.min.js
</code></pre><p>进一步查找可以发现<code>marked.min.js</code>是<code>marked.js</code>的一个压缩版本，并无其他的模块使用，那么进入<code>marked.js</code>中，可以找到<code>&lt;em&gt;</code>的渲染规则:<br><img src="/img/Fix-Hexo-Bug-In-Mathjax/fix1.png" width="500px"><br>和<br><img src="/img/Fix-Hexo-Bug-In-Mathjax/fix2.png" width="500px"></p>
<p>可以发现<code>&lt;em&gt;</code>标签除了<code>*</code>可以渲染，<code>_</code>同样也可以渲染，那么这样就通了<br>解决问题最方便的方法就是关于<code>_</code>渲染，直接将<code>|</code>左侧的<code>_</code>正则匹配删除即可</p>
<p>然后再重新生成页面，刷新可以发现：<br><img src="/img/Fix-Hexo-Bug-In-Mathjax/correct_display.png" width="500px"><br>终于得到期望的结果了</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>这应该严格意义上不算Hexo的bug，但是在写Mathjax的时候就会踩中-_-
</code></pre><blockquote>
<p>说起<code>Markdown</code>写文章时，加粗的第一反应是<code>**</code>，斜体的第一反应是<code>*</code>，因为各种<code>Markdown</code>格式规范的文章里面都是这么教的，但是你不知道的是<code>__</code>可以支持粗体，<code>_</code>可以支持斜体，一般而言这是没什么问题，但是当在写<code>Latex</code>（<code>Hexo</code>里使用<code>Mathjax</code>实现）数据公式时，<code>_</code>表示下标，并且使用频率很高，当一行里面有多个<code>_</code>出现时，<code>Hexo</code>进行解析导致所期待的公式失效。</p>
</blockquote>
<p>自从用<code>Hexo</code>写数学公式的时候，就发现一点小问题，公式复杂了，在<code>Hexo</code>里面就不<code>work</code>，起初以为是<code>Mathjax</code>的支持不完善的缘故，后来发现用了<code>Mathjax</code>的其他博客里面都可以写复杂的公式，而今天又遇到了这个问题：<br>我的公式文本是:<br><code>对于每个$X_i$，$P(X_i|Y=y_k)$服从高斯分布$N(\mu_{ik},\sigma_i)$</code><br>结果生成页面查看之后却发现:<br>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://kubicode.me/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://kubicode.me/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在信息检索中Term之间的Proximity计算研究]]></title>
    <link href="http://kubicode.me/2016/02/23/Search%20Engine/Proximity-Measures-In-Information-Retrieval/"/>
    <id>http://kubicode.me/2016/02/23/Search Engine/Proximity-Measures-In-Information-Retrieval/</id>
    <published>2016-02-23T12:58:43.000Z</published>
    <updated>2016-03-23T07:28:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="为啥要做Proximity计算">为啥要做Proximity计算</h2><p>先来看下信息检索/搜索引擎 的一般架构流程:</p>
<ol>
<li>对<code>Doc</code>进行分词,这些分词也叫做<code>Term</code>，然后离线做各种计算</li>
<li>将这些<code>Term</code>灌入倒排索引中</li>
<li>用户查询</li>
<li>根据倒排召回命中<code>Term</code>的文档</li>
<li>将文档根据各个<code>Term</code>算分排序</li>
</ol>
<p>其实可以发现这里查的<code>Term</code> 都是<code>bag-of-words</code>的形式，并且第五步的算法也一般是在线的，所以基本不会做全文扫描之类的事情，那么这样的话问题就来了：<br><a id="more"></a></p>
<pre><code>如果搜索“红色连衣裙”,则可能会出现下面的文档:
<span class="number">1.</span>xxxx红色连衣裙xxxx
<span class="number">2.</span>红色高跟鞋配连衣裙
很明显文档<span class="number">1</span>的相关性比<span class="number">2</span>要高，但是此时如果仅仅是bag-<span class="keyword">of</span>-<span class="property">words</span>模型就很难保证<span class="number">1</span>的相关性分要比<span class="number">2</span>高
</code></pre><p>所以一般的搜索引擎还有一个叫做<code>Proximity Measures</code>的特征计算，可以理解为计算文档里面出现的<code>query Term</code>的相近程度，为了保证可行性，降低计算的复杂度，一般也只会计算两个<code>Term</code>之间的<code>Proximity</code>分</p>
<h2 id="使用距离度量">使用距离度量</h2><p>这种方式主要是计算<code>Term</code>之间距离作为<code>Proximity</code>得分，主要分两大类:</p>
<ol>
<li><code>Span-based</code>:使用时将全部的<code>query term</code>丢进去一起算距离</li>
<li><code>Distance aggregation</code>:先算两两之间的距离，再聚集起来</li>
</ol>
<p>假设现在有文档<code>D = t1, t2, t1, t3, t5, t4, t2, t3, t4</code>，基于<code>D</code>集合来讲讲各个距离的计算方式<br><strong>Span-based</strong></p>
<ul>
<li><code>Span</code>:在文档中可以覆盖所有term的最小距离称为<code>Span</code>，<strong>需要包含所有重复的term</strong><br>  比如$Q=t1,t2$这个查询的$Span=7$</li>
<li><code>MinCover</code>:在文档中可以覆盖所有term的最小距离称为<code>MinCover</code>,<strong>每个term至少被包含一次</strong><br>  比如这里的$Q=t1,t2$查询的$MinCover=1$</li>
</ul>
<p><strong>Distance aggregation</strong></p>
<blockquote>
<p>这种方式计算的最近单元是计算一个term pair的最小距离，使用$Dis(t_i,t_j;D)$来表示</p>
</blockquote>
<ul>
<li><code>MinDist(Minimum pair distance)</code>:计算所有pair的最小距离的最小值,<br>  <center>$MinDist=min_{q_1,q_2 \in Q \cap D,q_1 \neq q_2} Dis(q_1,q_2;D)$</center><br>比如$Q={t1,t2,t3}$，则$MinDist=min(1,2,3)=1$</li>
<li><code>AveDist(Average pair distance)</code>:计算所有pair的最小距离的平均值，<br>  <center>$AveDist=\frac{2}{n \cdot (n+1)}min_{q_1,q_2 \in Q \cap D,q_1 \neq q_2} Dis(q_1,q_2;D)$</center><br>比如$Q={t1,t2,t3}$，则$AveDist=(1+2+3)/3=2$</li>
<li><code>MaxDist(Maximum pair distance)</code>:与<code>MinDist</code>正好相反，它是求最大值<br>  <center>$MinDist=max_{q_1,q_2 \in Q \cap D,q_1 \neq q_2} Dis(q_1,q_2;D)$</center><br>  比如$Q={t1,t2,t3}$，则$MaxDist=max(1,2,3)=3$</li>
</ul>
<p>文献中实验表明:</p>
<ol>
<li><code>Span-based</code>为考虑到各个文档长度，以各自文档的长度最为归一化因子进行归一化之后效果要好一些</li>
<li><code>Distance aggregation</code>系列一般比<code>Span-based</code>的效果要好</li>
<li><code>Distance aggregation</code>中<code>MinDist</code>的效果最好</li>
</ol>
<p>但是在一般使用过程中不会直接将距离作为<code>Proximity</code>的值，现将$\delta(Q,D)$作为查询词在各个文档的中的距离度量，$\delta(Q,D)$最小表明查询词与文档越相关，而在使用过程中一般以这个相关性越大最好，这将这个相关性记为:$\pi(Q,D)$，则使用下面的公式来转换:<br>$$\pi(Q,D)=log(\alpha + exp(- \delta(Q,D)))$$</p>
<blockquote>
<p>$\alpha$可以作为调节因子</p>
</blockquote>
<p>使用这种方式的度量最大的优点就是方便，但是单独用起来效果可能不怎么理解，并且波动性较大.~</p>
<h2 id="引入BM25模型">引入BM25模型</h2><p>主要对<code>bi-term</code>进行<code>BM25</code>得分的计算，这里<code>BM25</code>的计算方式可以按传统的进行，<a href="http://kubicode.me/2016/01/26/Search%20Engine/Study-BM25-For-Query-Document-Relevance/" target="_blank" rel="external">参考这个</a> </p>
<p>关于<code>bi-term</code>的构建主要有两种方式:</p>
<ol>
<li>直接使用<code>B-Gram</code>:认为相邻两个<code>term</code>是有依赖的，所以可以直接使用<code>B-Gram</code>的方式来构建</li>
<li>使用滑窗的方式:认为一个窗口里面的两两<code>term</code>有依赖，因此可以对他们进行两两组合，这个窗口大小一般会小于8</li>
</ol>
<blockquote>
<p>其实更好的应该是<code>依存</code>关系来构建这个<code>bi-term</code>，不过上述的几种方式构建出来的<code>pair</code>都会很大，所以还需要其他一些方式来剪枝</p>
</blockquote>
<h1 id="持续研究中~~~">持续研究中~~~</h1><h2 id="参考">参考</h2><ol>
<li>2007-An Exploration of Proximity Measures in Information Retrieval</li>
<li>2005-A Markov random field model for term dependencies</li>
<li>2010-How good is a span of terms?: exploiting proximity to improve web retrieval</li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="为啥要做Proximity计算">为啥要做Proximity计算</h2><p>先来看下信息检索/搜索引擎 的一般架构流程:</p>
<ol>
<li>对<code>Doc</code>进行分词,这些分词也叫做<code>Term</code>，然后离线做各种计算</li>
<li>将这些<code>Term</code>灌入倒排索引中</li>
<li>用户查询</li>
<li>根据倒排召回命中<code>Term</code>的文档</li>
<li>将文档根据各个<code>Term</code>算分排序</li>
</ol>
<p>其实可以发现这里查的<code>Term</code> 都是<code>bag-of-words</code>的形式，并且第五步的算法也一般是在线的，所以基本不会做全文扫描之类的事情，那么这样的话问题就来了：<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://kubicode.me/tags/Machine-Learning/"/>
    
      <category term="Search Engine" scheme="http://kubicode.me/tags/Search-Engine/"/>
    
      <category term="Search Engine" scheme="http://kubicode.me/categories/Search-Engine/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[针对BM25遇到长文档时失效情况的一种高效解决方案]]></title>
    <link href="http://kubicode.me/2016/02/16/Search%20Engine/BM25-Fails-When-The-Docments-Are-Very-Long/"/>
    <id>http://kubicode.me/2016/02/16/Search Engine/BM25-Fails-When-The-Docments-Are-Very-Long/</id>
    <published>2016-02-16T09:17:19.000Z</published>
    <updated>2016-02-27T06:58:10.000Z</updated>
    <content type="html"><![CDATA[<pre><code>B<span class="title">M25</span>在长文档下会失效，文本是记录SIGIR上的一个Paper的解决方案~
</code></pre><h2 id="当BM25遇到长文档">当BM25遇到长文档</h2><p>文档相关性模型-<code>BM25</code>的拟合公式如下:</p>
<center>$\sum_{i\in Q} log \frac {(r_i+0.5)((N-R)-(n_i-r_i)+0.5)}{(n_i-r_i+0.5)(R-r_i+0.5)} \cdot \frac{(k_1+1)f_i}{K+f_i} \cdot \frac{(k_2+1)qf_i}{k_2+qf_i}$</center>

<p>其中第一部分表示<code>BIM</code>的值，第二部分表示在文档中的权重，第三部分表示在查询词中的权重，(具体符号解释参考之前的<a href="http://kubicode.me/2016/01/26/Search%20Engine/Study-BM25-For-Query-Document-Relevance/" target="_blank" rel="external">BM25介绍</a>)现将第二部分单独拿出来:</p>
<p><center>$f(q,D)=\frac{(k_1+1) \times TF}{k_1 \times ((1-b)+b \cdot \frac{dl}{avdl} )+TF}=\frac{(k_1+1) \times c’(q,D)}{k_1+c’(q,D)}$</center><br>其中:<br><a id="more"></a></p>
<p><center>$c’(q,D)=\frac{TF}{1-b+b \cdot \frac{dl}{avdl}}$</center><br>现在先来做一个假设，假设当前有个文档<code>很长很长</code>，也就是$dl$这个值很大，则可以发现$c’(q,D)$就会很小，小到接近于0，因此会导致文档部分的因子$f(q,D)$也会接近于0，几乎和这个词没有出现在这个文档一样..-_-</p>
<p>在这种情况下，针对长文档，<code>BM25</code>的效果会比较差<br>下面的图就是<code>BM25</code>在不同文档长度下的实验</p>
<p><img src="/img/BM25-Fails-When-The-Docments-Are-Very-Long/doc-len-comp.png" width="600px"></p>
<p>可以发现在<code>BM25</code>中，随着文档的变长，相关性在变高，但是其被检索的概率并没有随着相关性的趋势而变高，也就是长文档使用<code>BM25</code>的效果变得比较差。</p>
<h2 id="高效解决方案">高效解决方案</h2><p>为了避免长文档在<code>BM25</code>的相关性中被惩罚，我们需要对文档权重$f(q,D)$做一个规范化约束，但是由于<code>BM25</code>早已被公认为是一种比较有效的文档相关性，所以这个约束不能破坏掉<code>BM25</code>自身的特征.</p>
<p>我们希望规范化约束之后保持以下三点特性:</p>
<ol>
<li>当$c’(q,D)=0$的时候，$f(q,D)$也为0</li>
<li>随着$c’(q,D)$的变大，$f(q,D)$也需要呈现单调递增，但是会趋向于一个最大值</li>
<li>随着$c’(q,D)$的减少，$f(q,D)$会单调递减趋向于一个最小值，但是这个最小值需要足够大</li>
</ol>
<blockquote>
<p>就是因为原生的<code>BM25</code>不满足第3点，所以会出现在长文档下<code>BM25</code>出现失效的情况</p>
</blockquote>
<!-- 
f'(q,D)=\left\{
\begin{aligned}
\frac{(k_1+1) \cdot [c'(q,D)+\delta ]}{k_1 + [c'(q,D)+\delta ]}  & \quad if \quad c'(q,D)>0\\
0 & \quad otherwise\\
\end{aligned}
\right.
-->
<p>而下面的改进$f’(q,D)$正好可以满足上述三个特性:</p>
<p><img src="/img/BM25-Fails-When-The-Docments-Are-Very-Long/gj.gif" alt=""></p>
<p>使用时针对原来的$c’(q,D)$值增加了一个平滑项$\delta$，增加了平滑项之后依然满足<code>第1、2点</code>特性，并且当$c’(q,D)&gt;0$的时候$f’(q,D)$有一个下界:</p>
<p><center>$\frac{(k_1+1) \cdot \delta}{k_1+ \delta}$</center><br>这样也正好可以满足<code>第3点</code>特性</p>
<p>进行该项小改进之后的模型称为<code>BM25L</code>,遇到长文档时并不会失效，并且还保持原有的<code>BM25</code>特性.</p>
<h2 id="实验效果验证">实验效果验证</h2><p>针对多个数据集  ，使用不同的调节参数$b$,$k_1$,$\delta$进行试验:<br><img src="/img/BM25-Fails-When-The-Docments-Are-Very-Long/exp.png"></p>
<p>在第三章图明显可以发现<code>BM25L</code>的效果对<code>BM25</code>有较大的绝对提升，其中较优的参数范围为:</p>
<ol>
<li>$b \in [0,3,0.6] $</li>
<li>$k_1 \in [1.0,2.0]$</li>
<li>$\delta = 0.5$时最优</li>
</ol>
<h2 id="参考">参考</h2><ol>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.600.16&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">When Documents Are Very Long, BM25 Fails!</a></li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>B<span class="title">M25</span>在长文档下会失效，文本是记录SIGIR上的一个Paper的解决方案~
</code></pre><h2 id="当BM25遇到长文档">当BM25遇到长文档</h2><p>文档相关性模型-<code>BM25</code>的拟合公式如下:</p>
<center>$\sum_{i\in Q} log \frac {(r_i+0.5)((N-R)-(n_i-r_i)+0.5)}{(n_i-r_i+0.5)(R-r_i+0.5)} \cdot \frac{(k_1+1)f_i}{K+f_i} \cdot \frac{(k_2+1)qf_i}{k_2+qf_i}$</center>

<p>其中第一部分表示<code>BIM</code>的值，第二部分表示在文档中的权重，第三部分表示在查询词中的权重，(具体符号解释参考之前的<a href="http://kubicode.me/2016/01/26/Search%20Engine/Study-BM25-For-Query-Document-Relevance/">BM25介绍</a>)现将第二部分单独拿出来:</p>
<p><center>$f(q,D)=\frac{(k_1+1) \times TF}{k_1 \times ((1-b)+b \cdot \frac{dl}{avdl} )+TF}=\frac{(k_1+1) \times c’(q,D)}{k_1+c’(q,D)}$</center><br>其中:<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://kubicode.me/tags/Machine-Learning/"/>
    
      <category term="Search Engine" scheme="http://kubicode.me/tags/Search-Engine/"/>
    
      <category term="Search Engine" scheme="http://kubicode.me/categories/Search-Engine/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Learning to rank学习基础]]></title>
    <link href="http://kubicode.me/2016/02/15/Machine%20Learning/Learning-To-Rank-Base-Knowledge/"/>
    <id>http://kubicode.me/2016/02/15/Machine Learning/Learning-To-Rank-Base-Knowledge/</id>
    <published>2016-02-15T02:31:43.000Z</published>
    <updated>2016-02-24T07:22:24.000Z</updated>
    <content type="html"><![CDATA[<pre><code>Learning to <span class="function"><span class="title">rank</span><span class="params">(简写 LTR、L2R)</span></span> 也叫排序学习，指的是机器学习中任何用于排序的技术。
</code></pre><h2 id="为什么要用LTR">为什么要用LTR</h2><p>传统的检索模型靠人工拟合排序公式，并通过不断的实验确定最佳的参数组合，以此来形成相关性打分。这种方式非常简单高效，应该范围也很广，比如简单的博客排序、论坛的<code>QA</code>排序等.但是也同时存在较大的问题:</p>
<ol>
<li>手动调参工作量太大</li>
<li>可能会过拟合</li>
<li>如果模型参数很多，手动调参的可用性就很低了~</li>
</ol>
<p>LTR与此思路不同，最合理的排序公式由机器学习算法来确定，而人则需要给机器学习提供训练数据,他的优势有:</p>
<ol>
<li>可以自动调节参数</li>
<li>可以融合多方面观点的(evidences)的数据</li>
<li>避免过拟合(通过正则项)</li>
</ol>
<a id="more"></a>
<h2 id="LTR基本框架">LTR基本框架</h2><p><code>LTR</code>的核心还是机器学习，只是目标不仅仅是简单的分类或者回归了，最主要的是产出文档的排序结果，它通常的工作框架如下:<br><img src="/img/Learning-To-Rank-Base-Knowledge/lrt_framework.png" width="400px"></p>
<p>所描述的步骤为:<code>训练数据获取-&gt;特征提取-&gt;模型训练-&gt;测试数据预测-&gt;效果评估</code></p>
<h2 id="训练数据的获取">训练数据的获取</h2><h4 id="人工标注">人工标注</h4><p>人工标注的数据主要有以下几大类型:</p>
<ul>
<li><p>单点标注</p>
<ul>
<li>对于每个查询文档打上绝对标签</li>
<li>二元标注：相关 vs 不相关</li>
<li><p>五级标注：完美(Perfect),出色(Excellent),好(Good),一般(Fair),差(Bad) ，一般后面两档属于不相关</p>
<blockquote>
<p>好处：标注的量少O(n)<br>坏处：难标。。。不好统一</p>
</blockquote>
</li>
</ul>
</li>
<li><p>两两标注</p>
<ul>
<li><p>对于一个查询<code>Query</code>,要标注文档$d1$比文档$d2$是否更加相关 $(q,d1)\succ (q,d2)?$</p>
<blockquote>
<p>好处：标注起来比较方便<br>坏处：标注量大 估计得有O(n^2)</p>
</blockquote>
</li>
</ul>
</li>
<li><p>列表标注</p>
<ul>
<li><p>对于一个查询<code>Query</code>，将人工理想的排序整个儿标好</p>
<blockquote>
<p>好处： 相对于上面两种，标的效果会很好<br>坏处： 这个工作量也太大了…-_-||</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="日志抽取">日志抽取</h4><p>当搜索引擎搭建起来之后用户的点击数据就变得非常好使。</p>
<pre><code>比如，结果ABC分别位于<span class="number">123</span>位，B比<span class="literal">A</span>位置低，但却得到了更多的点击，那么B的相关性可能好于<span class="literal">A</span>.
</code></pre><p>这种点击数据隐含了<code>Query</code>到文档的相关性好坏。所以一般会使用点击倒置的<code>高低位</code>结果作为训练数据.</p>
<p>但是他也是存在问题的：</p>
<ul>
<li>用户总是习惯于从上到下浏览搜索结果</li>
<li>用户点击有比较大的噪声</li>
<li>一般头查询(<code>head query</code>)才存在用户点击</li>
</ul>
<h2 id="特征提取">特征提取</h2><p>检索系统会使用一系列特征来表示一次查询，通过模型之后最终决定文档的排序顺序，这里用$q$来表示查询,$d$表示查询的文档,$occur-term$表示$q$与$d$共现的词，则提取的特征主要有以下三大类:</p>
<ul>
<li>$occur-term$与$q$特征<ul>
<li>共现在查询中的出现次数、比率等</li>
</ul>
</li>
<li>$occur-term$与$d$的特征<ul>
<li>共现在文档中的出现次数、比率等</li>
<li>共现词与文档的相关性特征:<code>BM25系列</code></li>
</ul>
</li>
<li>$d$自身特征<ul>
<li><code>PageRank</code>值</li>
<li><code>Spam</code>信息</li>
<li><code>Quality</code>质量分</li>
<li>行为分,<code>ctr</code>，<code>停留时间</code>，<code>二跳率</code>等..</li>
</ul>
</li>
</ul>
<h2 id="模型训练">模型训练</h2><p><code>LTR</code>的模型主要有单文档方法(<code>Pointwise Approach</code>)、文档对方法(<code>Pairwise Approach</code>)和列表方法(<code>Listwise Approach</code>)三大类,下面是实现他们的各种算法:</p>
<h3 id="Pointwise_Approach">Pointwise Approach</h3><pre><code><span class="variable">Pointwise</span>的处理对象是单独的一篇文档，将文档转换为特征向量之后，机器学习模型根据从训练数据中学习到的分类或者回归函数对文档打分，打分的结果就是搜索的结果.
</code></pre><p>其实就是将文档排序转为了文档的回归、分类和有序分类问题，其函数的框架为:</p>
<center>$L(F(X),y)=\sum_{i=1}^{n}l(f(x_i)-y_i)$</center><br>输入:<br>- 单个文档查询对:$(x_i,y_i)$<br>- 完全忽略上下文的关系<br>- 将标注转为数字，比如<code>Perfect-&gt;5, Excellent-&gt;4, Good-&gt;3, Fair-&gt;2, Bad-&gt;1</code><br><br>输出:<br>- 排序函数,对于给定查询文档对,能够计算出得分(score)<br><br>关于<code>Pointwise</code>下的三个分支，这张图解释的很好:<br><center><img src="/img/Learning-To-Rank-Base-Knowledge/pointwise_flow.png" width="400px"></center>

<p>其主要区别就是<code>loss function</code>不同，也就是最后的结果目标不一样:</p>
<ul>
<li><code>Classification</code>:输入的是5档类别（作为离散），最后通过分类模型输测试数据的各个档位档位的概率，然后进行加权成一个实数值</li>
<li><code>Regression</code>:输入的是5档或者2档（作为连续），最后通过回归模型输出测试数据的一个相关性实数(就是回归)</li>
<li><code>Ordinal Classification</code>:输入有序的档位，一般2档(离散),最后通过分类模型的阈值给到一个档位(应该是二分类把)</li>
</ul>
<p>实现<code>Pointwise</code>方法的主要算法有:</p>
<ul>
<li>Classification<ul>
<li>Discriminative model for IR (SIGIR 2004)</li>
<li><strong>McRank (NIPS 2007)</strong></li>
</ul>
</li>
<li>Regression<ul>
<li>Least Square Retrieval Function (TOIS 1989)</li>
<li>Regression Tree for Ordinal Class Prediction (Fundamenta Informaticae, 2000)</li>
<li><strong>Subset Ranking using Regression (COLT 2006)</strong></li>
</ul>
</li>
<li>Ordinal Classification<ul>
<li><strong>Pranking (NIPS 2002)</strong></li>
<li>OAP-BPM (EMCL 2003)</li>
<li>Ranking with Large Margin Principles (NIPS 2002)</li>
<li>Constraint Ordinal Regression (ICML 2005)</li>
</ul>
</li>
</ul>
<p><strong>优点:</strong></p>
<ul>
<li>速度快，复杂度低.</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>效果一般</li>
<li>没有考虑到文档之间的相对关系</li>
<li>忽略了文档相关度与查询的关联，比如<code>Top Query</code>排在后面的相关性比<code>Tial Query</code>排在前面的都要高，导致训练样本不一致</li>
</ul>
<h3 id="Pairwise_Approach">Pairwise Approach</h3><pre><code>对于搜索任务来说，系统接收到用户查询后，返回相关文档列表，所以问题的关键是确定文档之间的先后相对顺序关系，而<span class="variable">Pairwise</span>则将重点转向对文档关系是否合理的判断.
</code></pre><p><code>Pairwise</code>主要是讲排序问题转为了文档对顺序的判断<br>以下图为例:<br><img src="/img/Learning-To-Rank-Base-Knowledge/pairwise_example.png" width="500px"><br>对于查询<code>Q1</code>进行人工标注之后,<code>Doc2=5</code>的分数最高，其次是<code>Doc3</code>为4分，最差的是<code>Doc1</code>为3分，将此转为相对关系之后有:<code>Doc2&gt;Doc1、Doc2&gt;Doc3、Doc3&gt;Doc1</code>，而根据这个顺序关系逆向也可以得到相关性的排序顺序，所以排序问题可以很自然的转为任意两个文档关系的判断,而任意两个文档顺序的判断就称为了一个很熟悉的分类问题.<br><code>Pairwise</code>的函数框架为:</p>
<!-- $L(F(x),y)=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}(sign(y_i-y_j),f(x_i)-f(x_j))$ -->
<center><img src="/img/Learning-To-Rank-Base-Knowledge/pairwise_func.gif"></center>

<p><strong>输入</strong>:</p>
<ul>
<li>同一查询的一对文档$(x_i,x_j,sign(y_i-y_j))$</li>
<li>标注两个文档的相对关系，如果文档$x_i$比$x_j$更加相关，则$sign(y_i-y_j))=1$</li>
<li>分布保留同一查询下的文档间关系</li>
</ul>
<p><strong>输出</strong>:</p>
<ul>
<li>排序函数给出文档对的计算得分</li>
</ul>
<p>关于<code>Pairwise</code>最终的算分，其实分类和回归都可以实现:</p>
<center><img src="/img/Learning-To-Rank-Base-Knowledge/pairwise_flow.png" width="400px"></center>


<p>实现<code>Pairwise Approach</code>方法的主要算法有:</p>
<ul>
<li>Learning to Retrieve Information (SCC 1995)</li>
<li>Learning to Order Things (NIPS 1998)</li>
<li><strong>Ranking SVM (ICANN 1999)</strong></li>
<li><strong>RankBoost (JMLR 2003)</strong></li>
<li>LDM (SIGIR 2005)</li>
<li><strong>RankNet (ICML 2005)</strong></li>
<li><strong>Frank (SIGIR 2007)</strong></li>
<li>MHR(SIGIR 2007)</li>
<li><strong>GBRank (SIGIR 2007)</strong></li>
<li>QBRank (NIPS 2007)</li>
<li>MPRank (ICML 2007)</li>
<li><strong>IRSVM (SIGIR 2006)</strong></li>
<li>LambdaRank (NIPS 2006)</li>
</ul>
<p>虽然<code>Pairwise</code>方法对<code>Pointwise</code>方法做了改进，但是也明显存在两个问题:</p>
<ol>
<li>只考虑了两个文档的先后顺序，没有考虑文档出现在搜索列表中的位置</li>
<li>不同的查询，其相关文档数量差异很大，转换为文档对之后，有的查询可能有几百对文档，有的可能只有几十个，最终对机器学习的效果评价造成困难</li>
</ol>
<h3 id="Listwise_Approach">Listwise Approach</h3><pre><code>与<span class="variable">Pointwise</span>和<span class="variable">Pairwise</span>不同，<span class="variable">Listwise</span>是将一个查询对应的所有搜索结果列表作为一个训练实例，因此也称为文档列方法.
</code></pre><p>文档列方法根据$K$个训练实例训练得到最优的评分函数$F$，对于一个新的查询，函数$F$对每一个文档进行打分，之后按照得分顺序高低排序，就是对应的搜索结果.<br><code>Listwise</code>主要有两类:</p>
<ul>
<li><code>Measure specific</code>:损失函数与评估指标相关,比如:$L(F(x),y)=exp(-NDCG)$</li>
<li><code>Non-measure specific</code>:损失函数与评估指标不是显示相关,考虑了信息检索中的一些独特性质</li>
</ul>
<p>实现<code>Listwise</code>的算法主要有:</p>
<ul>
<li>Measure-specific<ul>
<li><strong>AdaRank (SIGIR 2007)</strong></li>
<li><strong>SVM-MAP (SIGIR 2007)</strong></li>
<li><strong>SoftRank (LR4IR 2007)</strong></li>
<li>RankGP (LR4IR 2007)</li>
<li>LambdaMART (inf.retr 2010)</li>
</ul>
</li>
<li>Non-measure specific<ul>
<li><strong>ListNet (ICML 2007)</strong></li>
<li><strong>ListMLE (ICML 2008)</strong></li>
<li>BoltzRank (ICML 2009)</li>
</ul>
</li>
</ul>
<blockquote>
<p>实验表明 一般<code>Listwise</code>要好于前两种排序算法，但是其复杂度是在太高了</p>
</blockquote>
<h3 id="方法对比">方法对比</h3><table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">pointwise</th>
<th style="text-align:left">pairwise</th>
<th style="text-align:left">listwise</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">输入信息的完整度</td>
<td style="text-align:left"><strong>不完全</strong></td>
<td style="text-align:left"><strong>部分完全</strong></td>
<td style="text-align:left"><strong>完全</strong></td>
</tr>
<tr>
<td style="text-align:left">输入</td>
<td style="text-align:left">$(x,y)$</td>
<td style="text-align:left">$(x_1,x_2,y)$</td>
<td style="text-align:left">$(x_1,x_2…x_n,\pi)$</td>
</tr>
<tr>
<td style="text-align:left">输出</td>
<td style="text-align:left">$f(x)$</td>
<td style="text-align:left">$f(x)$</td>
<td style="text-align:left">$f(x)$</td>
</tr>
<tr>
<td style="text-align:left">样本复杂度</td>
<td style="text-align:left">$O(n)$</td>
<td style="text-align:left">O(n^2)</td>
<td style="text-align:left">O(n!)</td>
</tr>
<tr>
<td style="text-align:left">表现</td>
<td style="text-align:left"><em>差</em></td>
<td style="text-align:left"><em>中</em></td>
<td style="text-align:left"><em>好</em></td>
</tr>
</tbody>
</table>
<h2 id="评估指标">评估指标</h2><h3 id="MAP">MAP</h3><p><code>MAP</code>(<code>Mean Average Precision</code>)表示文档在排序中的平均精度均值，是用于衡量个query查询见过的平均精度值<code>AP</code>,<br>系统检索出来的相关文档越靠前(rank 越高)，MAP就可能越高。如果系统没有返回相关文档，则准确率默认为0。</p>
<p>所以对于计算<code>AP</code>的值就是关键了,<code>MAP</code>对文档只分为两档:相关与不相关，则<code>AP</code>表示为</p>
<center>$AP=\frac{\sum_{i:relvance}^{n}P_i/R_i}{n}$</center>

<blockquote>
<p>其中$P_i$表示所有召回文档中相关文档的相对次序，$R_i$表示所有被召回的相关文档中在所有文档中的次序</p>
</blockquote>
<p>比如在某个<code>query</code>得到的排序中:<br><img src="/img/Learning-To-Rank-Base-Knowledge/map_demo.png" width="400px"><br>则他的相对顺序的表格为:</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">O</th>
<th style="text-align:left">X</th>
<th style="text-align:left">O</th>
<th style="text-align:left">O</th>
<th style="text-align:left">O</th>
<th style="text-align:left">O</th>
<th style="text-align:left">X</th>
<th style="text-align:left">X</th>
<th style="text-align:left">X</th>
<th style="text-align:left">O</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">相关文档次序</td>
<td style="text-align:left">1</td>
<td style="text-align:left"></td>
<td style="text-align:left">2</td>
<td style="text-align:left">3</td>
<td style="text-align:left">4</td>
<td style="text-align:left">5</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">6</td>
</tr>
<tr>
<td style="text-align:left">所有召回文档次序</td>
<td style="text-align:left">1</td>
<td style="text-align:left">2</td>
<td style="text-align:left">3</td>
<td style="text-align:left">4</td>
<td style="text-align:left">5</td>
<td style="text-align:left">6</td>
<td style="text-align:left">7</td>
<td style="text-align:left">8</td>
<td style="text-align:left">9</td>
<td style="text-align:left">10</td>
</tr>
<tr>
<td style="text-align:left">Precision</td>
<td style="text-align:left">1/1</td>
<td style="text-align:left"></td>
<td style="text-align:left">2/3</td>
<td style="text-align:left">3/4</td>
<td style="text-align:left">4/5</td>
<td style="text-align:left">5/6</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">6/10</td>
</tr>
</tbody>
</table>
<p>最终计算的$AP=(1/1+2/3+3/4+4/5+5/6+6/10)/6=0.78$</p>
<h3 id="NDCG">NDCG</h3><p><code>NDCG</code>表示表示归一化折损累积增益，主要是衡量实际相关性越高的文档排在越前面，它的全称是<code>Normalized Discounted Cumulative Gain</code>,也正好代表了4个部分的含义:</p>
<ul>
<li><p><code>Gain</code>:表示增益，一般相关性越高，增益值也是越大</p>
  <center>$G_i=2^{y_i}-1$</center>

<blockquote>
<p>其中$y_i$表示文档相关性档位，一般档位越高，相关性越大</p>
</blockquote>
</li>
<li><p><code>Discounted</code>:一般认为排序位置 带来的权重不同，所以会有一个折损因子</p>
  <center>$DG_i=\frac{2^{y_i}-1}{log(1+i)}$</center>

<blockquote>
<p>其中$i$为文档的排序位置，从1开始</p>
</blockquote>
</li>
<li><p><code>Cumulative</code>：表示在一次<code>query</code>查询中所有的增益累加</p>
  <center>$DCG=\sum_{i=1}^{n}{\frac{2^{y_i}-1}{log(1+i)}}$</center>
</li>
<li><p><code>Normalized</code>：为归一化，因为在不同的查询中可能<code>DCG</code>的值波动较大，这里计算各个query最理想的排序的<code>DCG</code>值作为归一化因子，也称为<code>IDCG</code></p>
  <center>$NDCG=\frac{1}{IDCG} \cdot \sum_{i=1}^{n}{\frac{2^{y_i}-1}{log(1+i)}}$</center>

</li>
</ul>
<p><code>NDCG</code>的可使用性更加广泛了，但是还是存在以下三点限制:</p>
<ol>
<li><code>NDCG</code>并没有对不相关文档进行惩罚</li>
<li><code>NDCG</code>对一些缺失的完成结果也没有进行惩罚</li>
</ol>
<h2 id="公开数据集">公开数据集</h2><ol>
<li><a href="http://research.microsoft.com/en-us/um/beijing/projects/letor/" target="_blank" rel="external">http://research.microsoft.com/en-us/um/beijing/projects/letor/</a></li>
<li><a href="http://research.microsoft.com/en-us/projects/mslr/" target="_blank" rel="external">http://research.microsoft.com/en-us/projects/mslr/</a></li>
<li><a href="http://webscope.sandbox.yahoo.com/" target="_blank" rel="external">http://webscope.sandbox.yahoo.com/</a></li>
</ol>
<h2 id="总结">总结</h2><p>在玩搜索引擎时敲定特征分的权重是非常疼的一件事儿，而<code>LTR</code>正好帮你定分，<code>LTR</code>的三种实现方法其实各有优劣：</p>
<ol>
<li>难点主要在训练样本的构建(人工或者挖日志)，另外就是训练复杂</li>
<li>虽说<code>Listwise</code>效果最好，但是天下武功唯快不破，看看这篇文章<a href="http://www.cnblogs.com/zjgtan/p/3652689.html" target="_blank" rel="external">http://www.cnblogs.com/zjgtan/p/3652689.html</a>体验下</li>
<li>在工业界用的比较多的应该还是<code>Pairwise</code>，因为他构建训练样本相对方便，并且复杂度也还可以，所以<code>Rank SVM</code>就很火啊^_^</li>
</ol>
<h2 id="参考">参考</h2><ul>
<li>《这就是搜索引擎：核心技术详解》 . 第五章</li>
<li><a href="http://blog.crackcell.com/posts/2011/12/17/a_short_intro_2_ltr.html" target="_blank" rel="external">Learning to Rank小结</a></li>
<li><a href="http://www.icst.pku.edu.cn/lcwm/course/WebDataMining/slides2012/8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8F%8A%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80.pdf" target="_blank" rel="external">机器学习及排序学习基础</a></li>
<li><a href="http://www.contem.org/2010summer/slides/LEARNING%20TO%20RANK%20TUTORIAL%20-%20tyliu.pdf" target="_blank" rel="external">Learning to Rank for Information Retrieval</a></li>
<li><a href="https://en.wikipedia.org/wiki/Discounted_cumulative_gain" target="_blank" rel="external">https://en.wikipedia.org/wiki/Discounted_cumulative_gain</a></li>
<li><a href="https://www.kaggle.com/wiki/MeanAveragePrecision" target="_blank" rel="external">https://www.kaggle.com/wiki/MeanAveragePrecision</a></li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>Learning to <span class="function"><span class="title">rank</span><span class="params">(简写 LTR、L2R)</span></span> 也叫排序学习，指的是机器学习中任何用于排序的技术。
</code></pre><h2 id="为什么要用LTR">为什么要用LTR</h2><p>传统的检索模型靠人工拟合排序公式，并通过不断的实验确定最佳的参数组合，以此来形成相关性打分。这种方式非常简单高效，应该范围也很广，比如简单的博客排序、论坛的<code>QA</code>排序等.但是也同时存在较大的问题:</p>
<ol>
<li>手动调参工作量太大</li>
<li>可能会过拟合</li>
<li>如果模型参数很多，手动调参的可用性就很低了~</li>
</ol>
<p>LTR与此思路不同，最合理的排序公式由机器学习算法来确定，而人则需要给机器学习提供训练数据,他的优势有:</p>
<ol>
<li>可以自动调节参数</li>
<li>可以融合多方面观点的(evidences)的数据</li>
<li>避免过拟合(通过正则项)</li>
</ol>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://kubicode.me/tags/Machine-Learning/"/>
    
      <category term="Search Engine" scheme="http://kubicode.me/tags/Search-Engine/"/>
    
      <category term="Machine Learning" scheme="http://kubicode.me/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[求二进制中1的个数]]></title>
    <link href="http://kubicode.me/2016/02/12/Algorithm/The-One-Occur-in-Bitnum/"/>
    <id>http://kubicode.me/2016/02/12/Algorithm/The-One-Occur-in-Bitnum/</id>
    <published>2016-02-12T12:26:05.000Z</published>
    <updated>2016-04-12T15:20:11.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>求一个二进制数字中1出现的个数
</code></pre><blockquote>
<p>这道题目面试非常常见，但是工作中也很实用，以32位int整形为例，下面列举一下一些经典的做法(主要是做记录用^_^)</p>
</blockquote>
<h2 id="遍历法">遍历法</h2><p>这个是最简单的方法，向右移位，判断最低位是否为1进行计数即可!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 普通遍历法</span><br><span class="line"> *<span class="javadoctag"> @param</span> n</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">traverseCount</span><span class="params">(<span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		n = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>该方法最直观，不过复杂度是<code>O(N)</code></p>
<h2 id="快速查找法">快速查找法</h2><p>为啥说快速呢，因为这里的复杂度是和1个个数有关，有多少1就循环多少次，该方法的设计也非常巧妙<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 快速计数法</span><br><span class="line"> *<span class="javadoctag"> @param</span> n</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quickCount</span><span class="params">(<span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		n &amp;= (n-<span class="number">1</span>);</span><br><span class="line">		count ++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大致可以这么理解</p>
<pre><code>假设当前的<span class="keyword">n</span>=7
<span class="keyword">n</span>          <span class="keyword">n</span>-1
0111    0110
0110    0101
0100    0000
</code></pre><p>复杂度是<code>O(K)</code>,其中<code>K</code>为二进制数中1个数，非常实用</p>
<h2 id="查表法">查表法</h2><p>一般整形的位数是固定的，假如我们知道每种情况下的1的个数，其实直接查表即可，但是如果是32位的整形枚举这个表的可能性不是很大，但是巧妙的方法是可以将其分割成4个8位的数字，而8位的数字就只有256种情况了，可以直接方法预设的表中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 查表法</span><br><span class="line"> *<span class="javadoctag"> @param</span> n</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchTableCount</span><span class="params">(<span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] table = </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, </span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, </span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, </span><br><span class="line">        <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, </span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, </span><br><span class="line">        <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, </span><br><span class="line">        <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, </span><br><span class="line">        <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, </span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, </span><br><span class="line">        <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, </span><br><span class="line">        <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, </span><br><span class="line">        <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, </span><br><span class="line">        <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, </span><br><span class="line">        <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, </span><br><span class="line">        <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, </span><br><span class="line">        <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, </span><br><span class="line">    &#125;; </span><br><span class="line">	<span class="comment">//直接查表得到</span></span><br><span class="line">	<span class="keyword">return</span> table[n&amp;<span class="number">0xFF</span>] + table[(n&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xFF</span>] +table[(n&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xFF</span>] +table[(n&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xFF</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法的复杂度是<code>O(N/8)</code>,占的空间也不是特别多，也是比较实用的一种</p>
<p>还有一些神奇的方法可以看<a href="http://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html" target="_blank" rel="external">http://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html</a>,写得非常赞</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>求一个二进制数字中1出现的个数
</code></pre><blockquote>
<p>这道题目面试非常常见，但是工作中也很实用，以32位int整形为例，下面列举一下一些经典的做法(主要是做记录用^_^)</p>
</blockquote>
<h2 id="遍历法">遍历法</h2><p>这个是最简单的方法，向右移位，判断最低位是否为1进行计数即可!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 普通遍历法</span><br><span class="line"> *<span class="javadoctag"> @param</span> n</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">traverseCount</span><span class="params">(<span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		n = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://kubicode.me/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://kubicode.me/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Hexo中离线安装数据工具包-Mathjax]]></title>
    <link href="http://kubicode.me/2016/01/27/Hexo/Offline-Install-Mathjax-In-Hexo-Jacman/"/>
    <id>http://kubicode.me/2016/01/27/Hexo/Offline-Install-Mathjax-In-Hexo-Jacman/</id>
    <published>2016-01-27T09:30:11.000Z</published>
    <updated>2016-02-03T06:24:54.000Z</updated>
    <content type="html"><![CDATA[<pre><code>这里与其说安装，还是不如直接拷贝相应文件到hexo目录
</code></pre><p>最近尝试在写<code>blog</code>的时候用<code>Latex</code>来写数学公式，写起来还是极其方便灵活滴，但是，但是其速度慢如爬蜗牛，一般修改一下，在刷新一下要<code>4~5s</code>才能将公式渲染出来，其书写效率也太低了，总之我不能忍，所以准备将其<code>MathJax</code>放在本地.</p>
<ol>
<li>一方面是希望加快公式的渲染速度</li>
<li>另一方面也是希望能支持我在断网的情况下也能正常使用<code>Mathjax</code></li>
</ol>
<a id="more"></a>
<p>我用的是<a href="http://wuchong.me/" target="_blank" rel="external">Jark</a>大神的<code>jacman</code>主题，在简单<code>grep</code>查找之后可以发现<code>MathJax</code>的引用在:<br><code>/themes/jacman/layout/_partial/mathjax.ejs</code>这里，可以发现也就远程引用了官网cdn的一个js<br><code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;</code></p>
<p>在<a href="http://docs.mathjax.org/en/latest/installation.html" target="_blank" rel="external">http://docs.mathjax.org/en/latest/installation.html</a>可以下载到<code>Mathjax</code>的离线包（建议乖乖直接下包，别去爬<code>cdn</code>里面的目录，心累）。</p>
<p>离线包解压之后的<code>unpacked</code>目录里面有整理好直接引用的资源文件(尼玛，之类有<code>16m</code>，难怪慢如蜗牛..)</p>
<p>在<code>/themes/jacman/source/js</code>新建一个<code>mathjax/2.5-latest</code>的目录，将<code>unpacked</code>下的文件整个儿拷贝过去,修改<code>mathjax.ejs</code>中的引用<br><code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/mathjax/2.5-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;</code></p>
<p>清空目录，再重新生成文件,启动服务器，跑起来看公式 只能说   <code>如丝般顺滑</code> ^_^</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>这里与其说安装，还是不如直接拷贝相应文件到hexo目录
</code></pre><p>最近尝试在写<code>blog</code>的时候用<code>Latex</code>来写数学公式，写起来还是极其方便灵活滴，但是，但是其速度慢如爬蜗牛，一般修改一下，在刷新一下要<code>4~5s</code>才能将公式渲染出来，其书写效率也太低了，总之我不能忍，所以准备将其<code>MathJax</code>放在本地.</p>
<ol>
<li>一方面是希望加快公式的渲染速度</li>
<li>另一方面也是希望能支持我在断网的情况下也能正常使用<code>Mathjax</code></li>
</ol>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://kubicode.me/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://kubicode.me/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[概率检索模型BM25系列-文档相关性检索的利器]]></title>
    <link href="http://kubicode.me/2016/01/26/Search%20Engine/Study-BM25-For-Query-Document-Relevance/"/>
    <id>http://kubicode.me/2016/01/26/Search Engine/Study-BM25-For-Query-Document-Relevance/</id>
    <published>2016-01-26T09:06:31.000Z</published>
    <updated>2016-04-02T14:20:39.000Z</updated>
    <content type="html"><![CDATA[<pre><code>给定一个用户需求(<span class="keyword">query</span>),如果搜索系统展示的搜索结果是根据文档和<span class="keyword">query</span>的相关性由高向低排序的，那么这个搜索引擎是最优的。在文档集合的基础上计算其相关性估计是其核心~
</code></pre><h2 id="概率排序原理">概率排序原理</h2><p>以往的<code>向量空间模型</code>是将<code>query</code>和文档使用向量表示然后计算其内容相似性来进行相关性估计的，而<code>概率检索模型</code>是一种直接对用户需求进行相关性的建模方法,一个<code>query</code>进来，将所有的文档分为两类—-<code>相关文档</code>、<code>不相关文档</code>,这样就转为了一个相关性的分类问题,赞!</p>
<p>对于某个文档$D$来说，$P(R|D)$表示该文档数据相关文档的概率，则$P(NR|D)$表示该文档属于不相关文档的概率，如果<code>query</code>属于相关文档的概率大于不相关文档$P(R|D)&gt;P(RN|D)$，则认为这个文档是与用户查询相关相关的.</p>
<a id="more"></a>
<p>现在使用贝叶斯公式将其转一下:</p>
<center>$P(R|D)&gt;P(NR|D) &lt;=&gt;\frac{P(D|R)P(R)}{P(D)}&gt;\frac{P(D|NR)P(NR)}{P(D)} &lt;=&gt; \frac{P(D|R)}{P(D|NR)}&gt;\frac{P(NR)}{P(R)}$</center>

<p>在搜索排序过程中不需要真正的分类，只需要保证相关性由高到底排序即可，所以只需要$\frac{P(D|R)}{P(D|NR)}$降序即可，<br>这样就最终转为计算$P(D|R)$,$P(D|NR)$的值即可.</p>
<h2 id="二元独立模型(BIM)">二元独立模型(BIM)</h2><pre><code><span class="xml">词汇独立性假设:文档里面出现的词没有任何关联，这样一个文档的出现就可以转为各个单词出现概率的乘积（虽然这种假设有违实际，但是算起来简单的啊</span><span class="keyword">^_</span><span class="xml">^）</span>
</code></pre><p>上述提到的文档$D$表示为<code>{1,0,1,0,1}</code>，用$p_i$来表示第$i$个单词在相关文档出现的概率,则在已知<code>相关文档</code>集合的情况下，观察到$D$的概率为:<br>    <center>$P(D|R)=p_1 \times (1-p_2) \times p_3 \times (1-p_4) \times p_5$ </center></p>
<blockquote>
<p>第<code>1,3,5</code>表示这个单词在$D$中出现,所以其贡献概率为$p_i$，而第<code>2,4</code>这两个单词并没有在$D$中出现，所以其贡献的概率为$1-p_i$ </p>
</blockquote>
<p>同理在<code>不相关文档</code>中观察到的概率为:<br>    <center>$P(D|R)=s_1 \times (1-s_2) \times s_3 \times (1-s_4) \times s_5$ </center></p>
<p>最终得到的相关性概率估算为:</p>
<center>$\frac{P(D|R)}{P(D|NR)}=\frac{p_1 \times (1-p_2) \times p_3 \times (1-p_4) \times p_5}{s_1 \times (1-s_2) \times s_3 \times (1-s_4) \times s_5}$</center>

<p>现在将其推广之后可以有通用的式子：</p>
<p>$$\frac{P(D|R)}{P(D|NR)}= \prod_{i:d_i=1} \frac{p_i}{s_i} \times \prod_{i:d_i=0} \frac{1-p_i}{1-s_i}$$</p>
<blockquote>
<p>$d_i=1$表示在文档中出现的单词，$d_i=0$表示没在文档中出现的单词:</p>
</blockquote>
<p>在这里进一步对上述公式进行等价变换之后有:</p>
<p>$$\begin{equation}\begin{split} \frac{P(D|R)}{P(D|NR)} &amp;=\prod_{i:d_i=1} \frac{p_i}{s_i} \times \left ( \prod_{i:d_i=1} \frac{1-s_i}{1-p_i} \times \prod_{i:d_i=1} \frac{1-p_i}{1-s_i} \right ) \times \prod_{i:d_i=0} \frac{1-p_i}{1-s_i}\\<br>&amp;= \left ( \prod_{i:d_i=1} \frac{p_i}{s_i} \times \prod_{i:d_i=1} \frac{1-s_i}{1-p_i} \right ) \times  \left ( \prod_{i:d_i=1} \frac{1-p_i}{1-s_i} \times \prod_{i:d_i=0} \frac{1-p_i}{1-s_i} \right )  \\<br>&amp;=\prod_{i:d_i=1} \frac{p_i(1-s_i)}{s_i(1-p_i)} \times \prod_i \frac{1-pi}{1-s_i} \\<br>&amp;=\prod_{i:d_i=1} \frac{p_i(1-s_i)}{s_i(1-p_i)}<br>\end{split}\end{equation}$$</p>
<p>其中上面式子第三步的第二部分$\prod_i \frac{1-pi}{1-s_i} $表示各个单词在所有文档中出现的概率，所以这个式子的值和具体文档并没有什么关系，在排序中不起作用，才可以简化到第4步.</p>
<p>为了方便计算，将上述连乘公式取$log$:</p>
<center>$log(\frac{P(D|R)}{P(D|NR)}) =  \sum_{i:d_i=1} log \frac{p_i(1-s_i)}{s_i(1-p_i)}$</center>

<p>有了上述最终可计算的式子之后，我们就只需要统计文档$D$中的各个单词在<code>相关文档</code>/<code>不相关文档</code>中出现的概率即可:</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">相关文档</th>
<th style="text-align:left">不相关文档</th>
<th style="text-align:left">文档数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$d_i=1$</td>
<td style="text-align:left">$r_i$</td>
<td style="text-align:left">$n_i-r_i$</td>
<td style="text-align:left">$n_i$</td>
</tr>
<tr>
<td style="text-align:left">$d_i=0$</td>
<td style="text-align:left">$R-r_i$</td>
<td style="text-align:left">$(N-R)-(n_i-r_i)$</td>
<td style="text-align:left">$N-n_i$</td>
</tr>
<tr>
<td style="text-align:left">文档数量</td>
<td style="text-align:left">$R$</td>
<td style="text-align:left">$N-R$</td>
<td style="text-align:left">$N$</td>
</tr>
</tbody>
</table>
<p>上面的表格表示各个单词在文档集合中的<code>相关文档</code>/<code>不相关文档</code>出现数量,同时为了避免$log(0)$出现，加上平滑之后可以计算得到:</p>
<center>$p_i=\frac{r_i+0.5}{R+1}$</center><br><center>$s_i=\frac{(n_i-r_i)+0.5}{(N-R)+1}$</center>

<p>则最终可以得到如下公式:</p>
<center>$\sum_{q_i=d_i=1} log \frac {(r_i+0.5)((N-R)-(n_i-r_i)+0.5)}{(n_i-r_i+0.5)(R-r_i+0.5)}$</center>

<p>上面的公式表示对于同时出现查询$q_i$以及文档$d_i$的时候，对$q_i$在$d_i$中出现的单词在<code>相关文档</code>/<code>不相关文档</code>进行统计，即可得到查询与文档的相关性估计值.</p>
<blockquote>
<p>在不确定哪些文档是相关的，哪些文档是不相关的的时候，可以给公式的估算因子直接赋予固定值，则该公式将会蜕化为$IDF$因子.</p>
</blockquote>
<h2 id="BM25_模型">BM25 模型</h2><h3 id="模型概述">模型概述</h3><blockquote>
<p>上一小节中的<code>BIM模型</code>效果并不佳，也没有考虑单词权重，但是他给<code>BM25模型</code>打下了深深的基础</p>
</blockquote>
<pre><code>B<span class="title">M25</span> 模型在BIM模型的基础上考虑了查询词在Query以及Doc中的权重，并通过实验引入了一些经验参数。B<span class="title">M25</span>模型是目前最成功的内容排序模型.
</code></pre><p>改进之后的<code>BM25</code>模型的拟合公式如下:</p>
<center>$\sum_{i\in Q} log \frac {(r_i+0.5)((N-R)-(n_i-r_i)+0.5)}{(n_i-r_i+0.5)(R-r_i+0.5)} \cdot \frac{(k_1+1)f_i}{K+f_i} \cdot \frac{(k_2+1)qf_i}{k_2+qf_i}$</center>

<p>上面的式子中:</p>
<ol>
<li>第1部分即为上一小节的二元独立模型BIM计算得分</li>
<li>第2部分是查询词在$D$中的权重，其中$f_i$代表词在文档中的词频,$K$因子代表了对文档长度的考虑，其计算公式为$K=k_1((1-b)+b \cdot \frac{dl}{avdl})$<ol>
<li>$k_1$为经验参数,这里的$k_1$一般设置为1.2,</li>
<li>$b$为调节因子，将$b$设为0时，文档长度因素将不起作用，经验表明一般$b=0.75$</li>
<li>$dl$代表当前文档的长度</li>
<li>$avdl$代表所有文档的平均长度</li>
</ol>
</li>
<li>第3部分是查询词在自身的权重,$qf_i$表示在查询中的词频,$k_2$也为调节因子，因为在短查询下这部分一般为1，为了放大这部分的差异，$k_2$一般取值为<code>0~1000</code></li>
</ol>
<blockquote>
<p>综合看来,<code>BM25</code>模型结合了<code>BIM</code>因子、<code>文档长度</code>、<code>文档词频</code>和<code>查询词频</code>进行公式融合，并利用$k_1$、$k_2$、$b$对各种因子进行权重的调整.</p>
</blockquote>
<h3 id="栗子">栗子</h3><p>假设当前以<code>乔布斯 IPAD2</code>这个查询词为例，来计算在某文档$D$中<code>BM25相关性</code>的值，由于不知道文档集中相关与不相关的分类，所以这里直接将相关文档个数$r$置为0,则将得到的<code>BIM</code>因子为:<br>    <center>$Rel_{BIM}=log \frac {(0+0.5)((N-0)-(n_i-0)+0.5)}{(n_i-0+0.5)(0-0+0.5)}=log \frac{N-n_i+0.5}{n_i+0.5}$</center></p>
<p>其他数值假定如下:</p>
<ol>
<li>文档的集合总数$N=100000$</li>
<li>包含<code>乔布斯</code>的文档个数为$n_{乔布斯}=1000$</li>
<li>包含<code>IPAD2</code>的文档个数为$n_{IPAD2}=100$</li>
<li>文档$D$中出现<code>乔布斯</code>的词频为$f_{乔布斯}=8$</li>
<li>文档$D$中出现<code>IPAD2</code>的词频为$f_{IPAD2}=8$</li>
<li>查询词频均为$qf_i=1$</li>
<li>调节因子$k_1=1.2$</li>
<li>调节因子$k_2=200$</li>
<li>调节因子$b=0.75$</li>
<li>设文档$D$的长度为平均长度的1.5倍($\frac{dl}{avdl}=1.5$),即$K=1.2 \times (0.25+0.75 \times 1.5)=1.65$</li>
</ol>
<p>则最终可以计算到的<code>BM25</code>结果为:</p>
<p>$Rel_{BM25}=log \frac{100000-1000+0.5}{1000+0.5} \times \frac{(1.2+1) \times 8}{1.65+8} \times \frac{(200+1) \times 1}{200+1}+ log \frac{100000-1000+0.5}{1000+0.5} \times \frac{(1.2+1) \times 5}{1.65+5} \times \frac{(200+1) \times 1}{200+1} = 8.59$</p>
<p>每个文档按上述公式计算得到相关性排序即可.</p>
<h2 id="BM25F_模型">BM25F 模型</h2><blockquote>
<p>在<code>BM25</code>模型中，文档被当做一个整体进行进行词频的统计，而忽视了不同区域的重要性，<code>BM25F</code>模型正是抓住了这点进行了相应的改进。</p>
</blockquote>
<p><code>BM25F</code>模型在计算相关性时候，会对文档分割成不同的域来进行加权统计，非常适用于网页搜索，因为在一个网页有<code>标题信息</code>、<code>meta信息</code>、<code>页面内容信息</code>等，而<code>标题信息</code>无疑是最重要的，其次是<code>meta信息</code>，最后才是<code>网页内容</code>，<code>BM25F</code>在计算相关性的，会将网页分为不用的区域，在各个区域分别统计自己的词频。<br>所以<code>BM25F</code>模型的计算公式为:</p>
<p>$$\sum_{i:q_i=d_i=1} log \frac {(r_i+0.5)((N-R)-(n_i-r_i)+0.5)}{(n_i-r_i+0.5)(R-r_i+0.5)} \times \frac{f_i^u}{k_1+f_i^u}$$</p>
<blockquote>
<p><code>BM25F</code>的第1部分还是<code>BIM</code>的值</p>
</blockquote>
<p>其中与<code>BM25</code>主要的差别体现在$f_i^u$因子上,它是单词$i$在各个区域不同的得分,计算公式如下:</p>
<p>$$f_i^u=\sum_{k=1}^uw_k \times \frac{f_{ui}}{B_u}$$</p>
<p>$$B_u=((1-b_u)+b_u \times  \frac{ul_u}{uvul_u})$$</p>
<p>上面的公式表示:</p>
<ol>
<li>文档$D$来个不同的$u$个域</li>
<li>各个域对应的权重为$W_k$</li>
<li>$f_i^u$为第$i$个单词在各个域中的 $\frac{f_{ui}}{B_u}$ 的加权和</li>
<li>$f_{ui}$表示词频</li>
<li>$B_u$表示各个域的长度情况</li>
<li>$ul_u$为实际域的实际长度,$uvul_u$表示域的平均长度</li>
<li>$b_u$则为各个域长度的调节因子</li>
</ol>
<h2 id="总结">总结</h2><p><code>BM25</code>系列的模型主要是考虑查询词到文档里面的各种词频，含有大量自由的调节因子，最终给出查询到文档的相关性，模型都是比较简单的，但是里面提高的相关文档和不相关文档的引入将比较麻烦，有实际场景可以一试。</p>
<h2 id="参考">参考</h2><ol>
<li>《这就是搜索引擎：核心技术详解》 . 第五章</li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>给定一个用户需求(<span class="keyword">query</span>),如果搜索系统展示的搜索结果是根据文档和<span class="keyword">query</span>的相关性由高向低排序的，那么这个搜索引擎是最优的。在文档集合的基础上计算其相关性估计是其核心~
</code></pre><h2 id="概率排序原理">概率排序原理</h2><p>以往的<code>向量空间模型</code>是将<code>query</code>和文档使用向量表示然后计算其内容相似性来进行相关性估计的，而<code>概率检索模型</code>是一种直接对用户需求进行相关性的建模方法,一个<code>query</code>进来，将所有的文档分为两类—-<code>相关文档</code>、<code>不相关文档</code>,这样就转为了一个相关性的分类问题,赞!</p>
<p>对于某个文档$D$来说，$P(R|D)$表示该文档数据相关文档的概率，则$P(NR|D)$表示该文档属于不相关文档的概率，如果<code>query</code>属于相关文档的概率大于不相关文档$P(R|D)&gt;P(RN|D)$，则认为这个文档是与用户查询相关相关的.</p>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://kubicode.me/tags/Machine-Learning/"/>
    
      <category term="Search Engine" scheme="http://kubicode.me/tags/Search-Engine/"/>
    
      <category term="Search Engine" scheme="http://kubicode.me/categories/Search-Engine/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用笨方法解决Shell中按行读取文件之后Tab键不见的问题]]></title>
    <link href="http://kubicode.me/2016/01/03/Linux/shell-line-no-tab/"/>
    <id>http://kubicode.me/2016/01/03/Linux/shell-line-no-tab/</id>
    <published>2016-01-03T14:24:09.000Z</published>
    <updated>2016-01-03T15:03:02.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><code>Shell</code>强大灵活，但是今天在使用<code>Shell</code>处理按行读取文件时发现  读取到的行设定的<code>tab</code>分割符不见了</p>
</blockquote>
<p>先看一下演示的待<a href="http://kubicode.me/img/awk-study-list/score.log" target="_blank" rel="external">处理文件</a>:<br><img src="/img/shell-line-no-tab/demo_text.png" alt=""></p>
<p>需要做的需求就是将里面的数据使用<code>shell</code>将第一列读取出来做一些其他处理(当然如果仅仅是完成读取首列这个功能，使用<code>awk</code>是最快的，这里只是演示)</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">cat score.log | <span class="keyword">while</span> <span class="built_in">read</span> line  <span class="comment">#按行读取文件</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">    grade=`<span class="built_in">echo</span> <span class="variable">$line</span> | awk -F <span class="string">"\t"</span> <span class="string">'&#123;print $1&#125;'</span>` <span class="comment">#读取首列（年级）</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$grade</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>执行这个文件并且使用管道<code>| vim -</code> 打印只之后可以发现格式不对，按行打印了，并且其原先的分隔符<code>tab</code>也消失了<br><img src="/img/shell-line-no-tab/no_tab.png" alt=""></p>
<p>后来查到据说<code>shell</code>的默认分隔符是空格的原因,所以一种最直接的方式就是去<code>.bashrc</code>里面修改分割符,但是这么做可能会影响其他的<code>shell程序</code><br>所以比较保险的一种方法就是先将行中的<code>tab</code>替换，再对替换后的数据进行操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">cat score.log | awk <span class="string">'gsub("\t","\001",$0)'</span> | <span class="keyword">while</span> <span class="built_in">read</span> line  <span class="comment">#按行读取文件</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    grade=`<span class="built_in">echo</span> <span class="variable">$line</span> | awk -F <span class="string">"\001"</span> <span class="string">'&#123;print $1&#125;'</span>` <span class="comment">#读取首列（年级）</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$grade</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>先做了独立的<code>tab</code>去掉之后就可以很顺利地看到需要的结果了</p>
<p><img src="/img/shell-line-no-tab/ok.png" alt=""></p>
<blockquote>
<p>这个方法虽然比较简单，但是非常实用~</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><code>Shell</code>强大灵活，但是今天在使用<code>Shell</code>处理按行读取文件时发现  读取到的行设定的<code>tab</code>分割符不见了</p>
</blockquote>
<p>先看一下演示的待<a href="http://kubicode.me/img/awk-study-list/score.log">处理文件</a>:<br><img src="/img/shell-line-no-tab/demo_text.png" alt=""></p>
<p>需要做的需求就是将里面的数据使用<code>shell</code>将第一列读取出来做一些其他处理(当然如果仅仅是完成读取首列这个功能，使用<code>awk</code>是最快的，这里只是演示)</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://kubicode.me/tags/Linux/"/>
    
      <category term="Vim" scheme="http://kubicode.me/tags/Vim/"/>
    
      <category term="Linux" scheme="http://kubicode.me/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[轻量的结构化文本处理工具-awk]]></title>
    <link href="http://kubicode.me/2015/12/24/Linux/awk-study-list/"/>
    <id>http://kubicode.me/2015/12/24/Linux/awk-study-list/</id>
    <published>2015-12-23T16:06:41.000Z</published>
    <updated>2016-01-03T02:38:47.000Z</updated>
    <content type="html"><![CDATA[<pre><code>与其说<span class="tag">awk</span>是一个强大的文本处理工具，我更加喜欢称之为轻量级的<span class="tag">C</span>语言版脚本，有了它，你就能非常自由，轻松的操作文本文件了。<span class="rule"><span class="attribute">ps</span>:<span class="value">比Excel更加方便哦,一句话：awk可以带你装b带你飞~</span></span>
</code></pre><h2 id="初体验：九九乘法表">初体验：九九乘法表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"></span><br><span class="line">BEGIN&#123;</span><br><span class="line">    <span class="built_in">print</span> <span class="string">"lets begins"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=NR;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%sx%s=%s\t"</span>,NR,i,NR*i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">END&#123;</span><br><span class="line">    <span class="built_in">print</span> <span class="string">"ends"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在先看<code>awk</code>程序之前，咱先来看一下由他实现的一个九九乘法表</p>
<pre><code>yans-MacBook-Pro:Downloads yanyl$ seq <span class="number">9</span> | awk -f chengfa.awk
lets begins
<span class="number">1</span><span class="variable">x1=</span><span class="number">1</span>
<span class="number">2</span><span class="variable">x1=</span><span class="number">2</span>    <span class="number">2</span><span class="variable">x2=</span><span class="number">4</span>
<span class="number">3</span><span class="variable">x1=</span><span class="number">3</span>    <span class="number">3</span><span class="variable">x2=</span><span class="number">6</span>    <span class="number">3</span><span class="variable">x3=</span><span class="number">9</span>
<span class="number">4</span><span class="variable">x1=</span><span class="number">4</span>    <span class="number">4</span><span class="variable">x2=</span><span class="number">8</span>    <span class="number">4</span><span class="variable">x3=</span><span class="number">12</span>    <span class="number">4</span><span class="variable">x4=</span><span class="number">16</span>
<span class="number">5</span><span class="variable">x1=</span><span class="number">5</span>    <span class="number">5</span><span class="variable">x2=</span><span class="number">10</span>    <span class="number">5</span><span class="variable">x3=</span><span class="number">15</span>    <span class="number">5</span><span class="variable">x4=</span><span class="number">20</span>    <span class="number">5</span><span class="variable">x5=</span><span class="number">25</span>
<span class="number">6</span><span class="variable">x1=</span><span class="number">6</span>    <span class="number">6</span><span class="variable">x2=</span><span class="number">12</span>    <span class="number">6</span><span class="variable">x3=</span><span class="number">18</span>    <span class="number">6</span><span class="variable">x4=</span><span class="number">24</span>    <span class="number">6</span><span class="variable">x5=</span><span class="number">30</span>    <span class="number">6</span><span class="variable">x6=</span><span class="number">36</span>
<span class="number">7</span><span class="variable">x1=</span><span class="number">7</span>    <span class="number">7</span><span class="variable">x2=</span><span class="number">14</span>    <span class="number">7</span><span class="variable">x3=</span><span class="number">21</span>    <span class="number">7</span><span class="variable">x4=</span><span class="number">28</span>    <span class="number">7</span><span class="variable">x5=</span><span class="number">35</span>    <span class="number">7</span><span class="variable">x6=</span><span class="number">42</span>    <span class="number">7</span><span class="variable">x7=</span><span class="number">49</span>
<span class="number">8</span><span class="variable">x1=</span><span class="number">8</span>    <span class="number">8</span><span class="variable">x2=</span><span class="number">16</span>    <span class="number">8</span><span class="variable">x3=</span><span class="number">24</span>    <span class="number">8</span><span class="variable">x4=</span><span class="number">32</span>    <span class="number">8</span><span class="variable">x5=</span><span class="number">40</span>    <span class="number">8</span><span class="variable">x6=</span><span class="number">48</span>    <span class="number">8</span><span class="variable">x7=</span><span class="number">56</span>    <span class="number">8</span><span class="variable">x8=</span><span class="number">64</span>
<span class="number">9</span><span class="variable">x1=</span><span class="number">9</span>    <span class="number">9</span><span class="variable">x2=</span><span class="number">18</span>    <span class="number">9</span><span class="variable">x3=</span><span class="number">27</span>    <span class="number">9</span><span class="variable">x4=</span><span class="number">36</span>    <span class="number">9</span><span class="variable">x5=</span><span class="number">45</span>    <span class="number">9</span><span class="variable">x6=</span><span class="number">54</span>    <span class="number">9</span><span class="variable">x7=</span><span class="number">63</span>    <span class="number">9</span><span class="variable">x8=</span><span class="number">72</span>    <span class="number">9</span><span class="variable">x9=</span><span class="number">81</span>
ends
yans-MacBook-Pro:Downloads yanyl$
</code></pre><a id="more"></a>
<p>是不是着实惊艳了一把，程序暂时不解释，不错，为了更好更加方便得处理<code>Linux</code>下的文本，文本就记录学习<code>awk</code>神器的基本用法^_^</p>
<h2 id="awk基础结构">awk基础结构</h2><p><code>awk</code>基础结构如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123;commands&#125; &#123;commands&#125; END&#123;commands&#125;'</span> filename</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这个命令敲下去之后，<code>awk</code>回去按行读取<code>filename</code>的文本进行操作，里面的程序就是你对应的文本处理逻辑，还有这里的文件输入也可以改为标准的<code>stdin</code>的形式哦~</p>
</blockquote>
<p>很清晰，<code>awk</code>可以分为3块:</p>
<ol>
<li><code>BEGIN</code>:可以理解为程序的初始化，可以自定一些变量，或者定义文件的分隔符等</li>
<li>{}模式块：这里会从文件或者输入里面按行读取，在这里可以使用<code>内建变量</code>或者列的值<code>$i</code> 或者自定义变量等，然后使用控制结果或者内置函数来进行相应的文本处理逻辑</li>
<li><code>END</code>:程序执行结束块，可以做一些<code>Summary</code>类型或者其他的输出</li>
</ol>
<blockquote>
<p>其实模式快可以省略，默认是执行<code>{print}</code> 打印行内容，其实其他两块也可以省略-_-</p>
</blockquote>
<p>所以总结来说<code>awk</code>的结构其实可以直接看做一个循环体<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGINE <span class="comment">#进行初始化</span></span><br><span class="line"><span class="keyword">while</span></span><br><span class="line">	&#123;commands&#125; <span class="comment">#内部循环的处理逻辑</span></span><br><span class="line">END <span class="comment">#结尾</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是：</p>
<ol>
<li><code>awk</code>语法的是包含在引号或者双引号里面的</li>
<li>程序复杂的话可以写成<code>awk</code>结尾的文件，然后使用<code>awk -f xxx.awk filename</code>来进行执行</li>
</ol>
<blockquote>
<p>当然了,刚刚都说了<code>awk</code>的优势在于轻量级，下面更多的<code>demo</code>都是行内的语法，并不会专门去写成<code>*.awk</code>文件再来执行^_^</p>
</blockquote>
<h2 id="列的操作">列的操作</h2><h3 id="列的输出">列的输出</h3><p>演示之前先看使用的实验文本文件<a href="/img/awk-study-list/score.log">成绩表score.log</a></p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ <span class="keyword">cat</span> <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    math    95
301    xiaoming    chinese    58
301    xiaoming    english    68
301    xiaohong    math    77
301    xiaohong    chinese    88
301    xiaohong    english    75
302    peter    math    35
302    peter    chinese    45
302    peter    english    95
</code></pre><blockquote>
<p>这里的列于列之间是使用<code>tab</code>隔开的</p>
</blockquote>
<p>先来看一下最简单的输出,假设我只关心年龄和成绩</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ awk '{<span class="keyword">print</span> <span class="label">$2</span>,<span class="label">$4}</span>' <span class="keyword">score</span>.<span class="literal">log</span>
name <span class="keyword">score</span>
xiaoming 95
xiaoming 58
xiaoming 68
xiaohong 77
xiaohong 88
xiaohong 75
peter 35
peter 45
peter 95
</code></pre><blockquote>
<p>这里的取列是使用<code>$i~n</code>  从1开始计数，比如<code>$1</code>是第一列，<code>$4</code>是第4列，其中<code>$0</code>表示整好</p>
</blockquote>
<p>但是发现没对齐，我想将其对个齐：</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ awk '{printf(<span class="string">"%-8s\t%-8s\n"</span>,<span class="label">$2</span>,<span class="label">$4</span>)}' <span class="keyword">score</span>.<span class="literal">log</span>
name        <span class="keyword">score</span>
xiaoming    95
xiaoming    58
xiaoming    68
xiaohong    77
xiaohong    88
xiaohong    75
peter       35
peter       45
peter       95
</code></pre><blockquote>
<p>就是就是使用了标准了<code>C</code>语言风格的<code>printf</code>函数了</p>
</blockquote>
<h3 id="列的过滤">列的过滤</h3><p>我感觉里面比较强大的就是使用<code>awk</code>进行各种过滤操作了，简直了<br>现在我只是想查看小明的成绩</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ awk 'NR==1 || <span class="label">$2</span>==<span class="string">"xiaoming"</span>' <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    math    95
301    xiaoming    chinese    58
301    xiaoming    english    68
</code></pre><blockquote>
<p>这里支持and(<code>&amp;&amp;</code>)和or(<code>||</code>)的操作，同时<code>NR</code>表示当前的行号，<code>NR==1</code>就是为了保留表头</p>
</blockquote>
<p>同时<code>awk</code>还支持<code>C</code>语言系的各种比较符号<code>!=, &gt;, &lt;, &gt;=, &lt;=</code><br>查看不及格的小兔崽子-_-</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ awk 'NR==1 || <span class="label">$4</span>&lt;60' <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    chinese    58
302    peter    math    35
302    peter    chinese    45
</code></pre><p>这里除了支持直接判断的语法，还支持字符串的匹配，使用<code>~</code>符号（这个有点强大），使用语法为<code>~/pattern/</code><br>现在来看一下姓小的同学</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ awk 'NR==1 || <span class="label">$2</span>~/xiao/' <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    math    95
301    xiaoming    chinese    58
301    xiaoming    english    68
301    xiaohong    math    77
301    xiaohong    chinese    88
301    xiaohong    english    75
</code></pre><p>还可以进行模式非匹配，要<code>!~</code>即可</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ awk 'NR==1 || <span class="label">$2</span>!~/xiao/' <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
302    peter    math    35
302    peter    chinese    45
302    peter    english    95
</code></pre><h2 id="变量">变量</h2><h3 id="变量定义使用">变量定义使用</h3><p><code>awk</code>里面变量的几个点:</p>
<ol>
<li>里面的变量命名和<code>C</code>系一样</li>
<li>变量区分大小写</li>
<li>变量一般都是数字和字符串类型</li>
<li>在初始化时，数字类型初始化为0，字符串类型初始化为空，并且在运行期间可变，同时不需要向<code>C</code>一样显示的初始化变量</li>
</ol>
<p>这里来看一个最简单的变量的创建与读写</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk '{name=<span class="string">"zhangsan"</span>} END{<span class="keyword">print</span> name}' <span class="keyword">score</span>.<span class="literal">log</span>
zhangsan
yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk '{age=23} END{<span class="keyword">print</span> age}' <span class="keyword">score</span>.<span class="literal">log</span>
23
</code></pre><blockquote>
<p>这里想想<code>python</code>的变量就可以了哦~</p>
</blockquote>
<p>另外参数不一定要在<code>awk</code>语句中初始化，还可以在输入文件中进行传递，语法格式为<code>awk &#39;statment&#39; var=value file</code>的方式</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk '<span class="label">$4</span>&gt;ms' ms=60 <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    math    95
301    xiaoming    english    68
301    xiaohong    math    77
301    xiaohong    chinese    88
301    xiaohong    english    75
302    peter    english    95
yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk '<span class="label">$4</span>&gt;ms' ms=90 <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    math    95
302    peter    english    95
</code></pre><p>这里示例是用于展示在输入文件的时候传一个<code>ms</code>变量，来控制过滤最小分数，应该还是蛮方便的</p>
<h3 id="类型转换">类型转换</h3><blockquote>
<p>这里的类型转换只有数字类型和字符串类型的转换啦-_-</p>
</blockquote>
<p>记住一个原则<code>+号表示数字类型的操作，会忽略字符串，而空才是正常字符串的拼接</code></p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk 'BEGIN{<span class="keyword">two</span>=2;three=3;<span class="keyword">print</span> <span class="keyword">two</span>+three}'
5
yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk 'BEGIN{<span class="keyword">two</span>=2;three=3;<span class="keyword">print</span> <span class="keyword">two</span> three}'
23
yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk 'BEGIN{<span class="keyword">two</span>=2;three=3;<span class="keyword">print</span> <span class="keyword">two</span>+<span class="string">"s"</span>+three}'
5
yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk 'BEGIN{<span class="keyword">two</span>=2;three=3;<span class="keyword">print</span> <span class="keyword">two</span> <span class="string">"s"</span> three}'
2s3
</code></pre><blockquote>
<p>还有关于详细的转换参考<a href="http://www.gnu.org/software/gawk/manual/gawk.html#Variables" target="_blank" rel="external">这里</a></p>
</blockquote>
<h3 id="内建变量">内建变量</h3><p>下面贴出的都是一些内置变量，在自己创建变量的时候请勿将变量名创建为下面的内置变量名</p>
<table>
<thead>
<tr>
<th style="text-align:left">变量名</th>
<th style="text-align:left">变量描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>$0</code></td>
<td style="text-align:left">表示当前正行的内容</td>
</tr>
<tr>
<td style="text-align:left"><code>$1~$n</code></td>
<td style="text-align:left">表示第几个列的值，这些列是使用<code>FS</code>变量进行分割的</td>
</tr>
<tr>
<td style="text-align:left"><code>FS</code></td>
<td style="text-align:left">列的分割符，默认是空格或者<code>tab</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NF</code></td>
<td style="text-align:left">表示当前文件中列的个数</td>
</tr>
<tr>
<td style="text-align:left"><code>NR</code></td>
<td style="text-align:left">表示当前读取的行数</td>
</tr>
<tr>
<td style="text-align:left"><code>FNR</code></td>
<td style="text-align:left">这个表示当前文件自己标的行号</td>
</tr>
<tr>
<td style="text-align:left"><code>NR</code></td>
<td style="text-align:left">表示当前读取的行数</td>
</tr>
<tr>
<td style="text-align:left"><code>RS</code></td>
<td style="text-align:left">表示输入记录的换行符，默认为换行符<code>\n</code></td>
</tr>
<tr>
<td style="text-align:left"><code>OFS</code></td>
<td style="text-align:left">表示输出记录的分割符，默认是空格</td>
</tr>
<tr>
<td style="text-align:left"><code>ORS</code></td>
<td style="text-align:left">表示输出记录的分割符，默认是换行符</td>
</tr>
<tr>
<td style="text-align:left"><code>FILENAME</code></td>
<td style="text-align:left">当前输出的文件名</td>
</tr>
<tr>
<td style="text-align:left"><code>ARGC</code></td>
<td style="text-align:left">传入参数的个数</td>
</tr>
<tr>
<td style="text-align:left"><code>ARGV</code></td>
<td style="text-align:left">传入参数的数组</td>
</tr>
</tbody>
</table>
<p>上面是列出了一些常用的内置变量，详细的可以看<a href="http://www.gnu.org/software/gawk/manual/gawk.html#Built_002din-Variables" target="_blank" rel="external">这里</a></p>
<blockquote>
<p>个人感觉最常用的就是<code>$i</code>犀利以及<code>FS</code>、<code>NR</code>之类的了^_^</p>
</blockquote>
<h2 id="控制流程">控制流程</h2><blockquote>
<p><code>awk</code>提供了类<code>C</code>系语言的强大的控制流程语法，可以发现绝大部门语法和<code>C</code>是一样的</p>
</blockquote>
<h3 id="if判断">if判断</h3><p><code>if</code>语法是你超级熟悉的<code>if (condition) then-body [else else-body]</code><br>现在需要给每个人每门成绩打一个标签，85分以上优秀，60及以上良好，否则。。。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (NR==<span class="number">1</span>) <span class="comment">#这里针对第一行  额外操作   追加一个标签列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span> <span class="variable">$0</span> <span class="string">"\tlabel"</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(<span class="variable">$4</span> &gt;= <span class="number">85</span>)</span><br><span class="line">	        label = <span class="string">"excellent"</span></span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$4</span> &gt;= <span class="number">60</span>)</span><br><span class="line">	        label = <span class="string">"well"</span></span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	        label = <span class="string">"shit"</span></span><br><span class="line"></span><br><span class="line">	    <span class="built_in">print</span> <span class="variable">$0</span> <span class="string">"\t"</span> label</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将这个<code>awk</code>文件进行执行之后可以看到</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk -f <span class="keyword">test</span>.awk <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>    <span class="keyword">label</span>
301    xiaoming    math    95    excellent
301    xiaoming    chinese    58    shit
301    xiaoming    english    68    well
301    xiaohong    math    77    well
301    xiaohong    chinese    88    excellent
301    xiaohong    english    75    well
302    peter    math    35    shit
302    peter    chinese    45    shit
302    peter    english    95    excellent
</code></pre><p>这里注意，你如果想把控制语句写到一行，就必须得使用<code>{}</code>显示标注执行主体，<code>;</code>来标注结束，就是像下面这么任性我也是没办法</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk '{<span class="keyword">if</span> (NR==1){<span class="keyword">print</span> <span class="label">$0</span> <span class="string">"\tlabel"</span>;}<span class="keyword">else</span>{<span class="keyword">if</span>(<span class="label">$4</span> &gt;= 85){<span class="keyword">label</span> = <span class="string">"excellent"</span>;}<span class="keyword">else</span> <span class="keyword">if</span> (<span class="label">$4</span> &gt;= 60){<span class="keyword">label</span> = <span class="string">"well"</span>;}<span class="keyword">else</span>{<span class="keyword">label</span> = <span class="string">"shit"</span>;}<span class="keyword">print</span> <span class="label">$0</span> <span class="string">"\t"</span> <span class="keyword">label</span>;}}' <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>    <span class="keyword">label</span>
301    xiaoming    math    95    excellent
301    xiaoming    chinese    58    shit
301    xiaoming    english    68    well
301    xiaohong    math    77    well
301    xiaohong    chinese    88    excellent
301    xiaohong    english    75    well
302    peter    math    35    shit
302    peter    chinese    45    shit
302    peter    english    95    excellent
</code></pre><h3 id="while循环">while循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)</span><br><span class="line">  body</span><br></pre></td></tr></table></figure>
<p><code>while</code>还是很方便使用</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk 'BEGIN{i=1;<span class="keyword">sum</span>=0;<span class="keyword">while</span>(i&lt;10) {<span class="keyword">sum</span>+=i;i++;} <span class="keyword">print</span> <span class="keyword">sum</span> }'
45
</code></pre><p>从1累加到9的实现</p>
<h3 id="do-while循环">do-while循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">  body</span><br><span class="line"><span class="keyword">while</span> (condition)</span><br></pre></td></tr></table></figure>
<h3 id="for循环">for循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; increment)</span><br><span class="line">  body</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个方法在最上面的初体验里面就有了</p>
</blockquote>
<h3 id="switch">switch</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switch (expression) &#123;</span><br><span class="line"><span class="keyword">case</span> value or regular expression:</span><br><span class="line">    <span class="keyword">case</span>-body</span><br><span class="line">default:</span><br><span class="line">    default-body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个在<code>gnu awk</code>的手册中说明支持，但是自己捣鼓了半天也没结果，下次深入了再贴出来</p>
</blockquote>
<h3 id="next控制">next控制</h3><p>既然有了上面那么强大的<code>C</code>系控制，肯定也少不了<code>break</code>和<code>continue</code>，在<code>awk</code>中都是支持的，而且用法都一样，所以这里不再一一描述，有意思的是来说一下这个<code>next</code>关键字</p>
<pre><code><span class="keyword">next</span>:在文章最上面描述的awk的结构的中间部分是一个天然的循环，<span class="keyword">next</span>关键词就是让你在这个天然的循环中跳转到下一行处理,就像<span class="keyword">continue</span>
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$4</span>&lt;<span class="number">60</span>)</span><br><span class="line">        next <span class="comment">#小于60的直接过掉  不做处理</span></span><br><span class="line">    <span class="built_in">print</span> <span class="variable">$0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序是用来过掉不及格的同学的</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk -f <span class="keyword">test</span>.awk <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    math    95
301    xiaoming    english    68
301    xiaohong    math    77
301    xiaohong    chinese    88
301    xiaohong    english    75
302    peter    english    95
</code></pre><h3 id="nextfile控制">nextfile控制</h3><p>另外一个与<code>next</code>类似的就是<code>nextfile</code> ，表示跳到下一个输入文件(因为<code>awk</code>一下子可以有多个输入文件呀)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$0</span>~/score/)</span><br><span class="line">        next <span class="comment">#含有score字符串的直接过掉</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$4</span>&lt;n)</span><br><span class="line">        nextfile</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> n <span class="string">"\t"</span> <span class="variable">$0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到结果</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk -f <span class="keyword">test</span>.awk <span class="keyword">n</span>=58 <span class="keyword">score</span>.<span class="keyword">log</span> <span class="keyword">n</span>=88 <span class="keyword">score</span>.<span class="literal">log</span>
58    301    xiaoming    math    95
58    301    xiaoming    chinese    58
58    301    xiaoming    english    68
58    301    xiaohong    math    77
58    301    xiaohong    chinese    88
58    301    xiaohong    english    75
88    301    xiaoming    math    95
</code></pre><p>都是符合预期的<br>同时还有一个<code>exit</code>关键词不再介绍，结束程序用的</p>
<h2 id="数组">数组</h2><h3 id="创建与使用">创建与使用</h3><p><code>awk</code>为了更好更加强大的处理出具，他也提供了数组这个功能，但是略有特点:</p>
<ol>
<li>数组的索引不一定是要连续数据，而且还可以字符串与汉字混合（据官网doc解释，<code>awk</code>将数字型的索引都转成了字符串）</li>
<li>使用数组签不需要显示声明他的长度</li>
<li>很多产生数组的函数  产生完了之后都是从1开始的（注意这个，不然得坑爹了）</li>
</ol>
<p>来看一个比较全面的使用数组的列子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line">BEGIN&#123;</span><br><span class="line">	<span class="comment">#可以直接给数组赋值了，不需要定义</span></span><br><span class="line">    arr[<span class="string">"color"</span>]=<span class="string">"red"</span>;</span><br><span class="line">    arr[<span class="string">"age"</span>]=<span class="number">23</span></span><br><span class="line">    arr[<span class="number">99</span>]=<span class="number">999</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">#使用for each的方式取值，当然也可以for的三段式取值</span></span><br><span class="line">    <span class="keyword">for</span>(x <span class="keyword">in</span> arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span> x <span class="string">":"</span> arr[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到输出结果中将数组的索引和值都打印出来了</p>
<pre><code>yans-MacBook-Pro-<span class="number">2</span>:awk_test yanyl$ seq <span class="number">1</span> | awk -f test.awk
<span class="label">age:</span><span class="number">23</span>
<span class="label">color:</span>red
<span class="number">99</span>:<span class="number">999</span>
</code></pre><p>但是需要注意的是你不能这么写<br><code>if(arr[&quot;name&quot;] == &quot;xiaoming&quot;)</code>，也许<code>awk</code>不会报错，但是也不会有正确结果出来，所以你可以些么写 <code>if(&quot;name&quot; in arr)</code>先进行一个是否有索引的判断，这样比较安全<br>其他的技巧自己看详情的doc拉</p>
<blockquote>
<p>我感觉<code>awk</code>的里面的数组俨然是一个<code>LinkedHashMap</code>-_-</p>
</blockquote>
<h3 id="删除">删除</h3><p>删除的语法也很简单<code>delete array[index-expression]</code>，<br>比如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line">BEGIN&#123;</span><br><span class="line">    arr[<span class="string">"color"</span>]=<span class="string">"red"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"color"</span> <span class="keyword">in</span> arr)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">"yes"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">"no"</span></span><br><span class="line"></span><br><span class="line">   delete arr[<span class="string">"color"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"color"</span> <span class="keyword">in</span> arr)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">"yes"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">"no"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进行一个打印之后可以发现</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ seq 1 | awk -f <span class="keyword">test</span>.awk
yes
<span class="keyword">no</span>
</code></pre><p>在第二次判断数组是否存在该元素的时 可以发现已经删除掉了<br>如果想删除全部元素就可以直接使用这个语法：<code>delete array</code>,但是要注意的是 删除了之后之后这个变量还是数组类型，此时无法被用于赋值字符串或者数字:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line">BEGIN&#123;</span><br><span class="line">    arr[<span class="string">"color"</span>]=<span class="string">"red"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    delete arr</span><br><span class="line">    arr=<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式在进行第二次赋值的时候会发错</p>
<pre><code>yans-MacBook-Pro-2:awk_test yanyl$ seq 1 | awk -f test.awk
awk: can't assign to arr; it's an<span class="instruction"> array </span>name.
 input record number 1, file
 source line number 9
</code></pre><blockquote>
<p>关于其余的<a href="http://www.gnu.org/software/gawk/manual/gawk.html#Multiscanning" target="_blank" rel="external">多维数组</a>还是去看文档把~</p>
</blockquote>
<h2 id="内置函数">内置函数</h2><p><code>awk</code>的另一个强大之处就是提供了很丰富的内置函数，写起来非常方便!</p>
<h3 id="算术函数">算术函数</h3><table>
<thead>
<tr>
<th style="text-align:left">函数名称</th>
<th style="text-align:left">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>atan2(y,x)</code></td>
<td style="text-align:left">反正切函数</td>
</tr>
<tr>
<td style="text-align:left"><code>cos(x)</code></td>
<td style="text-align:left">余弦函数</td>
</tr>
<tr>
<td style="text-align:left"><code>sin(x)</code></td>
<td style="text-align:left">正弦函数</td>
</tr>
<tr>
<td style="text-align:left"><code>exp(x)</code></td>
<td style="text-align:left"><code>e</code>的幂次方,任意数的幂次方可以使用<code>x**y</code>来算</td>
</tr>
<tr>
<td style="text-align:left"><code>log(x)</code></td>
<td style="text-align:left">自然数的对数</td>
</tr>
<tr>
<td style="text-align:left"><code>sqrt(x)</code></td>
<td style="text-align:left">平方根</td>
</tr>
<tr>
<td style="text-align:left"><code>int(x)</code></td>
<td style="text-align:left">整数的值</td>
</tr>
<tr>
<td style="text-align:left"><code>rand()</code></td>
<td style="text-align:left">任意随机数，大于0小于1，注意得加<code>srand()</code>方法设置种子</td>
</tr>
</tbody>
</table>
<p>这里仅演示<code>rand()</code>随机数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line">BEGIN&#123;</span><br><span class="line">    srand();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print</span> rand();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行得到</p>
<pre><code>yans-MacBook-Pro-<span class="number">2</span>:awk_<span class="built_in">test</span> yanyl$ seq <span class="number">9</span> | awk <span class="operator">-f</span> test.awk
<span class="number">0.107174</span>
<span class="number">0.117314</span>
<span class="number">0.89198</span>
<span class="number">0.700518</span>
<span class="number">0.269547</span>
<span class="number">0.503197</span>
<span class="number">0.402781</span>
<span class="number">0.958053</span>
<span class="number">0.523041</span>
</code></pre><blockquote>
<p>注意，如果不加<code>srand()</code>方法，则多次执行还是原来的随机数…</p>
</blockquote>
<h3 id="字符串函数">字符串函数</h3><table>
<thead>
<tr>
<th style="text-align:left">函数名称</th>
<th style="text-align:left">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>asort(source [, dest [, how ] ])</code></td>
<td style="text-align:left">对数组的值进行排序</td>
</tr>
<tr>
<td style="text-align:left"><code>asorti(source [, dest [, how ] ])</code></td>
<td style="text-align:left">对数组的索引进行排序</td>
</tr>
<tr>
<td style="text-align:left"><code>gensub(regexp, replacement, how [, target])</code></td>
<td style="text-align:left">正则替换，<code>how</code>为替换的个数，为<code>g or G</code>的时候替换全部，还可以将匹配到的部分使用<code>/N</code>的格式来取</td>
</tr>
<tr>
<td style="text-align:left"><code>gsub(regexp, replacement [, target])</code></td>
<td style="text-align:left">正则替换</td>
</tr>
<tr>
<td style="text-align:left"><code>index(in, find)</code></td>
<td style="text-align:left">查找指定字符串的索引位置，不存在时返回0, 还是注意它不支持正则</td>
</tr>
<tr>
<td style="text-align:left"><code>length([string])</code></td>
<td style="text-align:left">查找字符串的长度，如果查找变量未指定的时候，返回0（当做查一个数组）</td>
</tr>
<tr>
<td style="text-align:left"><code>match(string, regexp [, array])</code></td>
<td style="text-align:left">正则查找字符串 返回找到的位置，如果传了<code>array</code>参数，查找的字符串将会丢入这个数组</td>
</tr>
<tr>
<td style="text-align:left"><code>split(string, array [, fieldsep [, seps ] ])</code></td>
<td style="text-align:left">将字符串分割到数组</td>
</tr>
<tr>
<td style="text-align:left"><code>strtonum(str)</code></td>
<td style="text-align:left">将字符串转为数字</td>
</tr>
<tr>
<td style="text-align:left"><code>sub(regexp, replacement [, target])</code></td>
<td style="text-align:left">替换指定字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>substr(string, start [, length ])</code></td>
<td style="text-align:left">截取指定字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>sub(regexp, replacement [, target])</code></td>
<td style="text-align:left">替换指定字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>tolower(string)</code></td>
<td style="text-align:left">转小写</td>
</tr>
<tr>
<td style="text-align:left"><code>toupper(string)</code></td>
<td style="text-align:left">转大写</td>
</tr>
</tbody>
</table>
<p>演示几个常用的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line">BEGIN&#123;</span><br><span class="line">    str=<span class="string">"abc-def"</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> substr(str,<span class="number">3</span>,<span class="number">2</span>) <span class="comment">#截取字符串</span></span><br><span class="line">    sub(/<span class="built_in">cd</span>/,<span class="string">"CD"</span>,str) <span class="comment">#转大写</span></span><br><span class="line">    <span class="built_in">print</span> str</span><br><span class="line">    split(str,arr,<span class="string">"-"</span>) <span class="comment">#分割字符串</span></span><br><span class="line">    <span class="keyword">for</span>(i <span class="keyword">in</span> arr)</span><br><span class="line">        <span class="built_in">print</span> arr[i]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> index(str,<span class="string">"c-d"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到结果</p>
<pre><code>yans-<span class="constant">MacBook-Pro-</span><span class="number">2</span><span class="symbol">:awk_test</span> yanyl<span class="variable">$ </span>seq <span class="number">1</span> | awk -f test.awk
c-
abc-<span class="function"><span class="keyword">def</span>
<span class="title">def</span></span>
abc
<span class="number">3</span>
</code></pre><h3 id="自定义函数">自定义函数</h3><p><code>awk</code>很强大的一点就是支持自定义函数<br>自定义函数的语法如下</p>
<pre><code><span class="function"><span class="keyword">function</span></span> <span class="keyword">name</span>([<span class="type">parameter</span>-list])
{
     body-of-<span class="function"><span class="keyword">function</span></span>
}
</code></pre><p>还是非常简单的熟悉啊</p>
<blockquote>
<p>由于<code>awk</code>是读取整个代码之后再运行的，所以自定义函数也不需要放在调用者之前，可以放任何地方,如有也返回值也直接使用<code>return</code>即可</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BEGIN&#123;</span><br><span class="line">    sayhello(<span class="string">"tom"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> sayhello(name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello,%s\n"</span>,name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用可以有</p>
<pre><code>yans-MacBook-Pro-<span class="number">2</span>:awk_<span class="built_in">test</span> yanyl$ seq <span class="number">1</span> | awk <span class="operator">-f</span> test.awk
hello,tom
</code></pre><blockquote>
<p>函数里面想使用局部变量就必须将其放到传参中</p>
</blockquote>
<h2 id="总结">总结</h2><ol>
<li><code>awk</code>里面只有<code>数值</code>、<code>字符串</code>、<code>数组</code>三种变量</li>
<li><code>awk</code>的数组其实索引从<code>1</code>开始!!!</li>
<li><code>awk</code>的大部分语法和C一样，但是不需要预定义变量</li>
<li><code>awk</code>非常轻量级，处理结构化的文本文件非常的方便</li>
<li><code>awk</code>还有其他很多功能，参见官方文档，因为主要是用其轻量，所以这里不再一一介绍</li>
</ol>
<h2 id="参考">参考</h2><ol>
<li><a href="http://www.ibm.com/developerworks/cn/education/aix/au-gawk/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/education/aix/au-gawk/</a></li>
<li><a href="http://www.gnu.org/software/gawk/manual/gawk.html#Getopt-Function" target="_blank" rel="external">awk guid</a></li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>与其说<span class="tag">awk</span>是一个强大的文本处理工具，我更加喜欢称之为轻量级的<span class="tag">C</span>语言版脚本，有了它，你就能非常自由，轻松的操作文本文件了。<span class="rule"><span class="attribute">ps</span>:<span class="value">比Excel更加方便哦,一句话：awk可以带你装b带你飞~</span></span>
</code></pre><h2 id="初体验：九九乘法表">初体验：九九乘法表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"></span><br><span class="line">BEGIN&#123;</span><br><span class="line">    <span class="built_in">print</span> <span class="string">"lets begins"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=NR;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%sx%s=%s\t"</span>,NR,i,NR*i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">END&#123;</span><br><span class="line">    <span class="built_in">print</span> <span class="string">"ends"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在先看<code>awk</code>程序之前，咱先来看一下由他实现的一个九九乘法表</p>
<pre><code>yans-MacBook-Pro:Downloads yanyl$ seq <span class="number">9</span> | awk -f chengfa.awk
lets begins
<span class="number">1</span><span class="variable">x1=</span><span class="number">1</span>
<span class="number">2</span><span class="variable">x1=</span><span class="number">2</span>    <span class="number">2</span><span class="variable">x2=</span><span class="number">4</span>
<span class="number">3</span><span class="variable">x1=</span><span class="number">3</span>    <span class="number">3</span><span class="variable">x2=</span><span class="number">6</span>    <span class="number">3</span><span class="variable">x3=</span><span class="number">9</span>
<span class="number">4</span><span class="variable">x1=</span><span class="number">4</span>    <span class="number">4</span><span class="variable">x2=</span><span class="number">8</span>    <span class="number">4</span><span class="variable">x3=</span><span class="number">12</span>    <span class="number">4</span><span class="variable">x4=</span><span class="number">16</span>
<span class="number">5</span><span class="variable">x1=</span><span class="number">5</span>    <span class="number">5</span><span class="variable">x2=</span><span class="number">10</span>    <span class="number">5</span><span class="variable">x3=</span><span class="number">15</span>    <span class="number">5</span><span class="variable">x4=</span><span class="number">20</span>    <span class="number">5</span><span class="variable">x5=</span><span class="number">25</span>
<span class="number">6</span><span class="variable">x1=</span><span class="number">6</span>    <span class="number">6</span><span class="variable">x2=</span><span class="number">12</span>    <span class="number">6</span><span class="variable">x3=</span><span class="number">18</span>    <span class="number">6</span><span class="variable">x4=</span><span class="number">24</span>    <span class="number">6</span><span class="variable">x5=</span><span class="number">30</span>    <span class="number">6</span><span class="variable">x6=</span><span class="number">36</span>
<span class="number">7</span><span class="variable">x1=</span><span class="number">7</span>    <span class="number">7</span><span class="variable">x2=</span><span class="number">14</span>    <span class="number">7</span><span class="variable">x3=</span><span class="number">21</span>    <span class="number">7</span><span class="variable">x4=</span><span class="number">28</span>    <span class="number">7</span><span class="variable">x5=</span><span class="number">35</span>    <span class="number">7</span><span class="variable">x6=</span><span class="number">42</span>    <span class="number">7</span><span class="variable">x7=</span><span class="number">49</span>
<span class="number">8</span><span class="variable">x1=</span><span class="number">8</span>    <span class="number">8</span><span class="variable">x2=</span><span class="number">16</span>    <span class="number">8</span><span class="variable">x3=</span><span class="number">24</span>    <span class="number">8</span><span class="variable">x4=</span><span class="number">32</span>    <span class="number">8</span><span class="variable">x5=</span><span class="number">40</span>    <span class="number">8</span><span class="variable">x6=</span><span class="number">48</span>    <span class="number">8</span><span class="variable">x7=</span><span class="number">56</span>    <span class="number">8</span><span class="variable">x8=</span><span class="number">64</span>
<span class="number">9</span><span class="variable">x1=</span><span class="number">9</span>    <span class="number">9</span><span class="variable">x2=</span><span class="number">18</span>    <span class="number">9</span><span class="variable">x3=</span><span class="number">27</span>    <span class="number">9</span><span class="variable">x4=</span><span class="number">36</span>    <span class="number">9</span><span class="variable">x5=</span><span class="number">45</span>    <span class="number">9</span><span class="variable">x6=</span><span class="number">54</span>    <span class="number">9</span><span class="variable">x7=</span><span class="number">63</span>    <span class="number">9</span><span class="variable">x8=</span><span class="number">72</span>    <span class="number">9</span><span class="variable">x9=</span><span class="number">81</span>
ends
yans-MacBook-Pro:Downloads yanyl$
</code></pre>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://kubicode.me/tags/Linux/"/>
    
      <category term="Vim" scheme="http://kubicode.me/tags/Vim/"/>
    
      <category term="Linux" scheme="http://kubicode.me/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop Streaming 实践以及Debug]]></title>
    <link href="http://kubicode.me/2015/11/08/Hadoop/Hadoop-Streaming-Primary-Learning-And-Debug/"/>
    <id>http://kubicode.me/2015/11/08/Hadoop/Hadoop-Streaming-Primary-Learning-And-Debug/</id>
    <published>2015-11-08T01:23:38.000Z</published>
    <updated>2015-11-08T12:23:38.000Z</updated>
    <content type="html"><![CDATA[<pre><code>Hadoop Streaming是一个便于变成<span class="keyword">Map</span> <span class="keyword">Reduce</span>程序的工具包，这个工具包可以支持各种可执行/脚本语言来创建Mapper和Reducer，利用Hadoop的优势进行大数据的处理，这些语言仅仅只需要支持*unix的表示输出输入即可(python,c,c++,perl,akw etc.)
</code></pre><h2 id="Streaming实践">Streaming实践</h2><p>先直接来看一个由<code>python</code>写的<code>Streaming</code>程序，还有那个经典的word count,我们的数据集是一篇<a href="/img/Hadoop-Streaming-Primary-Learning-And-Debug/words.txt">英语作文</a>,<br>看来看他的<code>mapper</code>文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding=utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys,re</span><br><span class="line"></span><br><span class="line">re_english = re.compile(<span class="string">u'[^a-zA-Z0-9\-]+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin: <span class="comment">#这里你可以看做是map类中的line输入</span></span><br><span class="line">    words = re_english.sub(<span class="string">' '</span>,line.strip()) <span class="comment">#这里只提取英文数字</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words.split():</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'%s\t%s'</span> % (word, <span class="number">1</span>)  <span class="comment">#这儿就是标准的输出，用tab隔开  默认第一个值为key</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>其实看上面的<code>mapper</code>文件还是挺带感的，和标准的<code>mapper</code>类很类似，这里就不解释了，相信用<code>java</code>写过标准<code>Map-Reduce</code>都应该很熟悉<br><br>现在再来看<code>reducer</code>文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">!/usr/bin/env python</span><br><span class="line"><span class="comment">#-*- coding=utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">lastk = <span class="keyword">None</span> <span class="comment">#这里标志最后一个k  用于控制同一个key 到一个组中</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">        w,c = line.split(<span class="string">'\t'</span>)</span><br><span class="line">        c = int(c) <span class="comment">#不转成int会比较麻烦  这是是计数</span></span><br><span class="line">        <span class="keyword">if</span> lastk == <span class="keyword">None</span>: <span class="comment">#这里是判断是否过来的是第一个key</span></span><br><span class="line">            lastk=w</span><br><span class="line">            count += c</span><br><span class="line">        <span class="keyword">elif</span> lastk == w:</span><br><span class="line">            count += c</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"%s\t%s"</span>%(lastk,count)</span><br><span class="line">            lastk=w</span><br><span class="line">            count = c <span class="comment">#这里重置计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> lastk <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"%s\t%s"</span>%(lastk,count)</span><br></pre></td></tr></table></figure></p>
<p>陌生感来了把~其实这里是这样的：</p>
<pre><code>都说了是Streaming，他其实是流式进来的，在进来之前还是和标准的mr一样按<span class="built_in">key</span>进行partation划分到各个桶中，然后每个桶会有若干个<span class="built_in">key</span>，这里按<span class="built_in">key</span>分组一次会将记录一条一条的使用*unix的标准输入 读入道sys.stdin中，那么问题了来了，原来mr中的 迭代器的值如何构造？这里主要使用lastk来的变量，每次当输入的<span class="built_in">key</span>与lastk相等的时候，将当前的值加入到字典或者数组中（因为这个demo是wordcount，所以用累加计数来代替了，第<span class="number">16</span>行），直到<span class="built_in">key</span>与lastk不等时（第<span class="number">18</span>行），此时的数组或者字典就是原来 值的迭代器里面的东西，和正常的mr一样操作，该输出的输出，完了之后同时得更新lastk以迎接下一组<span class="built_in">key</span>的到来，同时清空数组或者字典，周而复始，直至全部输入之后，判断我的lastk是否存在值，有的话这个lastk作为最后一组<span class="built_in">key</span>进行输出（第<span class="number">23</span>行），这样的方式就可以构造出原来的(<span class="built_in">key</span>,iter[<span class="built_in">value</span>])模式了
</code></pre><blockquote>
<p>上述的构造看上去些代码可能更加麻烦一点，但是其实这样的方式是应该灵活了</p>
</blockquote>
<p>现在<code>mapper</code>和<code>reducer</code>两个文件写完了，该如何执行呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar <span class="variable">$HADOOP_HOME</span>/share/hadoop/tools/lib/hadoop-streaming-<span class="number">2.7</span>.<span class="number">0</span>.jar \</span><br><span class="line">-input /yyl/data/words.txt \</span><br><span class="line">-output /yyl/<span class="built_in">test</span>/ouput/streaming \</span><br><span class="line">-mapper <span class="variable">$HADOOP_HOME</span>/runjar/pyscript/word_count_mapper.py \</span><br><span class="line">-reducer <span class="variable">$HADOOP_HOME</span>/runjar/pyscript/word_count_reducer.py \</span><br><span class="line">-file <span class="variable">$HADOOP_HOME</span>/runjar/pyscript/*.py \</span><br></pre></td></tr></table></figure>
<p>其实提交的方式很类似原生的<code>jar</code>包提交，只是这里的<code>jar</code>是使用了<code>Hadoop</code>自带的<code>streaming</code>包,敲火车键进行执行</p>
<pre><code><span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">47</span> WARN streaming.<span class="string">StreamJob:</span> -file option is deprecated, please use generic option -files instead.
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">47</span> WARN util.<span class="string">NativeCodeLoader:</span> Unable to load native-hadoop library <span class="keyword">for</span> your platform... using builtin-java classes where applicable
<span class="string">packageJobJar:</span> [<span class="regexp">/root/</span>program<span class="regexp">/hadoop-2.7.0/</span>runjar<span class="regexp">/pyscript/</span>word_count_mapper.py, <span class="regexp">/root/</span>program<span class="regexp">/hadoop-2.7.0/</span>runjar<span class="regexp">/pyscript/</span>word_count_reducer.py, <span class="regexp">/tmp/</span>hadoop-unjar1825196483906999229<span class="regexp">/] [] /</span>tmp/streamjob6480432411236657839.jar tmpDir=<span class="literal">null</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">51</span> INFO client.<span class="string">RMProxy:</span> Connecting to ResourceManager at master/<span class="number">192.168</span>.56.2:<span class="number">8032</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">51</span> INFO client.<span class="string">RMProxy:</span> Connecting to ResourceManager at master/<span class="number">192.168</span>.56.2:<span class="number">8032</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">53</span> INFO mapred.<span class="string">FileInputFormat:</span> Total input paths to <span class="string">process :</span> <span class="number">1</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">54</span> INFO mapreduce.<span class="string">JobSubmitter:</span> number of <span class="string">splits:</span><span class="number">2</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">54</span> INFO mapreduce.<span class="string">JobSubmitter:</span> Submitting tokens <span class="keyword">for</span> <span class="string">job:</span> job_1446946409340_0001
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">55</span> INFO impl.<span class="string">YarnClientImpl:</span> Submitted application application_1446946409340_0001
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">55</span> INFO mapreduce.<span class="string">Job:</span> The url to track the <span class="string">job:</span> <span class="string">http:</span><span class="comment">//master:8088/proxy/application_1446946409340_0001/</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">55</span> INFO mapreduce.<span class="string">Job:</span> Running <span class="string">job:</span> job_1446946409340_0001
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">12</span> INFO mapreduce.<span class="string">Job:</span> Job job_1446946409340_0001 running <span class="keyword">in</span> uber <span class="string">mode :</span> <span class="literal">false</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">12</span> INFO mapreduce.<span class="string">Job:</span>  map <span class="number">0</span>% reduce <span class="number">0</span>%
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">33</span> INFO mapreduce.<span class="string">Job:</span>  map <span class="number">100</span>% reduce <span class="number">0</span>%
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">46</span> INFO mapreduce.<span class="string">Job:</span>  map <span class="number">100</span>% reduce <span class="number">100</span>%
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">47</span> INFO mapreduce.<span class="string">Job:</span> Job job_1446946409340_0001 completed successfully
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">47</span> INFO mapreduce.<span class="string">Job:</span> <span class="string">Counters:</span> <span class="number">49</span>
    File System Counters
----此处和mr一样  省略<span class="number">1</span>w字
    File Input Format Counters
        Bytes Read=<span class="number">2223</span>
    File Output Format Counters
        Bytes Written=<span class="number">1208</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">47</span> INFO streaming.<span class="string">StreamJob:</span> Output <span class="string">directory:</span> <span class="regexp">/yyl/</span>test<span class="regexp">/ouput/</span>streaming
</code></pre><p>然后来查看熟悉的word count结果</p>
<pre><code>[root<span class="annotation">@master</span> pyscript]# hadoop fs -get <span class="regexp">/yyl/</span>test<span class="regexp">/ouput/</span>streaming
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">16</span> WARN util.<span class="string">NativeCodeLoader:</span> Unable to load native-hadoop library <span class="keyword">for</span> your platform... using builtin-java classes where applicable
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">19</span> WARN hdfs.<span class="string">DFSClient:</span> DFSInputStream has been closed already
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">19</span> WARN hdfs.<span class="string">DFSClient:</span> DFSInputStream has been closed already
[root<span class="annotation">@master</span> pyscript]# cd streaming/
[root<span class="annotation">@master</span> streaming]# sort -nr -k <span class="number">2</span> part-<span class="number">00000</span> | head -n <span class="number">10</span>
and    <span class="number">11</span>
to    <span class="number">10</span>
people    <span class="number">10</span>
Micro-blog    <span class="number">8</span>
their    <span class="number">6</span>
a    <span class="number">5</span>
other    <span class="number">4</span>
of    <span class="number">4</span>
more    <span class="number">4</span>
has    <span class="number">4</span>
</code></pre><p>取计数最高的10个，看到了熟悉的字样，好了，这样一次<code>streaming</code>写执行完了，是不是甚是方便</p>
<blockquote>
<p>这里有一个提示，可以再通<code>hadoop版本hadoop-streaming-*.jar</code>的位置不一样，你可以使用<a href="http://kubicode.me/2015/07/26/Linux/Find-Command/" target="_blank" rel="external">find</a>命令进行查找具体的位置</p>
</blockquote>
<p>到了这里已经可以基本执行<code>streaming</code>程序了，但是从上面的跑的命令里可以看到有好多配置的样子，还有另外可以发现，在写的<code>mapper</code>和<code>reducer</code>中只写了数据的处理逻辑，其他的一些配置参数根本无法写入，那么这些东西都是得在执行的命令里面进行配置的，他可以有的配置参数大致有如下几个</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数名称</th>
<th style="text-align:left">可选/必选</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-input</code></td>
<td style="text-align:left"><strong>必选</strong></td>
<td style="text-align:left">输入文件/目录的位置</td>
</tr>
<tr>
<td style="text-align:left"><code>-output</code></td>
<td style="text-align:left"><strong>必选</strong></td>
<td style="text-align:left">输出目录</td>
</tr>
<tr>
<td style="text-align:left"><code>-mapper</code></td>
<td style="text-align:left"><strong>必选</strong></td>
<td style="text-align:left"><code>mapper</code>的执行文件或者<code>JavaClassName</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-reducer</code></td>
<td style="text-align:left"><strong>必选</strong></td>
<td style="text-align:left"><code>reducer</code>的执行或者<code>JavaClassName</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-file</code></td>
<td style="text-align:left"><strong>必选</strong></td>
<td style="text-align:left">执行的mapper或者reducer文件以及其依赖文件，一定要写，多个可以写多行，他会共享到各个节点上，也可以是jar包</td>
</tr>
<tr>
<td style="text-align:left"><code>-inputformat</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">填<code>JavaClassName</code>，为自定义的输入格式，默认是<code>TextInputFormat</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-outputformat</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">填<code>JavaClassName</code>，为自定义的输出格式，默认是<code>TextOutputformat</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-partitioner</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">填<code>JavaClassName</code>，为自定义的分区函数</td>
</tr>
<tr>
<td style="text-align:left"><code>-combiner</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left"><code>mapper</code>输出之后的合并类，是<code>JavaClassName</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-cmdenv</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left"><code>name=value</code>为输入到流命令里面的环境变量</td>
</tr>
<tr>
<td style="text-align:left"><code>-inputreader</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">貌似可以代替<code>-inputformat</code>这个东西</td>
</tr>
<tr>
<td style="text-align:left"><code>-verbose</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">启用<code>java</code>的<code>verbose</code>输出</td>
</tr>
<tr>
<td style="text-align:left"><code>-lazyOutput</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">当输出格式为<code>FileOutputFormat</code>时，可以配置为懒输出-_-</td>
</tr>
<tr>
<td style="text-align:left"><code>-numReduceTasks</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">指定的<code>reducer</code>的数目</td>
</tr>
<tr>
<td style="text-align:left"><code>-mapdebug</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">指定一个脚本当<code>mapper</code>失败的时候进行调用</td>
</tr>
<tr>
<td style="text-align:left"><code>-reducedebug</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">指定一个脚本当<code>reducer</code>失败的时候进行调用</td>
</tr>
<tr>
<td style="text-align:left"><code>-conf</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">指定配置文件</td>
</tr>
<tr>
<td style="text-align:left"><code>-D</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left"><code>property=value</code> 可以配置<code>Hadoop</code>原生的配置项 <strong>实用</strong>^_^</td>
</tr>
</tbody>
</table>
<blockquote>
<p>这么看来，<code>streaming</code>还是很强大以及很灵活的</p>
</blockquote>
<h2 id="Streaming调试">Streaming调试</h2><p>从上述的配置中可以看到 可以配置<code>mapdebug</code>和<code>reducedebug</code>来追踪<code>streaming</code>中的错误信息来进行调试，除了这种方式，<code>streaming</code>调试还有一种更加方便的方式，<br>先来看<code>streaming</code>的执行过程<code>mapper-&gt;shuffle-&gt;reducer</code>，数据以流的方式进行传递的，在<code>Linux</code>中可以配合自带的命令以及官道来完成这一过程，现在可以看模拟刚刚的demo执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master pyscript]<span class="comment"># cat ~/data/words.txt | python word_count_mapper.py | sort | python word_count_reducer.py | sort -nr -k 2 |head -n 10</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到其输出</p>
<pre><code><span class="operator">and</span>    <span class="number">11</span>
<span class="built_in">to</span>    <span class="number">10</span>
people    <span class="number">10</span>
Micro-blog    <span class="number">8</span>
their    <span class="number">6</span>
<span class="operator">a</span>    <span class="number">5</span>
other    <span class="number">4</span>
<span class="operator">of</span>    <span class="number">4</span>
more    <span class="number">4</span>
has    <span class="number">4</span>
</code></pre><p>与上述demo中的结果一模一样，现在大致来分解一下上述命令</p>
<ol>
<li><code>cat ~/data/words.txt </code>:输出文件内容</li>
<li><code>| python word_count_mapper.py</code>:管道命令  将上一步输出的内容输出到要执行的<code>mapper</code>中</li>
<li><code>| sort </code>:管道命令 直接将<code>mapper</code>中输出的内容按第一列进行排序，排序完了之后其实就是达到了分组的效应</li>
<li><code>| python word_count_reducer.py</code>:管道 将排序后的值一次输入到<code>reducer</code>中进行执行，其实到了这一步已经完成了<code>streaming</code>的模拟</li>
<li><code>| sort -nr -k 2 |head -n 10</code> 将最后的结果排个序，再取top</li>
</ol>
<p>使用上述方式来进行调试我感觉有两大优势</p>
<ol>
<li>快，不需要提交到服务器上 慢悠悠的取执行</li>
<li>准，可以直接看到<code>python</code>抛出来的错误</li>
</ol>
<h2 id="Streaming常见错误">Streaming常见错误</h2><ul>
<li>Caused by: java.io.IOException: error=2, No such file or directory<br>  这个往往是由于没有指定<code>mapper,redue=cer</code>的<code>-file</code>引起的，也可以使用通配符<code>*</code></li>
<li>另一未知的错误 估计就是写的脚本执行出了问题，使用上述方式先在本地调试完了再跑</li>
</ul>
<h2 id="总结">总结</h2><p><code>Hadoop streaming</code>写起来很灵活，并且由于跨语言，迁移起来很很快，熟悉不同语言的开发人员也非常容易合作，如果<code>Hadoop streaming</code>程序由多个<code>Map-Reduce</code>构成，那么用<code>Shell</code>来组织整个程序也就会非常的方便快捷</p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://hadoop.apache.org/docs/r2.7.1/hadoop-streaming/HadoopStreaming.html" target="_blank" rel="external">Hadoop Streaming</a></li>
<li><a href="http://shiyanjun.cn/archives/336.html" target="_blank" rel="external">Hadoop Streaming原理及实践</a></li>
<li><a href="http://dongxicheng.org/mapreduce/hadoop-streaming-programming/" target="_blank" rel="external">Hadoop Streaming 编程</a></li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>Hadoop Streaming是一个便于变成<span class="keyword">Map</span> <span class="keyword">Reduce</span>程序的工具包，这个工具包可以支持各种可执行/脚本语言来创建Mapper和Reducer，利用Hadoop的优势进行大数据的处理，这些语言仅仅只需要支持*unix的表示输出输入即可(python,c,c++,perl,akw etc.)
</code></pre><h2 id="Streaming实践">Streaming实践</h2><p>先直接来看一个由<code>python</code>写的<code>Streaming</code>程序，还有那个经典的word count,我们的数据集是一篇<a href="/img/Hadoop-Streaming-Primary-Learning-And-Debug/words.txt">英语作文</a>,<br>看来看他的<code>mapper</code>文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding=utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys,re</span><br><span class="line"></span><br><span class="line">re_english = re.compile(<span class="string">u'[^a-zA-Z0-9\-]+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin: <span class="comment">#这里你可以看做是map类中的line输入</span></span><br><span class="line">    words = re_english.sub(<span class="string">' '</span>,line.strip()) <span class="comment">#这里只提取英文数字</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words.split():</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'%s\t%s'</span> % (word, <span class="number">1</span>)  <span class="comment">#这儿就是标准的输出，用tab隔开  默认第一个值为key</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Hadoop" scheme="http://kubicode.me/tags/Hadoop/"/>
    
      <category term="Hadoop" scheme="http://kubicode.me/categories/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Mac的OSX系统中配置VIM]]></title>
    <link href="http://kubicode.me/2015/11/07/Mac/Mac-OSX-Vim-highlight/"/>
    <id>http://kubicode.me/2015/11/07/Mac/Mac-OSX-Vim-highlight/</id>
    <published>2015-11-07T12:19:43.000Z</published>
    <updated>2015-11-07T12:39:50.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文主要参考<a href="http://www.yeyaxi.com/2011/06/how-to-enable-syntax-highlighting-for-vim-in-mac-osx/" target="_blank" rel="external">[译]如何在Mac OS X中开启VIM语法高亮</a>,他是真的work啊^_^</p>
</blockquote>
<p>使用<code>vim</code>来敲代码很带感，设置<code>vim</code>是一大要事，但是在<code>Mac</code>的<code>vim</code>默认是黑白的，而且并不能像<code>Linux</code>设置<code>~/.vimrc</code>来进行配置，但是毕竟还有其他的方法，先下面一步一步走就可以了</p>
<p>首先进入终端之后输入如下代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/vim</span><br><span class="line"></span><br><span class="line">sudo vim vimrc</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>然后再打开的文件中插入下面的配置<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> ai                  <span class="string">" auto indenting</span><br><span class="line"></span><span class="keyword">set</span> <span class="keyword">history</span>=<span class="number">100</span>         <span class="string">" keep 100 lines of history</span><br><span class="line"></span><span class="keyword">set</span> ruler               <span class="string">" show the cursor position</span><br><span class="line"></span><span class="keyword">syntax</span> <span class="keyword">on</span>               <span class="string">" syntax highlighting</span><br><span class="line"></span><span class="keyword">set</span> hlsearch            <span class="string">" highlight the last searched term</span><br><span class="line"></span><span class="keyword">filetype</span> plugin <span class="keyword">on</span>      <span class="string">" use the file type plugins</span><br><span class="line"></span><span class="keyword">set</span> <span class="keyword">ts</span>=<span class="number">4</span>                <span class="string">" tab space =4</span><br><span class="line"></span><span class="keyword">set</span> expandtab</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span>				<span class="string">" show line number</span><br><span class="line"></span><span class="keyword">set</span> <span class="built_in">shiftwidth</span>          <span class="string">" 这个貌是可以用于批量缩进的时候设置为4个空格</span><br><span class="line"></span><span class="keyword">highlight</span> Comment ctermfg=green guifg=green  <span class="string">"高亮备注为绿色</span><br><span class="line"></span></span><br><span class="line"><span class="string">" When editing a file, always jump to the last cursor position</span><br><span class="line"></span><span class="keyword">autocmd</span> BufReadPost *</span><br><span class="line">\ <span class="keyword">if</span> ! <span class="built_in">exists</span>(<span class="string">"g:leave_my_cursor_position_alone"</span>) |</span><br><span class="line">\ <span class="keyword">if</span> <span class="built_in">line</span>(<span class="string">"'\""</span>) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">line</span> (<span class="string">"'\""</span>) &lt;= <span class="built_in">line</span>(<span class="string">"$"</span>) |</span><br><span class="line">\ <span class="keyword">exe</span> <span class="string">"normal g'\""</span> |</span><br><span class="line">\ <span class="keyword">endif</span> |</span><br><span class="line">\ <span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p>
<p>接着退出之后随便使用<code>vim</code>打开一个文件之后可以看到颜色亮起来了<br><img src="/img/Mac-OSX-Vim-highlight/vim_highlight.png" alt=""></p>
<p>瞬间就带感了，其他的设置都可以去在刚刚的文件里面进行配置</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文主要参考<a href="http://www.yeyaxi.com/2011/06/how-to-enable-syntax-highlighting-for-vim-in-mac-osx/">[译]如何在Mac OS X中开启VIM语法高亮</a>,他是真的work啊^_^</p>
</blockquote>
<p>使用<code>vim</code>来敲代码很带感，设置<code>vim</code>是一大要事，但是在<code>Mac</code>的<code>vim</code>默认是黑白的，而且并不能像<code>Linux</code>设置<code>~/.vimrc</code>来进行配置，但是毕竟还有其他的方法，先下面一步一步走就可以了</p>
<p>首先进入终端之后输入如下代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/vim</span><br><span class="line"></span><br><span class="line">sudo vim vimrc</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://kubicode.me/tags/Mac/"/>
    
      <category term="Mac" scheme="http://kubicode.me/categories/Mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[来来来，学习Shell的命令]]></title>
    <link href="http://kubicode.me/2015/11/04/Linux/Shell-Command-List/"/>
    <id>http://kubicode.me/2015/11/04/Linux/Shell-Command-List/</id>
    <published>2015-11-04T14:34:28.000Z</published>
    <updated>2015-11-27T08:29:34.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Shell脚本是非常强的大一个脚本语言，但是不用会手生，所以在此记录Shell脚本的相应关键点，也做查字典用^_^</p>
</blockquote>
<h2 id="变量">变量</h2><h3 id="变量定义">变量定义</h3><p>先来简单的看一下变量定义的规则</p>
<ol>
<li>在<code>Shell</code>中，使用变量之前不需要事先声明，只是通过使用它们来创建它们；</li>
<li>在默认情况下，所有变量都被看做是字符串，并以字符串来存储；</li>
<li><code>Shell</code>变量是区分大小写的；</li>
<li>在赋值变量的时候等号两端不能有空格-_-</li>
</ol>
<a id="more"></a>
<p>定义了变量之后，一定要加上<code>$</code>符号才能使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">VAR1=HELLO</span><br><span class="line">VAR2=MY NAME</span><br><span class="line">VAR3=<span class="string">"MY AGE"</span></span><br><span class="line">VAR4 = IS</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> VAR1 <span class="comment">#error 能输出 但不是输出该变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$VAR1</span> <span class="comment">#ok 正常读取变量并打印</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$VAR2</span> <span class="comment">#error 定义变量的值 用空格隔开了</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$VAR3</span> <span class="comment">#ok 作为一整个字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$VAR4</span> <span class="comment">#error 变量定义的时候等号两端有空格</span></span><br></pre></td></tr></table></figure>
<p>输出的结果为</p>
<pre><code>./test.sh: <span class="built_in">line</span> <span class="number">2</span>: NAME: <span class="command"><span class="keyword">command</span> <span class="title">not</span> <span class="title">found</span></span>
./test.sh: <span class="built_in">line</span> <span class="number">4</span>: VAR4: <span class="command"><span class="keyword">command</span> <span class="title">not</span> <span class="title">found</span></span>
VAR1
HELLO

MY AGE
</code></pre><blockquote>
<p>关于<code>shell</code>脚本的执行：<code>shell</code>基本一般是以<code>.sh</code>为后缀,然后在<code>*unix</code>系统下一般都是直接使用<code>./[当前shell文件名]</code> 的方式来执行，也可以使用<code>全部经/[shell文件名]</code>的方式来执行，并且需要注意的是 被执行的<code>shell</code>文件一定是有含有可执行权限了的，可以使用<code>chmod</code>命令来修改</p>
</blockquote>
<p>还有另一个点就是在调用变量的时候 ，如果在双引号中直接使用<code>$name</code>任然可以识别，但是如果在单引号是就无法适用<code>$name</code>的方式来调用变量</p>
<h3 id="read读取输入值">read读取输入值</h3><p>这个功能就像<code>java</code>中的<code>readline</code>来读取，使用方法为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"whats your name?"</span></span><br><span class="line"><span class="built_in">read</span> NAME  <span class="comment">#在这里读取输入值到NAME变量中 ，这里如果不输入会停留在屏幕上</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"webcome back"</span> <span class="variable">$NAME</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到熟悉的结果为</p>
<pre><code>whats your <span class="property">name</span>?
tom
webcome <span class="keyword">back</span> tom
</code></pre><h3 id="环境变量">环境变量</h3><p><code>Shell</code>脚本还提供能一些实用的环境变量</p>
<ol>
<li><code>$HOME</code>:为当前用户所在的目录</li>
<li><code>$PATH</code>:当前用户所能方法的PATH变量</li>
<li><code>$#</code>:传递参数额个数  类似<code>java</code>中的<code>args.length</code></li>
<li><code>$$</code><code>:Shell</code>脚本的进程号，脚本程序通常会用它来生成一个唯一的临时文件。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前用户所在的目录为"</span> <span class="variable">$HOME</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前的执行目录为"</span> $(<span class="built_in">pwd</span>)  <span class="comment">#这个是访问当前的脚本的目录很实用</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前用户所能访问的PATH为"</span> <span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前参数的参数个数为"</span> <span class="variable">$#</span>  <span class="comment">#这儿参数的格式是使用空格隔开的哦</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前Shell脚本的进程号为"</span> $$</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以到看的结果是</p>
<pre><code>yans-MacBook-<span class="string">Pro:</span>Downloads yanyl$ ./hi.sh  hello world
当前用户所在的目录为 <span class="regexp">/Users/</span>yanyl
当前的执行目录为 <span class="regexp">/Users/</span>yanyl/Downloads
当前用户所能访问的PATH为 <span class="regexp">/usr/</span>local<span class="regexp">/bin:/</span>usr<span class="regexp">/bin:/</span><span class="string">bin:</span><span class="regexp">/usr/</span><span class="string">sbin:</span><span class="regexp">/sbin:/</span>Users<span class="regexp">/yanyl/</span>Program<span class="regexp">/apache-maven-3.2.5/</span><span class="string">bin:</span><span class="regexp">/Users/</span>yanyl<span class="regexp">/Program/</span>scala-<span class="number">2.10</span>.4<span class="comment">//bin</span>
当前参数的参数个数为 <span class="number">2</span>
当前Shell脚本的进程号为 <span class="number">43746</span>
</code></pre><blockquote>
<p>假如需要进入当前目录的父目录，可以使用<code>$(dirname $(pwd))</code></p>
</blockquote>
<h3 id="参数变量">参数变量</h3><p>刚刚看到可以使用<code>read</code>关键字可以来读取输入变量，但是我们可能更加常用的是参数变量，也就是<code>$#</code>的个数，它的规则如下</p>
<ol>
<li><code>$#</code>表示参数变量的个数</li>
<li><code>$0</code>表示当前的脚本名称</li>
<li><code>$1,$2…$n</code>表示依次能读取到的变量 但是如果参数变量不够，<code>$i</code>会被赋值为空</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前输入的参数变量的长度为"</span> <span class="variable">$#</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前执行的Shell脚本为"</span> <span class="variable">$0</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前输入的第一个参数为"</span> <span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前输入的第二个参数为"</span> <span class="variable">$2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前的输入的第三个参数为"</span> <span class="variable">$3</span> <span class="comment">#现在如果只传2个参数 这里将不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以看到的结果为</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ ./hi.<span class="keyword">sh</span>  hello world
当前输入的参数变量的长度为 2
当前执行的<span class="keyword">Shell</span>脚本为 ./hi.<span class="keyword">sh</span>
当前输入的第一个参数为 hello
当前输入的第二个参数为 world
当前的输入的第三个参数为
</code></pre><p>可以看到在<code>Shell</code>脚本中去读取参数变量还是很方便的，这样配合下面的条件判断以及循环就可以做很多事情了</p>
<h3 id="读取返回码">读取返回码</h3><p>一般的程序/命令在执行结束时都会返回一个 返回码，比如</p>
<ul>
<li><code>java</code>的<code>system.exit(-1)</code></li>
<li><code>python</code>的<code>sys.exit(-1)</code></li>
<li>还有上面<code>Shell</code>脚本中的最后一行<code>exit 0</code></li>
</ul>
<blockquote>
<p>如果你不显式指定返回码，一般默认为0，表示正常退出，但是有时候显式的指定返回码是一个好习惯哦<br>这些程序在<code>Shell</code>中执行的,可以使用<code>$?</code>来读取上一个程序执行下来的脚本码</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">du <span class="operator">-s</span> <span class="comment">#执行的返回码一般为0</span></span><br><span class="line"><span class="built_in">echo</span> du <span class="operator">-s</span>的返回码为 $?</span><br><span class="line"></span><br><span class="line">duu <span class="operator">-s</span> <span class="comment">#这个命令故意输错</span></span><br><span class="line"><span class="built_in">echo</span> duu <span class="operator">-s</span>的返回码为 $?</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以看到正确的结果为</p>
<pre><code><span class="number">28494656</span>    .
du <span class="operator">-s</span>的返回码为 <span class="number">0</span>
./hi.sh: line <span class="number">6</span>: duu: <span class="built_in">command</span> not found
duu <span class="operator">-s</span>的返回码为 <span class="number">127</span>
</code></pre><blockquote>
<p>返回码配上<code>if</code>判断，就可以使用<code>shell</code>脚本自由得在各个语言以及命令中穿梭啦^_^</p>
</blockquote>
<h2 id="数学运算">数学运算</h2><p>在上一小节中说道，<code>Shell</code>中变量一般都是当字符串来处理，那我遇到数字运算该咋办呢？？</p>
<p>可以先看<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">a=<span class="number">1</span>+<span class="number">2</span></span><br><span class="line">b=<span class="variable">$a</span>+<span class="number">3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>结果却看到</p>
<pre><code>1+2
1+2+3
</code></pre><p>那在<code>Shell</code>中解决这个问题大概有这么几种方法</p>
<h3 id="let关键字">let关键字</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">let</span> a=<span class="number">1</span>+<span class="number">2</span></span><br><span class="line"><span class="built_in">let</span> b=<span class="variable">$a</span>+<span class="number">3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>输出的结果为</p>
<pre><code>3
6
</code></pre><p>这个关键词大致需要注意以下几个点:</p>
<ul>
<li><code>let</code>只支持整数运算</li>
<li>当<code>let</code>后面的运算部分有<code>bash</code>关键字时，需加双引号</li>
<li>幂次方可以使用**符号</li>
</ul>
<h3 id="使用(())">使用(())</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">((a=<span class="number">1</span>+<span class="number">2</span>))</span><br><span class="line">((b=<span class="variable">$a</span>+<span class="number">3</span>))</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>结果还是正确的</p>
<pre><code>3
6
</code></pre><blockquote>
<p><code>(())</code>的用法与<code>let</code>完全相同</p>
</blockquote>
<h3 id="使用$[]">使用$[]</h3><p>上面的效果需要这么写<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=$[<span class="number">1</span>+<span class="number">2</span>]</span><br><span class="line">b=$[<span class="variable">$a</span>+<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<p>其余与上面两种限制大致相同</p>
<h3 id="使用expr">使用expr</h3><p>关于这个方式是这么写的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=`expr <span class="number">1</span> + <span class="number">2</span>`</span><br><span class="line">b=`expr <span class="variable">$a</span> \* <span class="number">3</span>`  <span class="comment">#需要转义</span></span><br></pre></td></tr></table></figure></p>
<p>需要额外注意的有：</p>
<ul>
<li>运算符两端需要加空格  一定要记住。。。很容易失误</li>
<li>对于<code>|、&amp;、&lt;、&lt;=、&gt;=、&gt;、*</code>运算符号需要加上<code>\</code>进行转义</li>
</ul>
<h3 id="使用bc">使用bc</h3><p>这个终于是可以用于浮点数的运算了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">a=<span class="number">3.1415926</span></span><br><span class="line">b=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span>*2"</span>|bc`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到结果</p>
<pre><code>3.1415926
6.2831852
</code></pre><p>据说这里还有一个<code>scale</code>来设置精度，但是我设置了感觉木有效果-_-</p>
<h2 id="条件判断">条件判断</h2><h3 id="if_语法">if 语法</h3><p>在<code>Shell</code>脚本中有两种书写<code>if</code>判断的语法</p>
<ul>
<li><p>使用<code>test</code> 关键字</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># if test expression1 operation expression2</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="number">5</span> <span class="operator">-gt</span> <span class="number">4</span>;  <span class="comment">#这个最后的结尾可以加上:或者;</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"ok,5&gt;4"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"oh,no"</span></span><br><span class="line"><span class="keyword">fi</span> <span class="comment">#这个结束符号必须得加</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>  输出为</p>
<pre><code><span class="ok">ok</span>,<span class="number">5</span>&gt;<span class="number">4</span>
</code></pre></li>
<li><p>使用<code>[</code>和<code>]</code>关键字</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># if [ expression1 operation expression2 ]</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="number">5</span> <span class="operator">-lt</span> <span class="number">4</span> ];  <span class="comment">#注意[和]两端必须留空格 同时表达式两端都需要有空格</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"ok,5&gt;4"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"oh,no"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>  输出为</p>
<pre><code>oh,<span class="literal">no</span>
</code></pre></li>
</ul>
<blockquote>
<p>如果还更加复杂的判断你可以使用<code>elif</code>继续增加条件表达式，但是别忘了加<code>then</code>哦</p>
</blockquote>
<h3 id="判断表达式">判断表达式</h3><p>在<code>Shell</code>中有三种判断表达式</p>
<h4 id="字符串比较">字符串比较</h4><table>
<thead>
<tr>
<th style="text-align:left">字符串比较</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>string1 = string2</code></td>
<td style="text-align:left">如果两个字符串相同，也可用<code>==</code>结果就为真</td>
</tr>
<tr>
<td style="text-align:left"><code>string1 != string2</code></td>
<td style="text-align:left">如果两个字符串不同，结果就为真</td>
</tr>
<tr>
<td style="text-align:left"><code>-n string</code></td>
<td style="text-align:left">如果字符串不为空，则结果为真</td>
</tr>
<tr>
<td style="text-align:left"><code>-z string</code></td>
<td style="text-align:left">如果字符串为一个空串（<code>null</code>），则结果为真</td>
</tr>
</tbody>
</table>
<blockquote>
<p>这里需要注意下，<code>-n</code> 和 <code>-z string</code>比较时必须用双引号(“”)将变量引起来</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">a=<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$a</span>"</span>  ]  <span class="comment">#注意要空括号来包住哦</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> exists</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> null</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$c</span>"</span>  ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> exists</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> null</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>结果为</p>
<pre><code>exists
<span class="literal">null</span>
</code></pre><h4 id="算术比较">算术比较</h4><table>
<thead>
<tr>
<th style="text-align:left">算术比较</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>expression1 -eq expression2</code></td>
<td style="text-align:left">如果两个表达式相等，则结果为真</td>
</tr>
<tr>
<td style="text-align:left"><code>expression1 -ne expression2</code></td>
<td style="text-align:left">如果两个表达式不等，则结果为真</td>
</tr>
<tr>
<td style="text-align:left"><code>expression1 -gt expression2</code></td>
<td style="text-align:left">如果<code>expression1</code> 大于<code>expression2</code> ，则为真</td>
</tr>
<tr>
<td style="text-align:left"><code>expression1 -ge expression2</code></td>
<td style="text-align:left">如果<code>expression1</code> 大于等于<code>expression2</code> ,则为真</td>
</tr>
<tr>
<td style="text-align:left"><code>expression1 -lt expression2</code></td>
<td style="text-align:left">如果<code>expression1</code> 小于<code>expression2</code> ，则为真</td>
</tr>
<tr>
<td style="text-align:left"><code>expression1 -le expression2</code></td>
<td style="text-align:left">如果<code>expression1</code> 小于等于<code>expression2</code> ，则为真</td>
</tr>
<tr>
<td style="text-align:left"><code>!expression</code></td>
<td style="text-align:left">表达式为假，则结果就为真；反之亦然</td>
</tr>
</tbody>
</table>
<blockquote>
<p>关于上面比较符号的快速记法如下：<code>eq=equal</code>,<code>gt=great than</code>,<code>lt=less than</code>，然后组合拼凑即可，如果觉得这样还是很难记，就可以像我一样，将这些符号记录下来，需要的时候来查表-_-</p>
</blockquote>
<h4 id="文件条件测试">文件条件测试</h4><table>
<thead>
<tr>
<th style="text-align:left">文件条件测试</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-d file</code></td>
<td style="text-align:left">如果文件是一个目录，则为真</td>
</tr>
<tr>
<td style="text-align:left"><code>-f file</code></td>
<td style="text-align:left">如果文件是一个普通文件，则为真；也可以用来测试文件是否存在</td>
</tr>
<tr>
<td style="text-align:left"><code>-r file</code></td>
<td style="text-align:left">如果文件可读，则结果为真</td>
</tr>
<tr>
<td style="text-align:left"><code>-s file</code></td>
<td style="text-align:left">如果文件大小不为0，则结果为真</td>
</tr>
<tr>
<td style="text-align:left"><code>-w file</code></td>
<td style="text-align:left">如果文件可写，则结果为真</td>
</tr>
<tr>
<td style="text-align:left"><code>-x file</code></td>
<td style="text-align:left">如果文件可执行，则结果为真</td>
</tr>
</tbody>
</table>
<blockquote>
<p>这，真的是一个利民的测试</p>
</blockquote>
<h2 id="循环结构">循环结构</h2><h3 id="for_循环">for 循环</h3><p>先来看一种经典<code>C</code>语法版的<code>for</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">for</span> ((i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>看输出，</p>
<pre><code>0
1
2
3
4
</code></pre><p>还支持在外部控制步长<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">for</span> ((i=<span class="number">0</span>;i&lt;<span class="number">5</span>;))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">    i=$[<span class="variable">$i</span>+<span class="number">2</span>]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<pre><code>0
2
4
</code></pre><blockquote>
<p>是不是感觉基本功能都有呀，就是写某些东西写起来奇怪点<br>是不是有一种莫名的熟悉感</p>
</blockquote>
<p>另一种就是类似<code>foreach</code>的情况了，他的格式是这样的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> variable <span class="keyword">in</span> values</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>values</code> 可能有的情况为：</p>
<ol>
<li><p>使用<code>linux</code>命令输出的行作为迭代的输入:<code>ls</code>,<code>seq</code>,<code>cat</code>之类均可,其实就可以完成很强大的文件读取功能</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `head -n <span class="number">5</span> words.dit`;<span class="keyword">do</span>  <span class="comment">#words.dit 这是一个通用词表 每行一个词</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p> 可以看到通用词典中前5个词</p>
<pre><code>阿
阿巴丹
阿巴岛
阿巴鸟
阿巴伊达
</code></pre></li>
<li><p>使用<code>$*</code>可以来表示遍历传入的参数列表</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $*;<span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p> 来看个结果</p>
<pre><code>yans-MacBook-Pro:Downloads yanyl$ ./hi.sh  <span class="keyword">my</span> <span class="property">name</span> <span class="keyword">is</span> tom
<span class="keyword">my</span>
<span class="property">name</span>
<span class="keyword">is</span>
tom
</code></pre></li>
<li><p>还可以使用带空格的字符串 来进行按空格分隔输出</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">a=<span class="string">"yello red green"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$a</span>;<span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p> 这样在一定程度上可以看成一个简易的数组</p>
</li>
</ol>
<p>这里需要注意的是包含条件以及循环逻辑是双重括号，以及开始结果的<code>do</code>和<code>Done</code></p>
<h3 id="while_循环">while 循环</h3><p>另一个常用的就是<code>while</code>循环了<br>他的结构是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>这个也是蛮好理解的，可以来看一个demo<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"please ent your password:"</span></span><br><span class="line"><span class="built_in">read</span> <span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">"<span class="variable">$pwd</span>"</span>x != <span class="string">"root"</span>x  ] <span class="comment">#这里加x是为了防止啥也不输入直接回车产生的报错</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"error,please try again:"</span></span><br><span class="line">    <span class="built_in">read</span> <span class="built_in">pwd</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"welcome here"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>看一下结果</p>
<pre><code>please ent your <span class="string">password:</span>
sha
error,please <span class="keyword">try</span> <span class="string">again:</span>

error,please <span class="keyword">try</span> <span class="string">again:</span>
root
welcome here
</code></pre><p>很有意思的一个哈~</p>
<h3 id="until语句">until语句</h3><p>这个语句与<code>while</code>的结构完全一样，只是使用了<code>until</code>关键字来代替了<code>while</code>，然后在条件为<code>true</code>的时候停止，正好与<code>while</code>相反</p>
<h2 id="函数">函数</h2><p><code>Shell</code>这么叼，能没有函数吗<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">function</span>] <span class="function"><span class="title">functon_name</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是定义函数的结构，大致有以下几个要点</p>
<ol>
<li>前面的<code>function</code>关键字可有可无，不过感觉还是加上去比较好，这样在代码里面比较好辨识</li>
<li>函数名后面的括号中不能带参数 取的参数是用过<code>$1,$2…$n</code>这样的方式来取的 </li>
<li>调用的时候直接写函数名 不需要加括号</li>
<li>如果想传递参数的话 直接在调用后来加上参数列表 用空格隔开 （就是<code>Shell</code>的传参一样）</li>
<li>使用<code>local</code>关键字来定义函数体里面的局部变量</li>
<li>所以在函数调用必须在函数定义之后</li>
</ol>
<p>先看一个小的demo<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sayhi</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> hi <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayhi tom <span class="comment">#前面的sayhi是函数的调用 后面的tom是传参</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到输出</p>
<pre><code><span class="title">hi</span> tom
</code></pre><h3 id="函数的返回值">函数的返回值</h3><p>关于<code>Shell</code>的返回值方式有两种</p>
<ol>
<li><p>输出给主程序，他的结构为：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">function_name</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$something</span>  <span class="comment">#通过输出的方式来返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a=`<span class="keyword">function</span>_name`  这种方式接收返回值</span><br></pre></td></tr></table></figure>
<p> 看到的demo可以是这样的</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Press ENTER or <span class="built_in">type</span> <span class="built_in">command</span> to <span class="built_in">continue</span></span><br><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sum</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> $[<span class="variable">$1</span>+<span class="variable">$2</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a=`sum <span class="number">1</span> <span class="number">2</span>`</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> the sum is <span class="variable">$a</span></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p> 最终输出结果为</p>
<pre><code><span class="operator">the</span> <span class="built_in">sum</span> is <span class="number">3</span>
</code></pre></li>
<li><p>使用<code>return</code>作为返回码来返回值</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">function_name</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> <span class="variable">$ret</span> <span class="comment">#这里进行返回码的返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>_name</span><br><span class="line">$? <span class="comment">#在这里接收返回值</span></span><br></pre></td></tr></table></figure>
<p> 一样再来一个demo</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sum</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> $[<span class="variable">$1</span>+<span class="variable">$2</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="built_in">echo</span> the sum is $?</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p> 可以看到输出为</p>
<pre><code><span class="operator">the</span> <span class="built_in">sum</span> is <span class="number">3</span>
</code></pre></li>
</ol>
<h2 id="case语句">case语句</h2><p>这里的<code>case</code>的与传统的<code>switch</code>有点像，但是又像<code>scala</code>中的<code>match</code>模式匹配的强大，<br>他的结构是这样的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> variable <span class="keyword">in</span></span><br><span class="line">    pattern [ | pattern] ...) statements;;</span><br><span class="line">    pattern [ | pattern] ...) statements;;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></p>
<p>来看这个强大的demo<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">match</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">        root ) <span class="built_in">echo</span> this is password ;;</span><br><span class="line">        h* ) <span class="built_in">echo</span> hi <span class="variable">$1</span> ;; <span class="comment">#使用通配符</span></span><br><span class="line">        yes | YES ) <span class="built_in">echo</span> agree with me ;; <span class="comment">#可以进行或操作</span></span><br><span class="line">        * ) <span class="built_in">echo</span> everything is here;;  <span class="comment">#你可以理解为switch中的default</span></span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">match root</span><br><span class="line">match hello</span><br><span class="line">match YES</span><br><span class="line">match Yes</span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>来看一下结果</p>
<pre><code><span class="keyword">this</span> <span class="keyword">is</span> password
hi hello
agree <span class="keyword">with</span> me
everything <span class="keyword">is</span> here
</code></pre><blockquote>
<p>注意，这里一旦匹配中了一个之后就马上会停止匹配</p>
</blockquote>
<h2 id="外部命令/文件/语言的调用">外部命令/文件/语言的调用</h2><p><code>Shell</code>的另一个强大之处就是可以无缝的和外部的命令，文件，语言结合，去调用组织他们</p>
<ol>
<li>外部命令：一般情况下可以直接写外部命令，如果要赋值的话得使用<code>``</code>括起来</li>
<li>外部文件：比如资源配置文件，profile文件之类的，可以直接使用<code>source</code>关键字的来执行</li>
<li>外部语言：比如<code>java,python</code>可以直接使用他们的<code>java</code>调用<code>jar,java</code>文件，也可以直接使用<code></code>关键字来执行<code>python</code>文件</li>
</ol>
<h2 id="总结">总结</h2><ol>
<li><code>Shell</code>很好很强大，得学习！！！</li>
<li>注意变量的字符串格式以及需要数学运算时的语法</li>
<li>注意变量赋值时等号两端一定不能有空格以及再取值时一定要加<code>$</code></li>
<li>平常的控制结束符号别忘了，比如<code>fi,doen,esac</code>等</li>
<li>忘了的时候来查查这个文件</li>
</ol>
<h2 id="参考">参考</h2><ul>
<li><a href="http://blog.csdn.net/mdx20072419/article/details/9381339" target="_blank" rel="external">shell 函数返回值接收问题</a></li>
<li><a href="http://www.jellythink.com/archives/699" target="_blank" rel="external">Linux Shell简明教程</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_9d074aae01012ytf.html" target="_blank" rel="external">shell中for循环总结</a></li>
<li><a href="http://www.1987.name/181.html" target="_blank" rel="external">Shell函数的定义、执行、传参和递归函数</a></li>
<li><a href="http://www.cnblogs.com/liujiahi/archive/2011/03/30/2196400.html" target="_blank" rel="external">shell 中数学计算总结</a></li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Shell脚本是非常强的大一个脚本语言，但是不用会手生，所以在此记录Shell脚本的相应关键点，也做查字典用^_^</p>
</blockquote>
<h2 id="变量">变量</h2><h3 id="变量定义">变量定义</h3><p>先来简单的看一下变量定义的规则</p>
<ol>
<li>在<code>Shell</code>中，使用变量之前不需要事先声明，只是通过使用它们来创建它们；</li>
<li>在默认情况下，所有变量都被看做是字符串，并以字符串来存储；</li>
<li><code>Shell</code>变量是区分大小写的；</li>
<li>在赋值变量的时候等号两端不能有空格-_-</li>
</ol>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://kubicode.me/tags/Linux/"/>
    
      <category term="Vim" scheme="http://kubicode.me/tags/Vim/"/>
    
      <category term="Linux" scheme="http://kubicode.me/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[KNN算法中KD树的应用]]></title>
    <link href="http://kubicode.me/2015/10/12/Machine%20Learning/KDTree-In-KNN/"/>
    <id>http://kubicode.me/2015/10/12/Machine Learning/KDTree-In-KNN/</id>
    <published>2015-10-12T03:57:39.000Z</published>
    <updated>2015-10-12T08:10:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="KNN算法">KNN算法</h2><pre><code>给一个训练数据集和一个新的实例，在训练数据集中找出与这个新实例最近的k个训练实例，然后统计最近的k个训练实例中所属类别计数最多的那个类，就是新实例的类。
</code></pre><p><a href="http://kubicode.me/2015/08/16/Machine%20Learning/Algorithm-Summary-for-Interview/#KNN算法" target="_blank" rel="external">点我查看详情</a></p>
<blockquote>
<p>但是该算法每次在查询k个最近邻的时候都需要遍历全集  才能计算出来，可想而且如果训练样本很大的话，代价还是很大的，那有没有啥方法可以优化呢？本文就针对<code>KNN</code>算法实现一个简单的<code>KD</code>树</p>
</blockquote>
<h2 id="KD树">KD树</h2><pre><code>KD树是一个二叉树，表示对<span class="keyword">K</span>维空间的一个划分，可以进行快速检索（那KNN计算的时候不需要对全样本进行距离的计算了）
</code></pre><p>比如针对6个二维数据点{（2,3），（5,4），（9,6），（4,7），（8,1），（7,2）}，可以形成以下树形结构以及空间划分<br><img src="/img/KDTree-In-KNN/example.png" alt=""></p>
<a id="more"></a>
<p>该树的功能就是在高维空间下进行一个快速的最近邻查询。先来看定义的树的类结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">double</span>[] data;<span class="comment">//树上节点的数据  是一个多维的向量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">double</span> distance;<span class="comment">//与当前查询点的距离  初始化的时候是没有的</span></span><br><span class="line">	<span class="keyword">public</span> Node left,right,parent;<span class="comment">//左右子节点  以及父节点</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> dim=-<span class="number">1</span>;<span class="comment">//维度  建立树的时候判断的维度</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">double</span>[] data)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data=data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 返回指定索引上的数值</span><br><span class="line">	 *<span class="javadoctag"> @param</span> index</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getData</span><span class="params">(<span class="keyword">int</span> index)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(data==<span class="keyword">null</span> || data.length&lt;=index)</span><br><span class="line">			<span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">		<span class="keyword">return</span> data[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.distance&gt;o.distance)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(<span class="keyword">this</span>.distance==o.distance)</span></span><br><span class="line">			return 0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 计算距离 这里返回欧式距离</span><br><span class="line">	 *<span class="javadoctag"> @param</span> that</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">computeDistance</span><span class="params">(Node that)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.data==<span class="keyword">null</span> || that.data==<span class="keyword">null</span> || <span class="keyword">this</span>.data.length!=that.data.length)</span><br><span class="line">			<span class="keyword">return</span> Double.MAX_VALUE;<span class="comment">//出问题了  距离最远</span></span><br><span class="line">		<span class="keyword">double</span> d=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.data.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			d+=Math.pow(<span class="keyword">this</span>.data[i]-that.data[i], <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> Math.sqrt(d);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(data==<span class="keyword">null</span> || data.length==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.length;i++)</span><br><span class="line">			sb.append(data[i]+<span class="string">" "</span>);</span><br><span class="line">		sb.append(<span class="string">" d:"</span>+<span class="keyword">this</span>.distance);</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="建立KD树">建立KD树</h3><p>在<code>d</code>维的空间上循环找子区域的中位数进行划分的过程。<br>假设现在有<code>d</code>维空间的数据集<code>T={x<sub>1</sub>,x<sub>2</sub>,x<sub>3</sub>,…x<sub>n</sub>},xi={a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>..a<sub>d</sub>}</code></p>
<ol>
<li>首先构造根节点，以坐标<code>a<sub>1</sub></code>的中位数<code>b</code>为切分点，将根结点对应的矩形局域划分为两个区域，区域1中<code>a1&lt;b</code>,区域2中<code>a1&gt;b</code>，中位数所在的节点就是树上的节点</li>
<li>构造叶子节点，分别以上面两个区域中<code>a<sub>2</sub></code>的中位数作为切分点，再次将他们两两划分，作为深度1的叶子节点，（如果<code>a<sub>2</sub></code>=中位数，则<code>a<sub>2</sub></code>的实例落在切分面）</li>
<li>不断重复2的操作，深度为<code>j</code>的叶子节点划分的时候，索取的<code>a<sub>i</sub></code> 的<code>i=j%d+1</code>，直到两个子区域没有实例时停止</li>
</ol>
<p>所以我们首先需要在高维的数据中针对某一维进行一个中位数的查找的，这里最快捷的就是借用快排的方法</p>
<pre><code>假设f为快排的排头，进行一轮对比之后如果f所在的索引大于<span class="built_in">size</span>/<span class="number">2</span>，则此时只需要对左边进行递归排序就可以了，若小于<span class="built_in">size</span>/<span class="number">2</span>，则只需对右边区域进行递归排序，如果等于<span class="built_in">size</span>/<span class="number">2</span>  则说明
f就是中位数  直接返回就好啦
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 使用快排进进行一个中位数的查找  完了之后返回的数组size/2即中位数</span><br><span class="line"> *<span class="javadoctag"> @param</span> nodeList</span><br><span class="line"> *<span class="javadoctag"> @param</span> index</span><br><span class="line"> *<span class="javadoctag"> @param</span> left</span><br><span class="line"> *<span class="javadoctag"> @param</span> right</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSortForMedian</span><span class="params">(List&lt;Node&gt; nodeList,<span class="keyword">int</span> index,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&gt;=right || nodeList.size()&lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	</span><br><span class="line">	Node kn=nodeList.get(left);</span><br><span class="line">	<span class="keyword">double</span> k=kn.getData(index);<span class="comment">//取得向量指定索引的值</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i=left,j=right;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(nodeList.get(j).getData(index)&gt;=k &amp;&amp; i&lt;j)</span><br><span class="line">			j--;</span><br><span class="line">		nodeList.set(i, nodeList.get(j));</span><br><span class="line">		<span class="keyword">while</span>(nodeList.get(i).getData(index)&lt;=k &amp;&amp; i&lt;j)</span><br><span class="line">			i++;</span><br><span class="line">		nodeList.set(j, nodeList.get(i));</span><br><span class="line">	&#125;</span><br><span class="line">	nodeList.set(i, kn);</span><br><span class="line">	<span class="keyword">if</span>(i==nodeList.size()/<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> ;<span class="comment">//完成中位数的排序了</span></span><br><span class="line">	<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(i&lt;nodeList.size()</span>/2)</span><br><span class="line">	</span>&#123;</span><br><span class="line">		quickSortForMedian(nodeList,index,i+<span class="number">1</span>,right);<span class="comment">//只需要排序右边就可以了</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		quickSortForMedian(nodeList,index,left,i-<span class="number">1</span>);<span class="comment">//只需要排序左边就可以了</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了中位数查找，接下来就可以使用递归来进行树的建立了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 构建kd树  返回根节点</span><br><span class="line"> *<span class="javadoctag"> @param</span> nodeList</span><br><span class="line"> *<span class="javadoctag"> @param</span> index</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">buildKDTree</span><span class="params">(List&lt;Node&gt; nodeList,<span class="keyword">int</span> index)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(nodeList==<span class="keyword">null</span> || nodeList.size()==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	quickSortForMedian(nodeList,index,<span class="number">0</span>,nodeList.size()-<span class="number">1</span>);<span class="comment">//中位数排序</span></span><br><span class="line">	Node root=nodeList.get(nodeList.size()/<span class="number">2</span>);<span class="comment">//中位数 当做根节点</span></span><br><span class="line">	root.dim=index;</span><br><span class="line">	List&lt;Node&gt; leftNodeList=<span class="keyword">new</span> ArrayList&lt;Node&gt;();<span class="comment">//放入左侧区域的节点  包括包含与中位数等值的节点-_-</span></span><br><span class="line">	List&lt;Node&gt; rightNodeList=<span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(Node node:nodeList)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(root!=node)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(node.getData(index)&lt;=root.getData(index))</span><br><span class="line">				leftNodeList.add(node);<span class="comment">//左子区域 包含与中位数等值的节点</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				rightNodeList.add(node);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> newIndex=index+<span class="number">1</span>;<span class="comment">//进入下一个维度</span></span><br><span class="line">	<span class="keyword">if</span>(newIndex&gt;=root.data.length)</span><br><span class="line">		newIndex=<span class="number">0</span>;<span class="comment">//从0维度开始再算</span></span><br><span class="line">	root.left=buildKDTree(leftNodeList,newIndex);<span class="comment">//添加左右子区域</span></span><br><span class="line">	root.right=buildKDTree(rightNodeList,newIndex);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">		root.left.parent=root;<span class="comment">//添加父指针  </span></span><br><span class="line">	<span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">		root.right.parent=root;<span class="comment">//添加父指针  </span></span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="KD树搜索">KD树搜索</h3><ol>
<li>首先从根节点开始递归往下找到包含<code>q</code>的叶子节点，每一层都是找对应的<code>x<sub>i</sub></code></li>
<li>将这个叶子节点认为是当前的“近似最近点”</li>
<li>递归向上回退，如果以<code>q</code>圆心，以“近似最近点”为半径的球与根节点的另一半子区域边界相交，则说明另一半子区域中存在与<code>q</code>更近的点，则进入另一个子区域中查找该点并且更新”近似最近点“</li>
<li>重复3的步骤，直到另一子区域与球体不相交或者退回根节点</li>
<li>最后更新的”近似最近点“与<code>q</code>真正的最近点</li>
</ol>
<p>这里注意按上述方式找到的与查询点最近的那个点，但是我们在<code>KNN</code>的时候是查询<code>k</code>个最近点，<code>topK</code>问题嘛，这里我们就使用了一个最大堆的维护来保证最近的<code>k</code>个点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 维护一个k的最大堆</span><br><span class="line"> *<span class="javadoctag"> @param</span> listNode</span><br><span class="line"> *<span class="javadoctag"> @param</span> newNode</span><br><span class="line"> *<span class="javadoctag"> @param</span> k</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maintainMaxHeap</span><span class="params">(List&lt;Node&gt; listNode,Node newNode,<span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(listNode.size()&lt;k)</span><br><span class="line">	&#123;</span><br><span class="line">		maxHeapFixUp(listNode,newNode);<span class="comment">//不足k个堆   直接向上修复</span></span><br><span class="line">	&#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(newNode.distance&lt;listNode.get(<span class="number">0</span>)</span>.distance)</span>&#123;</span><br><span class="line">		<span class="comment">//比堆顶的要小   还需要向下修复 覆盖堆顶</span></span><br><span class="line">		maxHeapFixDown(listNode,newNode);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 从上往下修复  将会覆盖第一个节点</span><br><span class="line"> *<span class="javadoctag"> @param</span> listNode</span><br><span class="line"> *<span class="javadoctag"> @param</span> newNode</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeapFixDown</span><span class="params">(List&lt;Node&gt; listNode,Node newNode)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	listNode.set(<span class="number">0</span>, newNode);</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(j&lt;listNode.size())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(j+<span class="number">1</span>&lt;listNode.size() &amp;&amp; listNode.get(j).distance&lt;listNode.get(j+<span class="number">1</span>).distance)</span><br><span class="line">			j++;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(listNode.get(i).distance&gt;=listNode.get(j).distance)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		Node t=listNode.get(i);</span><br><span class="line">		listNode.set(i, listNode.get(j));</span><br><span class="line">		listNode.set(j, t);</span><br><span class="line">		</span><br><span class="line">		i=j;</span><br><span class="line">		j=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeapFixUp</span><span class="params">(List&lt;Node&gt; listNode,Node newNode)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	listNode.add(newNode);</span><br><span class="line">	<span class="keyword">int</span> j=listNode.size()-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> i=(j+<span class="number">1</span>)/<span class="number">2</span>-<span class="number">1</span>;<span class="comment">//i是parent节点</span></span><br><span class="line">	<span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(listNode.get(i).distance&gt;=listNode.get(j).distance)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		Node t=listNode.get(i);</span><br><span class="line">		listNode.set(i, listNode.get(j));</span><br><span class="line">		listNode.set(j, t);</span><br><span class="line">		</span><br><span class="line">		j=i;</span><br><span class="line">		i=(j+<span class="number">1</span>)/<span class="number">2</span>-<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好，现在就可以按照上述的思路来进行搜索了，搜索过程中维护一个k堆<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 查询最近邻</span><br><span class="line"> *<span class="javadoctag"> @param</span> root kd树</span><br><span class="line"> *<span class="javadoctag"> @param</span> q 查询点</span><br><span class="line"> *<span class="javadoctag"> @param</span> k</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Node&gt; <span class="title">searchKNN</span><span class="params">(Node root,Node q,<span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	List&lt;Node&gt; knnList=<span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">	Node almostNNode=searchLeaf(root,q);<span class="comment">//近似最近点</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(almostNNode!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">double</span> curD=q.computeDistance(almostNNode);<span class="comment">//最近近似点与查询点的距离 也就是球体的半径</span></span><br><span class="line">		almostNNode.distance=curD;</span><br><span class="line">		maintainMaxHeap(knnList,almostNNode,k);</span><br><span class="line">		<span class="keyword">if</span>(almostNNode.parent!=<span class="keyword">null</span> &amp;&amp;</span><br><span class="line">				curD&gt;Math.abs(q.getData(almostNNode.parent.dim)-almostNNode.parent.getData(almostNNode.parent.dim)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//这样可能在另一个子区域中存在更加近似的点</span></span><br><span class="line">			Node brother=getBrother(almostNNode);</span><br><span class="line">			brother.distance=q.computeDistance(brother);</span><br><span class="line">			maintainMaxHeap(knnList,brother,k);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		almostNNode=almostNNode.parent;<span class="comment">//返回上一级</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> knnList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 获取兄弟节点</span><br><span class="line"> *<span class="javadoctag"> @param</span> node</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">getBrother</span><span class="params">(Node node)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node==node.parent.left)</span><br><span class="line">		<span class="keyword">return</span> node.parent.right;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> node.parent.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 查询到叶子节点</span><br><span class="line"> *<span class="javadoctag"> @param</span> root</span><br><span class="line"> *<span class="javadoctag"> @param</span> q</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchLeaf</span><span class="params">(Node root,Node q)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Node leaf=root,next=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(leaf.left!=<span class="keyword">null</span> || leaf.right!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(q.getData(index)&lt;leaf.getData(index))</span><br><span class="line">		&#123;</span><br><span class="line">			next=leaf.left;<span class="comment">//进入左侧</span></span><br><span class="line">		&#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(q.getData(index)</span>&gt;leaf.<span class="title">getData</span><span class="params">(index)</span>)</span><br><span class="line">		</span>&#123;</span><br><span class="line">			next=leaf.right;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//当取到中位数时  判断左右子区域哪个更加近</span></span><br><span class="line">			<span class="keyword">if</span>(q.computeDistance(leaf.left)&lt;q.computeDistance(leaf.right))</span><br><span class="line">				next=leaf.left;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				next=leaf.right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(next==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//下一个节点是空时  结束了</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			leaf=next;</span><br><span class="line">			<span class="keyword">if</span>(++index&gt;=root.data.length)</span><br><span class="line">				index=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> leaf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意这里在判断查询点<code>q</code>与另一个子区域的边界是否相交时是需要判断半径与（<code>q</code>和父节点影响构建维数上的值之差即可）</p>
</blockquote>
<h2 id="栗子">栗子</h2><p>还是以上面的6个数据点进行构建<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Node&gt; nodeList=<span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">nodeList.add(<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>&#125;));</span><br><span class="line">nodeList.add(<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">5</span>,<span class="number">4</span>&#125;));</span><br><span class="line">nodeList.add(<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">9</span>,<span class="number">6</span>&#125;));</span><br><span class="line">nodeList.add(<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">4</span>,<span class="number">7</span>&#125;));</span><br><span class="line">nodeList.add(<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">8</span>,<span class="number">1</span>&#125;));</span><br><span class="line">nodeList.add(<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">7</span>,<span class="number">2</span>&#125;));</span><br><span class="line"></span><br><span class="line">KDTree kdTree=<span class="keyword">new</span> KDTree();</span><br><span class="line">Node root=kdTree.buildKDTree(nodeList,<span class="number">0</span>);</span><br><span class="line">System.out.println(root);</span><br></pre></td></tr></table></figure></p>
<p>对(2.1,3.1)进行查询<br><img src="/img/KDTree-In-KNN/search1.jpg" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(kdTree.searchKNN(root,<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">2.1</span>,<span class="number">3.1</span>&#125;),<span class="number">2</span>));</span><br></pre></td></tr></table></figure></p>
<p>可以发现最近的两个点</p>
<pre><code>[<span class="number">5.0</span> <span class="number">4.0</span>  d:<span class="number">3.0364452901377956</span>, <span class="number">2.0</span> <span class="number">3.0</span>  d:<span class="number">0.14142135623730964</span>]
</code></pre><p>完全符合预期</p>
<p>再来看(2,4.5)这个查询点<br><img src="/img/KDTree-In-KNN/search2.jpg" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(kdTree.searchKNN(root,<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">2</span>,<span class="number">4.5</span>&#125;),<span class="number">1</span>));</span><br><span class="line">System.out.println(kdTree.searchKNN(root,<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">2</span>,<span class="number">4.5</span>&#125;),<span class="number">3</span>));</span><br></pre></td></tr></table></figure></p>
<pre><code>[<span class="number">2.0</span> <span class="number">3.0</span>  d:<span class="number">1.5</span>]
[<span class="number">4.0</span> <span class="number">7.0</span>  d:<span class="number">3.2015621187164243</span>, <span class="number">2.0</span> <span class="number">3.0</span>  d:<span class="number">1.5</span>, <span class="number">5.0</span> <span class="number">4.0</span>  d:<span class="number">3.0413812651491097</span>]
</code></pre><p>首先最近邻的叶子节点是(4,7) 但是其半径会与另一子区域相交，所以继续进行(2,3)进行距离计算</p>
<blockquote>
<p>完整的源代码<a href="http://www.oschina.net/code/snippet_174837_51436" target="_blank" rel="external">在这儿有</a>!</p>
</blockquote>
<h2 id="参考">参考</h2><ol>
<li>《统计学习方法》第三章</li>
<li><a href="http://blog.csdn.net/qll125596718/article/details/8426458" target="_blank" rel="external">http://blog.csdn.net/qll125596718/article/details/8426458</a>这篇文章举例比较详细</li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="KNN算法">KNN算法</h2><pre><code>给一个训练数据集和一个新的实例，在训练数据集中找出与这个新实例最近的k个训练实例，然后统计最近的k个训练实例中所属类别计数最多的那个类，就是新实例的类。
</code></pre><p><a href="http://kubicode.me/2015/08/16/Machine%20Learning/Algorithm-Summary-for-Interview/#KNN算法">点我查看详情</a></p>
<blockquote>
<p>但是该算法每次在查询k个最近邻的时候都需要遍历全集  才能计算出来，可想而且如果训练样本很大的话，代价还是很大的，那有没有啥方法可以优化呢？本文就针对<code>KNN</code>算法实现一个简单的<code>KD</code>树</p>
</blockquote>
<h2 id="KD树">KD树</h2><pre><code>KD树是一个二叉树，表示对<span class="keyword">K</span>维空间的一个划分，可以进行快速检索（那KNN计算的时候不需要对全样本进行距离的计算了）
</code></pre><p>比如针对6个二维数据点{（2,3），（5,4），（9,6），（4,7），（8,1），（7,2）}，可以形成以下树形结构以及空间划分<br><img src="/img/KDTree-In-KNN/example.png" alt=""></p>]]>
    
    </summary>
    
      <category term="Data Struct" scheme="http://kubicode.me/tags/Data-Struct/"/>
    
      <category term="Java" scheme="http://kubicode.me/tags/Java/"/>
    
      <category term="Machine Learning" scheme="http://kubicode.me/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://kubicode.me/categories/Machine-Learning/"/>
    
  </entry>
  
</feed>