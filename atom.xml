<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Kubi Code'Blog]]></title>
  <subtitle><![CDATA[The palest ink is better than the best memory.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yyl8781697.github.io/"/>
  <updated>2015-12-04T01:15:10.000Z</updated>
  <id>http://yyl8781697.github.io/</id>
  
  <author>
    <name><![CDATA[Kubi Code]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[awk学习清单]]></title>
    <link href="http://yyl8781697.github.io/2015/11/24/Linux/awk-study-list/"/>
    <id>http://yyl8781697.github.io/2015/11/24/Linux/awk-study-list/</id>
    <published>2015-11-23T16:06:41.000Z</published>
    <updated>2015-12-04T01:15:10.000Z</updated>
    <content type="html"><![CDATA[<pre><code>与其说<span class="tag">awk</span>是一个强大的文本处理工具，我更加喜欢称之为轻量级的<span class="tag">C</span>语言版脚本，有了它，你就能非常自由，轻松的操作文本文件了。<span class="rule"><span class="attribute">ps</span>:<span class="value">比Excel更加方便哦,一句话：awk可以带你装b带你飞~</span></span>
</code></pre><h2 id="初体验：九九乘法表">初体验：九九乘法表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"></span><br><span class="line">BEGIN&#123;</span><br><span class="line">    <span class="built_in">print</span> <span class="string">"lets begins"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=NR;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%sx%s=%s\t"</span>,NR,i,NR*i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">END&#123;</span><br><span class="line">    <span class="built_in">print</span> <span class="string">"ends"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在先看<code>awk</code>程序之前，咱先来看一下由他实现的一个九九乘法表</p>
<pre><code>yans-MacBook-Pro:Downloads yanyl$ seq <span class="number">9</span> | awk -f chengfa.awk
lets begins
<span class="number">1</span><span class="variable">x1=</span><span class="number">1</span>
<span class="number">2</span><span class="variable">x1=</span><span class="number">2</span>    <span class="number">2</span><span class="variable">x2=</span><span class="number">4</span>
<span class="number">3</span><span class="variable">x1=</span><span class="number">3</span>    <span class="number">3</span><span class="variable">x2=</span><span class="number">6</span>    <span class="number">3</span><span class="variable">x3=</span><span class="number">9</span>
<span class="number">4</span><span class="variable">x1=</span><span class="number">4</span>    <span class="number">4</span><span class="variable">x2=</span><span class="number">8</span>    <span class="number">4</span><span class="variable">x3=</span><span class="number">12</span>    <span class="number">4</span><span class="variable">x4=</span><span class="number">16</span>
<span class="number">5</span><span class="variable">x1=</span><span class="number">5</span>    <span class="number">5</span><span class="variable">x2=</span><span class="number">10</span>    <span class="number">5</span><span class="variable">x3=</span><span class="number">15</span>    <span class="number">5</span><span class="variable">x4=</span><span class="number">20</span>    <span class="number">5</span><span class="variable">x5=</span><span class="number">25</span>
<span class="number">6</span><span class="variable">x1=</span><span class="number">6</span>    <span class="number">6</span><span class="variable">x2=</span><span class="number">12</span>    <span class="number">6</span><span class="variable">x3=</span><span class="number">18</span>    <span class="number">6</span><span class="variable">x4=</span><span class="number">24</span>    <span class="number">6</span><span class="variable">x5=</span><span class="number">30</span>    <span class="number">6</span><span class="variable">x6=</span><span class="number">36</span>
<span class="number">7</span><span class="variable">x1=</span><span class="number">7</span>    <span class="number">7</span><span class="variable">x2=</span><span class="number">14</span>    <span class="number">7</span><span class="variable">x3=</span><span class="number">21</span>    <span class="number">7</span><span class="variable">x4=</span><span class="number">28</span>    <span class="number">7</span><span class="variable">x5=</span><span class="number">35</span>    <span class="number">7</span><span class="variable">x6=</span><span class="number">42</span>    <span class="number">7</span><span class="variable">x7=</span><span class="number">49</span>
<span class="number">8</span><span class="variable">x1=</span><span class="number">8</span>    <span class="number">8</span><span class="variable">x2=</span><span class="number">16</span>    <span class="number">8</span><span class="variable">x3=</span><span class="number">24</span>    <span class="number">8</span><span class="variable">x4=</span><span class="number">32</span>    <span class="number">8</span><span class="variable">x5=</span><span class="number">40</span>    <span class="number">8</span><span class="variable">x6=</span><span class="number">48</span>    <span class="number">8</span><span class="variable">x7=</span><span class="number">56</span>    <span class="number">8</span><span class="variable">x8=</span><span class="number">64</span>
<span class="number">9</span><span class="variable">x1=</span><span class="number">9</span>    <span class="number">9</span><span class="variable">x2=</span><span class="number">18</span>    <span class="number">9</span><span class="variable">x3=</span><span class="number">27</span>    <span class="number">9</span><span class="variable">x4=</span><span class="number">36</span>    <span class="number">9</span><span class="variable">x5=</span><span class="number">45</span>    <span class="number">9</span><span class="variable">x6=</span><span class="number">54</span>    <span class="number">9</span><span class="variable">x7=</span><span class="number">63</span>    <span class="number">9</span><span class="variable">x8=</span><span class="number">72</span>    <span class="number">9</span><span class="variable">x9=</span><span class="number">81</span>
ends
yans-MacBook-Pro:Downloads yanyl$
</code></pre><a id="more"></a>
<p>是不是着实惊艳了一把，程序暂时不解释，不错，为了更好更加方便得处理<code>Linux</code>下的文本，文本就记录学习<code>awk</code>神器的基本用法^_^</p>
<h2 id="awk基础结构">awk基础结构</h2><p><code>awk</code>基础结构如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123;commands&#125; &#123;commands&#125; END&#123;commands&#125;'</span> filename</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这个命令敲下去之后，<code>awk</code>回去按行读取<code>filename</code>的文本进行操作，里面的程序就是你对应的文本处理逻辑，还有这里的文件输入也可以改为标准的<code>stdin</code>的形式哦~</p>
</blockquote>
<p>很清晰，<code>awk</code>可以分为3块:</p>
<ol>
<li><code>BEGIN</code>:可以理解为程序的初始化，可以自定一些变量，或者定义文件的分隔符等</li>
<li>{}模式块：这里会从文件或者输入里面按行读取，在这里可以使用<code>内建变量</code>或者列的值<code>$i</code> 或者自定义变量等，然后使用控制结果或者内置函数来进行相应的文本处理逻辑</li>
<li><code>END</code>:程序执行结束块，可以做一些<code>Summary</code>类型或者其他的输出</li>
</ol>
<blockquote>
<p>其实模式快可以省略，默认是执行<code>{print}</code> 打印行内容，其实其他两块也可以省略-_-</p>
</blockquote>
<p>所以总结来说<code>awk</code>的结构其实可以直接看做一个循环体<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEGINE <span class="comment">#进行初始化</span></span><br><span class="line"><span class="keyword">while</span></span><br><span class="line">	&#123;commands&#125; <span class="comment">#内部循环的处理逻辑</span></span><br><span class="line">END <span class="comment">#结尾</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是：</p>
<ol>
<li><code>awk</code>语法的是包含在引号或者双引号里面的</li>
<li>程序复杂的话可以写成<code>awk</code>结尾的文件，然后使用<code>awk -f xxx.awk filename</code>来进行执行</li>
</ol>
<blockquote>
<p>当然了,刚刚都说了<code>awk</code>的优势在于轻量级，下面更多的<code>demo</code>都是行内的语法，并不会专门去写成<code>*.awk</code>文件再来执行^_^</p>
</blockquote>
<h2 id="列的操作">列的操作</h2><h3 id="列的输出">列的输出</h3><p>演示之前先看使用的实验文本文件<a href="/img/awk-study-list/score.log">成绩表score.log</a></p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ <span class="keyword">cat</span> <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    math    95
301    xiaoming    chinese    58
301    xiaoming    english    68
301    xiaohong    math    77
301    xiaohong    chinese    88
301    xiaohong    english    75
302    peter    math    35
302    peter    chinese    45
302    peter    english    95
</code></pre><blockquote>
<p>这里的列于列之间是使用<code>tab</code>隔开的</p>
</blockquote>
<p>先来看一下最简单的输出,假设我只关心年龄和成绩</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ awk '{<span class="keyword">print</span> <span class="label">$2</span>,<span class="label">$4}</span>' <span class="keyword">score</span>.<span class="literal">log</span>
name <span class="keyword">score</span>
xiaoming 95
xiaoming 58
xiaoming 68
xiaohong 77
xiaohong 88
xiaohong 75
peter 35
peter 45
peter 95
</code></pre><blockquote>
<p>这里的取列是使用<code>$i~n</code>  从1开始计数，比如<code>$1</code>是第一列，<code>$4</code>是第4列，其中<code>$0</code>表示整好</p>
</blockquote>
<p>但是发现没对齐，我想将其对个齐：</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ awk '{printf(<span class="string">"%-8s\t%-8s\n"</span>,<span class="label">$2</span>,<span class="label">$4</span>)}' <span class="keyword">score</span>.<span class="literal">log</span>
name        <span class="keyword">score</span>
xiaoming    95
xiaoming    58
xiaoming    68
xiaohong    77
xiaohong    88
xiaohong    75
peter       35
peter       45
peter       95
</code></pre><blockquote>
<p>就是就是使用了标准了<code>C</code>语言风格的<code>printf</code>函数了</p>
</blockquote>
<h3 id="列的过滤">列的过滤</h3><p>我感觉里面比较强大的就是使用<code>awk</code>进行各种过滤操作了，简直了<br>现在我只是想查看小明的成绩</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ awk 'NR==1 || <span class="label">$2</span>==<span class="string">"xiaoming"</span>' <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    math    95
301    xiaoming    chinese    58
301    xiaoming    english    68
</code></pre><blockquote>
<p>这里支持and(<code>&amp;&amp;</code>)和or(<code>||</code>)的操作，同时<code>NR</code>表示当前的行号，<code>NR==1</code>就是为了保留表头</p>
</blockquote>
<p>同时<code>awk</code>还支持<code>C</code>语言系的各种比较符号<code>!=, &gt;, &lt;, &gt;=, &lt;=</code><br>查看不及格的小兔崽子-_-</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ awk 'NR==1 || <span class="label">$4</span>&lt;60' <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    chinese    58
302    peter    math    35
302    peter    chinese    45
</code></pre><p>这里除了支持直接判断的语法，还支持字符串的匹配，使用<code>~</code>符号（这个有点强大），使用语法为<code>~/pattern/</code><br>现在来看一下姓小的同学</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ awk 'NR==1 || <span class="label">$2</span>~/xiao/' <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    math    95
301    xiaoming    chinese    58
301    xiaoming    english    68
301    xiaohong    math    77
301    xiaohong    chinese    88
301    xiaohong    english    75
</code></pre><p>还可以进行模式非匹配，要<code>!~</code>即可</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ awk 'NR==1 || <span class="label">$2</span>!~/xiao/' <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
302    peter    math    35
302    peter    chinese    45
302    peter    english    95
</code></pre><h2 id="变量">变量</h2><h3 id="变量定义使用">变量定义使用</h3><p><code>awk</code>里面变量的几个点:</p>
<ol>
<li>里面的变量命名和<code>C</code>系一样</li>
<li>变量区分大小写</li>
<li>变量一般都是数字和字符串类型</li>
<li>在初始化时，数字类型初始化为0，字符串类型初始化为空，并且在运行期间可变，同时不需要向<code>C</code>一样显示的初始化变量</li>
</ol>
<p>这里来看一个最简单的变量的创建与读写</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk '{name=<span class="string">"zhangsan"</span>} END{<span class="keyword">print</span> name}' <span class="keyword">score</span>.<span class="literal">log</span>
zhangsan
yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk '{age=23} END{<span class="keyword">print</span> age}' <span class="keyword">score</span>.<span class="literal">log</span>
23
</code></pre><blockquote>
<p>这里想想<code>python</code>的变量就可以了哦~</p>
</blockquote>
<p>另外参数不一定要在<code>awk</code>语句中初始化，还可以在输入文件中进行传递，语法格式为<code>awk &#39;statment&#39; var=value file</code>的方式</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk '<span class="label">$4</span>&gt;ms' ms=60 <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    math    95
301    xiaoming    english    68
301    xiaohong    math    77
301    xiaohong    chinese    88
301    xiaohong    english    75
302    peter    english    95
yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk '<span class="label">$4</span>&gt;ms' ms=90 <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    math    95
302    peter    english    95
</code></pre><p>这里示例是用于展示在输入文件的时候传一个<code>ms</code>变量，来控制过滤最小分数，应该还是蛮方便的</p>
<h3 id="类型转换">类型转换</h3><blockquote>
<p>这里的类型转换只有数字类型和字符串类型的转换啦-_-</p>
</blockquote>
<p>记住一个原则<code>+号表示数字类型的操作，会忽略字符串，而空才是正常字符串的拼接</code></p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk 'BEGIN{<span class="keyword">two</span>=2;three=3;<span class="keyword">print</span> <span class="keyword">two</span>+three}'
5
yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk 'BEGIN{<span class="keyword">two</span>=2;three=3;<span class="keyword">print</span> <span class="keyword">two</span> three}'
23
yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk 'BEGIN{<span class="keyword">two</span>=2;three=3;<span class="keyword">print</span> <span class="keyword">two</span>+<span class="string">"s"</span>+three}'
5
yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk 'BEGIN{<span class="keyword">two</span>=2;three=3;<span class="keyword">print</span> <span class="keyword">two</span> <span class="string">"s"</span> three}'
2s3
</code></pre><blockquote>
<p>还有关于详细的转换参考<a href="http://www.gnu.org/software/gawk/manual/gawk.html#Variables" target="_blank" rel="external">这里</a></p>
</blockquote>
<h3 id="内建变量">内建变量</h3><p>下面贴出的都是一些内置变量，在自己创建变量的时候请勿将变量名创建为下面的内置变量名</p>
<table>
<thead>
<tr>
<th style="text-align:left">变量名</th>
<th style="text-align:left">变量描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>$0</code></td>
<td style="text-align:left">表示当前正行的内容</td>
</tr>
<tr>
<td style="text-align:left"><code>$1~$n</code></td>
<td style="text-align:left">表示第几个列的值，这些列是使用<code>FS</code>变量进行分割的</td>
</tr>
<tr>
<td style="text-align:left"><code>FS</code></td>
<td style="text-align:left">列的分割符，默认是空格或者<code>tab</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NF</code></td>
<td style="text-align:left">表示当前文件中列的个数</td>
</tr>
<tr>
<td style="text-align:left"><code>NR</code></td>
<td style="text-align:left">表示当前读取的行数</td>
</tr>
<tr>
<td style="text-align:left"><code>FNR</code></td>
<td style="text-align:left">这个表示当前文件自己标的行号</td>
</tr>
<tr>
<td style="text-align:left"><code>NR</code></td>
<td style="text-align:left">表示当前读取的行数</td>
</tr>
<tr>
<td style="text-align:left"><code>RS</code></td>
<td style="text-align:left">表示输入记录的换行符，默认为换行符<code>\n</code></td>
</tr>
<tr>
<td style="text-align:left"><code>OFS</code></td>
<td style="text-align:left">表示输出记录的分割符，默认是空格</td>
</tr>
<tr>
<td style="text-align:left"><code>ORS</code></td>
<td style="text-align:left">表示输出记录的分割符，默认是换行符</td>
</tr>
<tr>
<td style="text-align:left"><code>FILENAME</code></td>
<td style="text-align:left">当前输出的文件名</td>
</tr>
<tr>
<td style="text-align:left"><code>ARGC</code></td>
<td style="text-align:left">传入参数的个数</td>
</tr>
<tr>
<td style="text-align:left"><code>ARGV</code></td>
<td style="text-align:left">传入参数的数组</td>
</tr>
</tbody>
</table>
<p>上面是列出了一些常用的内置变量，详细的可以看<a href="http://www.gnu.org/software/gawk/manual/gawk.html#Built_002din-Variables" target="_blank" rel="external">这里</a></p>
<blockquote>
<p>个人感觉最常用的就是<code>$i</code>犀利以及<code>FS</code>、<code>NR</code>之类的了^_^</p>
</blockquote>
<h2 id="控制流程">控制流程</h2><blockquote>
<p><code>awk</code>提供了类<code>C</code>系语言的强大的控制流程语法，可以发现绝大部门语法和<code>C</code>是一样的</p>
</blockquote>
<h3 id="if判断">if判断</h3><p><code>if</code>语法是你超级熟悉的<code>if (condition) then-body [else else-body]</code><br>现在需要给每个人每门成绩打一个标签，85分以上优秀，60及以上良好，否则。。。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (NR==<span class="number">1</span>) <span class="comment">#这里针对第一行  额外操作   追加一个标签列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span> <span class="variable">$0</span> <span class="string">"\tlabel"</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(<span class="variable">$4</span> &gt;= <span class="number">85</span>)</span><br><span class="line">	        label = <span class="string">"excellent"</span></span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$4</span> &gt;= <span class="number">60</span>)</span><br><span class="line">	        label = <span class="string">"well"</span></span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	        label = <span class="string">"shit"</span></span><br><span class="line"></span><br><span class="line">	    <span class="built_in">print</span> <span class="variable">$0</span> <span class="string">"\t"</span> label</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将这个<code>awk</code>文件进行执行之后可以看到</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk -f <span class="keyword">test</span>.awk <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>    <span class="keyword">label</span>
301    xiaoming    math    95    excellent
301    xiaoming    chinese    58    shit
301    xiaoming    english    68    well
301    xiaohong    math    77    well
301    xiaohong    chinese    88    excellent
301    xiaohong    english    75    well
302    peter    math    35    shit
302    peter    chinese    45    shit
302    peter    english    95    excellent
</code></pre><p>这里注意，你如果想把控制语句写到一行，就必须得使用<code>{}</code>显示标注执行主体，<code>;</code>来标注结束，就是像下面这么任性我也是没办法</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk '{<span class="keyword">if</span> (NR==1){<span class="keyword">print</span> <span class="label">$0</span> <span class="string">"\tlabel"</span>;}<span class="keyword">else</span>{<span class="keyword">if</span>(<span class="label">$4</span> &gt;= 85){<span class="keyword">label</span> = <span class="string">"excellent"</span>;}<span class="keyword">else</span> <span class="keyword">if</span> (<span class="label">$4</span> &gt;= 60){<span class="keyword">label</span> = <span class="string">"well"</span>;}<span class="keyword">else</span>{<span class="keyword">label</span> = <span class="string">"shit"</span>;}<span class="keyword">print</span> <span class="label">$0</span> <span class="string">"\t"</span> <span class="keyword">label</span>;}}' <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>    <span class="keyword">label</span>
301    xiaoming    math    95    excellent
301    xiaoming    chinese    58    shit
301    xiaoming    english    68    well
301    xiaohong    math    77    well
301    xiaohong    chinese    88    excellent
301    xiaohong    english    75    well
302    peter    math    35    shit
302    peter    chinese    45    shit
302    peter    english    95    excellent
</code></pre><h3 id="while循环">while循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)</span><br><span class="line">  body</span><br></pre></td></tr></table></figure>
<p><code>while</code>还是很方便使用</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk 'BEGIN{i=1;<span class="keyword">sum</span>=0;<span class="keyword">while</span>(i&lt;10) {<span class="keyword">sum</span>+=i;i++;} <span class="keyword">print</span> <span class="keyword">sum</span> }'
45
</code></pre><p>从1累加到9的实现</p>
<h3 id="do-while循环">do-while循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">  body</span><br><span class="line"><span class="keyword">while</span> (condition)</span><br></pre></td></tr></table></figure>
<h3 id="for循环">for循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; increment)</span><br><span class="line">  body</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个方法在最上面的初体验里面就有了</p>
</blockquote>
<h3 id="switch">switch</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switch (expression) &#123;</span><br><span class="line"><span class="keyword">case</span> value or regular expression:</span><br><span class="line">    <span class="keyword">case</span>-body</span><br><span class="line">default:</span><br><span class="line">    default-body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个在<code>gnu awk</code>的手册中说明支持，但是自己捣鼓了半天也没结果，下次深入了再贴出来</p>
</blockquote>
<h3 id="next控制">next控制</h3><p>既然有了上面那么强大的<code>C</code>系控制，肯定也少不了<code>break</code>和<code>continue</code>，在<code>awk</code>中都是支持的，而且用法都一样，所以这里不再一一描述，有意思的是来说一下这个<code>next</code>关键字</p>
<pre><code><span class="keyword">next</span>:在文章最上面描述的awk的结构的中间部分是一个天然的循环，<span class="keyword">next</span>关键词就是让你在这个天然的循环中跳转到下一行处理,就像<span class="keyword">continue</span>
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$4</span>&lt;<span class="number">60</span>)</span><br><span class="line">        next <span class="comment">#小于60的直接过掉  不做处理</span></span><br><span class="line">    <span class="built_in">print</span> <span class="variable">$0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序是用来过掉不及格的同学的</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk -f <span class="keyword">test</span>.awk <span class="keyword">score</span>.<span class="literal">log</span>
<span class="keyword">class</span>    name    course    <span class="keyword">score</span>
301    xiaoming    math    95
301    xiaoming    english    68
301    xiaohong    math    77
301    xiaohong    chinese    88
301    xiaohong    english    75
302    peter    english    95
</code></pre><h3 id="nextfile控制">nextfile控制</h3><p>另外一个与<code>next</code>类似的就是<code>nextfile</code> ，表示跳到下一个输入文件(因为<code>awk</code>一下子可以有多个输入文件呀)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"><span class="comment">#file = test.awk</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$0</span>~/score/)</span><br><span class="line">        next <span class="comment">#含有score字符串的直接过掉</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$4</span>&lt;n)</span><br><span class="line">        nextfile</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> n <span class="string">"\t"</span> <span class="variable">$0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到结果</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>-2:awk_test yanyl$ awk -f <span class="keyword">test</span>.awk <span class="keyword">n</span>=58 <span class="keyword">score</span>.<span class="keyword">log</span> <span class="keyword">n</span>=88 <span class="keyword">score</span>.<span class="literal">log</span>
58    301    xiaoming    math    95
58    301    xiaoming    chinese    58
58    301    xiaoming    english    68
58    301    xiaohong    math    77
58    301    xiaohong    chinese    88
58    301    xiaohong    english    75
88    301    xiaoming    math    95
</code></pre><p>都是符合预期的<br>同时还有一个<code>exit</code>关键词不再介绍，结束程序用的</p>
<h1 id="#">#</h1><h2 id="参考">参考</h2><ol>
<li><a href="http://www.ibm.com/developerworks/cn/education/aix/au-gawk/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/education/aix/au-gawk/</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>与其说<span class="tag">awk</span>是一个强大的文本处理工具，我更加喜欢称之为轻量级的<span class="tag">C</span>语言版脚本，有了它，你就能非常自由，轻松的操作文本文件了。<span class="rule"><span class="attribute">ps</span>:<span class="value">比Excel更加方便哦,一句话：awk可以带你装b带你飞~</span></span>
</code></pre><h2 id="初体验：九九乘法表">初体验：九九乘法表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/awk -f</span></span><br><span class="line"></span><br><span class="line">BEGIN&#123;</span><br><span class="line">    <span class="built_in">print</span> <span class="string">"lets begins"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=NR;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%sx%s=%s\t"</span>,NR,i,NR*i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">END&#123;</span><br><span class="line">    <span class="built_in">print</span> <span class="string">"ends"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在先看<code>awk</code>程序之前，咱先来看一下由他实现的一个九九乘法表</p>
<pre><code>yans-MacBook-Pro:Downloads yanyl$ seq <span class="number">9</span> | awk -f chengfa.awk
lets begins
<span class="number">1</span><span class="variable">x1=</span><span class="number">1</span>
<span class="number">2</span><span class="variable">x1=</span><span class="number">2</span>    <span class="number">2</span><span class="variable">x2=</span><span class="number">4</span>
<span class="number">3</span><span class="variable">x1=</span><span class="number">3</span>    <span class="number">3</span><span class="variable">x2=</span><span class="number">6</span>    <span class="number">3</span><span class="variable">x3=</span><span class="number">9</span>
<span class="number">4</span><span class="variable">x1=</span><span class="number">4</span>    <span class="number">4</span><span class="variable">x2=</span><span class="number">8</span>    <span class="number">4</span><span class="variable">x3=</span><span class="number">12</span>    <span class="number">4</span><span class="variable">x4=</span><span class="number">16</span>
<span class="number">5</span><span class="variable">x1=</span><span class="number">5</span>    <span class="number">5</span><span class="variable">x2=</span><span class="number">10</span>    <span class="number">5</span><span class="variable">x3=</span><span class="number">15</span>    <span class="number">5</span><span class="variable">x4=</span><span class="number">20</span>    <span class="number">5</span><span class="variable">x5=</span><span class="number">25</span>
<span class="number">6</span><span class="variable">x1=</span><span class="number">6</span>    <span class="number">6</span><span class="variable">x2=</span><span class="number">12</span>    <span class="number">6</span><span class="variable">x3=</span><span class="number">18</span>    <span class="number">6</span><span class="variable">x4=</span><span class="number">24</span>    <span class="number">6</span><span class="variable">x5=</span><span class="number">30</span>    <span class="number">6</span><span class="variable">x6=</span><span class="number">36</span>
<span class="number">7</span><span class="variable">x1=</span><span class="number">7</span>    <span class="number">7</span><span class="variable">x2=</span><span class="number">14</span>    <span class="number">7</span><span class="variable">x3=</span><span class="number">21</span>    <span class="number">7</span><span class="variable">x4=</span><span class="number">28</span>    <span class="number">7</span><span class="variable">x5=</span><span class="number">35</span>    <span class="number">7</span><span class="variable">x6=</span><span class="number">42</span>    <span class="number">7</span><span class="variable">x7=</span><span class="number">49</span>
<span class="number">8</span><span class="variable">x1=</span><span class="number">8</span>    <span class="number">8</span><span class="variable">x2=</span><span class="number">16</span>    <span class="number">8</span><span class="variable">x3=</span><span class="number">24</span>    <span class="number">8</span><span class="variable">x4=</span><span class="number">32</span>    <span class="number">8</span><span class="variable">x5=</span><span class="number">40</span>    <span class="number">8</span><span class="variable">x6=</span><span class="number">48</span>    <span class="number">8</span><span class="variable">x7=</span><span class="number">56</span>    <span class="number">8</span><span class="variable">x8=</span><span class="number">64</span>
<span class="number">9</span><span class="variable">x1=</span><span class="number">9</span>    <span class="number">9</span><span class="variable">x2=</span><span class="number">18</span>    <span class="number">9</span><span class="variable">x3=</span><span class="number">27</span>    <span class="number">9</span><span class="variable">x4=</span><span class="number">36</span>    <span class="number">9</span><span class="variable">x5=</span><span class="number">45</span>    <span class="number">9</span><span class="variable">x6=</span><span class="number">54</span>    <span class="number">9</span><span class="variable">x7=</span><span class="number">63</span>    <span class="number">9</span><span class="variable">x8=</span><span class="number">72</span>    <span class="number">9</span><span class="variable">x9=</span><span class="number">81</span>
ends
yans-MacBook-Pro:Downloads yanyl$
</code></pre>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yyl8781697.github.io/tags/Linux/"/>
    
      <category term="Vim" scheme="http://yyl8781697.github.io/tags/Vim/"/>
    
      <category term="Linux" scheme="http://yyl8781697.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop Streaming 实践以及Debug]]></title>
    <link href="http://yyl8781697.github.io/2015/11/08/Hadoop/Hadoop-Streaming-Primary-Learning-And-Debug/"/>
    <id>http://yyl8781697.github.io/2015/11/08/Hadoop/Hadoop-Streaming-Primary-Learning-And-Debug/</id>
    <published>2015-11-08T01:23:38.000Z</published>
    <updated>2015-11-08T12:23:38.000Z</updated>
    <content type="html"><![CDATA[<pre><code>Hadoop Streaming是一个便于变成<span class="keyword">Map</span> <span class="keyword">Reduce</span>程序的工具包，这个工具包可以支持各种可执行/脚本语言来创建Mapper和Reducer，利用Hadoop的优势进行大数据的处理，这些语言仅仅只需要支持*unix的表示输出输入即可(python,c,c++,perl,akw etc.)
</code></pre><h2 id="Streaming实践">Streaming实践</h2><p>先直接来看一个由<code>python</code>写的<code>Streaming</code>程序，还有那个经典的word count,我们的数据集是一篇<a href="/img/Hadoop-Streaming-Primary-Learning-And-Debug/words.txt">英语作文</a>,<br>看来看他的<code>mapper</code>文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding=utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys,re</span><br><span class="line"></span><br><span class="line">re_english = re.compile(<span class="string">u'[^a-zA-Z0-9\-]+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin: <span class="comment">#这里你可以看做是map类中的line输入</span></span><br><span class="line">    words = re_english.sub(<span class="string">' '</span>,line.strip()) <span class="comment">#这里只提取英文数字</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words.split():</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'%s\t%s'</span> % (word, <span class="number">1</span>)  <span class="comment">#这儿就是标准的输出，用tab隔开  默认第一个值为key</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>其实看上面的<code>mapper</code>文件还是挺带感的，和标准的<code>mapper</code>类很类似，这里就不解释了，相信用<code>java</code>写过标准<code>Map-Reduce</code>都应该很熟悉<br><br>现在再来看<code>reducer</code>文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">!/usr/bin/env python</span><br><span class="line"><span class="comment">#-*- coding=utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">lastk = <span class="keyword">None</span> <span class="comment">#这里标志最后一个k  用于控制同一个key 到一个组中</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin:</span><br><span class="line">        w,c = line.split(<span class="string">'\t'</span>)</span><br><span class="line">        c = int(c) <span class="comment">#不转成int会比较麻烦  这是是计数</span></span><br><span class="line">        <span class="keyword">if</span> lastk == <span class="keyword">None</span>: <span class="comment">#这里是判断是否过来的是第一个key</span></span><br><span class="line">            lastk=w</span><br><span class="line">            count += c</span><br><span class="line">        <span class="keyword">elif</span> lastk == w:</span><br><span class="line">            count += c</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"%s\t%s"</span>%(lastk,count)</span><br><span class="line">            lastk=w</span><br><span class="line">            count = c <span class="comment">#这里重置计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> lastk <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"%s\t%s"</span>%(lastk,count)</span><br></pre></td></tr></table></figure></p>
<p>陌生感来了把~其实这里是这样的：</p>
<pre><code>都说了是Streaming，他其实是流式进来的，在进来之前还是和标准的mr一样按<span class="built_in">key</span>进行partation划分到各个桶中，然后每个桶会有若干个<span class="built_in">key</span>，这里按<span class="built_in">key</span>分组一次会将记录一条一条的使用*unix的标准输入 读入道sys.stdin中，那么问题了来了，原来mr中的 迭代器的值如何构造？这里主要使用lastk来的变量，每次当输入的<span class="built_in">key</span>与lastk相等的时候，将当前的值加入到字典或者数组中（因为这个demo是wordcount，所以用累加计数来代替了，第<span class="number">16</span>行），直到<span class="built_in">key</span>与lastk不等时（第<span class="number">18</span>行），此时的数组或者字典就是原来 值的迭代器里面的东西，和正常的mr一样操作，该输出的输出，完了之后同时得更新lastk以迎接下一组<span class="built_in">key</span>的到来，同时清空数组或者字典，周而复始，直至全部输入之后，判断我的lastk是否存在值，有的话这个lastk作为最后一组<span class="built_in">key</span>进行输出（第<span class="number">23</span>行），这样的方式就可以构造出原来的(<span class="built_in">key</span>,iter[<span class="built_in">value</span>])模式了
</code></pre><blockquote>
<p>上述的构造看上去些代码可能更加麻烦一点，但是其实这样的方式是应该灵活了</p>
</blockquote>
<p>现在<code>mapper</code>和<code>reducer</code>两个文件写完了，该如何执行呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar <span class="variable">$HADOOP_HOME</span>/share/hadoop/tools/lib/hadoop-streaming-<span class="number">2.7</span>.<span class="number">0</span>.jar \</span><br><span class="line">-input /yyl/data/words.txt \</span><br><span class="line">-output /yyl/<span class="built_in">test</span>/ouput/streaming \</span><br><span class="line">-mapper <span class="variable">$HADOOP_HOME</span>/runjar/pyscript/word_count_mapper.py \</span><br><span class="line">-reducer <span class="variable">$HADOOP_HOME</span>/runjar/pyscript/word_count_reducer.py \</span><br><span class="line">-file <span class="variable">$HADOOP_HOME</span>/runjar/pyscript/*.py \</span><br></pre></td></tr></table></figure>
<p>其实提交的方式很类似原生的<code>jar</code>包提交，只是这里的<code>jar</code>是使用了<code>Hadoop</code>自带的<code>streaming</code>包,敲火车键进行执行</p>
<pre><code><span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">47</span> WARN streaming.<span class="string">StreamJob:</span> -file option is deprecated, please use generic option -files instead.
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">47</span> WARN util.<span class="string">NativeCodeLoader:</span> Unable to load native-hadoop library <span class="keyword">for</span> your platform... using builtin-java classes where applicable
<span class="string">packageJobJar:</span> [<span class="regexp">/root/</span>program<span class="regexp">/hadoop-2.7.0/</span>runjar<span class="regexp">/pyscript/</span>word_count_mapper.py, <span class="regexp">/root/</span>program<span class="regexp">/hadoop-2.7.0/</span>runjar<span class="regexp">/pyscript/</span>word_count_reducer.py, <span class="regexp">/tmp/</span>hadoop-unjar1825196483906999229<span class="regexp">/] [] /</span>tmp/streamjob6480432411236657839.jar tmpDir=<span class="literal">null</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">51</span> INFO client.<span class="string">RMProxy:</span> Connecting to ResourceManager at master/<span class="number">192.168</span>.56.2:<span class="number">8032</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">51</span> INFO client.<span class="string">RMProxy:</span> Connecting to ResourceManager at master/<span class="number">192.168</span>.56.2:<span class="number">8032</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">53</span> INFO mapred.<span class="string">FileInputFormat:</span> Total input paths to <span class="string">process :</span> <span class="number">1</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">54</span> INFO mapreduce.<span class="string">JobSubmitter:</span> number of <span class="string">splits:</span><span class="number">2</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">54</span> INFO mapreduce.<span class="string">JobSubmitter:</span> Submitting tokens <span class="keyword">for</span> <span class="string">job:</span> job_1446946409340_0001
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">55</span> INFO impl.<span class="string">YarnClientImpl:</span> Submitted application application_1446946409340_0001
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">55</span> INFO mapreduce.<span class="string">Job:</span> The url to track the <span class="string">job:</span> <span class="string">http:</span><span class="comment">//master:8088/proxy/application_1446946409340_0001/</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">55</span> INFO mapreduce.<span class="string">Job:</span> Running <span class="string">job:</span> job_1446946409340_0001
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">12</span> INFO mapreduce.<span class="string">Job:</span> Job job_1446946409340_0001 running <span class="keyword">in</span> uber <span class="string">mode :</span> <span class="literal">false</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">12</span> INFO mapreduce.<span class="string">Job:</span>  map <span class="number">0</span>% reduce <span class="number">0</span>%
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">33</span> INFO mapreduce.<span class="string">Job:</span>  map <span class="number">100</span>% reduce <span class="number">0</span>%
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">46</span> INFO mapreduce.<span class="string">Job:</span>  map <span class="number">100</span>% reduce <span class="number">100</span>%
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">47</span> INFO mapreduce.<span class="string">Job:</span> Job job_1446946409340_0001 completed successfully
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">47</span> INFO mapreduce.<span class="string">Job:</span> <span class="string">Counters:</span> <span class="number">49</span>
    File System Counters
----此处和mr一样  省略<span class="number">1</span>w字
    File Input Format Counters
        Bytes Read=<span class="number">2223</span>
    File Output Format Counters
        Bytes Written=<span class="number">1208</span>
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">47</span>:<span class="number">47</span> INFO streaming.<span class="string">StreamJob:</span> Output <span class="string">directory:</span> <span class="regexp">/yyl/</span>test<span class="regexp">/ouput/</span>streaming
</code></pre><p>然后来查看熟悉的word count结果</p>
<pre><code>[root<span class="annotation">@master</span> pyscript]# hadoop fs -get <span class="regexp">/yyl/</span>test<span class="regexp">/ouput/</span>streaming
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">16</span> WARN util.<span class="string">NativeCodeLoader:</span> Unable to load native-hadoop library <span class="keyword">for</span> your platform... using builtin-java classes where applicable
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">19</span> WARN hdfs.<span class="string">DFSClient:</span> DFSInputStream has been closed already
<span class="number">15</span><span class="regexp">/11/</span><span class="number">07</span> <span class="number">20</span>:<span class="number">48</span>:<span class="number">19</span> WARN hdfs.<span class="string">DFSClient:</span> DFSInputStream has been closed already
[root<span class="annotation">@master</span> pyscript]# cd streaming/
[root<span class="annotation">@master</span> streaming]# sort -nr -k <span class="number">2</span> part-<span class="number">00000</span> | head -n <span class="number">10</span>
and    <span class="number">11</span>
to    <span class="number">10</span>
people    <span class="number">10</span>
Micro-blog    <span class="number">8</span>
their    <span class="number">6</span>
a    <span class="number">5</span>
other    <span class="number">4</span>
of    <span class="number">4</span>
more    <span class="number">4</span>
has    <span class="number">4</span>
</code></pre><p>取计数最高的10个，看到了熟悉的字样，好了，这样一次<code>streaming</code>写执行完了，是不是甚是方便</p>
<blockquote>
<p>这里有一个提示，可以再通<code>hadoop版本hadoop-streaming-*.jar</code>的位置不一样，你可以使用<a href="http://kubicode.me/2015/07/26/Linux/Find-Command/" target="_blank" rel="external">find</a>命令进行查找具体的位置</p>
</blockquote>
<p>到了这里已经可以基本执行<code>streaming</code>程序了，但是从上面的跑的命令里可以看到有好多配置的样子，还有另外可以发现，在写的<code>mapper</code>和<code>reducer</code>中只写了数据的处理逻辑，其他的一些配置参数根本无法写入，那么这些东西都是得在执行的命令里面进行配置的，他可以有的配置参数大致有如下几个</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数名称</th>
<th style="text-align:left">可选/必选</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-input</code></td>
<td style="text-align:left"><strong>必选</strong></td>
<td style="text-align:left">输入文件/目录的位置</td>
</tr>
<tr>
<td style="text-align:left"><code>-output</code></td>
<td style="text-align:left"><strong>必选</strong></td>
<td style="text-align:left">输出目录</td>
</tr>
<tr>
<td style="text-align:left"><code>-mapper</code></td>
<td style="text-align:left"><strong>必选</strong></td>
<td style="text-align:left"><code>mapper</code>的执行文件或者<code>JavaClassName</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-reducer</code></td>
<td style="text-align:left"><strong>必选</strong></td>
<td style="text-align:left"><code>reducer</code>的执行或者<code>JavaClassName</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-file</code></td>
<td style="text-align:left"><strong>必选</strong></td>
<td style="text-align:left">执行的mapper或者reducer文件以及其依赖文件，一定要写，多个可以写多行，他会共享到各个节点上，也可以是jar包</td>
</tr>
<tr>
<td style="text-align:left"><code>-inputformat</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">填<code>JavaClassName</code>，为自定义的输入格式，默认是<code>TextInputFormat</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-outputformat</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">填<code>JavaClassName</code>，为自定义的输出格式，默认是<code>TextOutputformat</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-partitioner</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">填<code>JavaClassName</code>，为自定义的分区函数</td>
</tr>
<tr>
<td style="text-align:left"><code>-combiner</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left"><code>mapper</code>输出之后的合并类，是<code>JavaClassName</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-cmdenv</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left"><code>name=value</code>为输入到流命令里面的环境变量</td>
</tr>
<tr>
<td style="text-align:left"><code>-inputreader</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">貌似可以代替<code>-inputformat</code>这个东西</td>
</tr>
<tr>
<td style="text-align:left"><code>-verbose</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">启用<code>java</code>的<code>verbose</code>输出</td>
</tr>
<tr>
<td style="text-align:left"><code>-lazyOutput</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">当输出格式为<code>FileOutputFormat</code>时，可以配置为懒输出-_-</td>
</tr>
<tr>
<td style="text-align:left"><code>-numReduceTasks</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">指定的<code>reducer</code>的数目</td>
</tr>
<tr>
<td style="text-align:left"><code>-mapdebug</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">指定一个脚本当<code>mapper</code>失败的时候进行调用</td>
</tr>
<tr>
<td style="text-align:left"><code>-reducedebug</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">指定一个脚本当<code>reducer</code>失败的时候进行调用</td>
</tr>
<tr>
<td style="text-align:left"><code>-conf</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left">指定配置文件</td>
</tr>
<tr>
<td style="text-align:left"><code>-D</code></td>
<td style="text-align:left">可选</td>
<td style="text-align:left"><code>property=value</code> 可以配置<code>Hadoop</code>原生的配置项 <strong>实用</strong>^_^</td>
</tr>
</tbody>
</table>
<blockquote>
<p>这么看来，<code>streaming</code>还是很强大以及很灵活的</p>
</blockquote>
<h2 id="Streaming调试">Streaming调试</h2><p>从上述的配置中可以看到 可以配置<code>mapdebug</code>和<code>reducedebug</code>来追踪<code>streaming</code>中的错误信息来进行调试，除了这种方式，<code>streaming</code>调试还有一种更加方便的方式，<br>先来看<code>streaming</code>的执行过程<code>mapper-&gt;shuffle-&gt;reducer</code>，数据以流的方式进行传递的，在<code>Linux</code>中可以配合自带的命令以及官道来完成这一过程，现在可以看模拟刚刚的demo执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master pyscript]<span class="comment"># cat ~/data/words.txt | python word_count_mapper.py | sort | python word_count_reducer.py | sort -nr -k 2 |head -n 10</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到其输出</p>
<pre><code><span class="operator">and</span>    <span class="number">11</span>
<span class="built_in">to</span>    <span class="number">10</span>
people    <span class="number">10</span>
Micro-blog    <span class="number">8</span>
their    <span class="number">6</span>
<span class="operator">a</span>    <span class="number">5</span>
other    <span class="number">4</span>
<span class="operator">of</span>    <span class="number">4</span>
more    <span class="number">4</span>
has    <span class="number">4</span>
</code></pre><p>与上述demo中的结果一模一样，现在大致来分解一下上述命令</p>
<ol>
<li><code>cat ~/data/words.txt </code>:输出文件内容</li>
<li><code>| python word_count_mapper.py</code>:管道命令  将上一步输出的内容输出到要执行的<code>mapper</code>中</li>
<li><code>| sort </code>:管道命令 直接将<code>mapper</code>中输出的内容按第一列进行排序，排序完了之后其实就是达到了分组的效应</li>
<li><code>| python word_count_reducer.py</code>:管道 将排序后的值一次输入到<code>reducer</code>中进行执行，其实到了这一步已经完成了<code>streaming</code>的模拟</li>
<li><code>| sort -nr -k 2 |head -n 10</code> 将最后的结果排个序，再取top</li>
</ol>
<p>使用上述方式来进行调试我感觉有两大优势</p>
<ol>
<li>快，不需要提交到服务器上 慢悠悠的取执行</li>
<li>准，可以直接看到<code>python</code>抛出来的错误</li>
</ol>
<h2 id="Streaming常见错误">Streaming常见错误</h2><ul>
<li>Caused by: java.io.IOException: error=2, No such file or directory<br>  这个往往是由于没有指定<code>mapper,redue=cer</code>的<code>-file</code>引起的，也可以使用通配符<code>*</code></li>
<li>另一未知的错误 估计就是写的脚本执行出了问题，使用上述方式先在本地调试完了再跑</li>
</ul>
<h2 id="总结">总结</h2><p><code>Hadoop streaming</code>写起来很灵活，并且由于跨语言，迁移起来很很快，熟悉不同语言的开发人员也非常容易合作，如果<code>Hadoop streaming</code>程序由多个<code>Map-Reduce</code>构成，那么用<code>Shell</code>来组织整个程序也就会非常的方便快捷</p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://hadoop.apache.org/docs/r2.7.1/hadoop-streaming/HadoopStreaming.html" target="_blank" rel="external">Hadoop Streaming</a></li>
<li><a href="http://shiyanjun.cn/archives/336.html" target="_blank" rel="external">Hadoop Streaming原理及实践</a></li>
<li><a href="http://dongxicheng.org/mapreduce/hadoop-streaming-programming/" target="_blank" rel="external">Hadoop Streaming 编程</a></li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>Hadoop Streaming是一个便于变成<span class="keyword">Map</span> <span class="keyword">Reduce</span>程序的工具包，这个工具包可以支持各种可执行/脚本语言来创建Mapper和Reducer，利用Hadoop的优势进行大数据的处理，这些语言仅仅只需要支持*unix的表示输出输入即可(python,c,c++,perl,akw etc.)
</code></pre><h2 id="Streaming实践">Streaming实践</h2><p>先直接来看一个由<code>python</code>写的<code>Streaming</code>程序，还有那个经典的word count,我们的数据集是一篇<a href="/img/Hadoop-Streaming-Primary-Learning-And-Debug/words.txt">英语作文</a>,<br>看来看他的<code>mapper</code>文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding=utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys,re</span><br><span class="line"></span><br><span class="line">re_english = re.compile(<span class="string">u'[^a-zA-Z0-9\-]+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sys.stdin: <span class="comment">#这里你可以看做是map类中的line输入</span></span><br><span class="line">    words = re_english.sub(<span class="string">' '</span>,line.strip()) <span class="comment">#这里只提取英文数字</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words.split():</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'%s\t%s'</span> % (word, <span class="number">1</span>)  <span class="comment">#这儿就是标准的输出，用tab隔开  默认第一个值为key</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Hadoop" scheme="http://yyl8781697.github.io/tags/Hadoop/"/>
    
      <category term="Hadoop" scheme="http://yyl8781697.github.io/categories/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Mac的OSX系统中配置VIM]]></title>
    <link href="http://yyl8781697.github.io/2015/11/07/Mac/Mac-OSX-Vim-highlight/"/>
    <id>http://yyl8781697.github.io/2015/11/07/Mac/Mac-OSX-Vim-highlight/</id>
    <published>2015-11-07T12:19:43.000Z</published>
    <updated>2015-11-07T12:39:50.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文主要参考<a href="http://www.yeyaxi.com/2011/06/how-to-enable-syntax-highlighting-for-vim-in-mac-osx/" target="_blank" rel="external">[译]如何在Mac OS X中开启VIM语法高亮</a>,他是真的work啊^_^</p>
</blockquote>
<p>使用<code>vim</code>来敲代码很带感，设置<code>vim</code>是一大要事，但是在<code>Mac</code>的<code>vim</code>默认是黑白的，而且并不能像<code>Linux</code>设置<code>~/.vimrc</code>来进行配置，但是毕竟还有其他的方法，先下面一步一步走就可以了</p>
<p>首先进入终端之后输入如下代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/vim</span><br><span class="line"></span><br><span class="line">sudo vim vimrc</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>然后再打开的文件中插入下面的配置<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> ai                  <span class="string">" auto indenting</span><br><span class="line"></span><span class="keyword">set</span> <span class="keyword">history</span>=<span class="number">100</span>         <span class="string">" keep 100 lines of history</span><br><span class="line"></span><span class="keyword">set</span> ruler               <span class="string">" show the cursor position</span><br><span class="line"></span><span class="keyword">syntax</span> <span class="keyword">on</span>               <span class="string">" syntax highlighting</span><br><span class="line"></span><span class="keyword">set</span> hlsearch            <span class="string">" highlight the last searched term</span><br><span class="line"></span><span class="keyword">filetype</span> plugin <span class="keyword">on</span>      <span class="string">" use the file type plugins</span><br><span class="line"></span><span class="keyword">set</span> <span class="keyword">ts</span>=<span class="number">4</span>                <span class="string">" tab space =4</span><br><span class="line"></span><span class="keyword">set</span> expandtab</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span>				<span class="string">" show line number</span><br><span class="line"></span><span class="keyword">set</span> <span class="built_in">shiftwidth</span>          <span class="string">" 这个貌是可以用于批量缩进的时候设置为4个空格</span><br><span class="line"></span><span class="keyword">highlight</span> Comment ctermfg=green guifg=green  <span class="string">"高亮备注为绿色</span><br><span class="line"></span></span><br><span class="line"><span class="string">" When editing a file, always jump to the last cursor position</span><br><span class="line"></span><span class="keyword">autocmd</span> BufReadPost *</span><br><span class="line">\ <span class="keyword">if</span> ! <span class="built_in">exists</span>(<span class="string">"g:leave_my_cursor_position_alone"</span>) |</span><br><span class="line">\ <span class="keyword">if</span> <span class="built_in">line</span>(<span class="string">"'\""</span>) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">line</span> (<span class="string">"'\""</span>) &lt;= <span class="built_in">line</span>(<span class="string">"$"</span>) |</span><br><span class="line">\ <span class="keyword">exe</span> <span class="string">"normal g'\""</span> |</span><br><span class="line">\ <span class="keyword">endif</span> |</span><br><span class="line">\ <span class="keyword">endif</span></span><br></pre></td></tr></table></figure></p>
<p>接着退出之后随便使用<code>vim</code>打开一个文件之后可以看到颜色亮起来了<br><img src="/img/Mac-OSX-Vim-highlight/vim_highlight.png" alt=""></p>
<p>瞬间就带感了，其他的设置都可以去在刚刚的文件里面进行配置</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文主要参考<a href="http://www.yeyaxi.com/2011/06/how-to-enable-syntax-highlighting-for-vim-in-mac-osx/">[译]如何在Mac OS X中开启VIM语法高亮</a>,他是真的work啊^_^</p>
</blockquote>
<p>使用<code>vim</code>来敲代码很带感，设置<code>vim</code>是一大要事，但是在<code>Mac</code>的<code>vim</code>默认是黑白的，而且并不能像<code>Linux</code>设置<code>~/.vimrc</code>来进行配置，但是毕竟还有其他的方法，先下面一步一步走就可以了</p>
<p>首先进入终端之后输入如下代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/vim</span><br><span class="line"></span><br><span class="line">sudo vim vimrc</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://yyl8781697.github.io/tags/Mac/"/>
    
      <category term="Mac" scheme="http://yyl8781697.github.io/categories/Mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[来来来，学习Shell的命令]]></title>
    <link href="http://yyl8781697.github.io/2015/11/04/Linux/Shell-Command-List/"/>
    <id>http://yyl8781697.github.io/2015/11/04/Linux/Shell-Command-List/</id>
    <published>2015-11-04T14:34:28.000Z</published>
    <updated>2015-11-27T08:29:34.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Shell脚本是非常强的大一个脚本语言，但是不用会手生，所以在此记录Shell脚本的相应关键点，也做查字典用^_^</p>
</blockquote>
<h2 id="变量">变量</h2><h3 id="变量定义">变量定义</h3><p>先来简单的看一下变量定义的规则</p>
<ol>
<li>在<code>Shell</code>中，使用变量之前不需要事先声明，只是通过使用它们来创建它们；</li>
<li>在默认情况下，所有变量都被看做是字符串，并以字符串来存储；</li>
<li><code>Shell</code>变量是区分大小写的；</li>
<li>在赋值变量的时候等号两端不能有空格-_-</li>
</ol>
<a id="more"></a>
<p>定义了变量之后，一定要加上<code>$</code>符号才能使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">VAR1=HELLO</span><br><span class="line">VAR2=MY NAME</span><br><span class="line">VAR3=<span class="string">"MY AGE"</span></span><br><span class="line">VAR4 = IS</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> VAR1 <span class="comment">#error 能输出 但不是输出该变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$VAR1</span> <span class="comment">#ok 正常读取变量并打印</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$VAR2</span> <span class="comment">#error 定义变量的值 用空格隔开了</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$VAR3</span> <span class="comment">#ok 作为一整个字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$VAR4</span> <span class="comment">#error 变量定义的时候等号两端有空格</span></span><br></pre></td></tr></table></figure>
<p>输出的结果为</p>
<pre><code>./test.sh: <span class="built_in">line</span> <span class="number">2</span>: NAME: <span class="command"><span class="keyword">command</span> <span class="title">not</span> <span class="title">found</span></span>
./test.sh: <span class="built_in">line</span> <span class="number">4</span>: VAR4: <span class="command"><span class="keyword">command</span> <span class="title">not</span> <span class="title">found</span></span>
VAR1
HELLO

MY AGE
</code></pre><blockquote>
<p>关于<code>shell</code>脚本的执行：<code>shell</code>基本一般是以<code>.sh</code>为后缀,然后在<code>*unix</code>系统下一般都是直接使用<code>./[当前shell文件名]</code> 的方式来执行，也可以使用<code>全部经/[shell文件名]</code>的方式来执行，并且需要注意的是 被执行的<code>shell</code>文件一定是有含有可执行权限了的，可以使用<code>chmod</code>命令来修改</p>
</blockquote>
<p>还有另一个点就是在调用变量的时候 ，如果在双引号中直接使用<code>$name</code>任然可以识别，但是如果在单引号是就无法适用<code>$name</code>的方式来调用变量</p>
<h3 id="read读取输入值">read读取输入值</h3><p>这个功能就像<code>java</code>中的<code>readline</code>来读取，使用方法为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"whats your name?"</span></span><br><span class="line"><span class="built_in">read</span> NAME  <span class="comment">#在这里读取输入值到NAME变量中 ，这里如果不输入会停留在屏幕上</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"webcome back"</span> <span class="variable">$NAME</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到熟悉的结果为</p>
<pre><code>whats your <span class="property">name</span>?
tom
webcome <span class="keyword">back</span> tom
</code></pre><h3 id="环境变量">环境变量</h3><p><code>Shell</code>脚本还提供能一些实用的环境变量</p>
<ol>
<li><code>$HOME</code>:为当前用户所在的目录</li>
<li><code>$PATH</code>:当前用户所能方法的PATH变量</li>
<li><code>$#</code>:传递参数额个数  类似<code>java</code>中的<code>args.length</code></li>
<li><code>$$</code><code>:Shell</code>脚本的进程号，脚本程序通常会用它来生成一个唯一的临时文件。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前用户所在的目录为"</span> <span class="variable">$HOME</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前的执行目录为"</span> $(<span class="built_in">pwd</span>)  <span class="comment">#这个是访问当前的脚本的目录很实用</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前用户所能访问的PATH为"</span> <span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前参数的参数个数为"</span> <span class="variable">$#</span>  <span class="comment">#这儿参数的格式是使用空格隔开的哦</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前Shell脚本的进程号为"</span> $$</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以到看的结果是</p>
<pre><code>yans-MacBook-<span class="string">Pro:</span>Downloads yanyl$ ./hi.sh  hello world
当前用户所在的目录为 <span class="regexp">/Users/</span>yanyl
当前的执行目录为 <span class="regexp">/Users/</span>yanyl/Downloads
当前用户所能访问的PATH为 <span class="regexp">/usr/</span>local<span class="regexp">/bin:/</span>usr<span class="regexp">/bin:/</span><span class="string">bin:</span><span class="regexp">/usr/</span><span class="string">sbin:</span><span class="regexp">/sbin:/</span>Users<span class="regexp">/yanyl/</span>Program<span class="regexp">/apache-maven-3.2.5/</span><span class="string">bin:</span><span class="regexp">/Users/</span>yanyl<span class="regexp">/Program/</span>scala-<span class="number">2.10</span>.4<span class="comment">//bin</span>
当前参数的参数个数为 <span class="number">2</span>
当前Shell脚本的进程号为 <span class="number">43746</span>
</code></pre><blockquote>
<p>假如需要进入当前目录的父目录，可以使用<code>$(dirname $(pwd))</code></p>
</blockquote>
<h3 id="参数变量">参数变量</h3><p>刚刚看到可以使用<code>read</code>关键字可以来读取输入变量，但是我们可能更加常用的是参数变量，也就是<code>$#</code>的个数，它的规则如下</p>
<ol>
<li><code>$#</code>表示参数变量的个数</li>
<li><code>$0</code>表示当前的脚本名称</li>
<li><code>$1,$2…$n</code>表示依次能读取到的变量 但是如果参数变量不够，<code>$i</code>会被赋值为空</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前输入的参数变量的长度为"</span> <span class="variable">$#</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前执行的Shell脚本为"</span> <span class="variable">$0</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前输入的第一个参数为"</span> <span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前输入的第二个参数为"</span> <span class="variable">$2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前的输入的第三个参数为"</span> <span class="variable">$3</span> <span class="comment">#现在如果只传2个参数 这里将不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以看到的结果为</p>
<pre><code>yans-MacBook-<span class="keyword">Pro</span>:Downloads yanyl$ ./hi.<span class="keyword">sh</span>  hello world
当前输入的参数变量的长度为 2
当前执行的<span class="keyword">Shell</span>脚本为 ./hi.<span class="keyword">sh</span>
当前输入的第一个参数为 hello
当前输入的第二个参数为 world
当前的输入的第三个参数为
</code></pre><p>可以看到在<code>Shell</code>脚本中去读取参数变量还是很方便的，这样配合下面的条件判断以及循环就可以做很多事情了</p>
<h3 id="读取返回码">读取返回码</h3><p>一般的程序/命令在执行结束时都会返回一个 返回码，比如</p>
<ul>
<li><code>java</code>的<code>system.exit(-1)</code></li>
<li><code>python</code>的<code>sys.exit(-1)</code></li>
<li>还有上面<code>Shell</code>脚本中的最后一行<code>exit 0</code></li>
</ul>
<blockquote>
<p>如果你不显式指定返回码，一般默认为0，表示正常退出，但是有时候显式的指定返回码是一个好习惯哦<br>这些程序在<code>Shell</code>中执行的,可以使用<code>$?</code>来读取上一个程序执行下来的脚本码</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">du <span class="operator">-s</span> <span class="comment">#执行的返回码一般为0</span></span><br><span class="line"><span class="built_in">echo</span> du <span class="operator">-s</span>的返回码为 $?</span><br><span class="line"></span><br><span class="line">duu <span class="operator">-s</span> <span class="comment">#这个命令故意输错</span></span><br><span class="line"><span class="built_in">echo</span> duu <span class="operator">-s</span>的返回码为 $?</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以看到正确的结果为</p>
<pre><code><span class="number">28494656</span>    .
du <span class="operator">-s</span>的返回码为 <span class="number">0</span>
./hi.sh: line <span class="number">6</span>: duu: <span class="built_in">command</span> not found
duu <span class="operator">-s</span>的返回码为 <span class="number">127</span>
</code></pre><blockquote>
<p>返回码配上<code>if</code>判断，就可以使用<code>shell</code>脚本自由得在各个语言以及命令中穿梭啦^_^</p>
</blockquote>
<h2 id="数学运算">数学运算</h2><p>在上一小节中说道，<code>Shell</code>中变量一般都是当字符串来处理，那我遇到数字运算该咋办呢？？</p>
<p>可以先看<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">a=<span class="number">1</span>+<span class="number">2</span></span><br><span class="line">b=<span class="variable">$a</span>+<span class="number">3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>结果却看到</p>
<pre><code>1+2
1+2+3
</code></pre><p>那在<code>Shell</code>中解决这个问题大概有这么几种方法</p>
<h3 id="let关键字">let关键字</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">let</span> a=<span class="number">1</span>+<span class="number">2</span></span><br><span class="line"><span class="built_in">let</span> b=<span class="variable">$a</span>+<span class="number">3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>输出的结果为</p>
<pre><code>3
6
</code></pre><p>这个关键词大致需要注意以下几个点:</p>
<ul>
<li><code>let</code>只支持整数运算</li>
<li>当<code>let</code>后面的运算部分有<code>bash</code>关键字时，需加双引号</li>
<li>幂次方可以使用**符号</li>
</ul>
<h3 id="使用(())">使用(())</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">((a=<span class="number">1</span>+<span class="number">2</span>))</span><br><span class="line">((b=<span class="variable">$a</span>+<span class="number">3</span>))</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>结果还是正确的</p>
<pre><code>3
6
</code></pre><blockquote>
<p><code>(())</code>的用法与<code>let</code>完全相同</p>
</blockquote>
<h3 id="使用$[]">使用$[]</h3><p>上面的效果需要这么写<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=$[<span class="number">1</span>+<span class="number">2</span>]</span><br><span class="line">b=$[<span class="variable">$a</span>+<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<p>其余与上面两种限制大致相同</p>
<h3 id="使用expr">使用expr</h3><p>关于这个方式是这么写的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=`expr <span class="number">1</span> + <span class="number">2</span>`</span><br><span class="line">b=`expr <span class="variable">$a</span> \* <span class="number">3</span>`  <span class="comment">#需要转义</span></span><br></pre></td></tr></table></figure></p>
<p>需要额外注意的有：</p>
<ul>
<li>运算符两端需要加空格  一定要记住。。。很容易失误</li>
<li>对于<code>|、&amp;、&lt;、&lt;=、&gt;=、&gt;、*</code>运算符号需要加上<code>\</code>进行转义</li>
</ul>
<h3 id="使用bc">使用bc</h3><p>这个终于是可以用于浮点数的运算了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">a=<span class="number">3.1415926</span></span><br><span class="line">b=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span>*2"</span>|bc`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到结果</p>
<pre><code>3.1415926
6.2831852
</code></pre><p>据说这里还有一个<code>scale</code>来设置精度，但是我设置了感觉木有效果-_-</p>
<h2 id="条件判断">条件判断</h2><h3 id="if_语法">if 语法</h3><p>在<code>Shell</code>脚本中有两种书写<code>if</code>判断的语法</p>
<ul>
<li><p>使用<code>test</code> 关键字</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># if test expression1 operation expression2</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="number">5</span> <span class="operator">-gt</span> <span class="number">4</span>;  <span class="comment">#这个最后的结尾可以加上:或者;</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"ok,5&gt;4"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"oh,no"</span></span><br><span class="line"><span class="keyword">fi</span> <span class="comment">#这个结束符号必须得加</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>  输出为</p>
<pre><code><span class="ok">ok</span>,<span class="number">5</span>&gt;<span class="number">4</span>
</code></pre></li>
<li><p>使用<code>[</code>和<code>]</code>关键字</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># if [ expression1 operation expression2 ]</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="number">5</span> <span class="operator">-lt</span> <span class="number">4</span> ];  <span class="comment">#注意[和]两端必须留空格 同时表达式两端都需要有空格</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"ok,5&gt;4"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"oh,no"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>  输出为</p>
<pre><code>oh,<span class="literal">no</span>
</code></pre></li>
</ul>
<blockquote>
<p>如果还更加复杂的判断你可以使用<code>elif</code>继续增加条件表达式，但是别忘了加<code>then</code>哦</p>
</blockquote>
<h3 id="判断表达式">判断表达式</h3><p>在<code>Shell</code>中有三种判断表达式</p>
<h4 id="字符串比较">字符串比较</h4><table>
<thead>
<tr>
<th style="text-align:left">字符串比较</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>string1 = string2</code></td>
<td style="text-align:left">如果两个字符串相同，也可用<code>==</code>结果就为真</td>
</tr>
<tr>
<td style="text-align:left"><code>string1 != string2</code></td>
<td style="text-align:left">如果两个字符串不同，结果就为真</td>
</tr>
<tr>
<td style="text-align:left"><code>-n string</code></td>
<td style="text-align:left">如果字符串不为空，则结果为真</td>
</tr>
<tr>
<td style="text-align:left"><code>-z string</code></td>
<td style="text-align:left">如果字符串为一个空串（<code>null</code>），则结果为真</td>
</tr>
</tbody>
</table>
<blockquote>
<p>这里需要注意下，<code>-n</code> 和 <code>-z string</code>比较时必须用双引号(“”)将变量引起来</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">a=<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$a</span>"</span>  ]  <span class="comment">#注意要空括号来包住哦</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> exists</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> null</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$c</span>"</span>  ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> exists</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> null</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>结果为</p>
<pre><code>exists
<span class="literal">null</span>
</code></pre><h4 id="算术比较">算术比较</h4><table>
<thead>
<tr>
<th style="text-align:left">算术比较</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>expression1 -eq expression2</code></td>
<td style="text-align:left">如果两个表达式相等，则结果为真</td>
</tr>
<tr>
<td style="text-align:left"><code>expression1 -ne expression2</code></td>
<td style="text-align:left">如果两个表达式不等，则结果为真</td>
</tr>
<tr>
<td style="text-align:left"><code>expression1 -gt expression2</code></td>
<td style="text-align:left">如果<code>expression1</code> 大于<code>expression2</code> ，则为真</td>
</tr>
<tr>
<td style="text-align:left"><code>expression1 -ge expression2</code></td>
<td style="text-align:left">如果<code>expression1</code> 大于等于<code>expression2</code> ,则为真</td>
</tr>
<tr>
<td style="text-align:left"><code>expression1 -lt expression2</code></td>
<td style="text-align:left">如果<code>expression1</code> 小于<code>expression2</code> ，则为真</td>
</tr>
<tr>
<td style="text-align:left"><code>expression1 -le expression2</code></td>
<td style="text-align:left">如果<code>expression1</code> 小于等于<code>expression2</code> ，则为真</td>
</tr>
<tr>
<td style="text-align:left"><code>!expression</code></td>
<td style="text-align:left">表达式为假，则结果就为真；反之亦然</td>
</tr>
</tbody>
</table>
<blockquote>
<p>关于上面比较符号的快速记法如下：<code>eq=equal</code>,<code>gt=great than</code>,<code>lt=less than</code>，然后组合拼凑即可，如果觉得这样还是很难记，就可以像我一样，将这些符号记录下来，需要的时候来查表-_-</p>
</blockquote>
<h4 id="文件条件测试">文件条件测试</h4><table>
<thead>
<tr>
<th style="text-align:left">文件条件测试</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-d file</code></td>
<td style="text-align:left">如果文件是一个目录，则为真</td>
</tr>
<tr>
<td style="text-align:left"><code>-f file</code></td>
<td style="text-align:left">如果文件是一个普通文件，则为真；也可以用来测试文件是否存在</td>
</tr>
<tr>
<td style="text-align:left"><code>-r file</code></td>
<td style="text-align:left">如果文件可读，则结果为真</td>
</tr>
<tr>
<td style="text-align:left"><code>-s file</code></td>
<td style="text-align:left">如果文件大小不为0，则结果为真</td>
</tr>
<tr>
<td style="text-align:left"><code>-w file</code></td>
<td style="text-align:left">如果文件可写，则结果为真</td>
</tr>
<tr>
<td style="text-align:left"><code>-x file</code></td>
<td style="text-align:left">如果文件可执行，则结果为真</td>
</tr>
</tbody>
</table>
<blockquote>
<p>这，真的是一个利民的测试</p>
</blockquote>
<h2 id="循环结构">循环结构</h2><h3 id="for_循环">for 循环</h3><p>先来看一种经典<code>C</code>语法版的<code>for</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">for</span> ((i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>看输出，</p>
<pre><code>0
1
2
3
4
</code></pre><p>还支持在外部控制步长<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">for</span> ((i=<span class="number">0</span>;i&lt;<span class="number">5</span>;))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">    i=$[<span class="variable">$i</span>+<span class="number">2</span>]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<pre><code>0
2
4
</code></pre><blockquote>
<p>是不是感觉基本功能都有呀，就是写某些东西写起来奇怪点<br>是不是有一种莫名的熟悉感</p>
</blockquote>
<p>另一种就是类似<code>foreach</code>的情况了，他的格式是这样的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> variable <span class="keyword">in</span> values</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>values</code> 可能有的情况为：</p>
<ol>
<li><p>使用<code>linux</code>命令输出的行作为迭代的输入:<code>ls</code>,<code>seq</code>,<code>cat</code>之类均可,其实就可以完成很强大的文件读取功能</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `head -n <span class="number">5</span> words.dit`;<span class="keyword">do</span>  <span class="comment">#words.dit 这是一个通用词表 每行一个词</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p> 可以看到通用词典中前5个词</p>
<pre><code>阿
阿巴丹
阿巴岛
阿巴鸟
阿巴伊达
</code></pre></li>
<li><p>使用<code>$*</code>可以来表示遍历传入的参数列表</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $*;<span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p> 来看个结果</p>
<pre><code>yans-MacBook-Pro:Downloads yanyl$ ./hi.sh  <span class="keyword">my</span> <span class="property">name</span> <span class="keyword">is</span> tom
<span class="keyword">my</span>
<span class="property">name</span>
<span class="keyword">is</span>
tom
</code></pre></li>
<li><p>还可以使用带空格的字符串 来进行按空格分隔输出</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line">a=<span class="string">"yello red green"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$a</span>;<span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p> 这样在一定程度上可以看成一个简易的数组</p>
</li>
</ol>
<p>这里需要注意的是包含条件以及循环逻辑是双重括号，以及开始结果的<code>do</code>和<code>Done</code></p>
<h3 id="while_循环">while 循环</h3><p>另一个常用的就是<code>while</code>循环了<br>他的结构是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>这个也是蛮好理解的，可以来看一个demo<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"please ent your password:"</span></span><br><span class="line"><span class="built_in">read</span> <span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">"<span class="variable">$pwd</span>"</span>x != <span class="string">"root"</span>x  ] <span class="comment">#这里加x是为了防止啥也不输入直接回车产生的报错</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"error,please try again:"</span></span><br><span class="line">    <span class="built_in">read</span> <span class="built_in">pwd</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"welcome here"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>看一下结果</p>
<pre><code>please ent your <span class="string">password:</span>
sha
error,please <span class="keyword">try</span> <span class="string">again:</span>

error,please <span class="keyword">try</span> <span class="string">again:</span>
root
welcome here
</code></pre><p>很有意思的一个哈~</p>
<h3 id="until语句">until语句</h3><p>这个语句与<code>while</code>的结构完全一样，只是使用了<code>until</code>关键字来代替了<code>while</code>，然后在条件为<code>true</code>的时候停止，正好与<code>while</code>相反</p>
<h2 id="函数">函数</h2><p><code>Shell</code>这么叼，能没有函数吗<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">function</span>] <span class="function"><span class="title">functon_name</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是定义函数的结构，大致有以下几个要点</p>
<ol>
<li>前面的<code>function</code>关键字可有可无，不过感觉还是加上去比较好，这样在代码里面比较好辨识</li>
<li>函数名后面的括号中不能带参数 取的参数是用过<code>$1,$2…$n</code>这样的方式来取的 </li>
<li>调用的时候直接写函数名 不需要加括号</li>
<li>如果想传递参数的话 直接在调用后来加上参数列表 用空格隔开 （就是<code>Shell</code>的传参一样）</li>
<li>使用<code>local</code>关键字来定义函数体里面的局部变量</li>
<li>所以在函数调用必须在函数定义之后</li>
</ol>
<p>先看一个小的demo<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sayhi</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> hi <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayhi tom <span class="comment">#前面的sayhi是函数的调用 后面的tom是传参</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到输出</p>
<pre><code><span class="title">hi</span> tom
</code></pre><h3 id="函数的返回值">函数的返回值</h3><p>关于<code>Shell</code>的返回值方式有两种</p>
<ol>
<li><p>输出给主程序，他的结构为：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">function_name</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$something</span>  <span class="comment">#通过输出的方式来返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a=`<span class="keyword">function</span>_name`  这种方式接收返回值</span><br></pre></td></tr></table></figure>
<p> 看到的demo可以是这样的</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Press ENTER or <span class="built_in">type</span> <span class="built_in">command</span> to <span class="built_in">continue</span></span><br><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sum</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span> $[<span class="variable">$1</span>+<span class="variable">$2</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a=`sum <span class="number">1</span> <span class="number">2</span>`</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> the sum is <span class="variable">$a</span></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p> 最终输出结果为</p>
<pre><code><span class="operator">the</span> <span class="built_in">sum</span> is <span class="number">3</span>
</code></pre></li>
<li><p>使用<code>return</code>作为返回码来返回值</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">function_name</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span> <span class="variable">$ret</span> <span class="comment">#这里进行返回码的返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>_name</span><br><span class="line">$? <span class="comment">#在这里接收返回值</span></span><br></pre></td></tr></table></figure>
<p> 一样再来一个demo</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sum</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> $[<span class="variable">$1</span>+<span class="variable">$2</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="built_in">echo</span> the sum is $?</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p> 可以看到输出为</p>
<pre><code><span class="operator">the</span> <span class="built_in">sum</span> is <span class="number">3</span>
</code></pre></li>
</ol>
<h2 id="case语句">case语句</h2><p>这里的<code>case</code>的与传统的<code>switch</code>有点像，但是又像<code>scala</code>中的<code>match</code>模式匹配的强大，<br>他的结构是这样的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> variable <span class="keyword">in</span></span><br><span class="line">    pattern [ | pattern] ...) statements;;</span><br><span class="line">    pattern [ | pattern] ...) statements;;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></p>
<p>来看这个强大的demo<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">match</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">        root ) <span class="built_in">echo</span> this is password ;;</span><br><span class="line">        h* ) <span class="built_in">echo</span> hi <span class="variable">$1</span> ;; <span class="comment">#使用通配符</span></span><br><span class="line">        yes | YES ) <span class="built_in">echo</span> agree with me ;; <span class="comment">#可以进行或操作</span></span><br><span class="line">        * ) <span class="built_in">echo</span> everything is here;;  <span class="comment">#你可以理解为switch中的default</span></span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">match root</span><br><span class="line">match hello</span><br><span class="line">match YES</span><br><span class="line">match Yes</span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>来看一下结果</p>
<pre><code><span class="keyword">this</span> <span class="keyword">is</span> password
hi hello
agree <span class="keyword">with</span> me
everything <span class="keyword">is</span> here
</code></pre><blockquote>
<p>注意，这里一旦匹配中了一个之后就马上会停止匹配</p>
</blockquote>
<h2 id="外部命令/文件/语言的调用">外部命令/文件/语言的调用</h2><p><code>Shell</code>的另一个强大之处就是可以无缝的和外部的命令，文件，语言结合，去调用组织他们</p>
<ol>
<li>外部命令：一般情况下可以直接写外部命令，如果要赋值的话得使用<code>``</code>括起来</li>
<li>外部文件：比如资源配置文件，profile文件之类的，可以直接使用<code>source</code>关键字的来执行</li>
<li>外部语言：比如<code>java,python</code>可以直接使用他们的<code>java</code>调用<code>jar,java</code>文件，也可以直接使用<code></code>关键字来执行<code>python</code>文件</li>
</ol>
<h2 id="总结">总结</h2><ol>
<li><code>Shell</code>很好很强大，得学习！！！</li>
<li>注意变量的字符串格式以及需要数学运算时的语法</li>
<li>注意变量赋值时等号两端一定不能有空格以及再取值时一定要加<code>$</code></li>
<li>平常的控制结束符号别忘了，比如<code>fi,doen,esac</code>等</li>
<li>忘了的时候来查查这个文件</li>
</ol>
<h2 id="参考">参考</h2><ul>
<li><a href="http://blog.csdn.net/mdx20072419/article/details/9381339" target="_blank" rel="external">shell 函数返回值接收问题</a></li>
<li><a href="http://www.jellythink.com/archives/699" target="_blank" rel="external">Linux Shell简明教程</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_9d074aae01012ytf.html" target="_blank" rel="external">shell中for循环总结</a></li>
<li><a href="http://www.1987.name/181.html" target="_blank" rel="external">Shell函数的定义、执行、传参和递归函数</a></li>
<li><a href="http://www.cnblogs.com/liujiahi/archive/2011/03/30/2196400.html" target="_blank" rel="external">shell 中数学计算总结</a></li>
</ul>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external"></a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Shell脚本是非常强的大一个脚本语言，但是不用会手生，所以在此记录Shell脚本的相应关键点，也做查字典用^_^</p>
</blockquote>
<h2 id="变量">变量</h2><h3 id="变量定义">变量定义</h3><p>先来简单的看一下变量定义的规则</p>
<ol>
<li>在<code>Shell</code>中，使用变量之前不需要事先声明，只是通过使用它们来创建它们；</li>
<li>在默认情况下，所有变量都被看做是字符串，并以字符串来存储；</li>
<li><code>Shell</code>变量是区分大小写的；</li>
<li>在赋值变量的时候等号两端不能有空格-_-</li>
</ol>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://yyl8781697.github.io/tags/Linux/"/>
    
      <category term="Vim" scheme="http://yyl8781697.github.io/tags/Vim/"/>
    
      <category term="Linux" scheme="http://yyl8781697.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[KNN算法中KD树的应用]]></title>
    <link href="http://yyl8781697.github.io/2015/10/12/Machine%20Learning/KDTree-In-KNN/"/>
    <id>http://yyl8781697.github.io/2015/10/12/Machine Learning/KDTree-In-KNN/</id>
    <published>2015-10-12T03:57:39.000Z</published>
    <updated>2015-10-12T08:10:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="KNN算法">KNN算法</h2><pre><code>给一个训练数据集和一个新的实例，在训练数据集中找出与这个新实例最近的k个训练实例，然后统计最近的k个训练实例中所属类别计数最多的那个类，就是新实例的类。
</code></pre><p><a href="http://kubicode.me/2015/08/16/Machine%20Learning/Algorithm-Summary-for-Interview/#KNN算法" target="_blank" rel="external">点我查看详情</a></p>
<blockquote>
<p>但是该算法每次在查询k个最近邻的时候都需要遍历全集  才能计算出来，可想而且如果训练样本很大的话，代价还是很大的，那有没有啥方法可以优化呢？本文就针对<code>KNN</code>算法实现一个简单的<code>KD</code>树</p>
</blockquote>
<h2 id="KD树">KD树</h2><pre><code>KD树是一个二叉树，表示对<span class="keyword">K</span>维空间的一个划分，可以进行快速检索（那KNN计算的时候不需要对全样本进行距离的计算了）
</code></pre><p>比如针对6个二维数据点{（2,3），（5,4），（9,6），（4,7），（8,1），（7,2）}，可以形成以下树形结构以及空间划分<br><img src="/img/KDTree-In-KNN/example.png" alt=""></p>
<a id="more"></a>
<p>该树的功能就是在高维空间下进行一个快速的最近邻查询。先来看定义的树的类结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">double</span>[] data;<span class="comment">//树上节点的数据  是一个多维的向量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">double</span> distance;<span class="comment">//与当前查询点的距离  初始化的时候是没有的</span></span><br><span class="line">	<span class="keyword">public</span> Node left,right,parent;<span class="comment">//左右子节点  以及父节点</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> dim=-<span class="number">1</span>;<span class="comment">//维度  建立树的时候判断的维度</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">double</span>[] data)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data=data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 返回指定索引上的数值</span><br><span class="line">	 *<span class="javadoctag"> @param</span> index</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getData</span><span class="params">(<span class="keyword">int</span> index)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(data==<span class="keyword">null</span> || data.length&lt;=index)</span><br><span class="line">			<span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">		<span class="keyword">return</span> data[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.distance&gt;o.distance)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(<span class="keyword">this</span>.distance==o.distance)</span></span><br><span class="line">			return 0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="javadoc">/**</span><br><span class="line">	 * 计算距离 这里返回欧式距离</span><br><span class="line">	 *<span class="javadoctag"> @param</span> that</span><br><span class="line">	 *<span class="javadoctag"> @return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">computeDistance</span><span class="params">(Node that)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.data==<span class="keyword">null</span> || that.data==<span class="keyword">null</span> || <span class="keyword">this</span>.data.length!=that.data.length)</span><br><span class="line">			<span class="keyword">return</span> Double.MAX_VALUE;<span class="comment">//出问题了  距离最远</span></span><br><span class="line">		<span class="keyword">double</span> d=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.data.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			d+=Math.pow(<span class="keyword">this</span>.data[i]-that.data[i], <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> Math.sqrt(d);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(data==<span class="keyword">null</span> || data.length==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.length;i++)</span><br><span class="line">			sb.append(data[i]+<span class="string">" "</span>);</span><br><span class="line">		sb.append(<span class="string">" d:"</span>+<span class="keyword">this</span>.distance);</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="建立KD树">建立KD树</h3><p>在<code>d</code>维的空间上循环找子区域的中位数进行划分的过程。<br>假设现在有<code>d</code>维空间的数据集<code>T={x<sub>1</sub>,x<sub>2</sub>,x<sub>3</sub>,…x<sub>n</sub>},xi={a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>..a<sub>d</sub>}</code></p>
<ol>
<li>首先构造根节点，以坐标<code>a<sub>1</sub></code>的中位数<code>b</code>为切分点，将根结点对应的矩形局域划分为两个区域，区域1中<code>a1&lt;b</code>,区域2中<code>a1&gt;b</code>，中位数所在的节点就是树上的节点</li>
<li>构造叶子节点，分别以上面两个区域中<code>a<sub>2</sub></code>的中位数作为切分点，再次将他们两两划分，作为深度1的叶子节点，（如果<code>a<sub>2</sub></code>=中位数，则<code>a<sub>2</sub></code>的实例落在切分面）</li>
<li>不断重复2的操作，深度为<code>j</code>的叶子节点划分的时候，索取的<code>a<sub>i</sub></code> 的<code>i=j%d+1</code>，直到两个子区域没有实例时停止</li>
</ol>
<p>所以我们首先需要在高维的数据中针对某一维进行一个中位数的查找的，这里最快捷的就是借用快排的方法</p>
<pre><code>假设f为快排的排头，进行一轮对比之后如果f所在的索引大于<span class="built_in">size</span>/<span class="number">2</span>，则此时只需要对左边进行递归排序就可以了，若小于<span class="built_in">size</span>/<span class="number">2</span>，则只需对右边区域进行递归排序，如果等于<span class="built_in">size</span>/<span class="number">2</span>  则说明
f就是中位数  直接返回就好啦
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 使用快排进进行一个中位数的查找  完了之后返回的数组size/2即中位数</span><br><span class="line"> *<span class="javadoctag"> @param</span> nodeList</span><br><span class="line"> *<span class="javadoctag"> @param</span> index</span><br><span class="line"> *<span class="javadoctag"> @param</span> left</span><br><span class="line"> *<span class="javadoctag"> @param</span> right</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSortForMedian</span><span class="params">(List&lt;Node&gt; nodeList,<span class="keyword">int</span> index,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&gt;=right || nodeList.size()&lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	</span><br><span class="line">	Node kn=nodeList.get(left);</span><br><span class="line">	<span class="keyword">double</span> k=kn.getData(index);<span class="comment">//取得向量指定索引的值</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i=left,j=right;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(nodeList.get(j).getData(index)&gt;=k &amp;&amp; i&lt;j)</span><br><span class="line">			j--;</span><br><span class="line">		nodeList.set(i, nodeList.get(j));</span><br><span class="line">		<span class="keyword">while</span>(nodeList.get(i).getData(index)&lt;=k &amp;&amp; i&lt;j)</span><br><span class="line">			i++;</span><br><span class="line">		nodeList.set(j, nodeList.get(i));</span><br><span class="line">	&#125;</span><br><span class="line">	nodeList.set(i, kn);</span><br><span class="line">	<span class="keyword">if</span>(i==nodeList.size()/<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> ;<span class="comment">//完成中位数的排序了</span></span><br><span class="line">	<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(i&lt;nodeList.size()</span>/2)</span><br><span class="line">	</span>&#123;</span><br><span class="line">		quickSortForMedian(nodeList,index,i+<span class="number">1</span>,right);<span class="comment">//只需要排序右边就可以了</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		quickSortForMedian(nodeList,index,left,i-<span class="number">1</span>);<span class="comment">//只需要排序左边就可以了</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了中位数查找，接下来就可以使用递归来进行树的建立了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 构建kd树  返回根节点</span><br><span class="line"> *<span class="javadoctag"> @param</span> nodeList</span><br><span class="line"> *<span class="javadoctag"> @param</span> index</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">buildKDTree</span><span class="params">(List&lt;Node&gt; nodeList,<span class="keyword">int</span> index)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(nodeList==<span class="keyword">null</span> || nodeList.size()==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	quickSortForMedian(nodeList,index,<span class="number">0</span>,nodeList.size()-<span class="number">1</span>);<span class="comment">//中位数排序</span></span><br><span class="line">	Node root=nodeList.get(nodeList.size()/<span class="number">2</span>);<span class="comment">//中位数 当做根节点</span></span><br><span class="line">	root.dim=index;</span><br><span class="line">	List&lt;Node&gt; leftNodeList=<span class="keyword">new</span> ArrayList&lt;Node&gt;();<span class="comment">//放入左侧区域的节点  包括包含与中位数等值的节点-_-</span></span><br><span class="line">	List&lt;Node&gt; rightNodeList=<span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(Node node:nodeList)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(root!=node)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(node.getData(index)&lt;=root.getData(index))</span><br><span class="line">				leftNodeList.add(node);<span class="comment">//左子区域 包含与中位数等值的节点</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				rightNodeList.add(node);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> newIndex=index+<span class="number">1</span>;<span class="comment">//进入下一个维度</span></span><br><span class="line">	<span class="keyword">if</span>(newIndex&gt;=root.data.length)</span><br><span class="line">		newIndex=<span class="number">0</span>;<span class="comment">//从0维度开始再算</span></span><br><span class="line">	root.left=buildKDTree(leftNodeList,newIndex);<span class="comment">//添加左右子区域</span></span><br><span class="line">	root.right=buildKDTree(rightNodeList,newIndex);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">		root.left.parent=root;<span class="comment">//添加父指针  </span></span><br><span class="line">	<span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">		root.right.parent=root;<span class="comment">//添加父指针  </span></span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="KD树搜索">KD树搜索</h3><ol>
<li>首先从根节点开始递归往下找到包含<code>q</code>的叶子节点，每一层都是找对应的<code>x<sub>i</sub></code></li>
<li>将这个叶子节点认为是当前的“近似最近点”</li>
<li>递归向上回退，如果以<code>q</code>圆心，以“近似最近点”为半径的球与根节点的另一半子区域边界相交，则说明另一半子区域中存在与<code>q</code>更近的点，则进入另一个子区域中查找该点并且更新”近似最近点“</li>
<li>重复3的步骤，直到另一子区域与球体不相交或者退回根节点</li>
<li>最后更新的”近似最近点“与<code>q</code>真正的最近点</li>
</ol>
<p>这里注意按上述方式找到的与查询点最近的那个点，但是我们在<code>KNN</code>的时候是查询<code>k</code>个最近点，<code>topK</code>问题嘛，这里我们就使用了一个最大堆的维护来保证最近的<code>k</code>个点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 维护一个k的最大堆</span><br><span class="line"> *<span class="javadoctag"> @param</span> listNode</span><br><span class="line"> *<span class="javadoctag"> @param</span> newNode</span><br><span class="line"> *<span class="javadoctag"> @param</span> k</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maintainMaxHeap</span><span class="params">(List&lt;Node&gt; listNode,Node newNode,<span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(listNode.size()&lt;k)</span><br><span class="line">	&#123;</span><br><span class="line">		maxHeapFixUp(listNode,newNode);<span class="comment">//不足k个堆   直接向上修复</span></span><br><span class="line">	&#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(newNode.distance&lt;listNode.get(<span class="number">0</span>)</span>.distance)</span>&#123;</span><br><span class="line">		<span class="comment">//比堆顶的要小   还需要向下修复 覆盖堆顶</span></span><br><span class="line">		maxHeapFixDown(listNode,newNode);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 从上往下修复  将会覆盖第一个节点</span><br><span class="line"> *<span class="javadoctag"> @param</span> listNode</span><br><span class="line"> *<span class="javadoctag"> @param</span> newNode</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeapFixDown</span><span class="params">(List&lt;Node&gt; listNode,Node newNode)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	listNode.set(<span class="number">0</span>, newNode);</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(j&lt;listNode.size())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(j+<span class="number">1</span>&lt;listNode.size() &amp;&amp; listNode.get(j).distance&lt;listNode.get(j+<span class="number">1</span>).distance)</span><br><span class="line">			j++;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(listNode.get(i).distance&gt;=listNode.get(j).distance)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		Node t=listNode.get(i);</span><br><span class="line">		listNode.set(i, listNode.get(j));</span><br><span class="line">		listNode.set(j, t);</span><br><span class="line">		</span><br><span class="line">		i=j;</span><br><span class="line">		j=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeapFixUp</span><span class="params">(List&lt;Node&gt; listNode,Node newNode)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	listNode.add(newNode);</span><br><span class="line">	<span class="keyword">int</span> j=listNode.size()-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> i=(j+<span class="number">1</span>)/<span class="number">2</span>-<span class="number">1</span>;<span class="comment">//i是parent节点</span></span><br><span class="line">	<span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(listNode.get(i).distance&gt;=listNode.get(j).distance)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		Node t=listNode.get(i);</span><br><span class="line">		listNode.set(i, listNode.get(j));</span><br><span class="line">		listNode.set(j, t);</span><br><span class="line">		</span><br><span class="line">		j=i;</span><br><span class="line">		i=(j+<span class="number">1</span>)/<span class="number">2</span>-<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好，现在就可以按照上述的思路来进行搜索了，搜索过程中维护一个k堆<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 查询最近邻</span><br><span class="line"> *<span class="javadoctag"> @param</span> root kd树</span><br><span class="line"> *<span class="javadoctag"> @param</span> q 查询点</span><br><span class="line"> *<span class="javadoctag"> @param</span> k</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Node&gt; <span class="title">searchKNN</span><span class="params">(Node root,Node q,<span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	List&lt;Node&gt; knnList=<span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">	Node almostNNode=searchLeaf(root,q);<span class="comment">//近似最近点</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(almostNNode!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">double</span> curD=q.computeDistance(almostNNode);<span class="comment">//最近近似点与查询点的距离 也就是球体的半径</span></span><br><span class="line">		almostNNode.distance=curD;</span><br><span class="line">		maintainMaxHeap(knnList,almostNNode,k);</span><br><span class="line">		<span class="keyword">if</span>(almostNNode.parent!=<span class="keyword">null</span> &amp;&amp;</span><br><span class="line">				curD&gt;Math.abs(q.getData(almostNNode.parent.dim)-almostNNode.parent.getData(almostNNode.parent.dim)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//这样可能在另一个子区域中存在更加近似的点</span></span><br><span class="line">			Node brother=getBrother(almostNNode);</span><br><span class="line">			brother.distance=q.computeDistance(brother);</span><br><span class="line">			maintainMaxHeap(knnList,brother,k);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		almostNNode=almostNNode.parent;<span class="comment">//返回上一级</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> knnList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 获取兄弟节点</span><br><span class="line"> *<span class="javadoctag"> @param</span> node</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">getBrother</span><span class="params">(Node node)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node==node.parent.left)</span><br><span class="line">		<span class="keyword">return</span> node.parent.right;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> node.parent.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 查询到叶子节点</span><br><span class="line"> *<span class="javadoctag"> @param</span> root</span><br><span class="line"> *<span class="javadoctag"> @param</span> q</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">searchLeaf</span><span class="params">(Node root,Node q)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Node leaf=root,next=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(leaf.left!=<span class="keyword">null</span> || leaf.right!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(q.getData(index)&lt;leaf.getData(index))</span><br><span class="line">		&#123;</span><br><span class="line">			next=leaf.left;<span class="comment">//进入左侧</span></span><br><span class="line">		&#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(q.getData(index)</span>&gt;leaf.<span class="title">getData</span><span class="params">(index)</span>)</span><br><span class="line">		</span>&#123;</span><br><span class="line">			next=leaf.right;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//当取到中位数时  判断左右子区域哪个更加近</span></span><br><span class="line">			<span class="keyword">if</span>(q.computeDistance(leaf.left)&lt;q.computeDistance(leaf.right))</span><br><span class="line">				next=leaf.left;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				next=leaf.right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(next==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//下一个节点是空时  结束了</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			leaf=next;</span><br><span class="line">			<span class="keyword">if</span>(++index&gt;=root.data.length)</span><br><span class="line">				index=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> leaf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意这里在判断查询点<code>q</code>与另一个子区域的边界是否相交时是需要判断半径与（<code>q</code>和父节点影响构建维数上的值之差即可）</p>
</blockquote>
<h2 id="栗子">栗子</h2><p>还是以上面的6个数据点进行构建<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Node&gt; nodeList=<span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">nodeList.add(<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>&#125;));</span><br><span class="line">nodeList.add(<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">5</span>,<span class="number">4</span>&#125;));</span><br><span class="line">nodeList.add(<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">9</span>,<span class="number">6</span>&#125;));</span><br><span class="line">nodeList.add(<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">4</span>,<span class="number">7</span>&#125;));</span><br><span class="line">nodeList.add(<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">8</span>,<span class="number">1</span>&#125;));</span><br><span class="line">nodeList.add(<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">7</span>,<span class="number">2</span>&#125;));</span><br><span class="line"></span><br><span class="line">KDTree kdTree=<span class="keyword">new</span> KDTree();</span><br><span class="line">Node root=kdTree.buildKDTree(nodeList,<span class="number">0</span>);</span><br><span class="line">System.out.println(root);</span><br></pre></td></tr></table></figure></p>
<p>对(2.1,3.1)进行查询<br><img src="/img/KDTree-In-KNN/search1.jpg" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(kdTree.searchKNN(root,<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">2.1</span>,<span class="number">3.1</span>&#125;),<span class="number">2</span>));</span><br></pre></td></tr></table></figure></p>
<p>可以发现最近的两个点</p>
<pre><code>[<span class="number">5.0</span> <span class="number">4.0</span>  d:<span class="number">3.0364452901377956</span>, <span class="number">2.0</span> <span class="number">3.0</span>  d:<span class="number">0.14142135623730964</span>]
</code></pre><p>完全符合预期</p>
<p>再来看(2,4.5)这个查询点<br><img src="/img/KDTree-In-KNN/search2.jpg" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(kdTree.searchKNN(root,<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">2</span>,<span class="number">4.5</span>&#125;),<span class="number">1</span>));</span><br><span class="line">System.out.println(kdTree.searchKNN(root,<span class="keyword">new</span> Node(<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">2</span>,<span class="number">4.5</span>&#125;),<span class="number">3</span>));</span><br></pre></td></tr></table></figure></p>
<pre><code>[<span class="number">2.0</span> <span class="number">3.0</span>  d:<span class="number">1.5</span>]
[<span class="number">4.0</span> <span class="number">7.0</span>  d:<span class="number">3.2015621187164243</span>, <span class="number">2.0</span> <span class="number">3.0</span>  d:<span class="number">1.5</span>, <span class="number">5.0</span> <span class="number">4.0</span>  d:<span class="number">3.0413812651491097</span>]
</code></pre><p>首先最近邻的叶子节点是(4,7) 但是其半径会与另一子区域相交，所以继续进行(2,3)进行距离计算</p>
<blockquote>
<p>完整的源代码<a href="http://www.oschina.net/code/snippet_174837_51436" target="_blank" rel="external">在这儿有</a>!</p>
</blockquote>
<h2 id="参考">参考</h2><ol>
<li>《统计学习方法》第三章</li>
<li><a href="http://blog.csdn.net/qll125596718/article/details/8426458" target="_blank" rel="external">http://blog.csdn.net/qll125596718/article/details/8426458</a>这篇文章举例比较详细</li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="KNN算法">KNN算法</h2><pre><code>给一个训练数据集和一个新的实例，在训练数据集中找出与这个新实例最近的k个训练实例，然后统计最近的k个训练实例中所属类别计数最多的那个类，就是新实例的类。
</code></pre><p><a href="http://kubicode.me/2015/08/16/Machine%20Learning/Algorithm-Summary-for-Interview/#KNN算法">点我查看详情</a></p>
<blockquote>
<p>但是该算法每次在查询k个最近邻的时候都需要遍历全集  才能计算出来，可想而且如果训练样本很大的话，代价还是很大的，那有没有啥方法可以优化呢？本文就针对<code>KNN</code>算法实现一个简单的<code>KD</code>树</p>
</blockquote>
<h2 id="KD树">KD树</h2><pre><code>KD树是一个二叉树，表示对<span class="keyword">K</span>维空间的一个划分，可以进行快速检索（那KNN计算的时候不需要对全样本进行距离的计算了）
</code></pre><p>比如针对6个二维数据点{（2,3），（5,4），（9,6），（4,7），（8,1），（7,2）}，可以形成以下树形结构以及空间划分<br><img src="/img/KDTree-In-KNN/example.png" alt=""></p>]]>
    
    </summary>
    
      <category term="Data Struct" scheme="http://yyl8781697.github.io/tags/Data-Struct/"/>
    
      <category term="Java" scheme="http://yyl8781697.github.io/tags/Java/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[numpy工具包常用快速记]]></title>
    <link href="http://yyl8781697.github.io/2015/10/05/Python/Numpy-Fast-Memory/"/>
    <id>http://yyl8781697.github.io/2015/10/05/Python/Numpy-Fast-Memory/</id>
    <published>2015-10-05T14:54:26.000Z</published>
    <updated>2015-10-08T02:33:12.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><code>numpy</code>这个科学计算工具大法好，但是里面的东西不用老是会忘，所以在此记录常用的一些语法，以备之后查询之用（也叫懒人模式）^_^,不过详细的使用方法还是得看<a href="http://docs.scipy.org/doc/" target="_blank" rel="external">scipy api</a></p>
</blockquote>
<p>使用之前首先得引入包<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure></p>
<h2 id="array">array</h2><p><code>np.array</code>实现了真正的数组，在<code>numpy</code>中其实就是矩阵啦，同时提供了丰富的矩阵计算方法<br><a id="more"></a></p>
<h3 id="np-array"><a href="http://docs.scipy.org/doc/numpy/reference/c-api.array.html#index-0" target="_blank" rel="external">np.array</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment">#一维数组</span></span><br><span class="line">np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])  <span class="comment">#二维数组</span></span><br></pre></td></tr></table></figure>
<h3 id="np-arange"><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html#numpy.arange" target="_blank" rel="external">np.arange</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.arange(<span class="number">10</span>) <span class="comment">#使用指定range来创建数组 array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br><span class="line">np.arange(<span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>)  <span class="comment">#开始，终止(不包含)，步长  array([1, 3, 5, 7])</span></span><br></pre></td></tr></table></figure>
<h3 id="np-linspace"><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html#numpy.linspace" target="_blank" rel="external">np.linspace</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>) <span class="comment">#开始，终止，创建元素个数   array([ 0.    0.25  0.5   0.75  1.  ])</span></span><br><span class="line">np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>,endpoint=<span class="keyword">False</span>) <span class="comment">#endpoint这个参数控制最后一个终止值是否被包含，默认Ture，array([ 0.   0.2  0.4  0.6  0.8])</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>arange与linspace都是在指定范围内生成均匀的变量，只是前者是按步长进行生成，后者是按指定的数量进行生成</p>
</blockquote>
<h3 id="np-ones"><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ones.html#numpy.ones" target="_blank" rel="external">np.ones</a></h3><blockquote>
<p>快速生成值为1的矩阵</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">np.ones(<span class="number">5</span>)  <span class="comment">#array([ 1.,  1.,  1.,  1.,  1.])</span></span><br><span class="line">np.ones((<span class="number">2</span>,<span class="number">2</span>)) <span class="comment">#生成一个2x2的值为1的矩阵</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">array([[ 1.,  1.],</span><br><span class="line">       [ 1.,  1.]])</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure>
<h3 id="np-zeros"><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.zeros.html#numpy.zeros" target="_blank" rel="external">np.zeros</a></h3><blockquote>
<p>快速生成值为1的矩阵</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">np.zeros(<span class="number">5</span>) <span class="comment">#array([ 0.,  0.,  0.,  0.,  0.])</span></span><br><span class="line">np.zeros((<span class="number">2</span>,<span class="number">2</span>)) <span class="comment">#生成一个2x2的值为0的矩阵</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">array([[ 0.,  0.],</span><br><span class="line">       [ 0.,  0.]])</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure>
<h3 id="np-eye"><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.eye.html#numpy.eye" target="_blank" rel="external">np.eye</a></h3><blockquote>
<p>快速生成值为1的对角矩阵</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">np.eye(<span class="number">3</span>)</span><br><span class="line"><span class="string">"""</span><br><span class="line">[[ 1.  0.  0.]</span><br><span class="line"> [ 0.  1.  0.]</span><br><span class="line"> [ 0.  0.  1.]]</span><br><span class="line">"""</span></span><br><span class="line"></span><br><span class="line">np.eye(<span class="number">3</span>,k=<span class="number">1</span>)  <span class="comment">#这里的k可以指定对角的索引位置 默认是0，也就是真正的对角</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">[[ 0.  1.  0.]</span><br><span class="line"> [ 0.  0.  1.]</span><br><span class="line"> [ 0.  0.  0.]]</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure>
<h3 id="np-diag"><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.diag.html#numpy.diag" target="_blank" rel="external">np.diag</a></h3><blockquote>
<p>提取普通矩阵的对角</p>
<ul>
<li>若普通矩阵是1维矩阵，则直接将该1维矩阵转为对角矩阵</li>
<li>若普通矩阵是2维矩阵，则提取该对角线(k)的矩阵并返回一个1维矩阵</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">np.diag(np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]))  <span class="comment">#将4x1的矩阵转为只有对角线上有值的方正</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">[[1 0 0 0]</span><br><span class="line"> [0 2 0 0]</span><br><span class="line"> [0 0 3 0]</span><br><span class="line"> [0 0 0 4]]</span><br><span class="line">"""</span></span><br><span class="line"></span><br><span class="line">np.diag(np.ones((<span class="number">3</span>,<span class="number">3</span>))) <span class="comment">#提取对角线上的元素 转为了1维矩阵 [ 1.  1.  1.]</span></span><br><span class="line"><span class="comment">#若继续想要对角方正，则需呀再一次转换</span></span><br><span class="line">np.diag(np.diag(np.ones((<span class="number">3</span>,<span class="number">3</span>))))</span><br><span class="line"><span class="string">"""</span><br><span class="line">[[ 1.  0.  0.]</span><br><span class="line"> [ 0.  1.  0.]</span><br><span class="line"> [ 0.  0.  1.]]</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure>
<h3 id="矩阵的四则运算">矩阵的四则运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a=np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)  <span class="comment">##0~8的3x3矩阵</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">array([[0, 1, 2],</span><br><span class="line">       [3, 4, 5],</span><br><span class="line">       [6, 7, 8]])</span><br><span class="line">"""</span></span><br><span class="line"></span><br><span class="line">b=np.array(range(<span class="number">9</span>)[::-<span class="number">1</span>]).reshape(<span class="number">3</span>,<span class="number">3</span>)  <span class="comment">##8~0的3x3矩阵</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">array([[8, 7, 6],</span><br><span class="line">       [5, 4, 3],</span><br><span class="line">       [2, 1, 0]])</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure>
<p>加减乘除都可以按这个走<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a+<span class="number">1</span> <span class="comment">#在每个元素上+1</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">array([[1, 2, 3],</span><br><span class="line">       [4, 5, 6],</span><br><span class="line">       [7, 8, 9]])</span><br><span class="line">"""</span></span><br><span class="line">a+b <span class="comment">#两个矩阵相加</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">array([[8, 8, 8],</span><br><span class="line">       [8, 8, 8],</span><br><span class="line">       [8, 8, 8]])</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure></p>
<p>还可以做幂次方<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a**<span class="number">2</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">array([[ 0,  1,  4],</span><br><span class="line">       [ 9, 16, 25],</span><br><span class="line">       [36, 49, 64]])</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure></p>
<p>还可以倒着运算<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>**a</span><br><span class="line">array([[  <span class="number">1</span>,   <span class="number">2</span>,   <span class="number">4</span>],</span><br><span class="line">       [  <span class="number">8</span>,  <span class="number">16</span>,  <span class="number">32</span>],</span><br><span class="line">       [ <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>]])</span><br></pre></td></tr></table></figure></p>
<h3 id="summary">summary</h3><ol>
<li>关于取值，还是按[index]的方式即可取</li>
<li>还有很方便的函数：<ul>
<li>求和:sum</li>
<li>转置：T</li>
<li>最大最小：max,min</li>
<li>方差：var,标准差：std</li>
<li>均值：mean</li>
</ul>
</li>
</ol>
<h2 id="random">random</h2><blockquote>
<p>用于产生强大的随机数呀,并且可以指定具体的矩阵形状</p>
</blockquote>
<h3 id="np-random-rand"><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.rand.html#numpy.random.rand" target="_blank" rel="external">np.random.rand</a></h3><blockquote>
<p>产生均匀的0~1之间的随机数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">np.random.rand(<span class="number">4</span>) <span class="comment">#生成1x4的随机矩阵 array([ 0.78374518,  0.64304815,  0.01667375,  0.50154654])</span></span><br><span class="line">np.random.rand(<span class="number">2</span>,<span class="number">3</span>)  <span class="comment">#生成2x3的随机矩阵</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">array([[ 0.20500983,  0.66468726,  0.55619774],</span><br><span class="line">       [ 0.37256962,  0.86550713,  0.05781776]])</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure>
<h3 id="np-random-randn"><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randn.html#numpy.random.randn" target="_blank" rel="external">np.random.randn</a></h3><blockquote>
<p>生成服从高斯分布的随机矩阵</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">np.random.randn(<span class="number">4</span>)  <span class="comment">#生成N(0,1)分布的的1x4的矩阵 array([ 0.72481524, -0.1976192 , -0.48224937, -0.8019294 ])</span></span><br><span class="line"><span class="comment">#如果想执行方差和均值的话，可以这么干sigma * np.random.randn(...) + mu</span></span><br><span class="line"><span class="number">2.5</span> * np.random.randn(<span class="number">2</span>, <span class="number">4</span>) + <span class="number">3</span>  <span class="comment">#比如这个就是服从N~(3,6.25)的高斯分布</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">array([[ 5.2147326 ,  0.90325509,  1.39212656,  5.97713821],</span><br><span class="line">       [-0.26270206,  3.09619677,  2.21054634,  2.94103359]])</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2><ul>
<li><a href="http://docs.scipy.org/doc/numpy/genindex.html" target="_blank" rel="external">numpy api</a></li>
<li><a href="http://www.scipy-lectures.org/" target="_blank" rel="external">http://www.scipy-lectures.org/</a>  其实上面写的这里都有-_-</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><code>numpy</code>这个科学计算工具大法好，但是里面的东西不用老是会忘，所以在此记录常用的一些语法，以备之后查询之用（也叫懒人模式）^_^,不过详细的使用方法还是得看<a href="http://docs.scipy.org/doc/">scipy api</a></p>
</blockquote>
<p>使用之前首先得引入包<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure></p>
<h2 id="array">array</h2><p><code>np.array</code>实现了真正的数组，在<code>numpy</code>中其实就是矩阵啦，同时提供了丰富的矩阵计算方法<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yyl8781697.github.io/tags/Python/"/>
    
      <category term="Python" scheme="http://yyl8781697.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Scala中Iterator中size/length的一个坑]]></title>
    <link href="http://yyl8781697.github.io/2015/09/19/Scala/Scala-Iterator-Size-Length-Keng/"/>
    <id>http://yyl8781697.github.io/2015/09/19/Scala/Scala-Iterator-Size-Length-Keng/</id>
    <published>2015-09-19T02:36:42.000Z</published>
    <updated>2015-09-19T04:18:46.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><code>Scala</code>语言是出了名的语法诡异，功能强大-_-，他的<code>Iterator</code>也是如此，还提供了亲民心的<code>size/length</code>方法，但是，但是，但是慎用!!</p>
</blockquote>
<p>事情是这样的</p>
<pre><code>今天在做这个：进行采样，在mapPartitions中操作，会传来一个Iterator迭代器，里面存着原始数据，我需要做的大概是先统计迭代器中的数量<span class="keyword">N</span>（使用size方法来做），然后计算出一个需要采样的量<span class="keyword">n</span>,然后遍历(直接<span class="keyword">for</span>来做)这个迭代器，按自己的业务采样<span class="keyword">n</span>个记录！
</code></pre><p>清晰明了的一个程序,这尼玛最终采样的变量一直是空，一直是空，一直是空。<br>起初还以为是概率那块算错了，导致采不出来，但是单独把程序剥离出来<code>debuge</code>发现这个<code>for</code>压根没数据，但是明明这个迭代器的里面的<code>size</code>是有值的啊，奇了怪了。。。<br><a id="more"></a></p>
<p>后来发现问题就是处在这个<code>size</code>方法。。</p>
<p><code>Iterator</code>大致是满足如下继承关系的:<br><code>AbstractIterator-&gt;Iterator-&gt;TraversableOnce-&gt;GenTraversableOnce</code></p>
<p>在<code>TraversableOnce</code>这个<code>trait</code>中对<code>size</code>方法进行了实现，<br>现在来看源码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span>:</span> <span class="type">Int</span> = &#123;</span><br><span class="line"><span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (x &lt;- self) result += <span class="number">1</span>   <span class="comment">//额，它的计数是直接遍历得来的..</span></span><br><span class="line">result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Iterator</code>这个<code>trait</code>中对<code>length</code>方法进行了实现，<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Returns the number of elements in this iterator.</span><br><span class="line">*  $willNotTerminateInf</span><br><span class="line">*</span><br><span class="line">*  @note Reuse: $consumesIterator</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">length</span>:</span> <span class="type">Int</span> = <span class="keyword">this</span>.size</span><br></pre></td></tr></table></figure></p>
<p>可以发现<code>size/length</code>是通过遍历迭代器累加来计数的，这样就是导致使用了<code>size/length</code>之后就无法再取迭代器里面的值，然后就出现了上述<code>for</code>根本无法进入。。-_-||</p>
<p>然后就会出现这样的测试结果<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">it=List</span>(</span><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).iterator</span><br><span class="line"><span class="type">System</span>.out.println(it.size);</span><br><span class="line"><span class="type">System</span>.out.println(it.size);</span><br></pre></td></tr></table></figure></p>
<pre><code>4
0
</code></pre><p>这是因为<code>collection.iterator</code>会产生一个新的迭代器实例<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="comment">/*IterableLike*/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iterator</span>:</span> <span class="type">Iterator</span>[<span class="type">A</span>] = <span class="keyword">new</span> <span class="type">AbstractIterator</span>[<span class="type">A</span>] &#123;</span><br><span class="line"><span class="keyword">var</span> these = self</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>:</span> <span class="type">Boolean</span> = !these.isEmpty</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next</span>(</span>): <span class="type">A</span> =</span><br><span class="line">  <span class="keyword">if</span> (hasNext) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">val</span> <span class="title">result</span> =</span> these.head; these = these.tail; result</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="type">Iterator</span>.empty.next</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Have to clear `these` so the iterator is exhausted like</span><br><span class="line"> *  it would be without the optimization.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toList</span>:</span> <span class="type">List</span>[<span class="type">A</span>] = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">val</span> <span class="title">xs</span> =</span> these.toList</span><br><span class="line">  these = newBuilder.result</span><br><span class="line">  xs</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一次<code>size</code>完了之后就已经将该迭代器遍历掉了-_-</p>
<blockquote>
<p>个人感觉<code>Iterator.size</code>这个方法简直是一个坑，还不如像<code>java</code>一样不提供该方法，所以慎用慎用..</p>
</blockquote>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><code>Scala</code>语言是出了名的语法诡异，功能强大-_-，他的<code>Iterator</code>也是如此，还提供了亲民心的<code>size/length</code>方法，但是，但是，但是慎用!!</p>
</blockquote>
<p>事情是这样的</p>
<pre><code>今天在做这个：进行采样，在mapPartitions中操作，会传来一个Iterator迭代器，里面存着原始数据，我需要做的大概是先统计迭代器中的数量<span class="keyword">N</span>（使用size方法来做），然后计算出一个需要采样的量<span class="keyword">n</span>,然后遍历(直接<span class="keyword">for</span>来做)这个迭代器，按自己的业务采样<span class="keyword">n</span>个记录！
</code></pre><p>清晰明了的一个程序,这尼玛最终采样的变量一直是空，一直是空，一直是空。<br>起初还以为是概率那块算错了，导致采不出来，但是单独把程序剥离出来<code>debuge</code>发现这个<code>for</code>压根没数据，但是明明这个迭代器的里面的<code>size</code>是有值的啊，奇了怪了。。。<br>]]>
    
    </summary>
    
      <category term="Scala" scheme="http://yyl8781697.github.io/tags/Scala/"/>
    
      <category term="Scala" scheme="http://yyl8781697.github.io/categories/Scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《台大机器学习基石》Validation]]></title>
    <link href="http://yyl8781697.github.io/2015/09/07/Machine%20Learning/Validation/"/>
    <id>http://yyl8781697.github.io/2015/09/07/Machine Learning/Validation/</id>
    <published>2015-09-07T15:32:37.000Z</published>
    <updated>2015-09-10T13:21:06.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Model_Select_problem">Model Select problem</h2><p>在机器学习的世界里面有非常多的模型（基石这个课暂时只讲了<a href="http://kubicode.me/2015/08/06/Machine%20Learning/Perceptron-Learning-Algorithm/" target="_blank" rel="external">Perceptron Learning Algorithm</a>，<a href="http://kubicode.me/2015/08/19/Machine%20Learning/Linear-Regression/" target="_blank" rel="external">Linear Regression</a>,<a href="http://kubicode.me/2015/08/21/Machine%20Learning/Logistic-Regression/" target="_blank" rel="external">Logistic Regression</a>），各个模型也会有自己不同的特点，有各自长处，也有各自的短处,并且除模型之外，还有其他的附属选择，比如<a href="http://kubicode.me/2015/09/05/Machine%20Learning/Regularization/" target="_blank" rel="external">Regularization</a>的类型，或者具体参数的值，比如<a href="http://kubicode.me/2015/08/21/Machine%20Learning/Logistic-Regression/#Gradient_Descent" target="_blank" rel="external">Gradient Descent</a>里面的步长等，我们知道，现在机器学习的目的就是得到最小化的<code>E<sub>out</sub></code>（也就是测试误差啦），那么现在给你一批数据，然后会出现上述那么多的选择，如果做才能得到最小的<code>E<sub>out</sub></code>呢？<br><img src="/img/Validation/goal.png" height="200px" width="500px"><br>也就是我们要找到一个最好的模型<code>H<sub>m<sup><em></em></sup></sub></code>，使得<code>E<sub>out</sub>(g<sub>m<sup></sup></sub>)</code>最小。<br><a id="more"></a></p>
<p>看到<code>E<sub>out</sub></code>首先联想到得就是<code>E<sub>in</sub></code>，根据<a href="http://kubicode.me/2015/08/15/Machine%20Learning/VC-Dimension/#VC_Bound" target="_blank" rel="external">VC Bound</a>可以知道,样本空间存在有限的break point，并且采样的资料量N够多的时候，有一个很大的概率<code>E<sub>out</sub></code>与<code>E<sub>in</sub></code>会很相似，但是又根据VC维中的模型复杂图可以看到，到VC维很高时（模型会很复杂），此时的<code>E<sub>in</sub></code>会很小，但是<code>E<sub>out</sub></code>就会很大了，这样就会出现了<code>BAD Regularization</code></p>
<pre><code>这里好比一个<span class="number">1126</span>次的多项式的E<span class="keyword">in</span>总是能低于<span class="number">1</span>次的多项式-_-，但是其E<span class="keyword">out</span>就不一定了
</code></pre><p>所以说只使用<code>E<sub>in</sub></code>最小化来选择模型并不是很靠谱，因为不能保证得到一个最小的<code>E<sub>out</sub></code>-_-||</p>
<p>现在再来思考一下，假如我们能够得到测试数据的误差<code>E<sub>test</sub></code>,那么<code>E<sub>out</sub></code>会不会与之很相似呢？<br>关于这个问题<code>Hoeffding</code>不等式又可以出来证明了<br><img src="/img/Validation/hof.png" height="150px" width="400px"> 1-2<br>这里的<code>M</code>表示可以进行模型选择的数量，<code>N<sub>test</sub></code>表示预测样本的数量，通过上面的不等式可以看到当预测样本足够大，可选模型足够少的时候，<code>E<sub>test</sub></code>和<code>E<sub>out</sub></code>是很就近的。<br>那么问题来了：关于这个测试样本如何得到？？？这是一个比较大的问题<br>先来看<code>E<sub>in</sub></code>和<code>E<sub>test</sub></code>这两者的对比<br><img src="/img/Validation/cbee.png" height="250px" width="500px"><br>可以发现：</p>
<ul>
<li><code>E<sub>in</sub></code>表示数据比较容易获取，但是可以变相得看做在原有数据集上训练完了 又在该数据库测试了一遍</li>
<li><code>E<sub>test</sub></code>测试数据比较难获取，但是一旦得到的测试数据都市无污染的，没有被训练过（也就是没有哎呦）</li>
</ul>
<p>所以这里又想了一种比较折中的方式<br><img src="/img/Validation/sib.png" height="250px" width="450px"><br>这个折中的方式就是使用现有的训练样本来进行测试，但是这个训练样本是没有被训练过， 这里叫做评估/验证的误差<code>E<sub>val</sub></code>,这中方式的具体做法就是将训练样本分为两部分，一本分用于训练，另一个部分用于测试，通过这种方式就可以有效的选择。</p>
<h2 id="Validation_Error">Validation Error</h2><p>现在假设总资料有<code>N</code>，切出<code>K</code>份来作为验证集，这样关于这个式子就可以有<br><img src="/img/Validation/cv.png" height="250px" width="500px"><br>（ps:其中D表示所有的数据集,<code>g<sub>m</sub></code>为我们需要的目标函数）<br>这样的话：</p>
<ol>
<li><code>D<sub>val</sub></code>表示验证数据集，并且是比较容易得到的</li>
<li>在<code>K</code>合适的情况下<code>E<sub>val</sub></code>与<code>E<sub>out</sub></code>是很接近的</li>
<li><code>D<sub>val</sub></code>数据从训练数据中剥离出来，并且是没有训练过</li>
</ol>
<p>那么根据上面的式子1-2 可以有<br><img src="/img/Validation/fhof.png" height="150px" width="400px"><br>(其中式子里面带减号是为了表示当前训练的数据集并不是全集，而是除去了切出去之后剩余的训练集)</p>
<p>按照上面的思路，我们只需要求<code>E<sub>val</sub></code>的最小化即可<br>在通过比较最小化的<code>E<sub>val</sub></code>之后得到的模型其实并不是我们需要的最终的模型，因为该模型是在部分数据集上训练得到的，接下来我们还可以将该模型在全集上再次训练出一个新的模型<br><img src="/img/Validation/Eout.png" height="250px" width="400px"><br>根据<a href="http://kubicode.me/2015/09/01/Machine%20Learning/Overfitting/#The_Role_of_Noise_and_Data_Size" target="_blank" rel="external">数据集的学习曲线</a>可以了解到 全集训练出模型的<code>E<sub>out</sub></code>将会更加小</p>
<p>所以我们最终产生一个最优模型的学习流程应该是这样的<br><img src="/img/Validation/process.png" height="400px" width="400px"> </p>
<ol>
<li>将数据集<code>D</code>分为两份，训练集叫做<code>D<sub>train</sub></code>，验证集叫做<code>D<sub>val</sub></code></li>
<li>将训练集<code>D<sub>train</sub></code>输入到各个模型中<code>H<sub>m</sub></code>得到各自的<code>g<sup>-</sup><sub>m</sub></code>（也就是模型模型训练之后得到的）</li>
<li>将这些训练出来的<code>g<sup>-</sup><sub>m</sub></code>通过验证集<code>D<sub>val</sub></code>来进行一个验证误差计算<code>E<sub>m</sub></code></li>
<li>将得到<code>E<sub>m</sub></code>最小的模型<code>H<sub>m<sup>*</sup></sub></code>再次输入到全部数据集中进行一个训练</li>
<li>最终输出全集上的训练得到<code>g<sub>m<sup>*</sup></sub></code>的结果</li>
</ol>
<p>这样将上面提到的几个概念连起来之后有<br><img src="/img/Validation/tog.png" height="150px" width="500px"> </p>
<p>现在来对比一下刚刚提到几种最优模型的选择方法<br><img src="/img/Validation/compare.png" height="300px" width="300px"> 2-6<br>其中横轴表示验证数据集<code>K</code>的大小，纵轴表示<code>E<sub>out</sub></code>的大小，从图中可以看到</p>
<ul>
<li>黑色的实线表示通过<code>E<code>in</code></code>来选择的模型，因为它是在全集上进行的计算，所以总是和验证集的大小没关系，故为一条直线</li>
<li>黑色的虚线表示直接在测试集上根据其误差选择的模型，测试集都给你了。。。当然能选择较好的模型，但是这种事情一般都是不现实的。。</li>
<li>红色的线表示根据<code>E<sub>val</sub></code>进行模型的选择，但是最终给的模型仍然是在除验证集的训练集上训练得出的</li>
<li>蓝色的线表示根据<code>E<sub>val</sub></code>进行模型的选择，但是最终给的模型会重新在全集上进行一次训练</li>
<li>可以发现蓝色的线总是优于红色的线，这也说明在全集的训练能将<code>E<sub>out</sub></code>降到更低</li>
<li>可以发现蓝色的线也总是低于黑色的实线，这也说明了使用<code>E<sub>val</sub></code>比<code>E<code>in</code></code>选择模型更加靠谱</li>
<li>还可以发现红色的线会在<code>K</code>到于一定程度之后会高于黑色的实线，这是因为<code>K</code>越大，而总得样本集是一定的，也就是说明能训练的样本就变少了，那么最后训练的<code>g<sup>-</sup><sub>m</sub></code>的<code>E<sub>val</sub></code>比较大了，也就会导致<code>E<sub>out</sub></code>变大</li>
</ul>
<blockquote>
<p>上图可以总结出使用<code>E<sub>val</sub></code>来选择模型是靠谱的，并且<code>E<sub>val</sub></code>大小也是相当重要的，当然是越小越好</p>
</blockquote>
<p>其实使用求<code>E<sub>val</sub></code>最小来选择模型，我们是希望<code>E<sub>val</sub></code>较小的同时可以得到一个较为相似的<code>E<sub>out</sub>(g<sup>-</sup>)</code>，那么我们也可以认为<code>E<sub>out</sub>(g<sup>-</sup>)</code>较小，同时在得到<code>E<sub>out</sub>(g<sup>-</sup>)</code>较小的同时又希望得到相似<code>E<sub>out</sub>(g)</code>,这才是模型选择的最终目的，但是这两个相似同时成立遂不如人愿啊-_-<br><img src="/img/Validation/rv.png" height="150px" width="500px"> </p>
<ol>
<li>看右侧：当<code>K</code>比较大的时候，这样才可以让<code>E<sub>val</sub></code>越准越好，也就是会越接近<code>E<sub>out</sub>(g<sup>-</sup>)</code><blockquote>
<p>但是此时的<code>E<sub>out</sub>(g<sup>-</sup>)</code>和<code>E<sub>out</sub>(g)</code>就会有较大的偏离的，从图2-6中<code>K&gt;5</code>之后，两者的偏差就会越来越大</p>
</blockquote>
</li>
<li>看左侧：当<code>K</code>比较小的时候，这样<code>E<sub>out</sub>(g<sup>-</sup>)</code>才是基于较多的训练样本训练出得模型，才能接近<code>E<sub>out</sub>(g)</code>，当<code>K=0</code>时，<code>E<sub>out</sub>(g<sup>-</sup>)=E<sub>out</sub>(g)</code></li>
</ol>
<p>那这个<code>K</code>值的选择可纠结了，该咋选呢？根据林老师的经验建议<code>K=N/5</code>比较合适，其中<code>N</code>为样本总数。</p>
<h2 id="Cross_Validation">Cross Validation</h2><p>现在考虑极端情况，当<code>K=1</code>的时候，我们去计算一个<code>E<sub>val</sub></code><br><img src="/img/Validation/en.png" height="120px" width="300px"><br>那么这个<code>e<sub>n</sub></code>会与<code>E<sub>out</sub></code>接近呢？一般一个<code>e<sub>n</sub></code>不太可能与之接近 -_-|| 想想也是~<br>那假如我们用<code>N</code>个<code>e<sub>n</sub></code>来求平均呢？每个<code>e<sub>n</sub></code>都是用不同的样本进行的校样(假设数据集中的各个样本都把不同)<br><img src="/img/Validation/ioocv.png" height="150px" width="400px"> </p>
<blockquote>
<p>这种方式就是叫做交叉验证（Cross Validation），因为里面同一个样本，有时会作为训练样本，有时会作为测试样本。<br> 在<code>K=1</code>的时候也叫<code>leave one out validation</code></p>
</blockquote>
<p>这张图就可以演示平面上三个点,现有一个一次函数和一个常量来拟合，使用交叉验证来进行选择<br><img src="/img/Validation/show.png" height="400px" width="500px"> </p>
<p> 那现在咱们只需要能证明<code>E<sub>ioocv</sub>(H,A)≈E<sub>out</sub>(g)</code>即可。<br> <img src="/img/Validation/prove.png" height="400px" width="500px"> </p>
<blockquote>
<p>我理解的大致推导的过程是,将整个对<code>Data</code>的期望拆解之后形成<code>D<sub>train</sub></code>和<code>D<sub>val</sub></code>，根据<code>E<sub>val</sub></code>推出<code>E<sup>-</sup><sub>out</sub></code>  再根据对<code>D<sub>train</sub></code>上的期望得到<code>E<sub>out</sub>(N-1)</code>的平均，再之外围的求和的平均可以抵消，结果就成了在  <code>E<sub>out</sub>(N-1)</code>的平均了。ps：当<code>K=1</code>的时候，<code>E<sup>-</sup><sub>out</sub></code> 和<code>E<sub>out</sub>(N-1)</code>很接近,同时<code>E<sub>out</sub>(N-1)</code>又会与<code>E<sub>out</sub></code>很接近，这就证明成立了。^_^</p>
</blockquote>
<h3 id="Example">Example</h3><p>到了这里，来看一个实际的例子<br><img src="/img/Validation/handwrite.png" height="300px" width="400px"><br>现在需要做一个手写体的识别，来识别是否是1，通过不同的选择方法来进行最优模型的选择<br><img src="/img/Validation/example.png" height="300px" width="400px"><br>可以发现，随着特征的增加<code>E<sub>in</sub></code>在不断的减少（这点其实很容易理解，与VC维里面的图相似），但是会发现<code>E<sub>out</sub></code>并不是一直的降低，反而特征增加到一定量之后，<code>E<sub>out</sub></code>就上升了<br>反而来看验证的误差<code>E<sub>cv</sub></code>(cv表示cross validation)，他的曲线几乎与<code>E<sub>out</sub></code>一致，并且在两者最低点的地方也很相似，最终可以分别看到用<code>E<sub>in</sub></code>和<code>E<sub>cv</sub></code>选择出来的模型<br><img src="/img/Validation/result.png" height="300px" width="500px"><br>很明显，通过交叉验证选出来的模型更加平滑，也更加不容易过拟合。^_^</p>
<h3 id="V-Fold_Cross_Validation">V-Fold Cross Validation</h3><p>上面说的使用<code>leave one out validation</code>的交叉验证来选择模型的效果虽然好，然后难免也存在以下两个主要的问题</p>
<ol>
<li>计算问题<br> 可以看到，计算一次<code>E<sub>ioocv</sub></code>,都大概需要<code>N</code>次，并且每次训练时的数据量为<code>N-1</code>,那这样整个训练的复杂度野生生的由<code>Ω(N)</code>提升到了<code>Ω(N)<sub>2</sub></code>，复杂一些的模型在数据量大一点的情况下整个训练速度已经很难控了，这么一来简直就是灾难。-_-||</li>
<li>稳定性问题<br> ps:关于这点现在还是没想通，感觉单个点测试总体平均之后应和<code>v-fold validation</code>一样的-_-，为啥就这个会有这么大的波动。。 来个高手指导下<blockquote>
<p>所以<code>leave one out validation</code>的交叉验证在实际中并不常用</p>
</blockquote>
</li>
</ol>
<p>既然有问题存在，那么如何改善呢？<br>在<code>leave one out validation</code>中，每个验证的样本只有1个，这个也未免太极端了，现在想想假如将整个样本划分为10分，每一份都轮流做一次验证集,每一轮中其余9份作为训练集，最终将求出来的10个验证集误差<code>E<sub>val</sub></code>求平均<br><img src="/img/Validation/vf.png" height="300px" width="500px"><br>这种方式在效果上其实很类似<code>leave one out validation</code>，但是在计算量上却可以大大的减少，该方式并一定是划分10份，叫做<code>v-fold cross-validation</code>，该<code>v</code>一般取5或者10的效果就已经不错了</p>
<blockquote>
<p>虽然这么看来使用<code>E<sub>val</sub></code>已经很错了，但是其实评估一个模型的好坏还是得看<code>E<sub>out</sub></code>，目的不能忘^_^</p>
</blockquote>
<h2 id="参考">参考</h2><ul>
<li>《台湾国立大学-机器学习基石》第十五讲</li>
</ul>
<p>配图均来自《台湾国立大学-机器学习基石》</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Model_Select_problem">Model Select problem</h2><p>在机器学习的世界里面有非常多的模型（基石这个课暂时只讲了<a href="http://kubicode.me/2015/08/06/Machine%20Learning/Perceptron-Learning-Algorithm/">Perceptron Learning Algorithm</a>，<a href="http://kubicode.me/2015/08/19/Machine%20Learning/Linear-Regression/">Linear Regression</a>,<a href="http://kubicode.me/2015/08/21/Machine%20Learning/Logistic-Regression/">Logistic Regression</a>），各个模型也会有自己不同的特点，有各自长处，也有各自的短处,并且除模型之外，还有其他的附属选择，比如<a href="http://kubicode.me/2015/09/05/Machine%20Learning/Regularization/">Regularization</a>的类型，或者具体参数的值，比如<a href="http://kubicode.me/2015/08/21/Machine%20Learning/Logistic-Regression/#Gradient_Descent">Gradient Descent</a>里面的步长等，我们知道，现在机器学习的目的就是得到最小化的<code>E<sub>out</sub></code>（也就是测试误差啦），那么现在给你一批数据，然后会出现上述那么多的选择，如果做才能得到最小的<code>E<sub>out</sub></code>呢？<br><img src="/img/Validation/goal.png" height="200px" width="500px" /><br>也就是我们要找到一个最好的模型<code>H<sub>m<sup><em></sup></sub></code>，使得<code>E<sub>out</sub>(g<sub>m<sup></em></sup></sub>)</code>最小。<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《台大机器学习基石》Regularization]]></title>
    <link href="http://yyl8781697.github.io/2015/09/05/Machine%20Learning/Regularization/"/>
    <id>http://yyl8781697.github.io/2015/09/05/Machine Learning/Regularization/</id>
    <published>2015-09-05T08:36:48.000Z</published>
    <updated>2015-09-08T12:37:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Regularization">Regularization</h2><p>正则化(<code>Regularization</code>)是缓解<code>Overfitting</code>非常有效的一项手段，在了解正则化之前，先来看下正则化做了什么：<br><img src="/img/Regularization/reg_target.png" height="300px" width="500px"></p>
<p>那这种正则化过程又该如何做呢？<br>其实上面图中的右侧可以看作十次多项式拟合出来的线，而左侧是由二次多项式拟合出得线(这里不了解的<a href="http://kubicode.me/2015/09/01/Machine%20Learning/Overfitting/" target="_blank" rel="external">点击我</a>)<br><a id="more"></a><br>并且我们还知道低次多项式的假设空间是包含在高次多项式中的<br><img src="/img/Regularization/contains.png" height="150px" width="250px"><br>那么也就是说我们如果能把高次的多项式慢慢退回到合适的低次多项式中，就可以缓解<code>Overfitting</code>问题</p>
<p>这里来看一下<code>H<sub>2</sub></code>和<code>H<sub>10</sub></code>的多项式关系<br><img src="/img/Regularization/h10h2.png" height="250px" width="500px"><br>可以发现<code>H<sub>2</sub></code>的多项式仅仅是在<code>H<sub>10</sub></code>添加了红色的约束即可形成</p>
<p>那这样给我们的启发是在<code>H<sub>10</sub></code>多项式退回到<code>H<sub>2</sub></code>多项式时可以加约束来操作<br>现在可以将上述的启发套用到求<code>min(E<sub>in</sub>)</code><br><img src="/img/Regularization/h10h2p.png" height="300px" width="700px"></p>
<ol>
<li>上图左侧：求<code>H<sub>10</sub></code>的<code>min(E<sub>in</sub>)</code>可以按具体模型正常求解,这样相对来说可以得到一个更小的<code>E<sub>in</sub></code></li>
<li>上图中间：求<code>H<sub>2</sub></code>的时候可以在红色约束(后面8个权重值均为0)的基础上求<code>H<sub>10</sub></code>的<code>min(E<sub>in</sub>)</code></li>
<li>上图右侧：让约束来的更加宽松一点，只要存在8个权重的值为0，这里可以用<code>H‘<sub>2</sub></code>来表示，产生的<code>hypothesis</code>也叫做<code>sparse hypothesis</code>，因为大部分权重值都为0呀^_^</li>
</ol>
<blockquote>
<p>这里就会有：<code>H<sub>2</sub> ⊂ H‘<sub>2</sub> ⊂ H<sub>10</sub></code></p>
</blockquote>
<p>现在看似求解<code>H‘<sub>2</sub></code>的<code>min(E<sub>in</sub>)</code>即可，但是遗憾的是他是一个NP难题-_-!!<br>只能继续改进了：原来在<code>H‘<sub>2</sub></code>中对不等于0的权重进行计数设定一个阈值，这个过程可以转为将权重平方和小于一个阈值来操作，这样就有了：<br><img src="/img/Regularization/hc.png" height="300px" width="250px"><br>这样就转为了一个类似的最佳化问题，并且可以解决原来<code>H‘<sub>2</sub></code>离散约束，这个<code>hypothesis</code>叫做<code>H(c)</code>,这个<code>H(c)</code>产生的权重要么非常稀疏，要么都是比较小的。<br>这样产生的权重值叫做<code>W<sub>reg</sub></code>，它也是通过<code>H(c)</code>来完成<code>Regularization</code>的优化解决方案。</p>
<p>现在使用<code>H(c)</code>的求解<code>Linear Regression</code>，将其转为矩阵形式求解为：<br><img src="/img/Regularization/lrReg.png" height="300px" width="400px"><br>则根据约束条件我们可以知道在约束下最优的解是在半径为<code>sqrt(C)</code>的球里面找到一个权重<code>w</code>使得原始的<code>E<sub>in</sub></code>最小<br>我们现在需要做的就是在条件下求最佳化问题：<br><img src="/img/Regularization/opt.png" height="300px" width="300px"></p>
<blockquote>
<p>原始问题是沿着梯度反方向滚到谷底即可，也就是椭圆中的<code>W<sub>lin</sub></code>,现在的话该点就会被限制在球内，则我们可以知道最佳点一定是在球的边缘。</p>
</blockquote>
<p>则现在<code>w</code>可以滚动的规则为：</p>
<ol>
<li>球的切面方向量的垂直方向为<code>normal</code>，但是只能往该方向的垂直方向滚动(绿色的向量)，不然就会违背了<code>w</code>在球内的约束条件</li>
<li>要往梯度的反方向滚动(蓝色的方向)，但是为了不违反在球内的条件，所以只能在梯度反方向的分量滚动，并且该方法还必须垂直于<code>normal</code></li>
</ol>
<p>所以<code>w</code>滚动的方向是梯度反方向中能垂直球的切面方向量的垂直方向（有点绕。。简单的说，就是蓝色方向与红色垂直的方向滚动），这样即可以满足在球内的约束条件，又可以进一步的优化<code>E<sub>in</sub></code>,直达梯度的反方向与求的切面方向垂直的方向平行，就达到最优了。</p>
<p>因为最终需要那两个方向是平行的，也样通过拉格朗日乘法可以将其写到一个式子里面去<br><img src="/img/Regularization/lagrange.png" height="250px" width="300px"></p>
<p>现在假设当前的模型是<code>Linear Regression</code><br><img src="/img/Regularization/par.png" height="250px" width="300px"></p>
<p>这样只需要求<code>w<sub>reg</sub></code>即可<br><img src="/img/Regularization/wreg.png" height="100px" width="300px"></p>
<p>现在延生看待这个问题的话<br><img src="/img/Regularization/lrg.png" height="350px" width="500px"><br>其中，在原始基础上添加的<code>w<sup>T</sup>w</code>称作正则项，这里的<code>λ</code>需要取正数大于等于0</p>
<blockquote>
<p>这种方式最大的优势就是将原本的阈值<code>C</code>，现在如果知道<code>λ</code>的话就可以在一个式子里面进行直接求解了</p>
</blockquote>
<p>关于<code>λ</code>产生的影响的结果图<br><img src="/img/Regularization/lamdba.png" height="300px" width="700px"><br>可以发现</p>
<ol>
<li><code>λ</code>如果不加的会产生<code>Overfitting</code></li>
<li><code>λ</code>加一点点就可以缓解<code>Overfitting</code></li>
<li>但是<code>λ</code>加太多的话会产生<code>underfitting</code></li>
</ol>
<p>这种正则化的方式叫做<code>weight-decay</code>，会把权重值变小（因为球面上权重向量的各个值都会比较小^_^）。</p>
<h2 id="Regularization_and_VC_theory">Regularization and VC theory</h2><p>通过求带有约束的<code>E<sub>in</sub></code>可以相继得到<code>augmented Error</code>和<code>VC Bound</code><br><img src="/img/Regularization/vct.jpg" height="400px" width="500px"></p>
<blockquote>
<p>这里在最优化<code>augmented Error</code>的同时其实在间接的求<code>VC Bound</code></p>
</blockquote>
<p>再来看一下他们俩的区别：</p>
<ul>
<li><code>augmented Error</code>它的正则项<code>w<sup>T</sup>w=Ω(W)</code>是表示一个<code>hypothesis</code>的复杂程度</li>
<li><code>VC Bound</code>的<code>Ω(H)</code>是表示整个<code>hypothesis set</code>的复杂程度</li>
</ul>
<p>那么如果<code>λ/N*Ω(W)</code>与<code>Ω(H)</code>之间存在关联的话，就可以说最小化<code>E<sub>aug</sub></code>是比通过<code>E<sub>in</sub></code>来求<code>E<sub>out</sub></code>的更好的一个代理</p>
<p>再来看具体的一个模型复杂度的一个问题<br><img src="/img/Regularization/complex.png" height="200px" width="400px"></p>
<ul>
<li>原始求<code>E<sub>in</sub></code>他需要的VC复杂度为<code>d<sub>vc</sub>(H)=d+1</code>，需要在整个<code>hypothesis set</code>中找</li>
<li>在<code>E<sub>aug</sub></code>中他是被限制在了<code>H(C)</code>中，所以所需的VC复杂度为<code>d<sub>vc</sub>(H(C))=d<sub>EFF</sub>(H,min E<sub>aug</sub>)</code>,他只考虑了<code>w</code>比较小的情况</li>
</ul>
<blockquote>
<p>所以<code>E<sub>aug</sub></code>有效的VC复杂度要比原来的<code>E<sub>in</sub></code>小很多</p>
</blockquote>
<h2 id="L2_VS_L1_Regularization">L2 VS L1 Regularization</h2><p>上面提到的<code>||W||<sup>2</sup></code>的正则化称为<code>L2 Regulariation</code>,这里再来看一个 <code>L1 Regularization</code><br><img src="/img/Regularization/l1l2.png" height="400px" width="700px"><br><code>L1 Regularization</code>主要是在原始<code>E<sub>in</sub></code>上添加了权重向量的绝对值求和<code>||W||<sub>1</sub></code>,它可以产生更为稀疏的权重值，因为<code>||W||<sub>1</sub></code>在多维中可以看做菱形体，根据上面求球体最优的方法，在上面提到的最有约束中我们可以知道w滚动的方向是菱形体法向量垂直的方法（该垂直方向是梯度方向的一个放量），直到滚到菱形体角上的时候，该垂直方向将与梯度方向平行，也就是到了最优，而菱形体角上各个权重的值会是比较稀疏的，也就是说<code>L1 Regularization</code>可以将特征稀疏化（特征稀疏化可以减少存储空间，又可以加快计算速度，只是。。这个稀疏化很不方便优化）。</p>
<p>参考上图对比一下<code>L2 Regulariation</code>和<code>L1 Regulariation</code>：</p>
<ul>
<li><code>L2 Regulariation</code>：凸函数，可以求导，并且很方便优化，最后通过正则化之后得到权重值都会偏小</li>
<li><code>L1 Regulariation</code>：凸函数，但是角上无法求导，也就是说优化比较难，通过正则化之后得到的权重值比较稀疏，对于计算和存储都是很大的优势。</li>
</ul>
<blockquote>
<p>关于<code>E<sub>aug</sub></code>中正则项的<code>λ</code>参数的取值最好是按照噪声大小来定^_^</p>
</blockquote>
<h2 id="参考">参考</h2><ul>
<li>《台湾国立大学-机器学习基石》第十四讲</li>
</ul>
<p>配图均来自《台湾国立大学-机器学习基石》</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Regularization">Regularization</h2><p>正则化(<code>Regularization</code>)是缓解<code>Overfitting</code>非常有效的一项手段，在了解正则化之前，先来看下正则化做了什么：<br><img src="/img/Regularization/reg_target.png" height="300px" width="500px" /></p>
<p>那这种正则化过程又该如何做呢？<br>其实上面图中的右侧可以看作十次多项式拟合出来的线，而左侧是由二次多项式拟合出得线(这里不了解的<a href="http://kubicode.me/2015/09/01/Machine%20Learning/Overfitting/">点击我</a>)<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《台大机器学习基石》Overfitting]]></title>
    <link href="http://yyl8781697.github.io/2015/09/01/Machine%20Learning/Overfitting/"/>
    <id>http://yyl8781697.github.io/2015/09/01/Machine Learning/Overfitting/</id>
    <published>2015-09-01T15:24:58.000Z</published>
    <updated>2015-09-03T16:44:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="What_is_Overfitting">What is Overfitting</h2><p>假设现在我们使用一个二次函数随机产生几个点，并且加入非常少量的噪声，然后使用一个四次函数来进行拟合<br>将得到如下的结果<br><img src="/img/Overfitting/4fit2.png" height="240px" width="240px"><br>可以发现4次函数可以完全拟合含有噪声的2次函数产生的点，也就是拟合出来的<code>E<sub>in</sub>=0</code>，但是此时如果使用新的2次函数的点用这个4次的拟合函数来进行预测的话，可以发现<code>E<sub>out</sub></code>会很高，<br>这种低<code>E<sub>in</sub></code>高<code>E<sub>out</sub></code>就是叫做泛化能力差(<code>BAD generalization</code>)，也是往往我们在做训练预测时不希望看到的。<br><a id="more"></a></p>
<p>此时再来回顾一下VC维中经典的一张图<br><img src="/img/Overfitting/vc.png" height="240px" width="240px"><br>可以看到VC维在<code>d<sup>*</sup><sub>vc</sub></code>的时候可以有最小的<code>E<sub>out</sub></code><br>但是在<code>d<sup>*</sup><sub>vc</sub></code>的右侧，可以发现VC维在不断增大时，<code>E<sub>in</sub></code>不断减小，但是<code>E<sub>out</sub></code>会不断增大，这种就是过拟合了（<code>Overfitting</code>）</p>
<blockquote>
<p>其实在<code>d<sup>*</sup><sub>vc</sub></code>的左侧叫做欠拟合<code>underfitting</code>，这种情况一般通过增加特征或者向高维映射来进行解决，但是<code>Overfitting</code>是由于一般是VC维太大造成的，不容易解决</p>
</blockquote>
<p><code>Overfitting</code>产生的主要原因有</p>
<ol>
<li>使用了太多的VC维，也就是模型太复杂了（类似刚刚用4次方的线）</li>
<li>噪声<code>Nosie</code>太多，这些噪声都被训练函数给拟合学习了</li>
<li>数据量太少</li>
</ol>
<h2 id="The_Role_of_Noise_and_Data_Size">The Role of Noise and Data Size</h2><p>以二维平面上的函数为例，现在平面上有这么一些点：</p>
<ol>
<li>一种是以十次多项式产生的点，但是加上了一些噪声</li>
<li>另一种时以五十次多项式产生的店，但是没有噪声</li>
</ol>
<p><img src="/img/Overfitting/case1.png" height="300px" width="500px"><br>分别使用一个二次多项式(<code>H<sub>2</sub></code>)和一个十次多项式<code>H<sub>10</sub></code>用回归的方式去拟合这两个平面上的点</p>
<p>最终拟合得结果为<br><img src="/img/Overfitting/case2.png" height="350px" width="500px"><br>从两个平面上均可以惊奇的发现：</p>
<ul>
<li><code>H<sub>2</sub></code>的<code>E<sub>in</sub></code>比<code>H<sub>10</sub></code>的大，但是在<code>E<sub>out</sub></code>却比<code>H<sub>10</sub></code>小的多</li>
<li><code>H<sub>10</sub></code>的<code>E<sub>in</sub></code>可以做到很小，但是观察图<code>H<sub>10</sub></code>在图上的高低之处正好与原图相反</li>
</ul>
<blockquote>
<p>也就是说从<code>H<sub>2</sub></code>切换到<code>H<sub>10</sub></code>时，<code>E<sub>in</sub></code>变小了，但是<code>E<sub>out</sub></code>增加了，也就是此时发生了<code>Overfitting</code></p>
</blockquote>
<p>这里比较有意思的是原来是十次项产生的点用十次项的线来拟合，该<code>E<sub>out</sub></code>竟然比二次项的线要高很多-_-，这是为何呢？？</p>
<p>可以看看这两个多项式的学习曲线（这个是针对<code>Liner Regression</code>）<br><img src="/img/Overfitting/curves.png" height="300px" width="500px"><br>其中：</p>
<ol>
<li>当样本量无限多的时候，<code>E<sub>in</sub></code>会接近于<code>E<sub>out</sub></code>，否在在有限样本时，<code>E<sub>in</sub></code>总小于<code>E<sub>out</sub></code>，因为训练出来的线总是往训练样本靠拢，这样在预测样本上的时候这个靠拢的距离就会变大。</li>
<li>随着样本量的增加，<code>E<sub>in</sub></code>会慢慢增加，但是<code>E<sub>out</sub></code>会慢慢减少</li>
<li>当样本量较少的时候(也就是左边的区域)，这里随着<code>E<sub>in</sub></code>的减少，<code>E<sub>out</sub></code>会增加，也就是出现了<code>Overfitting</code>的情况，应该就是出现了<code>Overfitting</code>的情况，只是左侧的图(十次多项式)更加明显而已</li>
</ol>
<blockquote>
<p>所以啊，可以看出使用简单的模型有多重要^_^</p>
</blockquote>
<p>这里再来进一步进行一些<code>Overfitting</code>的实验<br>现在有一个多项次函数和高斯噪声产生的点<br><img src="/img/Overfitting/yf.png" height="200px" width="300px"><br>有三个参数：</p>
<ol>
<li><code>σ<sup>2</sup></code>表示高斯噪声的强度</li>
<li><code>Q<sub>f</sub></code>表示目标多项次函数的复杂度(比如50次多项式 就是<code>Q<sub>f</sub>=50</code>)</li>
<li><code>N</code>表示训练数据量的大小</li>
</ol>
<p>还是用<code>H<sub>2</sub></code>(<code>g<sub>2</sub></code>)和<code>H<sub>10</sub></code>(<code>g<sub>10</sub></code>)进行实验，根据上一个实验的经验，这里肯定成立的是<code>E<sub>in</sub>(g<sub>10</sub>)&lt;E<sub>in</sub>(g<sub>2</sub>)</code>,现在设定<code>Overfitting</code>的度量为<code>E<sub>out</sub>(g<sub>10</sub>)-E<sub>out</sub>(g<sub>2</sub>)</code>，如果这个差值越大，说明<code>Overfitting</code>得越厉害。</p>
<p>那这样直接看实验结果图</p>
<blockquote>
<p>这里横纵坐标是用上面三个参数中选的，还有平面上的颜色表示<code>Overfitting</code>的程度，也就是右侧的那个小纵条，越往上升，<code>Overfitting</code>得越厉害（度量的差值越大）。</p>
</blockquote>
<p>先来看噪声强度<code>σ<sup>2</sup></code>和样本数量<code>N</code>对<code>Overfitting</code>的影响<br><img src="/img/Overfitting/isv.png" height="250px" width="250px"><br>从图中可以看到：</p>
<ul>
<li>样本数量越少，噪声强度越大的时候，<code>Overfitting</code>得越厉害</li>
<li>样本数量越多，噪声强度越小的时候，<code>Overfitting</code>的程度很轻<blockquote>
<p>恩，这想想也是，结果挺合理的^_^</p>
</blockquote>
</li>
</ul>
<p>再来看看一张比较扭曲的图：目标多项次函数的复杂度<code>Q<sub>f</sub></code>和样本数量<code>N</code>对<code>Overfitting</code>的影响<br><img src="/img/Overfitting/iqv.png" height="250px" width="250px"><br>其实这张图大致上和上面的趋势是一直的，只不过在较少样本同时在较小的复杂度情况下也可以得到较小的<code>Overfitting</code>。</p>
<blockquote>
<p>额。。。这个原因我也不是很了解，先去问问其他大神！！</p>
</blockquote>
<p>上面两个图中的纵坐标中：</p>
<ol>
<li>高斯噪声也叫做随机噪声(<code>stochastic noise</code>)</li>
<li>目标的复杂度也叫做确定性噪声(<code>deterministic nosie</code>)<br> 这个怎么说呢，比如一个十次项的目标函数产生的点，用一个二次项来拟合，那么这些点中必定有一些是在二次项之外的，那这不就是噪声了嘛，所以这个噪声是可以计算出来的</li>
</ol>
<p>他们俩都会对<code>Overfitting</code>都会有影响，并且影响都很类似，不过差别就是<code>deterministic nosie</code>和训练的模型是有改关的。</p>
<h2 id="Solution_for_Overfitting">Solution for Overfitting</h2><p>既然了解了<code>Overfitting</code>出现的原因以及导致的后果，那咱们该如何处理呢？大致有以下几种方法</p>
<ol>
<li>使用简单的模型<br> 根据之前VC维的理论，简单的模型VC维较低，可以得到较低的<code>E<sub>int</sub></code></li>
<li>剪枝或者数据清洗<br> 其实是为了降低噪声带来的影响</li>
<li>数据的提示<br> 在原特征上再挖掘有用特征，这样可以弥补训练样本少带来的问题</li>
<li>正则项<br> 额。好东西，不过下个视频才讲-_-</li>
<li>验证<br> 应该可以理解为交叉验证把？</li>
</ol>
<h2 id="参考">参考</h2><ul>
<li>《台湾国立大学-机器学习基石》第十三讲</li>
</ul>
<p>配图均来自《台湾国立大学-机器学习基石》</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="What_is_Overfitting">What is Overfitting</h2><p>假设现在我们使用一个二次函数随机产生几个点，并且加入非常少量的噪声，然后使用一个四次函数来进行拟合<br>将得到如下的结果<br><img src="/img/Overfitting/4fit2.png" height="240px" width="240px" /><br>可以发现4次函数可以完全拟合含有噪声的2次函数产生的点，也就是拟合出来的<code>E<sub>in</sub>=0</code>，但是此时如果使用新的2次函数的点用这个4次的拟合函数来进行预测的话，可以发现<code>E<sub>out</sub></code>会很高，<br>这种低<code>E<sub>in</sub></code>高<code>E<sub>out</sub></code>就是叫做泛化能力差(<code>BAD generalization</code>)，也是往往我们在做训练预测时不希望看到的。<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《台大机器学习基石》Multiclass-Classification]]></title>
    <link href="http://yyl8781697.github.io/2015/08/30/Machine%20Learning/Multiclass-Classification/"/>
    <id>http://yyl8781697.github.io/2015/08/30/Machine Learning/Multiclass-Classification/</id>
    <published>2015-08-30T01:27:19.000Z</published>
    <updated>2015-09-01T15:30:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Multiclass-Classification">Multiclass-Classification</h2><p><a href="http://kubicode.me/2015/08/06/Machine%20Learning/Perceptron-Learning-Algorithm/" target="_blank" rel="external">Perceptron Learning Algorithm</a>,<a href="http://kubicode.me/2015/08/21/Machine%20Learning/Logistic-Regression/" target="_blank" rel="external">Logistic Regression</a>这些算法的最初出现都是基于2分类的(Binary Classification)，但是生活中会出很多多分类的问题出现（比如选择题：四选一，视觉的识别，手写体的识别之类的）</p>
<p><img src="/img/Multiclass-Classification/mc.png" height="300px" width="500px"><br><img src="/img/Multiclass-Classification/mcw.png" height="100px" width="300px"><br>那么我们如何才能使用这些二分类的模型来完成多分类的需求呢？<br><a id="more"></a></p>
<h2 id="One-Vs-All">One-Vs-All</h2><p>这里可以先采用一对多的方法来进行多分类，以上面的4个不同形状的多边形分类为例：<br>这是将方块作为一类，其余作为另一类<br><img src="/img/Multiclass-Classification/oa1.png" height="300px" width="500px"><br>也其实就是一个二分类问题了，通过这个分类器我们可以至少将方块给区分出来<br><img src="/img/Multiclass-Classification/bc.png" height="100px" width="350px"></p>
<p>这是一个菱形作为一类的方案<br><img src="/img/Multiclass-Classification/oa2.png" height="300px" width="500px"></p>
<p>同理就会有4个区分不同形状的分类器<br><img src="/img/Multiclass-Classification/oa3.png" height="300px" width="500px"></p>
<p>那么原图上四个角可以进行很容易得分类的<br><img src="/img/Multiclass-Classification/oa4.png" height="250px" width="250px"></p>
<p>那么问题来了：<br><img src="/img/Multiclass-Classification/oa5.png" height="250px" width="250px"></p>
<ul>
<li>在1，2，3，4四个区域是每个单分类器的交集处，就会出现不知道这个分类应该属于哪个类额</li>
<li>还有在5这个区域，没有一个分类器去涉及它，就会成为了4不管区域了-_-</li>
</ul>
<p>这里可以用一个软性(<code>softly</code>)的方法来解决这个问题<br><img src="/img/Multiclass-Classification/s1.png" height="250px" width="250px"><br>颜色越深的区域属于这个类的概率越大，也就是<br><img src="/img/Multiclass-Classification/sp.png" height="100px" width="350px"><br>那么之后形成的4个形状各自的分类器为<br><img src="/img/Multiclass-Classification/s24.png" height="300px" width="500px"><br>使用这种软性分类器最终的多分类判别方式是<br><img src="/img/Multiclass-Classification/ccpb.png" height="100px" width="350px"><br>也就是它会取分类概率那大的那个类别作为预测出来的分类<br>这种软性多分类的分类能力为<br><img src="/img/Multiclass-Classification/s24s.png" height="250px" width="250px"><br>可以发现图中的4中形状的类别都基本已经分开了</p>
<p>现在以<a href="http://kubicode.me/2015/08/21/Machine%20Learning/Logistic-Regression/" target="_blank" rel="external">Logistic Regression</a>为例来总结一下<code>One-Vs-All</code>的多分类过程<br><img src="/img/Multiclass-Classification/lmc.png" height="300px" width="500px"></p>
<ol>
<li>首先是遍历每个类别，被遍历的类别作为<code>positive</code>，其余的类作为<code>negitive</code>类别，使用<code>Logistic Regression</code>来训练一个分类器</li>
<li>这样遍历完了之后就可以得到<code>k</code>（表示类别的种类数）分类器（这样也可以将每个分类器对应到一个类别）</li>
<li>在预测阶段输入一个样本，计算出概率最高的分类器作为预测的类别</li>
</ol>
<p>这种分类方法：</p>
<ul>
<li>优点：效率很高，有多少个类别就训练多少个分类器就可以完成多分类，并且普适性还比较广，可以应用于能输出值或者概率的分类器</li>
<li>缺点：就是有较大的样本不平衡，比如现在有很多个类别，每个类别都是只占其中一点点的样本，那么每个单模型在训练的时候可能都是偏向于<code>negitive</code>，最终在预测的时候就是相当于在一端偏向<code>negitive</code>的模型中找<code>positive</code>的分类器</li>
</ul>
<h2 id="One-Vs-One">One-Vs-One</h2><p>相当于<code>One-Vs-All</code>的方法，这里的<code>One-Vs-One</code>是从多个类别里面随便选两个出来进行分类,<br>比如还是以上面的四种形状分类为例，先单独拿出菱形和方块这两种类别<br><img src="/img/Multiclass-Classification/oo1.png" height="300px" width="500px"><br>然后单独对这两个类别做一个二分类<br><img src="/img/Multiclass-Classification/oo12.png" height="100px" width="300px"></p>
<p>还可以做<br>方块和三角形<br><img src="/img/Multiclass-Classification/oo2.png" height="200px" width="200px"><br>方块和星星<br><img src="/img/Multiclass-Classification/oo3.png" height="200px" width="200px"><br>等等还有其他的。。它在四种类别中就会有6种不同的方法(N(4,2),用于表示4的2组合)<br><img src="/img/Multiclass-Classification/oo5.png" height="250px" width="600px"></p>
<pre><code>现在将这个问题想做是4支队伍，两两对战，然后取出一组成绩最好的作为预测类别，也就是一种投票分类
</code></pre><p>所以关于上述分类的公式是<br><img src="/img/Multiclass-Classification/eq.png" height="150px" width="600px"></p>
<p>再来撸一下<code>One-Vs-One</code>的流程:</p>
<ol>
<li>遍历<code>k</code>个类别，两两之间进行组合，那么就会有<code>C(k,2)</code>组</li>
<li>对那么多组进行一个单独进行分类训练</li>
<li>训练完了之后最终模型的预测输出使用投票的方法</li>
</ol>
<p><img src="/img/Multiclass-Classification/lc.png" height="300px" width="500px"></p>
<p>这种分类方法有</p>
<ol>
<li>优点：高效，别看它分为了<code>N(k,2)</code>个模型，但是每个训练的时候他的训练样本只有针对训练类做一下，并且还比较稳定</li>
<li>缺点：预测的时间会变久，需要更加多得训练</li>
</ol>
<h2 id="总结">总结</h2><p>假设现在有<code>k</code>个类别，现在需要使用多分类的方法去预测一个样本属于具体哪个类</p>
<ul>
<li><code>One-Vs-All</code>:其中一个类别作为一类，剩余其他类作为一类训练一个二分类模型，按次方法共训练<code>k</code>模型，一般可以认为一个模型对应一个类别，预测时候取概率最大的那个模型即可<br>  优点：训练速度快<br>  缺点：会导致样本不平衡</li>
<li><code>One-Vs-One</code>:两两类别之间取数据进行二分类模型的训练，按此方法共训练<code>N(k,2)</code>个模型,在预测的时候使用投票的方法作为最终结果<br>  优点：高效（因为每个单模型并不是训练全部数据），稳定<br>  缺点：预测时间会变很久</li>
</ul>
<h2 id="参考">参考</h2><ul>
<li>《台湾国立大学-机器学习基石》第十一讲</li>
</ul>
<p>配图均来自《台湾国立大学-机器学习基石》</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Multiclass-Classification">Multiclass-Classification</h2><p><a href="http://kubicode.me/2015/08/06/Machine%20Learning/Perceptron-Learning-Algorithm/">Perceptron Learning Algorithm</a>,<a href="http://kubicode.me/2015/08/21/Machine%20Learning/Logistic-Regression/">Logistic Regression</a>这些算法的最初出现都是基于2分类的(Binary Classification)，但是生活中会出很多多分类的问题出现（比如选择题：四选一，视觉的识别，手写体的识别之类的）</p>
<p><img src="/img/Multiclass-Classification/mc.png" height="300px" width="500px" /><br><img src="/img/Multiclass-Classification/mcw.png" height="100px" width="300px" /><br>那么我们如何才能使用这些二分类的模型来完成多分类的需求呢？<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《台大机器学习基石》Logistic Regression]]></title>
    <link href="http://yyl8781697.github.io/2015/08/21/Machine%20Learning/Logistic-Regression/"/>
    <id>http://yyl8781697.github.io/2015/08/21/Machine Learning/Logistic-Regression/</id>
    <published>2015-08-21T13:07:01.000Z</published>
    <updated>2015-11-25T02:11:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Logistic_Regression">Logistic Regression</h2><p>前两篇文章中的模型<a href="http://kubicode.me/2015/08/06/Machine%20Learning/Perceptron-Learning-Algorithm/" target="_blank" rel="external">Perceptron Learning Algorithm</a>和<a href="http://kubicode.me/2015/08/19/Machine%20Learning/Linear-Regression/" target="_blank" rel="external">Linear Regression</a>可以解决的问题是判断一个患者是否会心脏病，但是实际生活中里面里面可能给出的报告的是患者患心脏病的一个概率：<br><img src="/img/Logistic-Regression/har.png" height="240px" width="240px"><br>这样的话从模型的角度来说更希望的是得到一个发生在患心脏病的概率<code>f(x)=P(+1|x)∈[0,1]</code>,<br>这个概率值越大，患心脏病的概率越大，反之则越小<br><a id="more"></a></p>
<blockquote>
<p>这个也叫<code>Soft Binary Classification</code>，因为这里的概率可以根据一个阈值来判断是否属于哪一类</p>
</blockquote>
<p>刚刚可以看到目标函数<code>f(x)</code>的值是属于一个[0,1]范围的值，理所应当，我们理想的训练数据应该是这样的<br><img src="/img/Logistic-Regression/ind1.png" height="300px" width="300px"><br>想法虽好，然是实际上训练目标的概率值很难得到（比如一个患者你过了两三个月之后也许可以观察到该用户是否会患上心脏病，但是你可能是无法知道他患心脏病的真实概率的）<br>所以我们拿到的真实数据是这样的<br><img src="/img/Logistic-Regression/ind2.png" height="300px" width="300px"><br>这样也可以你可以看成为上上概率训练数据一个有噪声的版本，每个标签值对应的0或者1都是直接在概率阈值上进行了一个分类了</p>
<p>那么现在的目标就是在原来（二分类）的数据上，以[0,1]范围为目标找到一个好的假设(<code>hypothesis</code>)</p>
<p>那么首先可以想到的是按<code>Linear Regression</code>一样在特征值和权重向量上进行一个加权<br><img src="/img/Logistic-Regression/fw.png" height="400px" width="300px"><br>得到加权之后的<code>score</code>之后，我们希望<code>score</code>越高，最终得到的概率值越大（但是不能大于1），<code>score</code>越低，最终的概率值越小（不能小于0），那正好可以通过下面的函数的转换来完成刚刚的需求<br><img src="/img/Logistic-Regression/lf.png" height="300px" width="400px"><br>这个函数也叫做<code>logistic function</code><br><img src="/img/Logistic-Regression/logit.png" height="100px" width="400px"><br>其中里面的<code>s</code>就是相当于<code>score</code></p>
<p>最终我们可以得到的模型函数为<br><img src="/img/Logistic-Regression/lh.png" height="300px" width="400px"><br>这也就是<code>Logistic Regression</code>的表示</p>
<h2 id="Cross-Entropy_Error">Cross-Entropy Error</h2><p>根据<code>Logistic Regression</code>的目标函数<code>f(x)</code>可以很容易得到如下关系<br><img src="/img/Logistic-Regression/fx.png" height="100px" width="500px"></p>
<p>假如现在有如下的数据<br><img src="/img/Logistic-Regression/cd.png" height="100px" width="500px"><br>那么这批数据产生的概率是<br><img src="/img/Logistic-Regression/d1.png" height="300px" width="300px"><br>使用<code>f(x)</code>替换可以得到<br><img src="/img/Logistic-Regression/d2.png" height="300px" width="300px"></p>
<p>现在以<code>hypothesis</code>的角度来看，通过<code>h(x)</code>产生的样本情况为<br><img src="/img/Logistic-Regression/h1.png" height="300px" width="300px"></p>
<p>如果<code>h(x)≈f(x)</code>,那么我们就可以说通过<code>h(x)</code>产生的样本的可能性与真正<code>f(x)</code>产生的数据很接近<br>那么我们现在找<br><img src="/img/Logistic-Regression/lhp.png" height="200px" width="500px"><br>这个是建立在<code>f(x)</code>产生的数据的可能性很大的基础上，所以现在也相应的就是求<code>h(x)</code>产生的样本的可能性也要很大。<br>用式子表达出来就是这个<br><img src="/img/Logistic-Regression/hn.png" height="100px" width="500px"><br>又因为<code>logistic function</code>的写对称性（<code>1-h(x)=h(-x)</code>），上面的式子可以转为<br><img src="/img/Logistic-Regression/hn2.png" height="100px" width="500px"><br>上面带负号的正好可以看做负样本(<code>y<sub>n</sub>=-1</code>)，带正好的也正好可以看做正样本(<code>y<sub>n</sub>=+1</code>)，同时对于每个<code>hypothesis</code>来说上图中灰色部分(产生各个数据的概率,不含目标)都是一样的，所以现在可以将上述式子简写为<br><img src="/img/Logistic-Regression/like.png" height="100px" width="500px"></p>
<blockquote>
<p>它是一个正比函数，<code>y<sub>n</sub></code>正好可以替换为原来的正负1</p>
</blockquote>
<p>现在要做的就是找到合适的<code>h(x)</code>，使的上述的可能性最高<br>把<code>h</code>用气w来替换为<br><img src="/img/Logistic-Regression/hwt.png" height="100px" width="500px"><br>为了求其最优化，我们将上述式子的连乘转为连加，通过添加一个<code>ln</code>函数(单调递增)，同时使用添加负号来由求最大化转为最小化(方便求)<br> <img src="/img/Logistic-Regression/cee.png" height="150px" width="500px">（式子2）<br>这里继续使用<code>logistic function</code>函数进行替换，可以有<br> <img src="/img/Logistic-Regression/ecc2.png" height="250px" width="500px"><br>(替换技巧ln a/b=ln a- ln b和ln 1=0)<br>紫色背景的表示对x<sub>n</sub>，y<sub>n</sub>的Error，通过累加再求平均就是很熟悉的<code>E<sub>in</sub></code>了,这个Error就叫做<code>Cross-Entropy Error</code></p>
<h2 id="Gradient_Descent">Gradient Descent</h2><p>求式子2中的最小值最直观的就是对其求梯度并且其梯度在0的地方就是最小(也是最优)</p>
<blockquote>
<p>这里能用上述的方法来求是因为<code>Logistic Regression</code>的<code>E<sub>in</sub></code>是可导可微的，并且是凸的</p>
</blockquote>
<p>现在将其对<code>w</code>求偏导<br> <img src="/img/Logistic-Regression/pwf.png" height="400px" width="500px"><br>上面求的是梯度里面的一个<code>Component</code>，那么对所有的<code>Component</code>都整理起来可以得到<br><img src="/img/Logistic-Regression/zpwf.png" height="100px" width="500px"><br>目标就变成了求上述梯度为0的情况<br><img src="/img/Logistic-Regression/tdt.png" height="250px" width="250px"><br>但是可以看到上述的梯度并不是一个一次的方程式，也就是无法直接求出具体的值(不能像<code>Linear Regression</code>中那样直接求出)</p>
<p>不过现在根据需要求解的问题看成现在这样<br><img src="/img/Logistic-Regression/gdt.png" height="250px" width="250px"><br>梯度的函数可以看成图种的曲线，而相应的参数<code>w</code>可以看成图种的那个球，每次都朝着错误的方向<code>v</code>滚，将球从上面滚到最低处，也就是得到梯度为0的情况<br><img src="/img/Logistic-Regression/aga.png" height="200px" width="400px"><br>其中<code>v</code>为球滚动的方向（后面可以知道是梯度的反方向），还有<code>η</code>表示步伐的长度(为正数，越大会滚的越快)<br>现在的问题就是转为了如果很快滚下去，并且是走对方向（真实中并不是一个二维空间，往往是一个多维空间）</p>
<p>在曲线上很小很小的一个区间内可以看作是一个线段，那这样就可以在曲线上的一个点出来，然后走出一小段的线段来，那这样可以通过多维度的泰勒展开可以得到<br><img src="/img/Logistic-Regression/aag.png" height="200px" width="500px"></p>
<blockquote>
<p>这里的<code>η</code>很小的时候，这个线段的逼近 还是很不错的</p>
</blockquote>
<p>上面公式中的灰色标志是表示与<code>v</code>没什么关系，在求解最小化的过程中有颜色部分两个向量内积的最小，那这样的话两个向量完全反方向就是最小的，也就是说<code>v</code>走的是梯度反方向，并且需要注意的是他是单位向量，所以这里就会有<br><img src="/img/Logistic-Regression/odo.png" height="200px" width="500px"><br>那么参数更新的方式就会有<br><img src="/img/Logistic-Regression/paraUpdate.png" height="200px" width="500px"></p>
<pre><code>这个就是梯度下降法<span class="comment">(Gradient Descent)</span>，也是一种较为简单的，有效的优化方法
</code></pre><p>好，到了这里<code>v</code>可以求了，那么<code>η</code>这个需要给定的参数取多少合适呢？<br><img src="/img/Logistic-Regression/eta.png" height="300px" width="400px"><br>从上图中可以发现：</p>
<ol>
<li><code>η</code>很小：那么整个参数更新过程就会很慢，不过准确性（与最小值的接近程度）应该还是可以保证的</li>
<li><code>η</code>很大，那么这个参数过程就会很不稳定，那么他的最终的准确性可能就会较低</li>
</ol>
<p>比较推荐的是采用一种自适应的方法来做<br><img src="/img/Logistic-Regression/jr.png" height="300px" width="200px"><br>当梯度较大的时候，<code>η</code>也跨的较大，那么当梯度慢慢减小的时候，<code>η</code>也同时慢慢减少，也就是说<code>η</code>与梯度值会呈正相关的关系，那么这样在保证了准确性的同时，又可以加快速度^_^<br>此时根据<code>η</code>正比于梯度值的特性可以惊奇的发现<br><img src="/img/Logistic-Regression/xjr.png" height="250px" width="500px"><br>（图种<span style="color:red">红色</span>的<code>η</code>为原生值，<span style="color:purple">紫色</span>的<code>η</code>为正比的比率）<br>在整个参数的更新过程中可以将梯度值的计算消除掉，这里的<span style="color:purple">紫色</span>的<code>η</code>也称为学习速率</p>
<p>现在<code>Logistic Regression</code>使用<code>Gradient Descent</code>来计算的过程为<br><img src="/img/Logistic-Regression/lrgd.png" height="400px" width="500px"></p>
<ol>
<li>首先将<code>w</code>初始化为0向量</li>
<li>不断迭代的遍历样本</li>
<li>每遍历一次样本时都计算当前样本的梯度(可以发现每个样本的梯度都需要遍历整个样本之后才能计算得到-_-)</li>
<li>计算完梯度之后往梯度的反方向更新权值<code>w</code></li>
<li>不断进行2~4的步骤，直到<code>E<sub>in</sub></code>足够小或者迭代次数足够多</li>
<li>返回最后一个更新的<code>w</code>就作为我们的最优<code>hypothesis</code></li>
</ol>
<blockquote>
<p>推导了这么久，但是最终发现整个计算过程还是比较简单清晰地，而且还有点像<code>PLA</code>的<code>Pocket Algorithm</code></p>
</blockquote>
<h2 id="Stochastic_Gradient_Descent">Stochastic Gradient Descent</h2><p>现在这里再重新理解一下<code>Gradient Descent</code>算法：每次迭代在计算其中一个样本的梯度的时候，都需要遍历所有的样本对梯度的贡献进行求和，然后取平均值作为最后的梯度，是不是感觉代价偏大(<strong>牵一发而动全身的感觉</strong>-_-，特别是在现在大数据的情况下，这效率应该会很慢)<br>现在我们是希望求得这个梯度的方向，但是不希望通过遍历所有样本求和求平均来得到梯度，有一个巧妙的方法就是将这个过程看过一个随机过程的平均，随便去抽一个样本然后将其作为梯度<br><img src="/img/Logistic-Regression/tor.png" height="200px" width="400px"><br>这种方式我们将随机的一个样本偏微分算出来的梯度称为随机梯度(Stochastic Gradient)，最终真实地梯度与这种随机方式求出来的梯度的期望是一致的<br><img src="/img/Logistic-Regression/tg.png" height="200px" width="400px"></p>
<pre><code>上面的过程就好比：现在有<span class="number">10000</span>个数字，需要求这些数字的平均数，最普通的方法就是<span class="number">10000</span>求和再求平均，但是遍历<span class="number">10000</span>次的复杂度认为太大，另一种解决方法就随机抽一小批数据<span class="comment">(比如100)</span>再求和求平均，其实这两个期望是很类似的，现在另一种trick的方法是直接只抽一个数字，把它认为就是这<span class="number">10000</span>个数字的平均数，现在再想想抽数字抽好多次最后结果喝第一次求和的期望也是类似的
</code></pre><blockquote>
<p>这个方式可以认为：随机得梯度=真实梯度+一些噪声</p>
</blockquote>
<p>这样的话在更新参数这一块的代价较大的梯度计算即可直接替换为轻量级的随机梯度，在足够多次的迭代之后，这个真实梯度的平均也会约等于随机梯度的平均<br>那么最终<code>Stochastic Gradient Descent(SGD)</code>算法的表示为<br><img src="/img/Logistic-Regression/sgd.png" height="200px" width="400px"><br>在整个算法计算过程中除了随机梯度计算的区别，还有其终止条件就是足够多的迭代，但是取的是<code>E<sub>in</sub></code>最小的那组作为最优</p>
<blockquote>
<p>貌似林老师爆出来关于<code>η</code>参数的取值最优是0.1126 经验参数值哦^_^</p>
</blockquote>
<p><code>SGD</code>优势有:</p>
<ol>
<li>轻量级计算</li>
<li>适合于大数据（因为复杂度低，计算梯度是O(1)）</li>
<li>还可以进行<code>online learning</code></li>
<li>。。。其实我想说比较容易实现并行</li>
</ol>
<p>劣势：就是可能不稳定</p>
<h2 id="总结">总结</h2><p><code>Logistic Regression(LR)</code>是一个线性的二分类模型，主要有以下优缺点<br>优点：</p>
<ol>
<li>实现简单；</li>
<li>分类时计算量非常小，速度很快，存储资源低，也很容易并行；(在大量数据情况下这个模型非常适用，这也是好多广告系统首选的原因)</li>
<li>在处理分类问题的同时还可能给出一个概率值(这个值有时候蛮有用的)</li>
<li>优化方法多：除了GD和SGD，应该还有拟牛顿法、BFGS、L-BFGS</li>
</ol>
<p>缺点：</p>
<ol>
<li>容易欠拟合，一般准确度不太高</li>
<li>只能处理两分类问题（在此基础上衍生出来的softmax可以用于多分类），且必须线性可分；</li>
</ol>
<h2 id="参考">参考</h2><ul>
<li>《台湾国立大学-机器学习基石》第十讲</li>
<li>《台湾国立大学-机器学习基石》第十一讲</li>
</ul>
<p>配图均来自《台湾国立大学-机器学习基石》</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Logistic_Regression">Logistic Regression</h2><p>前两篇文章中的模型<a href="http://kubicode.me/2015/08/06/Machine%20Learning/Perceptron-Learning-Algorithm/">Perceptron Learning Algorithm</a>和<a href="http://kubicode.me/2015/08/19/Machine%20Learning/Linear-Regression/">Linear Regression</a>可以解决的问题是判断一个患者是否会心脏病，但是实际生活中里面里面可能给出的报告的是患者患心脏病的一个概率：<br><img src="/img/Logistic-Regression/har.png" height="240px" width="240px" /><br>这样的话从模型的角度来说更希望的是得到一个发生在患心脏病的概率<code>f(x)=P(+1|x)∈[0,1]</code>,<br>这个概率值越大，患心脏病的概率越大，反之则越小<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《台大机器学习基石》Linear Regression]]></title>
    <link href="http://yyl8781697.github.io/2015/08/19/Machine%20Learning/Linear-Regression/"/>
    <id>http://yyl8781697.github.io/2015/08/19/Machine Learning/Linear-Regression/</id>
    <published>2015-08-19T15:15:46.000Z</published>
    <updated>2015-08-23T15:31:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Linear_Regression">Linear Regression</h2><p>现在相对比于之前的<a href="http://kubicode.me/2015/08/06/Machine%20Learning/Perceptron-Learning-Algorithm/" target="_blank" rel="external">Perceptron Learning Algorithm</a>算法，假如我们现在时的问题不是解决是否发行用卡，而是该发<strong>多少额度</strong>的问题<br><img src="/img/Linear-Regression/ed.png" width="300px" height="300px"><br>也就是输出空间属于一个实数，那么就需要一个回归算法来解决该问题！<br><a id="more"></a></p>
<p>那么我们其实可以直接使用特征属性与权重的加权求和来表示需要发的信用额度即可(与<code>PLA</code>类似，但是没有激活函数：二值判断逆函数)<br><img src="/img/Linear-Regression/jq.png" width="500px" height="300px"><br>上图中表示的就是为线性回归(<code>Linear Regression</code>)，其中<code>w<sup>T</sup>x</code>就是表示为全部的假设空间(<code>hypothesis set</code>)</p>
<p>如果当前的特征是一维的，那么这里的<code>hypothesis set</code>就表示一条线，（因为总体的特征向量里面还有一个常数值）<br><img src="/img/Linear-Regression/2d.png" width="300px" height="300px"><br>如果当前的特征是二维的，那么这里的<code>hypothesis set</code>就一个平面<br><img src="/img/Linear-Regression/3d.png" width="300px" height="300px"><br>当然特征更加多得话，最终<code>hypothesis set</code>表示一个超平面<br>其中图上红色的部分叫做误差（视频里面叫做<strong>余数</strong>），那么回归分析的目标就是将所有的误差降到最小越好<br>这里使用平方误差来衡量整体的误差<br><img src="/img/Linear-Regression/se.png" width="300px" height="100px"><br>那么从机器学习的角度来说，这里的误差就可以看做(下面这个表达式就很熟悉了)<br><img src="/img/Linear-Regression/jse.png" width="300px" height="100px"><br>相应的<br><img src="/img/Linear-Regression/jse2.png" width="300px" height="100px"><br>表示这个分类器在未来未训练数据集中产生的误差是多少<br>那么现在的线性回归的问题就是转为将<code>E<sub>in</sub>(w)</code>优化到最小。</p>
<h2 id="Ein(w)最小化">Ein(w)最小化</h2><p>现将上面小节的中的<code>E<sub>in</sub></code>转为矩阵的运算<br><img src="/img/Linear-Regression/mt.png" width="500px" height="400px"></p>
<ol>
<li>向量内积可交换，将<code>w<sup>T</sup>x</code>转为<code>x<sup>T</sup>w</code></li>
<li>将连加转为向量形式的长度（应该是二范数）</li>
<li>将<code>w</code>单独提出来（相当于隔离出了一个特征属性向量的矩阵）</li>
<li>最终使用缩写来进行整理</li>
</ol>
<p>到了这一步我们可以发现<code>E<sub>in</sub>(w)</code>只与<code>w</code>有关，那么他们的关系图是<br><img src="/img/Linear-Regression/wq.png" width="300px" height="300px"><br>可以发现<code>E<sub>in</sub>(w)</code>是连续可导，还有它是凸的<br>那么用<code>E<sub>in</sub>(w)</code>对<code>w</code>求偏导即可求导最优值(梯度为0的位置)<br><img src="/img/Linear-Regression/td.png" width="400px" height="300px"><br>这样现在问题又转为了 求<img src="/img/Linear-Regression/task.png" width="300px" height="100px"></p>
<p>首先将<img src="/img/Linear-Regression/ei.png" width="400px" height="100px"><br>现在对其求偏导<br><img src="/img/Linear-Regression/pd.png" width="300px" height="100px"><br>完了之后再将<code>A,b</code>替换回去<img src="/img/Linear-Regression/qw.png" width="300px" height="100px"></p>
<p>进一步将问题转换为<img src="/img/Linear-Regression/task2.png" width="400px" height="100px"><br>式子中<code>X<sup>T</sup>X</code>和<code>X<sup>T</sup>y</code>都是已知的，唯一不知道的就是<code>w</code>，这样就变为了一个一次的方程式</p>
<ol>
<li>假如有<code>(X<sup>T</sup>X)<sup>-1</sup></code>反矩阵的存在，那么就可以直接得到解了,并且是唯一的<br> <img src="/img/Linear-Regression/s1.png" width="250px" height="250px"></li>
<li>但是如果<code>(X<sup>T</sup>X)<sup>-1</sup></code>反矩阵不存在，那么得到的解可能就不唯一了<br> <img src="/img/Linear-Regression/s2.png" width="250px" height="250px"></li>
</ol>
<p>所以这里的核心就是计算虚假的反矩阵(<code>pseudo-inverse</code>),听林老师说这个的计算很多工具都是由现成的^_^</p>
<blockquote>
<p>刚刚求<code>E<sub>in</sub>(w)</code>最小化的过程中看似直接用公式代替可到，但是其中的<code>pseudo-inverse</code>计算起来麻烦，最终在计算的时候还是需要迭代，然后会触发<code>E<sub>in</sub>(w)</code>和<code>E<sub>out</sub>(w)</code>的变化，是一个深度隐含的学习过程(这种是叫做<code>Analytic Solution</code>)。</p>
</blockquote>
<h2 id="Learning_happened">Learning happened</h2><p>那么该如果保证<code>E<sub>out</sub></code>可以是小的呢？<br>我们先来看一下<code>E<sub>in</sub></code>的平均<br><img src="/img/Linear-Regression/eip.png" width="500px" height="100px"><br>其中<code>nosie level</code>表示样本中噪声的一个情况，<code>d+1</code>表示模型的自由度，<code>N</code>表示样本的容量<br>其中单独表示<code>E<sub>in</sub>(w)</code>的话为<br><img src="/img/Linear-Regression/eipt.png" width="500px" height="200px"><br>这样就形成了两项<code>1-XX<sup>+</sup></code>和<code>y</code>，也就是相当于将输入喝输出进行了一个分离,其中<code>XX<sup>+</sup></code>叫做<code>hat matrix</code><br>关于这个<code>hat matrix</code>,它的意义是这样纸的<br><img src="/img/Linear-Regression/hm.png" width="500px" height="400px"></p>
<ol>
<li>红色区块表示向量<code>X</code>的一个扩散，而<code>y^</code>就是落在这个空间上</li>
<li>目标就是求<code>y-y^</code>的最小化，也就是图种的绿色那条线（<code>y^</code>）向下投影的线</li>
<li><code>H</code>就是表示这个空间上<code>y</code>到<code>y^</code>的一个投影</li>
<li><code>I-H</code>就是表示误差部分<code>y-y^</code></li>
</ol>
<p>相应的会有<code>trace(I-H)=N-(d+1)</code></p>
<p>好，现在再来看<code>E<sub>in</sub></code>的平均到底是什么意思<br><img src="/img/Linear-Regression/eips.png" width="500px" height="400px"></p>
<ol>
<li>其中如果<code>f(x)</code>为目标函数，那么目标值<code>y</code>就相当于在<code>f(x)</code>上添加噪声</li>
<li>然后这个噪声通过<code>I-H</code>就可以转为<code>y-y^</code></li>
</ol>
<p>现在对噪声作评价的话，那么就可以得到<img src="/img/Linear-Regression/eint2.png" width="500px" height="60px"><br>此时<img src="/img/Linear-Regression/eint3.png" width="500px" height="60px"><br>这两个式子哲学上的意思是<code>E<sub>in</sub></code>的平均是可以看到的，所以当存在噪声的时候看到的线会偏向于噪声方向，而在<code>E<sub>out</sub></code>的平均是未知的，比最好的那个线还要向右边偏一点（没听懂-_-）</p>
<p>他们俩会形成如下的关系线<br><img src="/img/Linear-Regression/einout.png" width="300px" height="300px"><br>它描述的是当前的样本量与平均的<code>E<sub>in</sub></code>和<code>E<sub>out</sub></code>的关系,随着样本量<code>N</code>的增长，最终会趋向于<code>nosie level</code></p>
<p>那么就可以得到<br><img src="/img/Linear-Regression/vvv.png" width="300px" height="200px"><br>说明<code>N</code>足够大，然后他的<code>noise level</code>够小时，说明了<code>Learning happened</code></p>
<h2 id="总结">总结</h2><ol>
<li>线性回归最终求出的是一个加权求和的值.</li>
</ol>
<ul>
<li>线性回归的<code>E<sub>in</sub></code>的采用的是最小平方误差.</li>
<li>在计算<code>E<sub>in</sub></code>的最小化时，可以将问题转为矩阵之后就逆矩阵相关即可.</li>
<li>通过<code>E<sub>in</sub></code>平均的计算,说明了<code>Learning happened</code>.</li>
<li>其实线性回归去坐分类问题也是可以的^_^，第9课第4个小视频.</li>
</ul>
<h2 id="参考">参考</h2><ul>
<li>《台湾国立大学-机器学习基石》第九讲</li>
</ul>
<p>配图均来自《台湾国立大学-机器学习基石》</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Linear_Regression">Linear Regression</h2><p>现在相对比于之前的<a href="http://kubicode.me/2015/08/06/Machine%20Learning/Perceptron-Learning-Algorithm/">Perceptron Learning Algorithm</a>算法，假如我们现在时的问题不是解决是否发行用卡，而是该发<strong>多少额度</strong>的问题<br><img src="/img/Linear-Regression/ed.png" width="300px" height="300px" /><br>也就是输出空间属于一个实数，那么就需要一个回归算法来解决该问题！<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习常见算法个人总结（面试用）]]></title>
    <link href="http://yyl8781697.github.io/2015/08/16/Machine%20Learning/Algorithm-Summary-for-Interview/"/>
    <id>http://yyl8781697.github.io/2015/08/16/Machine Learning/Algorithm-Summary-for-Interview/</id>
    <published>2015-08-15T23:40:29.000Z</published>
    <updated>2015-08-23T10:58:45.000Z</updated>
    <content type="html"><![CDATA[<pre><code>这个总结最初是写在本地的<span class="variable">MacDown</span>中的，他的markdown语法解析与hexo的略微有点差异，懒得改了-<span class="variable">_</span>-，忍着点看..
</code></pre><h2 id="朴素贝叶斯">朴素贝叶斯</h2><p>P(A∩B)=P(A)*P(B|A)=P(B)*P(A|B)<br>所以有：P(A|B)=P(B|A)*P(A)/P(B)</p>
<p>对于给出的待分类项，求解在此项出现的条件下各个目标类别出现的概率，哪个最大，就认为此待分类项属于哪个类别</p>
<h3 id="工作原理">工作原理</h3><ol>
<li>假设现在有样本x=(a1,a2,a3,…an)这个待分类项(并认为x里面的特征独立)</li>
<li>再假设现在有分类目标Y={y1,y2,y3,y4..yn}</li>
<li>那么max(P(y1|x),P(y2|x),P(y3|x)..P(yn|x))中的最大者就是最终的分类类别</li>
<li>而P(yi|x)=p(x|yi)*P(yi)/P(x)</li>
<li>因为x对于每个分类目标来说都一样，所以就是求max(P(x|yi)*p(yi))</li>
<li>P(x|yi)*p(yi)=p(yi)*PI(P(ai|yi))  (PI表示连乘)</li>
<li>而具体的p(ai|yi)和p(yi)都是能从训练样本中统计出来<br> p(ai|yi)表示该类别下该特征出现的概率<br> p(yi)表示全部类别中这个这个类别出现的概率</li>
<li>好的，就是这么工作的^_^</li>
</ol>
<a id="more"></a>
<h3 id="工作流程">工作流程</h3><ol>
<li>准备阶段<br> 确定特征属性，并对每个特征属性进行适当划分，然后由人工对一部分待分类项进行分类，形成训练样本。</li>
<li>训练阶段<br> 计算每个类别在训练样本中的出现频率及每个特征属性划分对每个类别的条件概率估计</li>
<li>应用阶段<br> 使用分类器进行分类，输入是分类器和待分类样本，输出是样本属于的分类类别</li>
</ol>
<h3 id="属性特征">属性特征</h3><ol>
<li>特征为离散值时直接统计即可（表示统计概率）</li>
<li>特征为连续值的时候假定特征符合高斯分布:g(x,n,u)<br> 那么p(ak|yi)=g(xk,ni,ui)</li>
</ol>
<h3 id="Laplace校准(拉普拉斯校验)">Laplace校准(拉普拉斯校验)</h3><p>当某个类别下某个特征划分没有出现时，会有P(a|y)=0，就是导致分类器质量降低，所以此时引入Laplace校验，就是对没类别下所有划分的计数加1。</p>
<h3 id="遇到特征之间不独立问题">遇到特征之间不独立问题</h3><p>参考改进的贝叶斯网络，使用DAG来进行概率图的描述</p>
<h3 id="优缺点">优缺点</h3><p>朴素贝叶斯的优点：</p>
<ol>
<li>对小规模的数据表现很好，适合多分类任务，适合增量式训练。<br>缺点：</li>
<li>对输入数据的表达形式很敏感（离散、连续，值极大极小之类的）。</li>
</ol>
<p><a href="http://www.cnblogs.com/leoo2sk/archive/2010/09/17/naive-bayesian-classifier.html" target="_blank" rel="external">http://www.cnblogs.com/leoo2sk/archive/2010/09/17/naive-bayesian-classifier.html</a></p>
<h2 id="逻辑回归和线性回归">逻辑回归和线性回归</h2><pre><code>LR回归是一个线性的二分类模型，主要是计算在某个样本特征下事件发生的概率，比如根据用户的浏览购买情况作为特征来计算它是否会购买这个商品，抑或是它是否会点击这个商品。然后LR的最终值是根据一个线性和函数再通过一个sigmod函数来求得，这个线性和函数权重与特征值的累加以及加上偏置求出来的，所以在训练LR时也就是在训练线性和函数的各个权重值w。
关于这个权重值w一般使用最大似然法来估计，比如yi=<span class="number">1</span>的概率是pi,则yi=<span class="number">0</span>的概率是<span class="number">1</span>-pi，那么观测概率为<span class="function"><span class="title">p</span><span class="params">(yi)</span></span>=pi^yi*(<span class="number">1</span>-pi)^(<span class="number">1</span>-yi)这个这个最大似然函数为（<span class="function"><span class="title">hw</span><span class="params">(xi)</span></span>^yi*(<span class="number">1</span>-<span class="function"><span class="title">hw</span><span class="params">(xi)</span></span>)^(<span class="number">1</span>-yi)）连乘，对这个似然函数取对数之后就会得到的表达式<span class="function"><span class="title">L</span><span class="params">(w)</span></span>=<span class="function"><span class="title">sigma</span><span class="params">(yi*log(hw(xi)</span></span>)-(<span class="number">1</span>-yi)<span class="function"><span class="title">log</span><span class="params">(<span class="number">1</span>-hw(xi)</span></span>))=<span class="function"><span class="title">sigma</span><span class="params">(yi*(w*xi)</span></span>-<span class="function"><span class="title">log</span><span class="params">(<span class="number">1</span>+exp(w*xi)</span></span>))，估计这个<span class="function"><span class="title">L</span><span class="params">(w)</span></span>的极大值就可以得到w的估计值。
所以求解问题就变成了这个最大似然函数的最优化问题，这里通常会采样随机梯度下降法和拟牛顿迭代法来进行优化
</code></pre><h3 id="梯度下降法">梯度下降法</h3><pre><code>如果hw(x)=1/(1-<span class="keyword">e</span>^(-wx))，
则cost function=-1/<span class="keyword">m</span>* sigma(yi*<span class="literal">log</span>(hw(<span class="keyword">xi</span>)+(1-yi)*<span class="literal">log</span>(1-hw(<span class="keyword">xi</span>)))=<span class="literal">j</span>(w)
这里就成了就<span class="literal">min</span>(<span class="literal">j</span>(w))
所以更新w的过程为
w:=w-lamea*<span class="literal">j</span>(w)'  (求导)
w:=w-lamea* 1/<span class="keyword">m</span>\*sigma[<span class="keyword">m</span>](hw(<span class="keyword">xi</span>)-yi)*<span class="keyword">xi</span>)
直到<span class="literal">j</span>(w)不能再的时候停止

梯度下降法的最大问题就是会陷入局部最优，并且每次在对当前样本计算cost的时候都需要去遍历全部样本才能得到cost值，这样计算速度就会慢很多（虽然在计算的时候可以转为矩阵乘法去更新整个w值）
所以现在好多框架（mahout）中一般使用随机梯度下降法，它在计算cost的时候只计算当前的代价，最终cost是在全部样本迭代一遍之求和得出，还有他在更新当前的参数w的时候并不是依次遍历样本，而是从所有的样本中随机选择一条进行计算，它方法收敛速度快（一般是使用最大迭代次数），并且还可以避免局部最优，并且还很容易并行（使用参数服务器的方式进行并行）
这里SGD可以改进的地方就是使用动态的梯度值<span class="keyword">alpha</span>=0.04*(1.0+<span class="keyword">n</span>+i)+Rate
</code></pre><h3 id="其他优化方法">其他优化方法</h3><ul>
<li>拟牛顿法（记得是需要使用Hessian矩阵和cholesky分解）</li>
<li>BFGS</li>
<li>L-BFGS</li>
</ul>
<blockquote>
<p>优缺点：无需选择学习率α，更快，但是更复杂</p>
</blockquote>
<h3 id="关于LR的过拟合问题：">关于LR的过拟合问题：</h3><blockquote>
<p>如果我们有很多的特性，在训练集上拟合得很好，但是在预测集上却达不到这种效果</p>
</blockquote>
<pre><code>1. 减少feature个数（人工定义留多少个feature、算法选取这些feature）
2. 正则化（留下所有的feature，但对于部分feature定义其parameter非常小）
    在cost上加   lamea(sigma(w^2))
    同时w的更新变为w:=w-rate* 1/<span class="keyword">m</span>\*sigma[<span class="keyword">m</span>](hw(<span class="keyword">xi</span>)-yi)*<span class="keyword">xi</span>+ （lamea/<span class="keyword">m</span>)*<span class="literal">w</span>
    注意：这里的w0不受正则化影响
</code></pre><h3 id="关于LR的多分类：softmax">关于LR的多分类：softmax</h3><pre><code>softmax:假设离散型随机变量Y的取值集合是{<span class="number">1</span>,<span class="number">2</span>,..,k},则多分类的LR为
P<span class="comment">(Y=a|x)</span>=exp<span class="comment">(wa*x)</span>/<span class="comment">(1-1到k求和(wk*x)</span>)    <span class="number">1</span>&amp;<span class="keyword">lt</span>;a&amp;<span class="keyword">lt</span>;k
这里会输出当前样本下属于哪一类的概率，并且满足全部概率加起来=<span class="number">1</span>
</code></pre><h3 id="关于softmax和k个LR的选择">关于softmax和k个LR的选择</h3><p>如果类别之间是否互斥（比如音乐只能属于古典音乐、乡村音乐、摇滚月的一种）就用softmax<br>否则类别之前有联系（比如一首歌曲可能有影视原声，也可能包含人声，或者是舞曲），这个时候使用k个LR更为合适</p>
<p>优缺点：<br>Logistic回归优点：</p>
<ol>
<li>实现简单；</li>
<li>分类时计算量非常小，速度很快，存储资源低；</li>
</ol>
<p>缺点：</p>
<ol>
<li>容易欠拟合，一般准确度不太高</li>
<li>只能处理两分类问题（在此基础上衍生出来的softmax可以用于多分类），且必须线性可分；</li>
</ol>
<p><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/18/2595410.html" target="_blank" rel="external">http://www.cnblogs.com/biyeymyhjob/archive/2012/07/18/2595410.html</a><br><a href="http://blog.csdn.net/abcjennifer/article/details/7716281" target="_blank" rel="external">http://blog.csdn.net/abcjennifer/article/details/7716281</a><br><a href="http://ufldl.stanford.edu/wiki/index.php/Softmax%E5%9B%9E%E5%BD%92" target="_blank" rel="external">http://ufldl.stanford.edu/wiki/index.php/Softmax%E5%9B%9E%E5%BD%92</a></p>
<h2 id="KNN算法">KNN算法</h2><p>给一个训练数据集和一个新的实例，在训练数据集中找出与这个新实例最近的k个训练实例，然后统计最近的k个训练实例中所属类别计数最多的那个类，就是新实例的类</p>
<h3 id="三要素：">三要素：</h3><ol>
<li>k值的选择</li>
<li>距离的度量（常见的距离度量有欧式距离，马氏距离等）</li>
<li>分类决策规则 （多数表决规则）</li>
</ol>
<h3 id="k值的选择">k值的选择</h3><ol>
<li>k值越小表明模型越复杂，更加容易过拟合</li>
<li>但是k值越大，模型越简单，如果k=N的时候就表明无论什么点都是训练集中类别最多的那个类</li>
</ol>
<blockquote>
<p>所以一般k会取一个较小的值，然后用过交叉验证来确定<br>这里所谓的交叉验证就是将样本划分一部分出来为预测样本，比如95%训练，5%预测，然后k分别取1，2，3，4，5之类的，进行预测，计算最后的分类误差，选择误差最小的k</p>
</blockquote>
<h3 id="KNN的回归">KNN的回归</h3><p>在找到最近的k个实例之后，可以计算这k个实例的平均值作为预测值。或者还可以给这k个实例添加一个权重再求平均值，这个权重与度量距离成反比（越近权重越大）。</p>
<h3 id="优缺点：">优缺点：</h3><p>KNN算法的优点：</p>
<ol>
<li>思想简单，理论成熟，既可以用来做分类也可以用来做回归；</li>
<li>可用于非线性分类；</li>
<li>训练时间复杂度为O(n)；</li>
<li>准确度高，对数据没有假设，对outlier不敏感；</li>
</ol>
<p>缺点：</p>
<ol>
<li>计算量大；</li>
<li>样本不平衡问题（即有些类别的样本数量很多，而其它样本的数量很少）；</li>
<li>需要大量的内存；</li>
</ol>
<h3 id="KD树">KD树</h3><p>KD树是一个二叉树，表示对K维空间的一个划分，可以进行快速检索（那KNN计算的时候不需要对全样本进行距离的计算了）</p>
<h4 id="构造KD树">构造KD树</h4><p>在k维的空间上循环找子区域的中位数进行划分的过程。<br>假设现在有K维空间的数据集T={x1,x2,x3,…xn},xi={a1,a2,a3..ak}</p>
<ol>
<li>首先构造根节点，以坐标a1的中位数b为切分点，将根结点对应的矩形局域划分为两个区域，区域1中a1<b,区域2中a1>b</b,区域2中a1></li>
<li>构造叶子节点，分别以上面两个区域中a2的中位数作为切分点，再次将他们两两划分，作为深度1的叶子节点，（如果a2=中位数，则a2的实例落在切分面）</li>
<li>不断重复2的操作，深度为j的叶子节点划分的时候，索取的ai 的i=j%k+1，直到两个子区域没有实例时停止</li>
</ol>
<h4 id="KD树的搜索">KD树的搜索</h4><ol>
<li>首先从根节点开始递归往下找到包含x的叶子节点，每一层都是找对应的xi</li>
<li>将这个叶子节点认为是当前的“近似最近点”</li>
<li>递归向上回退，如果以x圆心，以“近似最近点”为半径的球与根节点的另一半子区域边界相交，则说明另一半子区域中存在与x更近的点，则进入另一个子区域中查找该点并且更新”近似最近点“</li>
<li>重复3的步骤，直到另一子区域与球体不相交或者退回根节点</li>
<li>最后更新的”近似最近点“与x真正的最近点</li>
</ol>
<h4 id="KD树进行KNN查找">KD树进行KNN查找</h4><p>通过KD树的搜索找到与搜索目标最近的点，这样KNN的搜索就可以被限制在空间的局部区域上了，可以大大增加效率。</p>
<h4 id="KD树搜索的复杂度">KD树搜索的复杂度</h4><p>当实例随机分布的时候，搜索的复杂度为log(N)，N为实例的个数，KD树更加适用于实例数量远大于空间维度的KNN搜索，如果实例的空间维度与实例个数差不多时，它的效率基于等于线性扫描。</p>
<h2 id="SVM、SMO">SVM、SMO</h2><p>对于样本点(xi,yi)以及svm的超平面：wix+b=0</p>
<ul>
<li>函数间隔：yi(wxi+b)</li>
<li>几何间隔：yi(wxi+b)/||w||,其中||w||为w的L2范数，几何间隔不会因为参数比例的改变而改变</li>
</ul>
<blockquote>
<p>svm的基本想法就是求解能正确划分训练样本并且其几何间隔最大化的超平面。</p>
</blockquote>
<h3 id="线性SVM问题">线性SVM问题</h3><p>yi(wxi+b)/||w||&gt;=d  （使用几何间隔）<br>求max(d)<br>那么假设d’=d<em>||w||<br>则将问题转为：yi(wxi+b)&gt;=1,max(d’/||w||)<br>由于d’的成比例增减不会影响实际间距，所以这里的取d’=1，又因为max(1/||w||)=min(1/2\</em>||w||^2)<br>所以最终的问题就变为了<br>yi(wxi+b)&gt;=1,min(1/2*||w||^2)<br>这样就变成了一个凸的二次规划化，可以将其转换为拉格朗日函数，然后使用对偶算法来求解</p>
<h4 id="对偶求解">对偶求解</h4><p>L(w,b,a)=1/2*||w||^2-sigma(ai*yi(wxi+b))+sigma(ai) 其中a={a1,a2..an}为拉格朗日向量<br>根据对偶性质  原始问题就是求对偶问题的极大极小max[a]min[w,b]L(w,b,a)<br>先求L对w,b的极小，再求对a的极大<br>求min[w,b]L(w,b,a)：<br>L’(w)=w-sigma(aiyixi)=0<br>L’(b)=sigma(aiyi)=0;<br>代入后可得min[w,b]L(w,b,a)=-1/2*sigma(sigma(aiajyiyj(xi·xj)))+sigma(ai)<br>求min[w,b]L(w,b,a)对a的极大<br>max[a] -1/2*sigma(sigma(aiajyiyj(xi·xj)))+sigma(ai)<br>sigma(aiyi)=0<br>转成等价的对偶形式就是<br>min[a] 1/2*sigma(sigma(aiajyiyj(xi·xj)))-sigma(ai)<br>sigma(aiyi)=0</p>
<p>假如求解出来的a为a^=(a1,a2,…an)<br>则得到最优的w,b分别为<br>w^=sigma(aiyixi)<br>b^=yj-sigma(aiyi(xi·xj))</p>
<p>所以，最终的决策分类面为<br>f=sign(sigma(aiyi(x·xi))+b^<br>也就是说，分类决策函数只依赖于输入x与训练样本的输入的内积</p>
<blockquote>
<p>与分离超平面最近的样本点称为支持向量</p>
</blockquote>
<h3 id="损失函数">损失函数</h3><p>经验损失函数:sigma(1-yi(wxi+b))   (注意，如果该值小于0时直接取0即可)<br>合页损失函数：sigma(1-yi(wi+b)) + leama||w||^2 后面的是L2正则项</p>
<h3 id="为什么要引入对偶算法">为什么要引入对偶算法</h3><ol>
<li>对偶问题往往更加容易求解(结合拉格朗日和kkt条件)</li>
<li>可以很自然的引用核函数（拉格朗日表达式里面有内积，而核函数也是通过内积进行映射的）</li>
</ol>
<h3 id="核函数">核函数</h3><p>将输入特征x（线性不可分）映射到高维特征R空间，可以在R空间上让SVM进行线性可以变，这就是核函数的作用</p>
<ul>
<li>多项式核函数:K(x,z)=(x*z+1)^p</li>
<li>高斯核函数:K(x,z)=exp(-(x-z)^2/a^2)   a为均值</li>
<li>字符串核函数：好像用于文本匹配、检索之类的，不懂</li>
</ul>
<h3 id="SVM优缺点">SVM优缺点</h3><p>优点：</p>
<ol>
<li>使用核函数可以向高维空间进行映射</li>
<li>使用核函数可以解决非线性的分类</li>
<li>分类思想很简单，就是将样本与决策面的间隔最大化</li>
<li>分类效果较好</li>
</ol>
<p>缺点：</p>
<ol>
<li>对大规模数据训练比较困难，因为它是用二次规划来求解的</li>
<li>无法直接支持多分类，但是可以使用间接的方法来做</li>
</ol>
<h3 id="SMO">SMO</h3><p>SMO是用于快速求解SVM的<br>它选择凸二次规划的两个变量，其他的变量保持不变，然后根据这两个变量构建一个二次规划问题，这个二次规划关于这两个变量解会更加的接近原始二次规划的解，通过这样的子问题划分可以大大增加整个算法的计算速度，关于这两个变量：</p>
<ol>
<li>其中一个是严重违反KKT条件的一个变量</li>
<li>另一个变量是根据自由约束确定，好像是求剩余变量的最大化来确定的。</li>
</ol>
<h3 id="SVM多分类问题">SVM多分类问题</h3><ol>
<li>直接法<br> 直接在目标函数上进行修改，将多个分类面的参数求解合并到一个最优化问题中，通过求解该优化就可以实现多分类（计算复杂度很高，实现起来较为困难）</li>
<li>间接法<ol>
<li>一对多<br>其中某个类为一类，其余n-1个类为另一个类，比如A,B,C,D四个类，第一次A为一个类，{B,C,D}为一个类训练一个分类器，第二次B为一个类,{A,C,D}为另一个类,按这方式共需要训练4个分类器，最后在测试的时候将测试样本经过这4个分类器f1(x),f2(x),f3(x)和f4(x),取其最大值为分类器(这种方式由于是1对M分类，会存在偏置，很不实用)</li>
<li>一对一(libsvm实现的方式)<br>任意两个类都训练一个分类器，那么n个类就需要n*(n-1)/2个svm分类器。<br>还是以A,B,C,D为例,那么需要{A,B},{A,C},{A,D},{B,C},{B,D},{C,D}为目标共6个分类器，然后在预测的将测试样本通过这6个分类器之后进行投票选择最终结果。（这种方法虽好，但是需要n*(n-1)/2个分类器代价太大，不过有好像使用循环图来进行改进）</li>
</ol>
</li>
</ol>
<h2 id="决策树">决策树</h2><p>决策树是一颗依托决策而建立起来的树。</p>
<h3 id="ID3">ID3</h3><ol>
<li>首先是针对当前的集合，计算每个特征的信息增益</li>
<li>然后选择信息增益最大的特征作为当前节点的决策决策特征</li>
<li>根据特征不同的类别划分到不同的子节点（比如年龄特征有青年，中年，老年，则划分到3颗子树）</li>
<li>然后继续对子节点进行递归，直到所有特征都被划分</li>
</ol>
<p>S(C,ai)=-sigma(pi<em>log(pi)) 一个属性中某个类别的熵  pi=P(yi|ai) pi表示ai情况下发生yi的概率，也即是统计概率<br>S(C,A)=sigma(P(A=ai)\</em>S(ai))  整个属性的熵，为各个类别的比例与各自熵的加权求和<br>Gain(C,A)=S(C)-S(C,A) 增益表示分类目标的熵减去当前属性的熵，增益越大，分类能力越强<br>(这里前者叫做经验熵，表示数据集分类C的不确定性，后者就是经验条件熵，表示在给定A的条件下对数据集分类C的不确定性，两者相减叫做互信息，决策树的增益等价于互信息)<br>比如说当前属性是是否拥有房产，分类是是否能偿还债务<br>现在：</p>
<ul>
<li>有用房产为7个，4个能偿还债务，3个无法偿还债务</li>
<li>然后无房产为3个，其中1个能偿还债务，2个无法偿还债务</li>
</ul>
<p>然后S(有房产)=-(4/7*log4/7+3/7*log3/7)<br>    S(无房产)=-(1/3*log1/3+2/3*log2/3)<br>    其中S(分类)=-(5/10*log5/10+5/10*log5/10)<br>    最终的增益=S(分类)-(7/10*S(有房产)+3/10*S(无房产))  最大越好</p>
<p>关于损失函数<br>设树的叶子节点个数为T，t为其中一个叶子节点，该叶子节点有Nt个样本，其中k类的样本有Ntk个，H(t)为叶子节点上的经验熵，则损失函数定义为<br>Ct(T)=sigma(Nt*H(t))+ lamdba |T|<br>其中H(t)=sigma(Ntk/Nt*log(Ntk/Nt))<br>代入可以得到Ct(T)=sigma(sigma(Ntk*log(Ntk/Nt)))+lamdba|T|<br>最终有Ct(T)=C(T)+ lamdba|T|<br>lamdba|T|为正则化项，leama是用于调节比率<br>决策树的生成只考虑了信息增益</p>
<h3 id="C4-5">C4.5</h3><p>它是ID3的一个改进算法，使用信息增益率来进行属性的选择<br>splitInformation(S,A)=-sigma(|Si|/|S|*log2(|Si|/|S|))<br>GainRatio(S,A)=Gain(S,A)/splitInformation(S,A)</p>
<p>优缺点：<br>准确率高，但是子构造树的过程中需要进行多次的扫描和排序，所以它的运算效率较低</p>
<h3 id="Cart">Cart</h3><p>分类回归树(Classification And Regression Tree)是一个决策二叉树，在通过递归的方式建立，每个节点在分裂的时候都是希望通过最好的方式将剩余的样本划分成两类，这里的分类指标：</p>
<ol>
<li>分类树：基尼指数最小化(gini_index)</li>
<li>回归树：平方误差最小化</li>
</ol>
<p>分类树：</p>
<ol>
<li>首先是根据当前特征计算他们的基尼增益</li>
<li>选择基尼增益最小的特征作为划分特征</li>
<li>从该特征中查找基尼指数最小的分类类别作为最优划分点</li>
<li>将当前样本划分成两类，一类是划分特征的类别等于最优划分点，另一类就是不等于</li>
<li>针对这两类递归进行上述的划分工作，直达所有叶子指向同一样本目标或者叶子个数小于一定的阈值</li>
</ol>
<p>gini用来度量分布不均匀性（或者说不纯），总体的类别越杂乱，GINI指数就越大（跟熵的概念很相似）<br>gini(ai)=1-sigma(pi^2) pi当前数据集中第i类样本的比例<br>gini越小，表示样本分布越均匀（0的时候就表示只有一类了），越大越不均匀<br>基尼增益gini_gain=sigma(Ni/N*gini(ai)) 表示当前属性的一个混乱  Ni/N表示当前类别占所有类别的概率<br>最终Cart选择GiniGain最小的特征作为划分特征</p>
<p>以ID3中的贷款的那棵树为样例：<br>gini(有房产)=1-((3/7)^2+(4/7)^2)  //基尼指数<br>gini(无房产)=1-((1/3)^2+(2/3)^2)<br>gini_gain=7/10*gini(有房产)+3/10*gini(无房产)  //基尼增益</p>
<p>回归树：</p>
<blockquote>
<p>回归树是以平方误差最小化的准则划分为两块区域</p>
</blockquote>
<ol>
<li>遍历特征计算最优的划分点s，<br> 使其最小化的平方误差是：min{min(R1.sigma((yi-c1)^2))+min(R2.sigma((yi-c2)^2))}<br> 计算根据s划分到左侧和右侧子树的目标值与预测值之差的平方和最小，这里的预测值是两个子树上输入xi样本对应yi的均值</li>
<li>找到最小的划分特征j以及其最优的划分点s,根据特征j以及划分点s将现有的样本划分为两个区域，一个是在特征j上小于等于s，另一个在在特征j上大于s<br> R1(j)={x|x(j)&lt;=s}、R2(j)={x|x(j)&gt;s}</li>
<li>进入两个子区域按上述方法继续划分，直到到达停止条件</li>
</ol>
<blockquote>
<p>这里面的最小化我记得可以使用最小二乘法来求</p>
</blockquote>
<p>关于剪枝：用独立的验证数据集对训练集生长的树进行剪枝（事后剪枝）。</p>
<h3 id="停止条件">停止条件</h3><ol>
<li>直到每个叶子节点都只有一种类型的记录时停止，（这种方式很容易过拟合）</li>
<li>另一种时当叶子节点的记录树小于一定的阈值或者节点的信息增益小于一定的阈值时停止</li>
</ol>
<h3 id="关于特征与目标值">关于特征与目标值</h3><ol>
<li>特征离散 目标值离散：可以使用ID3，cart</li>
<li>特征连续 目标值离散：将连续的特征离散化  可以使用ID3，cart</li>
<li>特征离散 目标值连续</li>
</ol>
<h3 id="决策树的分类与回归">决策树的分类与回归</h3><ul>
<li>分类树<br>  输出叶子节点中所属类别最多的那一类</li>
<li>回归树<br>  输出叶子节点中各个样本值的平均值</li>
</ul>
<h3 id="理想的决策树">理想的决策树</h3><ol>
<li>叶子节点数尽量少</li>
<li>叶子节点的深度尽量小(太深可能会过拟合)</li>
</ol>
<h3 id="解决决策树的过拟合">解决决策树的过拟合</h3><ol>
<li>剪枝<ol>
<li>前置剪枝：在分裂节点的时候设计比较苛刻的条件，如不满足则直接停止分裂（这样干决策树无法到最优，也无法得到比较好的效果）</li>
<li>后置剪枝：在树建立完之后，用单个节点代替子树，节点的分类采用子树中主要的分类（这种方法比较浪费前面的建立过程）</li>
</ol>
</li>
<li>交叉验证</li>
<li>随机森林</li>
</ol>
<h3 id="优缺点-1">优缺点</h3><p>优点：</p>
<ol>
<li>计算量简单，可解释性强，比较适合处理有缺失属性值的样本，能够处理不相关的特征；<br>缺点：</li>
<li>单颗决策树分类能力弱，并且对连续值变量难以处理；</li>
<li>容易过拟合（后续出现了随机森林，减小了过拟合现象）；</li>
</ol>
<h2 id="随机森林RF">随机森林RF</h2><p>随机森林是有很多随机得决策树构成，它们之间没有关联。得到RF以后，在预测时分别对每一个决策树进行判断，最后使用Bagging的思想进行结果的输出（也就是投票的思想）</p>
<h3 id="学习过程">学习过程</h3><ol>
<li>现在有N个训练样本，每个样本的特征为M个，需要建K颗树</li>
<li>从N个训练样本中有放回的取N个样本作为一组训练集（其余未取到的样本作为预测分类，评估其误差）</li>
<li>从M个特征中取m个特征左右子集特征(m&lt;&lt;M)</li>
<li>对采样的数据使用完全分裂的方式来建立决策树，这样的决策树每个节点要么无法分裂，要么所有的样本都指向同一个分类</li>
<li>重复2的过程K次，即可建立森林</li>
</ol>
<h3 id="预测过程">预测过程</h3><ol>
<li>将预测样本输入到K颗树分别进行预测</li>
<li>如果是分类问题，直接使用投票的方式选择分类频次最高的类别</li>
<li>如果是回归问题，使用分类之后的均值作为结果</li>
</ol>
<h3 id="参数问题">参数问题</h3><ol>
<li>这里的一般取m=sqrt(M)</li>
<li>关于树的个数K，一般都需要成百上千，但是也有具体的样本有关（比如特征数量）</li>
<li>树的最大深度，（太深可能可能导致过拟合？？）</li>
<li>节点上的最小样本数、最小信息增益</li>
</ol>
<h3 id="泛化误差估计">泛化误差估计</h3><p>使用oob（out-of-bag）进行泛化误差的估计，将各个树的未采样样本作为预测样本（大约有36.8%），使用已经建立好的森林对各个预测样本进行预测，预测完之后最后统计误分得个数占总预测样本的比率作为RF的oob误分率。</p>
<h3 id="学习算法">学习算法</h3><ol>
<li>ID3算法：处理离散值的量</li>
<li>C45算法：处理连续值的量</li>
<li>Cart算法：离散和连续 两者都合适？</li>
</ol>
<h3 id="关于CART">关于CART</h3><p>Cart可以通过特征的选择迭代建立一颗分类树，使得每次的分类平面能最好的将剩余数据分为两类</p>
<p>gini=1-sigma(pi^2)，表示每个类别出现的概率和与1的差值，<br>分类问题：argmax（Gini-GiniLeft-GiniRight）<br>回归问题argmax(Var-VarLeft-VarRight) </p>
<p>查找最佳特征f已经最佳属性阈值th  小于th的在左边，大于th的在右边子树</p>
<h3 id="优缺点-2">优缺点</h3><ol>
<li>能够处理大量特征的分类，并且还不用做特征选择</li>
<li>在训练完成之后能给出哪些feature的比较重要</li>
<li>训练速度很快</li>
<li>很容易并行</li>
<li>实现相对来说较为简单</li>
</ol>
<h2 id="GBDT">GBDT</h2><blockquote>
<p>GBDT的精髓在于训练的时候都是以上一颗树的残差为目标，这个残差就是上一个树的预测值与真实值的差值。</p>
</blockquote>
<pre><code>比如，当前样本年龄是18岁，那么第一颗会去按18岁来训练，但是训练完之后预测的年龄为12岁，差值为6，所以第二颗树的会以6岁来进行训练，假如训练完之后预测出来的结果为6，那么两棵树累加起来就是真实年龄了，但是假如第二颗树预测出来的结果是5，那么剩余的残差1就会交给第三个树去训练。
</code></pre><p>Boosting的好处就是每一步的参加就是变相了增加了分错instance的权重，而对已经对的instance趋向于0，这样后面的树就可以更加关注错分的instance的训练了</p>
<h3 id="Shrinkage">Shrinkage</h3><p>Shrinkage认为，每次走一小步逐步逼近的结果要比每次迈一大步逼近结果更加容易避免过拟合。<br>y(1 ~ i) = y(1 ~ i-1) + step * yi</p>
<blockquote>
<p>就像我们做互联网，总是先解决60%用户的需求凑合着，再解决35%用户的需求，最后才关注那5%人的需求，这样就能逐渐把产品做好.</p>
</blockquote>
<h3 id="调参">调参</h3><ol>
<li>树的个数  100~10000</li>
<li>叶子的深度 3~8</li>
<li>学习速率    0.01~1</li>
<li>叶子上最大节点树  20</li>
<li>训练采样比例 0.5~1</li>
<li>训练特征采样比例  sqrt(num)</li>
</ol>
<h3 id="优缺点：-1">优缺点：</h3><p>优点：</p>
<ol>
<li>精度高</li>
<li>能处理非线性数据</li>
<li>能处理多特征类型</li>
<li>适合低维稠密数据<br>缺点：</li>
<li>并行麻烦（因为上下两颗树有联系）</li>
<li>多分类的时候 复杂度很大</li>
</ol>
<h2 id="BP">BP</h2><h2 id="最小二乘法">最小二乘法</h2><p>最小二乘法是一种数学的优化技术，通过求最小化平方误差来寻找最佳的函数匹配<br>假设现在有二维的观测数据(x1,y1),(x2,y2)…(xn,yn)，求y=a+bx的拟合。</p>
<p>现设yi=a+bxi+ki 如果有a,b能得到sigma(|ki|)最小，则该线比较理想<br>所以先变为求min(sigma(ki)) ，这个与min(sigma(ki^2))等价<br>而ki=yi-(a+bxi)<br>那么现设f=sigma((yi-(a+bxi))^2)求其最小即可</p>
<blockquote>
<p>上述就是最小二乘原则，估计a,b的方法称为最小二乘法</p>
</blockquote>
<p>先求f对a,b的偏导：<br>f’(a)=-2*sigma(yi-(a+bxi))=0<br>f’(b)=-2*xi*sigma(yi-(a+bxi))=0</p>
<p>现设：X=sigma(xi)/n   Y=sigma(yi)/<br>则代入上述偏导：<br>an+bnX=nY<br>anX+b*sigma(xi^2)=sigma(xi*yi)</p>
<p>求该行列式:<br>|n ,nX         |<br>|nX,sigma(xi^2)|<br>=n*sigma((xi-X))!=0  所以有唯一解</p>
<p>最后记：<br>l(xx)=sigma((xi-X)^2)<br>l(yy)=sigma((yi-Y)^2)<br>l(xy)=sigma((xi-X)(yi-Y))</p>
<p>则b=l(xy)/l(xx)   a=Y-bX</p>
<p><a href="http://wenku.baidu.com/link?url=z-fofhp6T8y39P6tmaLzUiybVEQXpYTz6Uz-MjqxNNvg0GQrjCY0hA95mkqxg1Suk-fT_z-gq2jiMUhH9OWrv2e9kOA4uZ7ZlS6CcM2O0Zq" target="_blank" rel="external">百度文库-最小二乘法</a></p>
<h2 id="EM">EM</h2><p>EM用于隐含变量的概率模型的极大似然估计，它一般分为两步：第一步求期望(E),第二步求极大(M)，<br>如果概率模型的变量都是观测变量，那么给定数据之后就可以直接使用极大似然法或者贝叶斯估计模型参数。<br>但是当模型含有隐含变量的时候就不能简单的用这些方法来估计，EM就是一种含有隐含变量的概率模型参数的极大似然估计法。</p>
<p>应用到的地方：混合高斯模型、混合朴素贝叶斯模型、因子分析模型</p>
<h2 id="Bagging">Bagging</h2><ol>
<li>从N样本中有放回的采样N个样本</li>
<li>对这N个样本在全属性上建立分类器(CART,SVM)</li>
<li>重复上面的步骤，建立m个分类器</li>
<li>预测的时候使用投票的方法得到结果</li>
</ol>
<h2 id="Boosting">Boosting</h2><p>boosting在训练的时候会给样本加一个权重，然后使loss function尽量去考虑那些分错类的样本（比如给分错类的样本的权重值加大）</p>
<h2 id="凸优化">凸优化</h2><p>在机器学习中往往是最终要求解某个函数的最优值，但是一般情况下，任意一个函数的最优值求解比较困难，但是对于凸函数来说就可以有效的求解出全局最优值。</p>
<h3 id="凸集">凸集</h3><p>一个集合C是，当前仅当任意x,y属于C且0&lt;=theta&lt;=1，都有theta*x+(1-theta)*y属于C<br>用通俗的话来说C集合线段上的任意两点也在C集合中</p>
<h3 id="凸函数">凸函数</h3><p>一个函数f其定义域(D(f))是凸集，并且对任意x,y属于D(f)和0&lt;=theta&lt;=1都有<br>f(theta*x+(1-theta)*y)&lt;=theta*f(x)+(1-theta)*f(y)   —这个貌似叫做jensen不等式<br>用通俗的话来说就是曲线上任意两点的割线都在曲线的上方</p>
<p>常见的凸函数有：</p>
<ul>
<li>指数函数f(x)=a^x   a&gt;1</li>
<li>负对数函数-logax  a&gt;1,x&gt;0</li>
<li>开口向上的二次函数等</li>
</ul>
<p>凸函数的判定：</p>
<ol>
<li>如果f是一阶可导，对于任意数据域内的x,y满足f(y)&gt;=f(x)+f’(x)(y-x)</li>
<li>如果f是二阶可导，</li>
</ol>
<h3 id="凸优化应用举例">凸优化应用举例</h3><ul>
<li>SVM：其中由max|w|  转向min(1/2*|w|^2)</li>
<li>最小二乘法？</li>
<li>LR的损失函数sigma(yi*log(hw(x))+(1-yi)*(log(1-hw(x))))</li>
</ul>
<h2 id="备注">备注</h2><p>资料主要来源于网络或者《统计学习方法》，还有自己一小部分的总结，如果错误之处敬请指出</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>这个总结最初是写在本地的<span class="variable">MacDown</span>中的，他的markdown语法解析与hexo的略微有点差异，懒得改了-<span class="variable">_</span>-，忍着点看..
</code></pre><h2 id="朴素贝叶斯">朴素贝叶斯</h2><p>P(A∩B)=P(A)*P(B|A)=P(B)*P(A|B)<br>所以有：P(A|B)=P(B|A)*P(A)/P(B)</p>
<p>对于给出的待分类项，求解在此项出现的条件下各个目标类别出现的概率，哪个最大，就认为此待分类项属于哪个类别</p>
<h3 id="工作原理">工作原理</h3><ol>
<li>假设现在有样本x=(a1,a2,a3,…an)这个待分类项(并认为x里面的特征独立)</li>
<li>再假设现在有分类目标Y={y1,y2,y3,y4..yn}</li>
<li>那么max(P(y1|x),P(y2|x),P(y3|x)..P(yn|x))中的最大者就是最终的分类类别</li>
<li>而P(yi|x)=p(x|yi)*P(yi)/P(x)</li>
<li>因为x对于每个分类目标来说都一样，所以就是求max(P(x|yi)*p(yi))</li>
<li>P(x|yi)*p(yi)=p(yi)*PI(P(ai|yi))  (PI表示连乘)</li>
<li>而具体的p(ai|yi)和p(yi)都是能从训练样本中统计出来<br> p(ai|yi)表示该类别下该特征出现的概率<br> p(yi)表示全部类别中这个这个类别出现的概率</li>
<li>好的，就是这么工作的^_^</li>
</ol>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习常见面试题整理]]></title>
    <link href="http://yyl8781697.github.io/2015/08/16/Machine%20Learning/Common-Interview/"/>
    <id>http://yyl8781697.github.io/2015/08/16/Machine Learning/Common-Interview/</id>
    <published>2015-08-15T23:39:47.000Z</published>
    <updated>2015-10-20T11:03:21.000Z</updated>
    <content type="html"><![CDATA[<h2 id="有监督学习和无监督学习的区别">有监督学习和无监督学习的区别</h2><ul>
<li>有监督学习：对具有标记的训练样本进行学习，以尽可能对训练样本集外的数据进行分类预测。（LR,SVM,BP,RF,GBRT）</li>
<li>无监督学习：对未标记的样本进行训练学习，比发现这些样本中的结构知识。(KMeans,DL)</li>
</ul>
<h2 id="正则化">正则化</h2><p>正则化是针对过拟合而提出的，以为在求解模型最优的是一般优化最小的经验风险，现在在该经验风险上加入模型复杂度这一项（正则化项是模型参数向量的范数），并使用一个rate比率来权衡模型复杂度与以往经验风险的权重，如果模型复杂度越高，结构化的经验风险会越大，现在的目标就变为了结构经验风险的最优化，可以防止模型训练过度复杂，有效的降低过拟合的风险。</p>
<blockquote>
<p>奥卡姆剃刀原理，能够很好的解释已知数据并且十分简单才是最好的模型。</p>
</blockquote>
<a id="more"></a>
<h2 id="过拟合">过拟合</h2><p>如果一味的去提高训练数据的预测能力，所选模型的复杂度往往会很高，这种现象称为过拟合。所表现的就是模型训练时候的误差很小，但在测试的时候误差很大。</p>
<h3 id="产生的原因">产生的原因</h3><ol>
<li>因为参数太多，会导致我们的模型复杂度上升，容易过拟合</li>
<li>权值学习迭代次数足够多(Overtraining),拟合了训练数据中的噪声和训练样例中没有代表性的特征.</li>
</ol>
<h3 id="解决方法">解决方法</h3><ol>
<li>交叉验证法</li>
<li>减少特征</li>
<li>正则化</li>
<li>权值衰减</li>
<li>验证数据</li>
</ol>
<h2 id="泛化能力">泛化能力</h2><p>泛化能力是指模型对未知数据的预测能力</p>
<h2 id="生成模型和判别模型">生成模型和判别模型</h2><ol>
<li>生成模型：由数据学习联合概率分布P(X,Y)，然后求出条件概率分布P(Y|X)作为预测的模型，即生成模型：P(Y|X)= P(X,Y)/ P(X)。（朴素贝叶斯）<br> 生成模型可以还原联合概率分布p(X,Y)，并且有较快的学习收敛速度，还可以用于隐变量的学习</li>
<li>判别模型：由数据直接学习决策函数Y=f(X)或者条件概率分布P(Y|X)作为预测的模型，即判别模型。（k近邻、决策树）<br> 直接面对预测，往往准确率较高，直接对数据在各种程度上的抽象，所以可以简化模型</li>
</ol>
<h2 id="线性分类器与非线性分类器的区别以及优劣">线性分类器与非线性分类器的区别以及优劣</h2><p>如果模型是参数的线性函数，并且存在线性分类面，那么就是线性分类器，否则不是。<br>常见的线性分类器有：LR,贝叶斯分类，单层感知机、线性回归<br>常见的非线性分类器：决策树、RF、GBDT、多层感知机</p>
<blockquote>
<p>SVM两种都有(看线性核还是高斯核)</p>
</blockquote>
<ul>
<li>线性分类器速度快、编程方便，但是可能拟合效果不会很好</li>
<li>非线性分类器编程复杂，但是效果拟合能力强</li>
</ul>
<h3 id="特征比数据量还大时，选择什么样的分类器？">特征比数据量还大时，选择什么样的分类器？</h3><p>线性分类器，因为维度高的时候，数据一般在维度空间里面会比较稀疏，很有可能线性可分</p>
<h3 id="对于维度很高的特征，你是选择线性还是非线性分类器？">对于维度很高的特征，你是选择线性还是非线性分类器？</h3><p>理由同上</p>
<h3 id="对于维度极低的特征，你是选择线性还是非线性分类器？">对于维度极低的特征，你是选择线性还是非线性分类器？</h3><p>非线性分类器，因为低维空间可能很多特征都跑到一起了，导致线性不可分</p>
<h2 id="ill-condition病态问题">ill-condition病态问题</h2><p>训练完的模型测试样本稍作修改就会得到差别很大的结果，就是病态问题（这简直是不能用啊）</p>
<h2 id="L1和L2正则的区别，如何选择L1和L2正则">L1和L2正则的区别，如何选择L1和L2正则</h2><blockquote>
<p>他们都是可以防止过拟合，降低模型复杂度</p>
</blockquote>
<ul>
<li>L1是在loss function后面加上 模型参数的1范数（也就是|xi|）</li>
<li><p>L2是在loss function后面加上 模型参数的2范数（也就是sigma(xi^2)），注意L2范数的定义是sqrt(sigma(xi^2))，在正则项上没有添加sqrt根号是为了更加容易优化</p>
</li>
<li><p>L1 会产生稀疏的特征</p>
</li>
<li>L2 会产生更多地特征但是都会接近于0 </li>
</ul>
<p>L1会趋向于产生少量的特征，而其他的特征都是0，而L2会选择更多的特征，这些特征都会接近于0。L1在特征选择时候非常有用，而L2就只是一种规则化而已。</p>
<h2 id="特征向量的归一化方法">特征向量的归一化方法</h2><ol>
<li>线性函数转换，表达式如下：y=(x-MinValue)/(MaxValue-MinValue)</li>
<li>对数函数转换，表达式如下：y=log10 (x)</li>
<li>反余切函数转换 ，表达式如下：y=arctan(x)*2/PI</li>
<li>减去均值，乘以方差：y=(x-means)/ variance</li>
</ol>
<h2 id="特征向量的异常值处理">特征向量的异常值处理</h2><ol>
<li>用均值或者其他统计量代替</li>
</ol>
<h2 id="越小的参数说明模型越简单">越小的参数说明模型越简单</h2><p>过拟合的，拟合会经过曲面的每个点，也就是说在较小的区间里面可能会有较大的曲率，这里的导数就是很大，线性模型里面的权值就是导数，所以越小的参数说明模型越简单。</p>
<blockquote>
<p>追加：这个其实可以看VC维相关的东西感觉更加合适</p>
</blockquote>
<h2 id="svm中rbf核函数与高斯和函数的比较">svm中rbf核函数与高斯和函数的比较</h2><p>高斯核函数好像是RBF核的一种</p>
<h2 id="KMeans初始类簇中心点的选取">KMeans初始类簇中心点的选取</h2><h3 id="选择批次距离尽可能远的K个点">选择批次距离尽可能远的K个点</h3><pre><code>首先随机选取一个点作为初始点，然后选择距离与该点最远的那个点作为中心点，再选择距离与前两个点最远的店作为第三个中心店，以此类推，直至选取大k个
</code></pre><h3 id="选用层次聚类或者Canopy算法进行初始聚类">选用层次聚类或者Canopy算法进行初始聚类</h3><h2 id="ROC、AUC">ROC、AUC</h2><p>ROC和AUC通常是用来评价一个二值分类器的好坏</p>
<h3 id="ROC曲线">ROC曲线</h3><p>曲线坐标上：</p>
<ul>
<li>X轴是FPR（表示假阳率-预测结果为positive，但是实际结果为negitive，FP/(N)）</li>
<li>Y轴式TPR（表示真阳率-预测结果为positive，而且的确真实结果也为positive的,TP/P）</li>
</ul>
<p>那么平面的上点(X,Y)：</p>
<ul>
<li>(0,1)表示所有的positive的样本都预测出来了，分类效果最好</li>
<li>(0,0)表示预测的结果全部为negitive</li>
<li>(1,0)表示预测的错过全部分错了，分类效果最差</li>
<li>(1,1)表示预测的结果全部为positive<blockquote>
<p>针对落在x=y上点，表示是采用随机猜测出来的结果</p>
</blockquote>
</li>
</ul>
<p>ROC曲线建立<br>一般默认预测完成之后会有一个概率输出p，这个概率越高，表示它对positive的概率越大。<br>现在假设我们有一个threshold，如果p&gt;threshold，那么该预测结果为positive，否则为negitive，按照这个思路，我们多设置几个threshold,那么我们就可以得到多组positive和negitive的结果了，也就是我们可以得到多组FPR和TPR值了<br>将这些(FPR,TPR)点投射到坐标上再用线连接起来就是ROC曲线了</p>
<blockquote>
<p>当threshold取1和0时，分别得到的就是(0,0)和(1,1)这两个点。（threshold=1，预测的样本全部为负样本，threshold=0，预测的样本全部为正样本）</p>
</blockquote>
<h3 id="AUC">AUC</h3><p>AUC(Area Under Curve)被定义为ROC曲线下的面积，显然这个面积不会大于1（一般情况下ROC会在x=y的上方，所以0.5&lt;AUC&lt;1）.</p>
<blockquote>
<p>AUC越大说明分类效果越好</p>
</blockquote>
<h3 id="为什么要使用ROC和AUC">为什么要使用ROC和AUC</h3><p>因为当测试集中的正负样本发生变化时，ROC曲线能基本保持不变，但是precision和recall可能就会有较大的波动。<br><a href="http://www.douban.com/note/284051363/?type=like" target="_blank" rel="external">http://www.douban.com/note/284051363/?type=like</a></p>
<h2 id="测试集和训练集的区别">测试集和训练集的区别</h2><p>训练集用于建立模型,测试集评估模型的预测等能力</p>
<h2 id="优化Kmeans">优化Kmeans</h2><p>使用kd树或者ball tree(这个树不懂)<br>将所有的观测实例构建成一颗kd树，之前每个聚类中心都是需要和每个观测点做依次距离计算，现在这些聚类中心根据kd树只需要计算附近的一个局部区域即可</p>
<h2 id="数据挖掘和机器学习的区别">数据挖掘和机器学习的区别</h2><p>机器学习是数据挖掘的一个重要工具，但是数据挖掘不仅仅只有机器学习这一类方法，还有其他很多非机器学习的方法，比如图挖掘，频繁项挖掘等。感觉数据挖掘是从目的而言的，但是机器学习是从方法而言的。</p>
<h2 id="备注">备注</h2><p>题目主要来源于网络，答案主要来源于网络或者《统计学习方法》，还有自己一小部分的总结，如果错误之处敬请指出<br>如果想要了解关于常见模型的东东可以看这篇<a href="http://kubicode.me/2015/08/16/Machine%20Learning/Algorithm-Summary-for-Interview/" target="_blank" rel="external">机器学习常见算法个人总结（面试用）</a>文章</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="有监督学习和无监督学习的区别">有监督学习和无监督学习的区别</h2><ul>
<li>有监督学习：对具有标记的训练样本进行学习，以尽可能对训练样本集外的数据进行分类预测。（LR,SVM,BP,RF,GBRT）</li>
<li>无监督学习：对未标记的样本进行训练学习，比发现这些样本中的结构知识。(KMeans,DL)</li>
</ul>
<h2 id="正则化">正则化</h2><p>正则化是针对过拟合而提出的，以为在求解模型最优的是一般优化最小的经验风险，现在在该经验风险上加入模型复杂度这一项（正则化项是模型参数向量的范数），并使用一个rate比率来权衡模型复杂度与以往经验风险的权重，如果模型复杂度越高，结构化的经验风险会越大，现在的目标就变为了结构经验风险的最优化，可以防止模型训练过度复杂，有效的降低过拟合的风险。</p>
<blockquote>
<p>奥卡姆剃刀原理，能够很好的解释已知数据并且十分简单才是最好的模型。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《台大机器学习基石》VC Dimension]]></title>
    <link href="http://yyl8781697.github.io/2015/08/15/Machine%20Learning/VC-Dimension/"/>
    <id>http://yyl8781697.github.io/2015/08/15/Machine Learning/VC-Dimension/</id>
    <published>2015-08-15T07:45:20.000Z</published>
    <updated>2015-08-19T15:20:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="VC_Bound">VC Bound</h2><p>我们通过上一篇文章中了解到了<code>break point</code>以及<code>Growth Function</code>之后，<br>我们将<code>Growth Function</code>的上界设为<code>B(N,k)</code>（maximum possible m_H(N) when break point = k），表示在<code>break point</code>的<code>k</code>的情况下，其<code>m<sub>H</sub>(N)</code>的最大值，用通俗的话来说，在<code>N</code>个点中，任意取<code>k</code>个点不能<code>shatter</code>。</p>
<blockquote>
<p>这种方式定义的好处就是以后在计算不需要计较具体的成长函数是怎么样的，形成的<code>hypothesis</code>究竟是如何的。<br><a id="more"></a></p>
</blockquote>
<h3 id="证明">证明</h3><p>那能否证明<code>B(N,k)&lt;=ploy(N)</code>呢？<br>先来看下面这个表,其中当前纵向有<code>N</code>，横向表示具体的<code>k</code>值，表中的内容就是需要计算的<code>B(N,k)</code>值</p>
<ul>
<li><p>B(2,2)=3，B(3,2)=4 手算-_-<br>  <img src="/img/VC-Dimension/t1.png" width="500px" height="300px"><br>  因为任意两个点都不能被<code>shatter</code>，那么2个点产生的<code>dichotomies</code>不能超过3,同理3个点产生的<code>dichotomies</code>不能超过4</p>
</li>
<li><p>B(N,1)=1<br>  <img src="/img/VC-Dimension/t2.png" width="500px" height="300px"><br>  2^1=2 而最大值不能超过2，所以这里最大值都为1</p>
</li>
<li><p>B(N,k)=2<sup>N</sup>  当<code>N&lt;k</code><br>  <img src="/img/VC-Dimension/t3.png" width="500px" height="300px"><br>  这里的<code>2<sup>N</sup><2<sup>k<sup></sup></2<sup></code>必然成立，所以最大值直接取2<sup>N</sup>，不然多余选的点也都是重复的。</p>
</li>
<li><p>B(N,k)=2<sup>N</sup>-1  当<code>N=k</code><br>  <img src="/img/VC-Dimension/t4.png" width="500px" height="300px"><br>  在<code>N=k</code>的情况下满足全部不可能（点的所有组合为不可能），但是这里再减去一种就可以满足了</p>
</li>
<li><p>B(N,k)&lt;=B(N-1,k)+B(N-1,k-1)  当<code>N&gt;k</code><br>  <img src="/img/VC-Dimension/t5.png" width="500px" height="300px"><br>  表中新添的值为上限的上限，耐心地看下上图的推导-_-</p>
<ol>
<li>通过计算机暴力求解B(4,3)=11,(一共16种<code>dichotomies</code>,再从其中选不同情况的<code>dichotomies</code>来计算是否被<code>shatter</code>，最终有2<sup>16</sup>情况)<br> <img src="/img/VC-Dimension/d1.png" width="500px" height="300px"><br> 右侧着色的图中橙色的点在<code>x<sub>1</sub></code>,<code>x<sub>2</sub></code>,<code>x<sub>3</sub></code>这三个维度是一样的，<code>x<sub>4</sub></code>这个维度是不一样的（也就是传说中的成双成对），蓝色的点在<code>x<sub>1</sub></code>,<code>x<sub>2</sub></code>,<code>x<sub>3</sub></code>无法找到全部一样的</li>
<li>现在将<code>x<sub>4</sub></code>这个点遮掉<br> <img src="/img/VC-Dimension/d2.png" width="500px" height="300px"></li>
<li>同时将蓝色的遮掉<br> <img src="/img/VC-Dimension/d3.png" width="500px" height="300px"><br> 这里不能多余2个点被<code>shatter</code></li>
<li>整理之后就可以得到如下关系式<br> <img src="/img/VC-Dimension/d4.png" width="300px" height="200px"></li>
<li>写成通用式子为<br> <img src="/img/VC-Dimension/d5.png" width="300px" height="200px"><br> 即得解^_^</li>
</ol>
</li>
</ul>
<p>根据上限的上限的递推式，再结合数学归纳法可以得到<br><img src="/img/VC-Dimension/sg.png" width="300px" height="200px"><br>它的最高项的指数是<code>k-1</code></p>
<p>那么现在：</p>
<ol>
<li><code>Growth Function</code>会被上限<code>B(N,k)</code> bound住</li>
<li>而<code>B(N,k)</code> 又会被上限的上限bound住</li>
<li>这个上限的上限的多项式和<code>break point</code>点有关</li>
<li>所以可以得出结果，只要<code>break point</code>点存在，那么他的<code>Growth Function</code>最终会是一个多项式</li>
</ol>
<p>但是然并卵，<code>m<sub>H</sub>(N)</code>并无法直接代入到之前的</p>
<h3 id="计算VC">计算VC</h3><p><img src="/img/VC-Dimension/rbl.png" width="400px" height="200px"></p>
<blockquote>
<p>主要是因为：<code>E<sub>in</sub>(h)</code>的<code>hypothesis</code>可能取值是有限个的，但<code>E<sub>out</sub>(h)</code>的可能取值是无限的。可以通过将<code>E<sub>out</sub>(h)</code> 替换为验证集(verification set) 的<code>E<sub>in</sub>‘</code>来解决这个问题。<br><img src="/img/VC-Dimension/einp.png" width="500px" height="200px"></p>
</blockquote>
<p>好，那么接下来主要经历如下三个步骤：</p>
<ol>
<li>使用<code>E<sub>in</sub>‘</code>来代替<code>E<sub>out</sub></code><br> <img src="/img/VC-Dimension/s1.png" width="500px" height="200px"></li>
<li>这样最终可能出现的<code>H(x1,x2..xn,x1’,x2’…xn’)</code><br> <img src="/img/VC-Dimension/s2.png" width="500px" height="200px"></li>
<li>使用不替换的<code>Hoeffding</code><br> <img src="/img/VC-Dimension/s3.png" width="500px" height="200px"></li>
</ol>
<p>最终得到了著名的<code>VC Bound</code><br><img src="/img/VC-Dimension/vc.png" width="500px" height="200px"></p>
<pre><code>那么终于可以说明空间存在有限的break point，并且采样的资料量N够多，就可以保证找到一个<span class="function"><span class="title">Ein</span><span class="params">(h)</span></span>最小的时候，得到最小的<span class="function"><span class="title">Eout</span><span class="params">(h)</span></span>,也就是说明Learning的可行性
</code></pre><h2 id="VC_Dimension">VC Dimension</h2><h3 id="定义">定义</h3><p>先来看一下<code>VC Dimension</code>的定义<br><img src="/img/VC-Dimension/vi.png" width="400px" height="300px"><br><code>VC Dimension</code>表示在<code>N</code>个点中能够<code>shatter</code>的最大的值，也就是<code>k-1</code>（<code>k</code>为<code>break point</code>,该值时不能<code>shatter</code>的最小值）</p>
<p>这样的话就可以很容易计算出我们之前一直在讨论的那几种情况的<code>VC Dimension</code><br><img src="/img/VC-Dimension/vz.png" width="400px" height="300px"><br>那么我们可以知道好的<code>VC Dimension</code>应该是有限的，这样才可以保证<code>E<sub>in</sub>≈E<sub>out</sub></code><br>同时这样就就会有</p>
<ol>
<li><code>VC Dimension</code>与算法A无关</li>
<li><code>VC Dimension</code>与数据p的分布无关</li>
<li><code>VC Dimension</code>与目标函数f无关</li>
</ol>
<p>说了这么多，看一下<code>VC Dimension</code>与大<code>M</code>的关系<br><img src="/img/VC-Dimension/vm.png" width="500px" height="500px"><br>这样就可以看到：</p>
<ol>
<li><code>M</code>很小的时候，得到的<code>E<sub>in</sub></code>、<code>E<sub>out</sub></code>会非常相似，但是可选的<code>E<sub>in</sub></code>太少了，可能到最后选择了 一个较大的<code>E<sub>in</sub></code></li>
<li><code>M</code>很大的时候，可选的<code>E<sub>in</sub></code>比较多，可能到最后得到的<code>E<sub>in</sub></code>得到的<code>E<sub>in</sub></code>、<code>E<sub>out</sub></code>可能不怎么想相似</li>
<li><code>VC Dimension</code>很小的时候，与第一条一样，但是区别的是它的自由度受到了限制</li>
<li><code>VC Dimension</code>很大的时候，与第二条一样，但是区别的是它的自由度没受限制，很自由</li>
</ol>
<blockquote>
<p><code>VC Dimension</code>反映了假设空间<code>hypothesis set</code>的强大程度，<code>VC Dimension</code>越大，<code>hypothesis set</code>也越强，因为它可以<code>shatter</code>更多的点。</p>
</blockquote>
<h3 id="物理意义">物理意义</h3><p><code>VC Dimension</code>的物理意义是表示二元分类下的自由度是多少，而这个自由度是表示参数<code>w</code>的维度<br><img src="/img/VC-Dimension/vw.png" width="400px" height="300px"></p>
<h3 id="模型复杂度">模型复杂度</h3><p>现在将之前任意一<code>hypothesis</code>发生坏事的概率<code>VC bound</code>变一下形<br><img src="/img/VC-Dimension/mc.png" width="500px" height="400px"><br>最终，根号里面的叫做模型复杂度，<strong>模型的复杂度越大，其泛化能力就会越低</strong>，这个模型的复杂度越与三个项有关：</p>
<ol>
<li><code>N</code>，抽样有多少个点</li>
<li><code>H</code>，这里的<code>VC Dimension</code>有多大</li>
<li><code>δ</code>，<code>E<sub>in</sub></code>与<code>E<sub>out</sub></code>相似在一个阈值内的概率</li>
</ol>
<p>现在在图上画出三者的关系：<br><img src="/img/VC-Dimension/tt.png" width="400px" height="300px"><br>那么可以看到随着<code>VC Dimension</code>越大，其模型复杂度也会越大,<code>E<sub>in</sub></code>会变小，但是<code>E<sub>out</sub></code>会有像图中一样一个山谷形的表现，最小的<code>E<sub>out</sub></code>会在中间</p>
<p>所以更加深层次的可以了解到，我们并不是把<code>E<sub>in</sub></code>做的越小越好，因为这个时候可能会导致模型复杂度变大，从而最终使<code>E<sub>out</sub></code>也会变大,真正会做机器学习的人在优化<code>E<sub>in</sub></code>的同时会考虑带来的其他复杂度的代价。</p>
<h3 id="采样复杂度">采样复杂度</h3><p><code>VC bound</code>的另一个意义就是模型复杂度<br>那就现在给你<br><img src="/img/VC-Dimension/p.png" width="400px" height="100px"><br>这些参数，那么如果计算使用最少的样本量来完成上述需求，计算过程可以参考下面<br><img src="/img/VC-Dimension/js.png" width="400px" height="200px"><br>而在理论上需要的样本是<code>N≈10000d<sub>vc</sub></code><br>但是其实在实际上<code>N≈10d<sub>vc</sub></code>即可,<br>为什么会这样呢？<br><img src="/img/VC-Dimension/ks.png" width="500px" height="400px"><br>这是因为<code>VC bound</code>推导的过程很宽松，里面很多假设都是取了上限</p>
<blockquote>
<p>所以，模型较复杂时(<code>N≈10d<sub>vc</sub></code> 较大)，需要更多的训练数据</p>
</blockquote>
<pre><code>除此外，我们为了避免overfit，一般都会加正则项。那加了正则项后，新的假设空间会得到一些限制，此时新假设空间的VC维将变小，也就是同样训练数据条件下，E<span class="keyword">in</span>更有可能等于E<span class="keyword">out</span>，所以泛化能力更强。这里从VC维的角度解释了正则项的作用。
</code></pre><h2 id="参考">参考</h2><ul>
<li>《台湾国立大学-机器学习基石》第六讲</li>
<li>《台湾国立大学-机器学习基石》第七讲</li>
<li><a href="http://www.flickering.cn/machine_learning/2015/04/vc%E7%BB%B4%E7%9A%84%E6%9D%A5%E9%BE%99%E5%8E%BB%E8%84%89/" target="_blank" rel="external">VC维的来龙去脉</a></li>
</ul>
<p>配图均来自《台湾国立大学-机器学习基石》</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="VC_Bound">VC Bound</h2><p>我们通过上一篇文章中了解到了<code>break point</code>以及<code>Growth Function</code>之后，<br>我们将<code>Growth Function</code>的上界设为<code>B(N,k)</code>（maximum possible m_H(N) when break point = k），表示在<code>break point</code>的<code>k</code>的情况下，其<code>m<sub>H</sub>(N)</code>的最大值，用通俗的话来说，在<code>N</code>个点中，任意取<code>k</code>个点不能<code>shatter</code>。</p>
<blockquote>
<p>这种方式定义的好处就是以后在计算不需要计较具体的成长函数是怎么样的，形成的<code>hypothesis</code>究竟是如何的。<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一些面试常见的智力题啦]]></title>
    <link href="http://yyl8781697.github.io/2015/08/11/Algorithm/Intelligence-Problems/"/>
    <id>http://yyl8781697.github.io/2015/08/11/Algorithm/Intelligence-Problems/</id>
    <published>2015-08-11T15:10:06.000Z</published>
    <updated>2015-08-16T00:15:08.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>考智力，脑子不好使咋办？？只有记下来^_^</p>
</blockquote>
<h2 id="烧香/绳子计时1小时15分钟">烧香/绳子计时1小时15分钟</h2><pre><code>烧一根不均匀的绳,从头烧到尾总共需要 1 个小时。现在有若干条材质相同的绳子,问 如何用烧绳的方法来计时一个小时十五分钟呢?
</code></pre><p>假设现在有三根绳子A和B和C，现在将A的两端都点着，B的一端都点着<br>半小时过去后，A就烧没了，此时B应该还有半小时的时长可以烧，但是现在把B的另一端也点着<br>又过了十五分钟，B也烧没了，这个时候把C的两端也都点着<br>又过了半小时，C也烧没了<br>好了，一小时十五分钟就这么烧到了^_^<br>其实主要思路还是两端  一端 烧得搭配</p>
<a id="more"></a>
<h2 id="取两个同一颜色的果冻">取两个同一颜色的果冻</h2><pre><code>你有一桶果冻,其中有黄色、绿色、红色三种,闭上眼睛抓取同种颜色的两个。抓取多少 个就可以确定你肯定有两个同一颜色的果冻?
</code></pre><p>用鸽巢原理，很容易得出是4啊</p>
<h2 id="打水问题">打水问题</h2><pre><code>如果你有无穷多的水,一个 3 公升的􏰁捅,一个 5 公升的􏰁捅,两只􏰁捅形状上下都不 均匀,问你如何才能准确称出 4 公升的水
</code></pre><p>假设3、5公升的桶分别为A=0，B=0</p>
<ol>
<li>将B的桶装满，此时A=0,B=5</li>
<li>将B中的水倒入A，直到A满掉，此时A=3，B=2</li>
<li>A中的水倒掉，将B中剩余的水全部倒入A，此时A=2，B=0</li>
<li>将B中的水装满，此时，A=2，B=5</li>
<li>将B中的水倒入A直到A满了（也就是倒入了1升水），此时A=3，B=4</li>
</ol>
<h2 id="诚实国和说谎国">诚实国和说谎国</h2><pre><code>来了两个人,已知一个是诚实国的,另一个是说谎国的。 诚实国永远说实话,说谎国永远说谎话。现在你要去说谎国, 但不知道应该走哪条路,需要问这两个人。请问应该怎么问?
</code></pre><p>假设这两个人分别简称甲和乙.</p>
<ol>
<li><p>情况一</p>
<ul>
<li>问题1问甲：乙是来自说谎国的对吧?<br>如甲是说谎国的他只会说谎,甲不能回答正确答案乙是来自诚实国他必然回答“乙是来自诚实国”.</li>
<li>问题2问甲：乙是来自诚实国对吧?<br>如甲是说谎国的他只会说谎,那他在明知乙是诚实国人的情况下也回答“乙是来自说谎国”.<blockquote>
<p>经过前两个问题分析甲的回答前后矛盾,可知道甲在说谎,甲来自说谎国.</p>
</blockquote>
</li>
<li>问题3问甲：哪边的岔道口通向说谎国?<br>因为已经推论出甲必说谎话所以向他答案的反其道而行就好.</li>
</ul>
</li>
<li><p>情况二</p>
<ul>
<li>问题1问甲：乙是来自说谎国的对吧?<br>如甲是诚实的,他必然回答“乙是来自说谎国”.</li>
<li>问题2问甲：乙是来自诚实国对吧?<br>如甲是诚实的,他必然回答“不,乙来自说谎国”.<blockquote>
<p>经过前两个问题分析甲的回答前后一致,可知道甲是诚实的,甲来自诚实国.</p>
</blockquote>
</li>
<li>问题3问甲：哪边的岔道口通向说谎国?<br>按甲指出的方向走就好.</li>
</ul>
</li>
</ol>
<h2 id="称球问题">称球问题</h2><pre><code><span class="number">12</span> 个球一个天平,现知道只有一个和其它的重量不同,问怎样称才能用三次就找到那个 球。<span class="number">13</span> 个呢?<span class="comment">(注意此题并未说明那个球的重量是轻是重,所以需要仔细考虑)</span>
</code></pre><p><strong>先看12个球</strong><br>分三组:每组四个,第一组编号1-4，第二组5-8，第三组9-12.<br>第一次称：天平左边放第一组，右边放第二组。 </p>
<ul>
<li><p>A 第一种可能：<code>平衡</code>。则不同的在第三组。<br>  接下来可以在左边放第9、10、11号，右边放1、2、3号三个正常的。 </p>
<ul>
<li>a.如果<code>平衡</code>，则12号是不同的; </li>
<li>b.如果<code>左重右轻</code>，则不同的在9、10、11号中，而且比正常球重。再称一次：9放左边，10放右边，如果平衡，则11号是不同的；如果左重右轻，则9号是不同的，如果右重左轻，则10号是不同的。 </li>
<li>c.如果左轻右重，道理同b </li>
</ul>
</li>
<li><p>B 第二种可能：<code>左重右轻</code>，则不同的在1-8号中，但不知比正常的轻还是重。<br>  第二次称：左边放1、2、5号，右边放6、9、3号。 </p>
<ul>
<li>a.如果<code>平衡</code>。则不同的在4、7、8中。可以称第三次：左边放4、7，右边放9、10。如果平衡，则8是不同;如果左重右轻，则4是不同；如果左轻右重，则7是不同。 </li>
<li>b.仍然<code>左重右轻</code>。则不同的在位置没有改变的1、2、6中。可以称第三次：左边放1、6，右边放9、10。如果平衡，则2是不同; 如果左重右轻，则1是不同;如果左轻右重，则6是不同。 </li>
<li>c：<code>左轻右重</code>。则不同的在5、3、中，因为只有它们改变了原来的位置。可以称第三次：左放5，3，右放9，10。如果左轻右重，则5是不同，如果左重右轻，则3是不同。 </li>
</ul>
</li>
<li><p>C 第三种可能：<code>左轻右重</code>，道理同B </p>
<p>  至此，不论发生任何情况，称三次都可以找出不同，而且知道比正常的轻了还是重了。</p>
</li>
</ul>
<p><strong>现在来看13个球</strong><br>同样分三组，第一组编号1-4，第二组5-8，第三组9-13</p>
<ul>
<li>如果出现了上述A的情况，则说明不同的再第三组<br>  接下来可以左边放1、2、3  右边放9、19、11<ul>
<li>a 如果平衡，则说明不同的在12、13里面，那么拿一个正常的与12对比，即可得到结果</li>
<li>b 如果左重右轻，说明不同的球再11、12、13里面，则不同的在9、10、11号中，而且比正常球重。再称一次：9放左边，10放右边，如果平衡，则11号是不同的；如果左重右轻，则9号是不同的，如果右重左轻，则10号是不同的。 </li>
<li>c.如果左轻右重，道理同b </li>
</ul>
</li>
<li>如果出现了上述B或C的情况 按B或者C走就好了</li>
</ul>
<h2 id="每条直线上至少有三个点">每条直线上至少有三个点</h2><pre><code>在 9 个点上画 10 条直线,要求每条直线上至少有三个点
</code></pre><p>先画一个五角星，然后去掉一个点就可以了(bingo)</p>
<h2 id="抛硬币问题">抛硬币问题</h2><pre><code>101个硬币中有一个假币，有一个无砝码的天平，称两次，判断假币比真币重还是轻。
</code></pre><p>方案是分33，33，35三堆，先33与33称，</p>
<ul>
<li>如果相同，那么假币在35那堆里，然后去35枚真币与有假币那堆的称，就知道结果了。</li>
<li>如果33与33重量不相等，记录哪一堆更重，然后可以知道35枚硬币都只真的，从中取33枚，与其中33个中的一堆对比，<ul>
<li>如果相等，另一堆就是假，</li>
<li>不相等，那么这一堆就是假，根据之前记录的轻重比，就知道结果了。</li>
</ul>
</li>
</ul>
<h2 id="备注">备注</h2><p>理论上还会再更新-_-</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>考智力，脑子不好使咋办？？只有记下来^_^</p>
</blockquote>
<h2 id="烧香/绳子计时1小时15分钟">烧香/绳子计时1小时15分钟</h2><pre><code>烧一根不均匀的绳,从头烧到尾总共需要 1 个小时。现在有若干条材质相同的绳子,问 如何用烧绳的方法来计时一个小时十五分钟呢?
</code></pre><p>假设现在有三根绳子A和B和C，现在将A的两端都点着，B的一端都点着<br>半小时过去后，A就烧没了，此时B应该还有半小时的时长可以烧，但是现在把B的另一端也点着<br>又过了十五分钟，B也烧没了，这个时候把C的两端也都点着<br>又过了半小时，C也烧没了<br>好了，一小时十五分钟就这么烧到了^_^<br>其实主要思路还是两端  一端 烧得搭配</p>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《台大机器学习基石》Learning is Possible ]]></title>
    <link href="http://yyl8781697.github.io/2015/08/09/Machine%20Learning/Learning-Is-Possible/"/>
    <id>http://yyl8781697.github.io/2015/08/09/Machine Learning/Learning-Is-Possible/</id>
    <published>2015-08-09T10:55:28.000Z</published>
    <updated>2015-08-23T15:42:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Hoeffding不等式">Hoeffding不等式</h2><p>下面有一个罐子<br><img src="/img/Learning-Is-Possible/guanzi.png" height="140px" width="540px"><br>罐子中的球是橙色的概率是<code>μ</code>，现从罐子中取出<code>N</code>个数量的球作为样本，其中样本中含橙色求的概率是<code>ν</code>，那么<code>μ</code>和<code>ν</code>是否会接近呢？<br><a id="more"></a><br>这里有一个叫做<code>Hoeffding不等式</code>可以来解释该问题<br><img src="/img/Learning-Is-Possible/hfi.png" height="140px" width="540px"><br>大致的表述就是<code>μ</code>与<code>ν</code>之差的绝对值小于<code>ξ</code>的概率为<code>2exp(-2ξ<sup>2</sup>N)</code>（这个概率也叫坏事发生的几率，林老师的叫法真的很kwy ^_^）,<code>ξ</code>越小，<code>μ</code>与<code>ν</code>越接近，其概率：</p>
<ul>
<li><code>ξ</code>越大，坏事发生的几率越小，但是<code>ξ</code>真的很大时，坏事发不发生已经么啥意义了-_-</li>
<li><code>N</code>越大，坏事发生的几率越小，<code>μ</code>与<code>ν</code>会越来越接近,所以取样时大一点可以增加准确率.<blockquote>
<p>将<code>N</code>取到总得数量，那就是<code>μ</code>=<code>ν</code></p>
</blockquote>
</li>
</ul>
<pre><code><span class="attribute">这里的‘μ</span>=<span class="string">ν’的状态问题称为probably approximately correct（PAC）问题，表示大概差不多是对的。 </span>
</code></pre><p>所以，取的样本够大的时候，未知的<code>μ</code>可以从已知的<code>ν</code>推论出来，并且他们俩是类似的。</p>
<h2 id="应用于Learning">应用于Learning</h2><p>假设当前一个学习算法的最终的实际假设是<code>f(x)</code>(一般是未知的)，其<code>h(x)</code>表示采样了之后的假设，其<code>y<sub>n</sub></code>为对应样本上的目标值。<br><img src="/img/Learning-Is-Possible/le.png" height="200px" width="340px"><br>这里的<code>E<sub>out</sub>(h)</code>和<code>E<sub>in</sub>(h)</code>正好就是对应上一节的<code>μ</code>=<code>ν</code><br><code>Hoeffding不等式</code>同样是适用于Learning问题<br><img src="/img/Learning-Is-Possible/lf.png" height="240px" width="540px"><br>所以在Learning的时候，可以从<code>E<sub>in</sub>(h)</code>来推断出<code>E<sub>out</sub>(h)</code>，也就是我们的Learning目的<br><img src="/img/Learning-Is-Possible/eio.png" height="240px" width="340px"></p>
<p>上面如果能得到一个很小的<code>E<sub>in</sub>(h)</code>，当然是皆大欢喜，此时<code>g’=f’</code>(g,f分别对应h(x)和f(x)对应的线/假设)，但是要知道其实在算法上其实有很多h可以选，那时候选择到得<code>E<sub>in</sub>(h)</code>比较大得时候，那就比较悲催了，所以真实地学习应该是：<br><img src="/img/Learning-Is-Possible/rl.png" height="240px" width="340px"><br>像<code>PLA</code>一样选一根最优的线。</p>
<p><code>Hoeffding不等式</code>只能保证<code>E<sub>in</sub>(h)</code>和<code>E<sub>out</sub>(h)</code>会有一个较大的几率说明他俩是相似的，但是无法保证在非常多得假设下(h(x))下，<code>E<sub>in</sub>(h)</code>的值时比较小，那如果最终<code>E<sub>in</sub>(h)</code>的值比较大，那么最终学习的算法就不好了，这个也叫做踩雷过程(这也可能使由于样本原因造成的)<br><img src="/img/Learning-Is-Possible/cl.png" height="440px" width="440px"><br>现在有<code>M</code>个假设，同时数据集可能会有表中的几个样本采样出来，<code>BAD</code>标志就是表示当前假设下在对应的样本上是踩雷了(<code>E<sub>in</sub>(h)</code>)很大</p>
<blockquote>
<p>但是学习算法最希望的就是自由的选择具体假设下，能够得到具体的<code>BAD</code>几率</p>
</blockquote>
<p>这里可以使用联合<code>bound</code>的方式来求总体的<code>BAD</code>几率<br><img src="/img/Learning-Is-Possible/mpla.png" height="240px" width="540px"><br>从式子中可以发现最终的几率是加上了<code>M</code>的<code>Hoeffding不等式</code>几率</p>
<h2 id="关于M的无限大问题">关于M的无限大问题</h2><p>上面知道<code>M</code>表示所有假设，而比如在<code>PLA</code>问题中可以了解到其实平面上会有无数条线，也就是无数条假设(M)，那这样其实上一小节中计算出来的几率会变无限大吗？那不是白搭了嘛-_-</p>
<p>这里先换个思路想一下：<br><img src="/img/Learning-Is-Possible/plk.png" height="240px" width="240px"><br>上图的<code>PLA</code>只有一个点，上面画了可能存在的三条线，其实可以发现这两条实线是一个含义，这里只有两种线而已(一虚一实)<br>再者看一下两个点的<br><img src="/img/Learning-Is-Possible/plk2.png" height="340px" width="540px"><br>它就会有四种线<br>还有看一下三个点得<br><img src="/img/Learning-Is-Possible/plk3.png" height="440px" width="540px"><br>它最终会有八种线(其实如果这三个点成一条直线或者重叠在一个点上面的话不会有这么多)<br>再推演下去会有这么一个规律<br><img src="/img/Learning-Is-Possible/s.png" height="340px" width="200px"><br>在二维上，平面上划分这些点的种类数总是小于<code>2^N</code></p>
<p>现在假设使用<code>m<sub>H</sub>(N)</code>来表示<code>N</code>个点的时候可能出现的最大分类线种数<code>dichotomies</code><br><img src="/img/Learning-Is-Possible/mh.png" height="240px" width="540px"><br>那么这个<code>m<sub>H</sub>(N)</code>的上界就是<code>2^N</code>，这个函数也叫做成长函数(Growth Function)</p>
<p>现在综合看一下其他维度的成长函数值:</p>
<ul>
<li>一维的二分类 <code>N+1</code><br>  <img src="/img/Learning-Is-Possible/rays.png" height="400px" width="400px"></li>
<li>一维的二分类（使用中间区间分开） <code>1/2*N<sup>2</sup>+1/2*N+1</code><br>  <img src="/img/Learning-Is-Possible/int.png" height="400px" width="400px"></li>
<li>可以绕成一圈的凸集合 <code>2<sup>N</sup></code><br>  <img src="/img/Learning-Is-Possible/sc.png" height="400px" width="400px"><blockquote>
<p>这里类似凸集的情况下N个点可能hold住<code>2<sup>N</sup></code>分类面的情况叫<code>shattered</code></p>
</blockquote>
</li>
</ul>
<p><img src="/img/Learning-Is-Possible/mhv.png" height="300px" width="500px"><br>那么好了，如果<code>m<sub>H</sub>(N)</code>能直接取代<code>M</code>,同时<code>m<sub>H</sub>(N)</code>为多项式的话，<code>N</code>越大，那个这个<code>upbound</code>会越来越小，或者接近于0<br><img src="/img/Learning-Is-Possible/qd.png" height="300px" width="500px"></p>
<p>现在来看一个<code>break point</code>的概念<br><img src="/img/Learning-Is-Possible/bp.png" height="300px" width="400px"><br>表示第一个无法<code>shattered</code>的点,比如在上面<code>lines in 2D</code>的图里面在3个点的时候最多有8条线(2^3)，正好是<code>shattered</code>,但是到了4个点的时候最多只有14条线，此时就无法<code>shattered</code>,故4就是<code>2D-PLA</code>的<code>break point</code>，同理<br><img src="/img/Learning-Is-Possible/bps.png" height="300px" width="400px"><br>那么这里可以通过推算最终可以知道<code>m<sub>H</sub>(N)=O(N^(k-1))</code>（具体证明要看看下一个视频VC维相关）,其中这里的<code>k</code>表示<code>break point</code>，这样就可以说上上上面的<code>m<sub>H</sub>(N)</code>是有限的，关于如果代替<code>M</code>的问题还得看下个分解。</p>
<h2 id="总结">总结</h2><p>所以当算法的该含有一个有限的<code>break point</code>的时候，并且采样的资料量<code>N</code>够多，就可以保证找到一个<code>E<sub>in</sub>(h)</code>最小的时候，得到最小的<code>E<sub>out</sub>(h)</code>,也就是说明Learning的可行性。（好绕）^_^</p>
<h2 id="参考">参考</h2><ul>
<li>《台湾国立大学-机器学习基石》第四讲</li>
<li>《台湾国立大学-机器学习基石》第五讲</li>
<li>《台湾国立大学-机器学习基石》第六讲</li>
</ul>
<p>配图均来自《台湾国立大学-机器学习基石》</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Hoeffding不等式">Hoeffding不等式</h2><p>下面有一个罐子<br><img src="/img/Learning-Is-Possible/guanzi.png" height="140px" width="540px" /><br>罐子中的球是橙色的概率是<code>μ</code>，现从罐子中取出<code>N</code>个数量的球作为样本，其中样本中含橙色求的概率是<code>ν</code>，那么<code>μ</code>和<code>ν</code>是否会接近呢？<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《台大机器学习基石》Perceptron Learning Algorithm ]]></title>
    <link href="http://yyl8781697.github.io/2015/08/06/Machine%20Learning/Perceptron-Learning-Algorithm/"/>
    <id>http://yyl8781697.github.io/2015/08/06/Machine Learning/Perceptron-Learning-Algorithm/</id>
    <published>2015-08-06T13:15:25.000Z</published>
    <updated>2015-08-23T15:31:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Perceptron">Perceptron</h2><p>先来看一下一个经典的信用卡发放问题：<br><img src="/img/Perceptron-Learning-Algorithm/credit.png" height="140px" width="400px"><br>这是一个用户的基本的信息，现在要决定是否对他发放信用卡。</p>
<p>现在假设这些基本信息组成了一个向量X={x1,x2,…xd}<br>同时对于每一维度上有一个对应的权重向量W={w1,w2,…wd}<br><img src="/img/Perceptron-Learning-Algorithm/wx.png" height="140px" width="400px"><br>那么如果这两个向量乘积出来的值大于一个设定的阈值，我们就发他信用卡，否则就不发<br><a id="more"></a><br><img src="/img/Perceptron-Learning-Algorithm/y.png" height="140px" width="400px"><br>相应的表示：</p>
<ul>
<li><code>y=+1</code> 表示发卡，<code>y=-1</code>表示不发</li>
<li><code>sign</code>是一个取符号函数<code>sign(x) = 1 if x&gt;0, -1 otherwise</code></li>
<li>这里的<code>h</code>与<code>wi</code>的权重有关，以及与阈值<code>threshold</code>有关，这里的<code>h</code>就是叫做感知机</li>
</ul>
<pre><code>有了以上描述之后，我们需要电脑做的就是通过个人的基本信息以及每个维度上的权重算出一个分数值，如果这个分数值大于一个设定的阈值，如果超过这个阈值，最终得到的就判定给该用户发卡，否则不发信用卡。
</code></pre><p>这里我们将阈值<code>threshold</code>做一个简化<br><img src="/img/Perceptron-Learning-Algorithm/sum.png" height="340px" width="400px"><br>相当于是加一个第0维度，该维度上的权重就是这个阈值，这么做的好处就是<code>h</code>就变成了两个向量的内积</p>
<p>好，用形象的方式来表述，下面当只有2个属性的时候<br><img src="/img/Perceptron-Learning-Algorithm/h.png" height="340px" width="400px"></p>
<ul>
<li>(x1,x2)可以构成平面上的点</li>
<li>标签值<code>y</code>：圆圈表示+1,叉叉表示-1</li>
<li><code>h</code>就表示为平面上的线，其中线的一端是+1，另一端是-1</li>
</ul>
<blockquote>
<p>所以，感知机其实是一个线性的二元分类器</p>
</blockquote>
<p>还有，该平面上其实有无线条线（也就是<code>hypothesis set</code>），那如何能找到一条最合理的线(<code>hypothesis</code>)来完成发放信用卡得判断呢？</p>
<h2 id="Perceptron_Learning_Algorithm_(PLA)">Perceptron Learning Algorithm (PLA)</h2><p>现在我们是需要找到一个g(x) 这个g(x)≈f(x) 最近越好，也就是yn<br><img src="/img/Perceptron-Learning-Algorithm/g0.png" height="240px" width="240px"><br>首先我们从一个随机的线g0出发，这个g0可能不够好(这个g0这根线可以使用w0这个向量来表示，初始时都是0向量)，所以我们需要调整w的值来判断的改进学习g(x),直到到每个gn的时候每个点都判断正确(这里的t表示当前的一个样本点)</p>
<p><img src="/img/Perceptron-Learning-Algorithm/mistake.png" height="140px" width="240px"><br>那么如果这个线还不够好的话，那么必定存在一个点，它是分类错误的(犯错)，我们现在就可以根据这个点来进行调整<br>那么就会有两种情况：</p>
<ol>
<li>我要的是yn=+1，但是经过g(x)之后为-1，那么也就是说w和x向量的角度太大，我们需要转向x端，也就是更新为w:=w+x</li>
<li>我要的是yn=-1，但是经过g(x)之后为+1，那么也就是说w和x向量的角度太小，我们需要远离x端，也就是更新为w:=w-x<br><img src="/img/Perceptron-Learning-Algorithm/jd.png" height="340px" width="240px"><br>最终用一个式子来表示w的更新就是为<br><img src="/img/Perceptron-Learning-Algorithm/update.png" height="100px" width="240px"><br>直到这根线不再犯错，那么整个过程就是叫做<code>Perceptron Learning Algorithm (PLA)</code> </li>
</ol>
<p>那如果简单的判断当前的线g有没有犯错误？一种常见的方式就是使用<code>cycle PLA</code><br><img src="/img/Perceptron-Learning-Algorithm/cyclePLA.png" height="500px" width="500px"><br>这整个过程描述如下：</p>
<ol>
<li>假设现在有n个点，我们从1,2,3到逐个遍历过去</li>
<li>如果当前的点没有犯错，那么我们进入下一个，否则我们就做刚刚的错误修正，然后再进入下一个点</li>
<li>直到遍历了n个点又绕回来并且全部没有错得时候停止</li>
</ol>
<blockquote>
<p>这里的循环时可以依次1~N进行遍历循环，也可以进行乱序循环(建议^_^)</p>
</blockquote>
<p>现在留下两个问题：</p>
<ol>
<li>PLA在学习过程中一定会停下来吗？？</li>
<li>最终学习出来的先g能适用于训练以外的样本吗？</li>
</ol>
<h2 id="PLA_算法是否能正常终止">PLA 算法是否能正常终止</h2><p>先来看一下下面的几种数据情况<br><img src="/img/Perceptron-Learning-Algorithm/linerS.png" alt=""><br>其中第一幅图为线性可分，第二、三幅图为线性不可分</p>
<p>其中PLA算法只能在线性可分的数据下才可能终止运算（因为在线性不可分的数据中铁定没有那么一条线来划分两类数据，连线都没有，谈何停止）<br>现在假设有存在正确分类的线<code>w<sub>f</sub></code>,<code>w<sub>t</sub></code>为训练时的线</p>
<h3 id="wf和wt越来越接近">w<sub>f</sub>和w<sub>t</sub>越来越接近</h3><p><img src="/img/Perceptron-Learning-Algorithm/wf.png" height="340px" width="540px"></p>
<ul>
<li>那么该线与任意一点的内积乘以标签值一定是大于0的，也就是说其最小值是大于0的（上图的蓝色部分）</li>
<li>同时在学习训练过程中，在进行w全职的矫正之后，矫正点与当前权重的内积与目标值的乘积一定是大于目标权重相应计算值的最小值的(红色部分)</li>
</ul>
<p>现在来看一下目标权重<code>w<sub>f</sub></code>与当前训练权重<code>w<sub>t</sub></code>的关系（两个向量的内积可以衡量他们的相似度,表示角度上的接近）<br><img src="/img/Perceptron-Learning-Algorithm/neiji.png" height="340px" width="540px"><br>从上面的式子可以看出，每作出一次矫正，目标权重与当前权重的相似度就更加进一步，也就是说明<code>每一次矫正权重是有效的</code></p>
<h3 id="wt会缓慢的增长">w<sub>t</sub>会缓慢的增长</h3><p>因为PLA算法在只有犯错（预测错误）的时候才会进行权重的矫正，那么犯错的判断为<br><img src="/img/Perceptron-Learning-Algorithm/mistakeInq.png" height="140px" width="540px"><br>现在来看<code>w<sub>t</sub></code>矫正（增长）之后的值<code>w<sub>t+1</sub></code><br><img src="/img/Perceptron-Learning-Algorithm/wt1.png" height="440px" width="340px"><br>其中蓝色的部分正好为判断错误的不等式，恒小于0，而红色部分使用最大的点来代替之后，不等式成立<br>所以增长时<code>w<sub>t+1</sub></code>由上一个<code>x<sub>n</sub></code>决定，并且是在一个有界的范围内增长，比较缓慢。</p>
<h3 id="证明收敛">证明收敛</h3><p>结合以上两个式子，可以得出<br><img src="/img/Perceptron-Learning-Algorithm/prov.png" height="340px" width="540px"><br>这表示两个正规化向量内积，为他们真正的相似<br>其中<br><img src="/img/Perceptron-Learning-Algorithm/hm.png" height="70px" width="140px">为一个常数<br>所以可以得到随着T的越来越大，<code>w<sub>f</sub></code>,<code>w<sub>t</sub></code>的夹角会越来越小，<br>向量夹角余弦值不会大于1，可知T 的值有，证明了简单的PLA 算法可以收敛，也就是他会停下来 。</p>
<p>在</p>
<ol>
<li>数据是线性可分的，<code>w<sub>t</sub></code>会越来越接近<code>w<sub>f</sub></code></li>
<li>总是在犯错的情况下进行权值的矫正，<code>w<sub>t</sub></code>会进行一个缓慢的增长<br>的条件下，最终简单PLA会正常终止</li>
</ol>
<h2 id="线性不可分的PLA">线性不可分的PLA</h2><blockquote>
<p>如果得到数据是线性不可分怎么办（数据里面还有噪声），此时简单的PLA无法收敛</p>
</blockquote>
<p>但是我们有一种退而求其次的方法<br><img src="/img/Perceptron-Learning-Algorithm/nonpla.png" height="340px" width="540px"><br>在学习PLA算法的时候最终不一定要每个点都进行正确地划分，<strong>而是求最终出来的线分错的点最少</strong>（这根线不是完美的线，但是是一个最优的线）<br>但是求解那个最优的线是一个NP难题-_-</p>
<p>下面来介绍一种叫<code>Pocket Algorithm</code>算法可以近似的求解最优<br><img src="/img/Perceptron-Learning-Algorithm/pa.png" height="440px" width="540px"><br>该算法与简单PLA最大的区别就是：</p>
<ol>
<li>它不是一轮一轮的遍历数据，而是去随机取一个点来进行判断</li>
<li>只有当矫正了权重之后的犯错率（见那个min的公式）小于当前的权重的犯错率时，才会进行权重的更新<blockquote>
<p>这里的检测错误率额代价很大，应该是要遍历一遍样本才可以知道-_-</p>
</blockquote>
</li>
<li>它是提前设定了迭代次数</li>
</ol>
<h2 id="参考">参考</h2><ul>
<li>《台湾国立大学-机器学习基石》第二讲</li>
<li><a href="http://www.douban.com/note/319669984/" target="_blank" rel="external">http://www.douban.com/note/319669984/</a></li>
</ul>
<p>配图均来自《台湾国立大学-机器学习基石》</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Perceptron">Perceptron</h2><p>先来看一下一个经典的信用卡发放问题：<br><img src="/img/Perceptron-Learning-Algorithm/credit.png" height="140px" width="400px" /><br>这是一个用户的基本的信息，现在要决定是否对他发放信用卡。</p>
<p>现在假设这些基本信息组成了一个向量X={x1,x2,…xd}<br>同时对于每一维度上有一个对应的权重向量W={w1,w2,…wd}<br><img src="/img/Perceptron-Learning-Algorithm/wx.png" height="140px" width="400px" /><br>那么如果这两个向量乘积出来的值大于一个设定的阈值，我们就发他信用卡，否则就不发<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://yyl8781697.github.io/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[判断当前序列是否是二叉查找树的后续遍历结果]]></title>
    <link href="http://yyl8781697.github.io/2015/08/04/Algorithm/IsBSTPostOrder/"/>
    <id>http://yyl8781697.github.io/2015/08/04/Algorithm/IsBSTPostOrder/</id>
    <published>2015-08-04T13:54:53.000Z</published>
    <updated>2015-08-04T14:16:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><pre><code>输入一个整数数组,判断该数组是不是某二元查找树的后序遍历的结果。 如果是返回 <span class="literal">true</span>,否则返回 <span class="literal">false</span>。
例如输入 <span class="number">5</span>、<span class="number">7</span>、<span class="number">6</span>、<span class="number">9</span>、<span class="number">11</span>、<span class="number">10</span>、<span class="number">8</span>,由于这一整数序列是如下树的后序遍历结果:
      <span class="number">8</span> 
     / <span class="string">\</span>
    <span class="number">6</span>  <span class="number">10</span> 
   /<span class="string">\</span>   /<span class="string">\</span> 
  <span class="number">5</span>  <span class="number">7</span> <span class="number">9</span>  <span class="number">11</span>
因此返回 <span class="literal">true</span>。
如果输入 <span class="number">7</span>、<span class="number">4</span>、<span class="number">6</span>、<span class="number">5</span>,没有哪棵树的后序遍历的结果是这个序列,因此返回 <span class="literal">false</span>
</code></pre><h2 id="解析">解析</h2><p>做该题之前还必须得了解什么是<a href="http://kubicode.me/2015/06/29/Data%20Struct/Binary-Search-Tree/" target="_blank" rel="external">二叉查找树</a><br>最主要的性质就是左子树的任何节点都小于根节点，右子树的任何节点都大于根节点。<br>然后后序遍历的最后一位肯定是根节点，所以，可以得到巧妙的方法为：<br>则该序列的最后一位a[n-1]必定是根节点，然后前面的序列中连续一部分是左子树的遍历，另一部份是右子树的遍历<br>此时需要在前面的序列中查找第一个大于root的节点a[i]<br><a id="more"></a></p>
<pre><code>来个例子：后序遍历5、7，6，9，11，10，8
第一次迭代：根节点为8 然后从左遍历过来可以发现9为首个大于8的地方，那么如果再9后面的都大于8的话就可以判断9以及后面的为8的右子树
此时成立，8的左子树为5,7,6 右子树为9,11,10
第二次迭代：
左子树  6为根节点  同理7为6的右子树，5为6的左子树
右子树  10为根节点  同理11为10的右子树 9为11的左子树
剩余各个左右子树的各个孩子节点都为空，迭代停止，该序列为后序遍历

再来看7、4，6，5
其中5为根节点，7为第一个大于5的节点，但是7之后的4小于5，所以7以及后面的数字不可能为5的右子树，同时又不可能为左子树，所以不成立
</code></pre><h2 id="代码">代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 通过左右子树的递归序列判断他们是否也能构成二叉查找树即可</span><br><span class="line"> *<span class="javadoctag"> @param</span> a</span><br><span class="line"> *<span class="javadoctag"> @param</span> left</span><br><span class="line"> *<span class="javadoctag"> @param</span> right</span><br><span class="line"> *<span class="javadoctag"> @return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBSTPostOrder</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//这两个小于0的判断都是因为仅存在左子树 或者 仅存在右子树的时候 存在left必定会大于right</span></span><br><span class="line">	<span class="keyword">if</span>(left&gt;=right)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> root=a[right];</span><br><span class="line">	<span class="keyword">int</span> mid=-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;right;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(mid!=-<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&lt;root)</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//第一个大于root后面的节点存在小于root的节点  直接返回false</span></span><br><span class="line">		&#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(a[i]&gt;root)</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			mid=i;<span class="comment">//查找第一个大于root的值</span></span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(mid==-<span class="number">1</span>)</span><br><span class="line">		mid=right;<span class="comment">//表示只有左子树</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//分别递归左右子树</span></span><br><span class="line">	<span class="keyword">return</span> isBSTPostOrder(a,left,mid-<span class="number">1</span>) &amp;&amp; isBSTPostOrder(a,mid,right-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a=&#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">8</span>&#125;;<span class="comment">//ok</span></span><br><span class="line"><span class="keyword">int</span>[] b=&#123;<span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;<span class="comment">//not ok</span></span><br><span class="line">System.out.println(isBSTPostOrder(a,<span class="number">0</span>,a.length-<span class="number">1</span>));</span><br><span class="line">System.out.println(isBSTPostOrder(b,<span class="number">0</span>,b.length-<span class="number">1</span>));</span><br></pre></td></tr></table></figure></p>
<pre><code><span class="literal">true</span>
<span class="literal">false</span>
</code></pre><h2 id="参考">参考</h2><p>July 微软面试100题 第9题</p>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><pre><code>输入一个整数数组,判断该数组是不是某二元查找树的后序遍历的结果。 如果是返回 <span class="literal">true</span>,否则返回 <span class="literal">false</span>。
例如输入 <span class="number">5</span>、<span class="number">7</span>、<span class="number">6</span>、<span class="number">9</span>、<span class="number">11</span>、<span class="number">10</span>、<span class="number">8</span>,由于这一整数序列是如下树的后序遍历结果:
      <span class="number">8</span> 
     / <span class="string">\</span>
    <span class="number">6</span>  <span class="number">10</span> 
   /<span class="string">\</span>   /<span class="string">\</span> 
  <span class="number">5</span>  <span class="number">7</span> <span class="number">9</span>  <span class="number">11</span>
因此返回 <span class="literal">true</span>。
如果输入 <span class="number">7</span>、<span class="number">4</span>、<span class="number">6</span>、<span class="number">5</span>,没有哪棵树的后序遍历的结果是这个序列,因此返回 <span class="literal">false</span>
</code></pre><h2 id="解析">解析</h2><p>做该题之前还必须得了解什么是<a href="http://kubicode.me/2015/06/29/Data%20Struct/Binary-Search-Tree/">二叉查找树</a><br>最主要的性质就是左子树的任何节点都小于根节点，右子树的任何节点都大于根节点。<br>然后后序遍历的最后一位肯定是根节点，所以，可以得到巧妙的方法为：<br>则该序列的最后一位a[n-1]必定是根节点，然后前面的序列中连续一部分是左子树的遍历，另一部份是右子树的遍历<br>此时需要在前面的序列中查找第一个大于root的节点a[i]<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yyl8781697.github.io/categories/Algorithm/"/>
    
  </entry>
  
</feed>