
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>《Effective Java》第二章：创建和销毁对象 | Kubi Code&#39;Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Kubi Code">
    

    
    <meta name="description" content="本章的主题是创建和销毁对象：何时以及如何创建对象，何时以及如何避免创建对象，如何确保它们能够适时得销毁，以及如何管理对象和销毁之前必须进行的各种清理动作。
第1条：考虑用静态工厂方法代替构造器
这条感觉就是推荐我们尽量使用静态方法来生成实例对象。

1234public static Boolean valueOf(boolean b)&amp;#123;	return b?Boolean.TRUE:Bo">
<meta property="og:type" content="article">
<meta property="og:title" content="《Effective Java》第二章：创建和销毁对象">
<meta property="og:url" content="http://yyl8781697.github.io/2015/04/22/Effective Java/Create-Destory-Object/index.html">
<meta property="og:site_name" content="Kubi Code'Blog">
<meta property="og:description" content="本章的主题是创建和销毁对象：何时以及如何创建对象，何时以及如何避免创建对象，如何确保它们能够适时得销毁，以及如何管理对象和销毁之前必须进行的各种清理动作。
第1条：考虑用静态工厂方法代替构造器
这条感觉就是推荐我们尽量使用静态方法来生成实例对象。

1234public static Boolean valueOf(boolean b)&amp;#123;	return b?Boolean.TRUE:Bo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《Effective Java》第二章：创建和销毁对象">
<meta name="twitter:description" content="本章的主题是创建和销毁对象：何时以及如何创建对象，何时以及如何避免创建对象，如何确保它们能够适时得销毁，以及如何管理对象和销毁之前必须进行的各种清理动作。
第1条：考虑用静态工厂方法代替构造器
这条感觉就是推荐我们尽量使用静态方法来生成实例对象。

1234public static Boolean valueOf(boolean b)&amp;#123;	return b?Boolean.TRUE:Bo">

    
    <link rel="alternative" href="/atom.xml" title="Kubi Code&#39;Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/simpson.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/bart-simpson-09.png" alt="Kubi Code&#39;Blog" title="Kubi Code&#39;Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Kubi Code&#39;Blog">Kubi Code&#39;Blog</a></h1>
				<h2 class="blog-motto">The palest ink is better than the best memory.</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/books">Books</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yyl8781697.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/04/22/Effective Java/Create-Destory-Object/" title="《Effective Java》第二章：创建和销毁对象" itemprop="url">《Effective Java》第二章：创建和销毁对象</a>
  </h1>
  <p class="article-author">By
       
		<a href="http://yyl8781697.github.io/about" title="Kubi Code" target="_blank" itemprop="author">Kubi Code</a>
		
  <p class="article-time">
    <time datetime="2015-04-22T12:33:05.000Z" itemprop="datePublished"> 发表于 2015-04-22</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第1条：考虑用静态工厂方法代替构造器"><span class="toc-number">1.</span> <span class="toc-text">第1条：考虑用静态工厂方法代替构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第2条：遇到多个构造器参数的时候要考虑用构建器"><span class="toc-number">2.</span> <span class="toc-text">第2条：遇到多个构造器参数的时候要考虑用构建器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#重叠构造器"><span class="toc-number">2.1.</span> <span class="toc-text">重叠构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用setter方法来设置参数"><span class="toc-number">2.2.</span> <span class="toc-text">使用setter方法来设置参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Builder模式"><span class="toc-number">2.3.</span> <span class="toc-text">使用Builder模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第3条：用私有的构造器或者枚举类型强化Singleton属性"><span class="toc-number">3.</span> <span class="toc-text">第3条：用私有的构造器或者枚举类型强化Singleton属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第4条：通过私有构造器强化不可实例化的能力"><span class="toc-number">4.</span> <span class="toc-text">第4条：通过私有构造器强化不可实例化的能力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第5条：避免创建不必要的对象"><span class="toc-number">5.</span> <span class="toc-text">第5条：避免创建不必要的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第6条：消除过期的引用"><span class="toc-number">6.</span> <span class="toc-text">第6条：消除过期的引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第7条：避免终结方法"><span class="toc-number">7.</span> <span class="toc-text">第7条：避免终结方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">8.</span> <span class="toc-text">参考</span></a></li></ol>
		
		</div>
		
		<p>本章的主题是创建和销毁对象：何时以及如何创建对象，何时以及如何避免创建对象，如何确保它们能够适时得销毁，以及如何管理对象和销毁之前必须进行的各种清理动作。</p>
<h2 id="第1条：考虑用静态工厂方法代替构造器">第1条：考虑用静态工厂方法代替构造器</h2><blockquote>
<p>这条感觉就是推荐我们尽量使用静态方法来生成实例对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b?Boolean.TRUE:Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>推荐的理由如下：</p>
<ol>
<li>静态构造方法有自己的名称。（这理由是不是有点。。，个人感觉绝大部分程序猿在创建对象时都是首先尝试<code>new Construct()</code>）</li>
<li>不必在每次调用它们时都创建一个新的对象。(单例中比较常用吧)</li>
<li>它们可以返回原返回类型的任何子类型的对象。（<strong>这个特征的确是比较有优势一点</strong>）</li>
<li>在创建参数化类型实例的时候，它们使代码变得更加简洁。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通是需要这么干的</span></span><br><span class="line">Map&lt;String,List&lt;String&gt;&gt; m=<span class="keyword">new</span> HashMap&lt;String,List&lt;String&gt;&gt;();</span><br><span class="line"><span class="comment">//使用了第4条直接这么干就好了（但是实际上HashMap也没提供这个功能啊-_-）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;K,V&gt; HashMap&lt;K,V&gt; newInstance()&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;K,V&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然使用这种静态方法也有缺点：</p>
<ol>
<li>类如何不含有公有的或者受保护的构造器，就不能子类化。</li>
<li>它们与其他的静态方法实际上没有任何区别。</li>
</ol>
<p>一些静态工厂方法的惯用名称（也的确常见）：</p>
<ul>
<li>ValueOf</li>
<li>of</li>
<li>getInstance</li>
<li>newInstance</li>
<li>getType</li>
<li>newType</li>
</ul>
<h2 id="第2条：遇到多个构造器参数的时候要考虑用构建器">第2条：遇到多个构造器参数的时候要考虑用构建器</h2><p>当你的<code>Class</code>有多个自定义参数需要初始化的时候-_-</p>
<h3 id="重叠构造器">重叠构造器</h3><p>你可能会使用重叠构造器来编写代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="comment">//field</span></span><br><span class="line">	Test(arg1)<span class="comment">//</span></span><br><span class="line">	Test(arg1,arg2)<span class="comment">//</span></span><br><span class="line">	Test(arg1,arg2,arg3)<span class="comment">//</span></span><br><span class="line">	Test(arg1,arg2,arg3,arg4)<span class="comment">//</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是当需要初始化的参数实在太多的时候，这个<code>Class</code>的构造函数很快就会失去控制，而且在调用构造器的时候也会因为要初始化的参数太多而弄混。</p>
<h3 id="使用setter方法来设置参数">使用setter方法来设置参数</h3><p>即<code>JavaBean</code>模式，在这种模式下调用一个无参构造器来创建对象，然后调用setter方法来设置每个必要的参数，以及每个可选参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="comment">//field</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(arg1)</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArg1</span><span class="params">(arg1)</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArg1</span><span class="params">(arg2)</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArg1</span><span class="params">(arg3)</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArg1</span><span class="params">(arg4)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种模式弥补重叠构造器模式的不足，创建对象实例很容易，并且代码读起来也很容易：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Test test=<span class="keyword">new</span> Test();</span><br><span class="line">test.setArg1(..)</span><br><span class="line">test.setArg2(..)</span><br><span class="line">test.setArg3(..)</span><br><span class="line">test.setArg4(..)</span><br></pre></td></tr></table></figure>
<p>但是它有一个严重的缺点，就是这个构造过程被分到几个不同的调用中时，该对象可能处于不一致的状态。-_-</p>
<h3 id="使用Builder模式">使用Builder模式</h3><p>它既能保证那重叠构造器那样安全，也能保证像<code>JavaBean</code>那样有好的可读性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="comment">//field</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">		<span class="comment">//filed=builder.filed...</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">		<span class="comment">//field</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArg1</span><span class="params">(arg1)</span></span>&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArg1</span><span class="params">(arg2)</span></span>&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArg1</span><span class="params">(arg3)</span></span>&#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArg1</span><span class="params">(arg4)</span></span>&#123;&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Test <span class="title">build</span><span class="params">()</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Test(<span class="keyword">this</span>);<span class="comment">//通过内部类构造该类</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种模式其实是生成一个内部类，在内部类中通过<code>setter</code>方法设置相应的字段，然后调用<code>build</code>方法生成真正需要的<code>Class</code>实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Test test=<span class="keyword">new</span> Test.Builder()</span><br><span class="line">				.setArg1()</span><br><span class="line">				.setArg2()</span><br><span class="line">				.setArg3()</span><br><span class="line">				.setArg4()</span><br><span class="line">				.build()</span><br></pre></td></tr></table></figure>
<p>这个方法十分灵活，可以通过构建一个builder来构建多个对象，builder的参数可以在构建期间进行调整，也可以随不同的对象而改变。<br><br>此时，我们可以将这个builder定义为一个通用的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以通过创建接口来创建更多的实例对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Builder&lt;Test&gt; builderTest=<span class="keyword">new</span> Test.Builder()</span><br><span class="line">.setArg1()</span><br><span class="line">.setArg2()</span><br><span class="line">.setArg3()</span><br><span class="line">.setArg4()</span><br><span class="line"></span><br><span class="line">builderTest.build()</span><br></pre></td></tr></table></figure>
<p>Builder模式也有不足之处，为了创建对象，必须创建它的构建器，虽然创建构建器的开销在实践中不是那么明显，但是在某些十分注重性能的情况下，可能会成功问题。<br><br>简而言之，如果累的构造器或者静态工厂中具有多个参数，设计这种类时,Builder模式模式是一个不错的选择。</p>
<h2 id="第3条：用私有的构造器或者枚举类型强化Singleton属性">第3条：用私有的构造器或者枚举类型强化Singleton属性</h2><p>单例模式估计是大家在《设计模式》中最早接触的一种，也是较为常用的一种模式，从它的线程安全性和运行效率性上考虑，我们所了解的应该有这么几种类型的单例写法<sup>1<sup>：</sup></sup></p>
<ul>
<li>懒汉式单例</li>
<li>饿汉式单例</li>
<li>登记式单例</li>
</ul>
<p>除了上述，书本极力推荐的一种是<strong>单元素枚举类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Elvis&#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span></span>&#123;<span class="comment">//...&#125;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法无偿的提供了序列化机制，绝对防止多次实例化。但是由于为了使用单例将”类”改为了”枚举”，这样就是导致丢掉一些类的特征，比如说继承，因为枚举是默认继承<code>java.lang.Enum</code>。</p>
<h2 id="第4条：通过私有构造器强化不可实例化的能力">第4条：通过私有构造器强化不可实例化的能力</h2><p>当你的类里面只包含静态方法和静态变量时（比如说工具类），那么请在该类上添加一个私有的构造器，这样可以保护该类，同时也不会误导用户。<br><br>当然这么写有个副作用就是这个类就不能被继承了，子类就没有访问超类的构造器可用了。</p>
<h2 id="第5条：避免创建不必要的对象">第5条：避免创建不必要的对象</h2><p>一般来说，最好能重用对象而不是在每次需要的时候就创建一个项目功能的新对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String s=<span class="keyword">new</span> String(<span class="string">"stringette"</span>);<span class="comment">//不要这么做</span></span><br><span class="line">String s=<span class="string">"stringette"</span>;<span class="comment">//在同一台虚拟机中运行时，该对象会被重用</span></span><br></pre></td></tr></table></figure>
<p>几大重用的关键点：</p>
<ul>
<li>对于同时提供了静态工厂方法和构造器的不可变类，通常可以使用静态工厂方法，以免创建不必要的对象。</li>
<li>可以重用那些已知不会被修改的可变对象。</li>
<li>优先使用基本类型而不是装箱类型。</li>
</ul>
<blockquote>
<p>本条目并不是暗示“创建对象的代价非常昂贵，我们应该要尽量避免对象的创建”</p>
</blockquote>
<h2 id="第6条：消除过期的引用">第6条：消除过期的引用</h2><p>这条就是描述过期的引用会存在内存泄露的问题，那我们程序猿该如何处理呢？</p>
<blockquote>
<p>类要是自己管理内存，程序猿就应该警惕内存泄露问题。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * 简单的栈结构的实现</span><br><span class="line"> *<span class="javadoctag"> @author</span> yyl  form Effective Java</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object[] elements;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPCAITY=<span class="number">16</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		elements=<span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPCAITY];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		ensureCapacity();<span class="comment">//确保容量足够</span></span><br><span class="line">		elements[size++]=e;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">		<span class="keyword">return</span> elements[--size];<span class="comment">//</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(elements.length==size)</span><br><span class="line">			elements=Arrays.copyOf(elements, <span class="number">2</span>*size+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是一个简单的栈结构的实现，但是在元素被多次<code>pop()</code>之后，<code>Object[]</code>里面索引大于<code>size</code>的对象不在可用，但是由于他们还是存储在数组中，所以垃圾回收机制不会处理这些对象，最终会造成内存泄露。<br><br>可以用下面的方法来修复：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">	Object ret=elements[--size];</span><br><span class="line">	elements[size]=<span class="keyword">null</span>;<span class="comment">//清空引用</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述只是一个特征，这条并不是教我们对于每个对象引用不再用到时就将它清空，其实没有这个必要，这样做会把代码弄得很乱，清除过期引用最好的方法是让包含该引用变量结束生命周期。</p>
<blockquote>
<p>内存泄露另一种常见的来源是缓存</p>
</blockquote>
<p> 当对象放入缓存中很容易被遗忘，然而它会长期存储在内存中，这样可以使用<code>WeakHashMap</code>来代表缓存，当缓存的项过期之后，他们会被自动删除。<br><br>也可以使用<code>LinkedHashMap</code>来实现LRU缓存，当容量满时会删除最久一个没有用过的项。</p>
<blockquote>
<p>内存泄露的第三个常见的来源是监听器和其他回调</p>
</blockquote>
<p>比如说你注册了某些Api的回调，但是没有显示的取消注册，这样他们会越积越多。~~~~</p>
<h2 id="第7条：避免终结方法">第7条：避免终结方法</h2><blockquote>
<p>终结方法（<code>finalizer</code>）通常是不可预测的，也是很危险的，一般情况下是不必要的。</p>
</blockquote>
<p>避免的原因有如下几个：</p>
<ul>
<li><p>不能保证被及时的执行。<br><br>因为进行<code>gc</code>时终结方法的优先级一般比其他的要低，注重时间的任务不应该用终结方法来完成，比如在<code>finalizer</code>中关闭已打开的文件</p>
</li>
<li><p>JVM不会保证他们会被执行。<br><br>不应该依赖终结方法来更新中重要的持久状态。</p>
</li>
<li><p>终结方法可能会有非常重要的性能损失。</p>
</li>
</ul>
<p>所以如果在自己的类中真实的需要将对象终止，则自己最好提供一个显示的终止方法，并且要求编码人员再不需要该对象时进行显示掉调用终止方法，比如<code>file.close</code><br></p>
<p>当然终结方法也不是一无是处：</p>
<ol>
<li>当对象的所有者忘记调用前面段落中建议的显示终止方法时，可以用终止方法在日志中记录记录警告或者再显示的调用该终止方法</li>
<li>与对象的本地对等体有关。大概是普通对象通过<code>native method</code>委托给一个本地对象，而这个本地对象时不受<code>jVM</code>管理的。但是可以使用终结方法来完成必要资源释放，它可以是本地方法，也可以条用本地方法。</li>
</ol>
<blockquote>
<p>注意：<code>finalizer</code>方法链不会自动的执行，所以在自定义<code>finalizer</code>时最好显示得调用<code>super.finalizer()</code></p>
</blockquote>
<h2 id="参考">参考</h2><ol>
<li><a href="http://blog.csdn.net/jason0539/article/details/23297037" target="_blank" rel="external">http://blog.csdn.net/jason0539/article/details/23297037</a></li>
</ol>
<hr>
<blockquote>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">[知识共享署名-非商业性使用-相同方式共享 2.5]</a>中国大陆许可协议进行许可，我的博客欢迎复制共享，但在同时，希望保留我的署名权<a href="http://kubicode.me/" target="_blank" rel="external">kubiCode</a>，并且，不得用于商业用途。如您有任何疑问或者授权方面的协商，请给<a href="http://kubicode.me/about/" target="_blank" rel="external">我留言</a>。</p>
</blockquote>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Effective-Java/">Effective Java</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Java/">Java</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yyl8781697.github.io/2015/04/22/Effective Java/Create-Destory-Object/" data-title="《Effective Java》第二章：创建和销毁对象 | Kubi Code&#39;Blog" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/04/26/Scala/Scala-In-My-Eyes/" title="我眼中的Scala-简洁不简单">
  <strong>上一篇：</strong><br/>
  <span>
  我眼中的Scala-简洁不简单</span>
</a>
</div>


<div class="next">
<a href="/2015/04/21/Java Base/Enum-Override/"  title="关于Java枚举的重写">
 <strong>下一篇：</strong><br/> 
 <span>关于Java枚举的重写
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2015/04/22/Effective Java/Create-Destory-Object/" data-title="《Effective Java》第二章：创建和销毁对象" data-url="http://yyl8781697.github.io/2015/04/22/Effective Java/Create-Destory-Object/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第1条：考虑用静态工厂方法代替构造器"><span class="toc-number">1.</span> <span class="toc-text">第1条：考虑用静态工厂方法代替构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第2条：遇到多个构造器参数的时候要考虑用构建器"><span class="toc-number">2.</span> <span class="toc-text">第2条：遇到多个构造器参数的时候要考虑用构建器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#重叠构造器"><span class="toc-number">2.1.</span> <span class="toc-text">重叠构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用setter方法来设置参数"><span class="toc-number">2.2.</span> <span class="toc-text">使用setter方法来设置参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Builder模式"><span class="toc-number">2.3.</span> <span class="toc-text">使用Builder模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第3条：用私有的构造器或者枚举类型强化Singleton属性"><span class="toc-number">3.</span> <span class="toc-text">第3条：用私有的构造器或者枚举类型强化Singleton属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第4条：通过私有构造器强化不可实例化的能力"><span class="toc-number">4.</span> <span class="toc-text">第4条：通过私有构造器强化不可实例化的能力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第5条：避免创建不必要的对象"><span class="toc-number">5.</span> <span class="toc-text">第5条：避免创建不必要的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第6条：消除过期的引用"><span class="toc-number">6.</span> <span class="toc-text">第6条：消除过期的引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第7条：避免终结方法"><span class="toc-number">7.</span> <span class="toc-text">第7条：避免终结方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">8.</span> <span class="toc-text">参考</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/Akka/" title="Akka">Akka<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Algorithm/" title="Algorithm">Algorithm<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/Asp-Net/" title="Asp.Net">Asp.Net<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/CSharp/" title="CSharp">CSharp<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Data-Struct/" title="Data Struct">Data Struct<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Effective-Java/" title="Effective Java">Effective Java<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/Food/" title="Food">Food<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/Spark/Graphx/" title="Graphx">Graphx<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hadoop/" title="Hadoop">Hadoop<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo/" title="Hexo">Hexo<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java-Base/" title="Java Base">Java Base<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java-Source/" title="Java Source">Java Source<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/Javascript/" title="Javascript">Javascript<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/LeetCode/" title="LeetCode">LeetCode<sup>25</sup></a></li>
		  
		
		  
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Mac/" title="Mac">Mac<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/CSharp/NoSql/" title="NoSql">NoSql<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/OSGi/" title="OSGi">OSGi<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/PHP/" title="PHP">PHP<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Scala/" title="Scala">Scala<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Search-Engine/" title="Search Engine">Search Engine<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Spark/" title="Spark">Spark<sup>5</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/LeetCode/" title="LeetCode">LeetCode<sup>25</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>19</sup></a></li>
			
		
			
				<li><a href="/tags/Algorithm/" title="Algorithm">Algorithm<sup>13</sup></a></li>
			
		
			
				<li><a href="/tags/CSharp/" title="CSharp">CSharp<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/Food/" title="Food">Food<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Spark/" title="Spark">Spark<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Hadoop/" title="Hadoop">Hadoop<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Asp-Net/" title="Asp.Net">Asp.Net<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Scala/" title="Scala">Scala<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/OSGi/" title="OSGi">OSGi<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/pager/" title="pager">pager<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Linux/" title="Linux">Linux<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Data-Struct/" title="Data Struct">Data Struct<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Search-Engine/" title="Search Engine">Search Engine<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Cookie/" title="Cookie">Cookie<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Akka/" title="Akka">Akka<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo/" title="Hexo">Hexo<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Mac/" title="Mac">Mac<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Vim/" title="Vim">Vim<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Json4s/" title="Json4s">Json4s<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
          <li>
            
            	<a href="http://quanru.github.io/" target="_blank" title="quanru&#39;s Blog">quanru&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="http://yyl8781697.github.io/about" target="_blank" title="Kubi Code">Kubi Code</a>
		
		</p>
</div>
<a href="https://github.com/yyl8781697"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png"></a>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
    
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#nothing"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"kubiCode"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?439f8b724bc712e367d66b5e348997bd";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
